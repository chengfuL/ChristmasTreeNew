function p8(n,e){for(var t=0;t<e.length;t++){const r=e[t];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in n)){const i=Object.getOwnPropertyDescriptor(r,s);i&&Object.defineProperty(n,s,i.get?i:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const o of i.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function t(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function r(s){if(s.ep)return;s.ep=!0;const i=t(s);fetch(s.href,i)}})();function Ux(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function m8(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(r){var s=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return n[r]}})}),t}var NC={exports:{}},ov={},AC={exports:{}},Zn={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var s$;function g8(){if(s$)return Zn;s$=1;var n=Symbol.for("react.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),s=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),o=Symbol.for("react.context"),a=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),u=Symbol.for("react.memo"),c=Symbol.for("react.lazy"),h=Symbol.iterator;function d(G){return G===null||typeof G!="object"?null:(G=h&&G[h]||G["@@iterator"],typeof G=="function"?G:null)}var p={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,w={};function y(G,Q,ne){this.props=G,this.context=Q,this.refs=w,this.updater=ne||p}y.prototype.isReactComponent={},y.prototype.setState=function(G,Q){if(typeof G!="object"&&typeof G!="function"&&G!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,G,Q,"setState")},y.prototype.forceUpdate=function(G){this.updater.enqueueForceUpdate(this,G,"forceUpdate")};function x(){}x.prototype=y.prototype;function _(G,Q,ne){this.props=G,this.context=Q,this.refs=w,this.updater=ne||p}var T=_.prototype=new x;T.constructor=_,g(T,y.prototype),T.isPureReactComponent=!0;var E=Array.isArray,N=Object.prototype.hasOwnProperty,M={current:null},$={key:!0,ref:!0,__self:!0,__source:!0};function L(G,Q,ne){var ce,ye={},Se=null,Re=null;if(Q!=null)for(ce in Q.ref!==void 0&&(Re=Q.ref),Q.key!==void 0&&(Se=""+Q.key),Q)N.call(Q,ce)&&!$.hasOwnProperty(ce)&&(ye[ce]=Q[ce]);var Oe=arguments.length-2;if(Oe===1)ye.children=ne;else if(1<Oe){for(var Ke=Array(Oe),st=0;st<Oe;st++)Ke[st]=arguments[st+2];ye.children=Ke}if(G&&G.defaultProps)for(ce in Oe=G.defaultProps,Oe)ye[ce]===void 0&&(ye[ce]=Oe[ce]);return{$$typeof:n,type:G,key:Se,ref:Re,props:ye,_owner:M.current}}function k(G,Q){return{$$typeof:n,type:G.type,key:Q,ref:G.ref,props:G.props,_owner:G._owner}}function R(G){return typeof G=="object"&&G!==null&&G.$$typeof===n}function P(G){var Q={"=":"=0",":":"=2"};return"$"+G.replace(/[=:]/g,function(ne){return Q[ne]})}var B=/\/+/g;function Z(G,Q){return typeof G=="object"&&G!==null&&G.key!=null?P(""+G.key):Q.toString(36)}function V(G,Q,ne,ce,ye){var Se=typeof G;(Se==="undefined"||Se==="boolean")&&(G=null);var Re=!1;if(G===null)Re=!0;else switch(Se){case"string":case"number":Re=!0;break;case"object":switch(G.$$typeof){case n:case e:Re=!0}}if(Re)return Re=G,ye=ye(Re),G=ce===""?"."+Z(Re,0):ce,E(ye)?(ne="",G!=null&&(ne=G.replace(B,"$&/")+"/"),V(ye,Q,ne,"",function(st){return st})):ye!=null&&(R(ye)&&(ye=k(ye,ne+(!ye.key||Re&&Re.key===ye.key?"":(""+ye.key).replace(B,"$&/")+"/")+G)),Q.push(ye)),1;if(Re=0,ce=ce===""?".":ce+":",E(G))for(var Oe=0;Oe<G.length;Oe++){Se=G[Oe];var Ke=ce+Z(Se,Oe);Re+=V(Se,Q,ne,Ke,ye)}else if(Ke=d(G),typeof Ke=="function")for(G=Ke.call(G),Oe=0;!(Se=G.next()).done;)Se=Se.value,Ke=ce+Z(Se,Oe++),Re+=V(Se,Q,ne,Ke,ye);else if(Se==="object")throw Q=String(G),Error("Objects are not valid as a React child (found: "+(Q==="[object Object]"?"object with keys {"+Object.keys(G).join(", ")+"}":Q)+"). If you meant to render a collection of children, use an array instead.");return Re}function X(G,Q,ne){if(G==null)return G;var ce=[],ye=0;return V(G,ce,"","",function(Se){return Q.call(ne,Se,ye++)}),ce}function q(G){if(G._status===-1){var Q=G._result;Q=Q(),Q.then(function(ne){(G._status===0||G._status===-1)&&(G._status=1,G._result=ne)},function(ne){(G._status===0||G._status===-1)&&(G._status=2,G._result=ne)}),G._status===-1&&(G._status=0,G._result=Q)}if(G._status===1)return G._result.default;throw G._result}var se={current:null},W={transition:null},J={ReactCurrentDispatcher:se,ReactCurrentBatchConfig:W,ReactCurrentOwner:M};function K(){throw Error("act(...) is not supported in production builds of React.")}return Zn.Children={map:X,forEach:function(G,Q,ne){X(G,function(){Q.apply(this,arguments)},ne)},count:function(G){var Q=0;return X(G,function(){Q++}),Q},toArray:function(G){return X(G,function(Q){return Q})||[]},only:function(G){if(!R(G))throw Error("React.Children.only expected to receive a single React element child.");return G}},Zn.Component=y,Zn.Fragment=t,Zn.Profiler=s,Zn.PureComponent=_,Zn.StrictMode=r,Zn.Suspense=l,Zn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=J,Zn.act=K,Zn.cloneElement=function(G,Q,ne){if(G==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+G+".");var ce=g({},G.props),ye=G.key,Se=G.ref,Re=G._owner;if(Q!=null){if(Q.ref!==void 0&&(Se=Q.ref,Re=M.current),Q.key!==void 0&&(ye=""+Q.key),G.type&&G.type.defaultProps)var Oe=G.type.defaultProps;for(Ke in Q)N.call(Q,Ke)&&!$.hasOwnProperty(Ke)&&(ce[Ke]=Q[Ke]===void 0&&Oe!==void 0?Oe[Ke]:Q[Ke])}var Ke=arguments.length-2;if(Ke===1)ce.children=ne;else if(1<Ke){Oe=Array(Ke);for(var st=0;st<Ke;st++)Oe[st]=arguments[st+2];ce.children=Oe}return{$$typeof:n,type:G.type,key:ye,ref:Se,props:ce,_owner:Re}},Zn.createContext=function(G){return G={$$typeof:o,_currentValue:G,_currentValue2:G,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},G.Provider={$$typeof:i,_context:G},G.Consumer=G},Zn.createElement=L,Zn.createFactory=function(G){var Q=L.bind(null,G);return Q.type=G,Q},Zn.createRef=function(){return{current:null}},Zn.forwardRef=function(G){return{$$typeof:a,render:G}},Zn.isValidElement=R,Zn.lazy=function(G){return{$$typeof:c,_payload:{_status:-1,_result:G},_init:q}},Zn.memo=function(G,Q){return{$$typeof:u,type:G,compare:Q===void 0?null:Q}},Zn.startTransition=function(G){var Q=W.transition;W.transition={};try{G()}finally{W.transition=Q}},Zn.unstable_act=K,Zn.useCallback=function(G,Q){return se.current.useCallback(G,Q)},Zn.useContext=function(G){return se.current.useContext(G)},Zn.useDebugValue=function(){},Zn.useDeferredValue=function(G){return se.current.useDeferredValue(G)},Zn.useEffect=function(G,Q){return se.current.useEffect(G,Q)},Zn.useId=function(){return se.current.useId()},Zn.useImperativeHandle=function(G,Q,ne){return se.current.useImperativeHandle(G,Q,ne)},Zn.useInsertionEffect=function(G,Q){return se.current.useInsertionEffect(G,Q)},Zn.useLayoutEffect=function(G,Q){return se.current.useLayoutEffect(G,Q)},Zn.useMemo=function(G,Q){return se.current.useMemo(G,Q)},Zn.useReducer=function(G,Q,ne){return se.current.useReducer(G,Q,ne)},Zn.useRef=function(G){return se.current.useRef(G)},Zn.useState=function(G){return se.current.useState(G)},Zn.useSyncExternalStore=function(G,Q,ne){return se.current.useSyncExternalStore(G,Q,ne)},Zn.useTransition=function(){return se.current.useTransition()},Zn.version="18.3.1",Zn}var i$;function Vx(){return i$||(i$=1,AC.exports=g8()),AC.exports}/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var o$;function y8(){if(o$)return ov;o$=1;var n=Vx(),e=Symbol.for("react.element"),t=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,s=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,i={key:!0,ref:!0,__self:!0,__source:!0};function o(a,l,u){var c,h={},d=null,p=null;u!==void 0&&(d=""+u),l.key!==void 0&&(d=""+l.key),l.ref!==void 0&&(p=l.ref);for(c in l)r.call(l,c)&&!i.hasOwnProperty(c)&&(h[c]=l[c]);if(a&&a.defaultProps)for(c in l=a.defaultProps,l)h[c]===void 0&&(h[c]=l[c]);return{$$typeof:e,type:a,key:d,ref:p,props:h,_owner:s.current}}return ov.Fragment=t,ov.jsx=o,ov.jsxs=o,ov}var a$;function v8(){return a$||(a$=1,NC.exports=y8()),NC.exports}var Ie=v8(),we=Vx();const Yv=Ux(we);var fb={},MC={exports:{}},da={},kC={exports:{}},RC={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var l$;function x8(){return l$||(l$=1,(function(n){function e(W,J){var K=W.length;W.push(J);e:for(;0<K;){var G=K-1>>>1,Q=W[G];if(0<s(Q,J))W[G]=J,W[K]=Q,K=G;else break e}}function t(W){return W.length===0?null:W[0]}function r(W){if(W.length===0)return null;var J=W[0],K=W.pop();if(K!==J){W[0]=K;e:for(var G=0,Q=W.length,ne=Q>>>1;G<ne;){var ce=2*(G+1)-1,ye=W[ce],Se=ce+1,Re=W[Se];if(0>s(ye,K))Se<Q&&0>s(Re,ye)?(W[G]=Re,W[Se]=K,G=Se):(W[G]=ye,W[ce]=K,G=ce);else if(Se<Q&&0>s(Re,K))W[G]=Re,W[Se]=K,G=Se;else break e}}return J}function s(W,J){var K=W.sortIndex-J.sortIndex;return K!==0?K:W.id-J.id}if(typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var o=Date,a=o.now();n.unstable_now=function(){return o.now()-a}}var l=[],u=[],c=1,h=null,d=3,p=!1,g=!1,w=!1,y=typeof setTimeout=="function"?setTimeout:null,x=typeof clearTimeout=="function"?clearTimeout:null,_=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function T(W){for(var J=t(u);J!==null;){if(J.callback===null)r(u);else if(J.startTime<=W)r(u),J.sortIndex=J.expirationTime,e(l,J);else break;J=t(u)}}function E(W){if(w=!1,T(W),!g)if(t(l)!==null)g=!0,q(N);else{var J=t(u);J!==null&&se(E,J.startTime-W)}}function N(W,J){g=!1,w&&(w=!1,x(L),L=-1),p=!0;var K=d;try{for(T(J),h=t(l);h!==null&&(!(h.expirationTime>J)||W&&!P());){var G=h.callback;if(typeof G=="function"){h.callback=null,d=h.priorityLevel;var Q=G(h.expirationTime<=J);J=n.unstable_now(),typeof Q=="function"?h.callback=Q:h===t(l)&&r(l),T(J)}else r(l);h=t(l)}if(h!==null)var ne=!0;else{var ce=t(u);ce!==null&&se(E,ce.startTime-J),ne=!1}return ne}finally{h=null,d=K,p=!1}}var M=!1,$=null,L=-1,k=5,R=-1;function P(){return!(n.unstable_now()-R<k)}function B(){if($!==null){var W=n.unstable_now();R=W;var J=!0;try{J=$(!0,W)}finally{J?Z():(M=!1,$=null)}}else M=!1}var Z;if(typeof _=="function")Z=function(){_(B)};else if(typeof MessageChannel<"u"){var V=new MessageChannel,X=V.port2;V.port1.onmessage=B,Z=function(){X.postMessage(null)}}else Z=function(){y(B,0)};function q(W){$=W,M||(M=!0,Z())}function se(W,J){L=y(function(){W(n.unstable_now())},J)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(W){W.callback=null},n.unstable_continueExecution=function(){g||p||(g=!0,q(N))},n.unstable_forceFrameRate=function(W){0>W||125<W?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):k=0<W?Math.floor(1e3/W):5},n.unstable_getCurrentPriorityLevel=function(){return d},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(W){switch(d){case 1:case 2:case 3:var J=3;break;default:J=d}var K=d;d=J;try{return W()}finally{d=K}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(W,J){switch(W){case 1:case 2:case 3:case 4:case 5:break;default:W=3}var K=d;d=W;try{return J()}finally{d=K}},n.unstable_scheduleCallback=function(W,J,K){var G=n.unstable_now();switch(typeof K=="object"&&K!==null?(K=K.delay,K=typeof K=="number"&&0<K?G+K:G):K=G,W){case 1:var Q=-1;break;case 2:Q=250;break;case 5:Q=1073741823;break;case 4:Q=1e4;break;default:Q=5e3}return Q=K+Q,W={id:c++,callback:J,priorityLevel:W,startTime:K,expirationTime:Q,sortIndex:-1},K>G?(W.sortIndex=K,e(u,W),t(l)===null&&W===t(u)&&(w?(x(L),L=-1):w=!0,se(E,K-G))):(W.sortIndex=Q,e(l,W),g||p||(g=!0,q(N))),W},n.unstable_shouldYield=P,n.unstable_wrapCallback=function(W){var J=d;return function(){var K=d;d=J;try{return W.apply(this,arguments)}finally{d=K}}}})(RC)),RC}var u$;function w8(){return u$||(u$=1,kC.exports=x8()),kC.exports}/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var c$;function b8(){if(c$)return da;c$=1;var n=Vx(),e=w8();function t(f){for(var m="https://reactjs.org/docs/error-decoder.html?invariant="+f,S=1;S<arguments.length;S++)m+="&args[]="+encodeURIComponent(arguments[S]);return"Minified React error #"+f+"; visit "+m+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var r=new Set,s={};function i(f,m){o(f,m),o(f+"Capture",m)}function o(f,m){for(s[f]=m,f=0;f<m.length;f++)r.add(m[f])}var a=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),l=Object.prototype.hasOwnProperty,u=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,c={},h={};function d(f){return l.call(h,f)?!0:l.call(c,f)?!1:u.test(f)?h[f]=!0:(c[f]=!0,!1)}function p(f,m,S,I){if(S!==null&&S.type===0)return!1;switch(typeof m){case"function":case"symbol":return!0;case"boolean":return I?!1:S!==null?!S.acceptsBooleans:(f=f.toLowerCase().slice(0,5),f!=="data-"&&f!=="aria-");default:return!1}}function g(f,m,S,I){if(m===null||typeof m>"u"||p(f,m,S,I))return!0;if(I)return!1;if(S!==null)switch(S.type){case 3:return!m;case 4:return m===!1;case 5:return isNaN(m);case 6:return isNaN(m)||1>m}return!1}function w(f,m,S,I,D,F,Y){this.acceptsBooleans=m===2||m===3||m===4,this.attributeName=I,this.attributeNamespace=D,this.mustUseProperty=S,this.propertyName=f,this.type=m,this.sanitizeURL=F,this.removeEmptyString=Y}var y={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(f){y[f]=new w(f,0,!1,f,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(f){var m=f[0];y[m]=new w(m,1,!1,f[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(f){y[f]=new w(f,2,!1,f.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(f){y[f]=new w(f,2,!1,f,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(f){y[f]=new w(f,3,!1,f.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(f){y[f]=new w(f,3,!0,f,null,!1,!1)}),["capture","download"].forEach(function(f){y[f]=new w(f,4,!1,f,null,!1,!1)}),["cols","rows","size","span"].forEach(function(f){y[f]=new w(f,6,!1,f,null,!1,!1)}),["rowSpan","start"].forEach(function(f){y[f]=new w(f,5,!1,f.toLowerCase(),null,!1,!1)});var x=/[\-:]([a-z])/g;function _(f){return f[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(f){var m=f.replace(x,_);y[m]=new w(m,1,!1,f,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(f){var m=f.replace(x,_);y[m]=new w(m,1,!1,f,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(f){var m=f.replace(x,_);y[m]=new w(m,1,!1,f,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(f){y[f]=new w(f,1,!1,f.toLowerCase(),null,!1,!1)}),y.xlinkHref=new w("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(f){y[f]=new w(f,1,!1,f.toLowerCase(),null,!0,!0)});function T(f,m,S,I){var D=y.hasOwnProperty(m)?y[m]:null;(D!==null?D.type!==0:I||!(2<m.length)||m[0]!=="o"&&m[0]!=="O"||m[1]!=="n"&&m[1]!=="N")&&(g(m,S,D,I)&&(S=null),I||D===null?d(m)&&(S===null?f.removeAttribute(m):f.setAttribute(m,""+S)):D.mustUseProperty?f[D.propertyName]=S===null?D.type===3?!1:"":S:(m=D.attributeName,I=D.attributeNamespace,S===null?f.removeAttribute(m):(D=D.type,S=D===3||D===4&&S===!0?"":""+S,I?f.setAttributeNS(I,m,S):f.setAttribute(m,S))))}var E=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,N=Symbol.for("react.element"),M=Symbol.for("react.portal"),$=Symbol.for("react.fragment"),L=Symbol.for("react.strict_mode"),k=Symbol.for("react.profiler"),R=Symbol.for("react.provider"),P=Symbol.for("react.context"),B=Symbol.for("react.forward_ref"),Z=Symbol.for("react.suspense"),V=Symbol.for("react.suspense_list"),X=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),se=Symbol.for("react.offscreen"),W=Symbol.iterator;function J(f){return f===null||typeof f!="object"?null:(f=W&&f[W]||f["@@iterator"],typeof f=="function"?f:null)}var K=Object.assign,G;function Q(f){if(G===void 0)try{throw Error()}catch(S){var m=S.stack.trim().match(/\n( *(at )?)/);G=m&&m[1]||""}return`
`+G+f}var ne=!1;function ce(f,m){if(!f||ne)return"";ne=!0;var S=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(m)if(m=function(){throw Error()},Object.defineProperty(m.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(m,[])}catch(qe){var I=qe}Reflect.construct(f,[],m)}else{try{m.call()}catch(qe){I=qe}f.call(m.prototype)}else{try{throw Error()}catch(qe){I=qe}f()}}catch(qe){if(qe&&I&&typeof qe.stack=="string"){for(var D=qe.stack.split(`
`),F=I.stack.split(`
`),Y=D.length-1,pe=F.length-1;1<=Y&&0<=pe&&D[Y]!==F[pe];)pe--;for(;1<=Y&&0<=pe;Y--,pe--)if(D[Y]!==F[pe]){if(Y!==1||pe!==1)do if(Y--,pe--,0>pe||D[Y]!==F[pe]){var Te=`
`+D[Y].replace(" at new "," at ");return f.displayName&&Te.includes("<anonymous>")&&(Te=Te.replace("<anonymous>",f.displayName)),Te}while(1<=Y&&0<=pe);break}}}finally{ne=!1,Error.prepareStackTrace=S}return(f=f?f.displayName||f.name:"")?Q(f):""}function ye(f){switch(f.tag){case 5:return Q(f.type);case 16:return Q("Lazy");case 13:return Q("Suspense");case 19:return Q("SuspenseList");case 0:case 2:case 15:return f=ce(f.type,!1),f;case 11:return f=ce(f.type.render,!1),f;case 1:return f=ce(f.type,!0),f;default:return""}}function Se(f){if(f==null)return null;if(typeof f=="function")return f.displayName||f.name||null;if(typeof f=="string")return f;switch(f){case $:return"Fragment";case M:return"Portal";case k:return"Profiler";case L:return"StrictMode";case Z:return"Suspense";case V:return"SuspenseList"}if(typeof f=="object")switch(f.$$typeof){case P:return(f.displayName||"Context")+".Consumer";case R:return(f._context.displayName||"Context")+".Provider";case B:var m=f.render;return f=f.displayName,f||(f=m.displayName||m.name||"",f=f!==""?"ForwardRef("+f+")":"ForwardRef"),f;case X:return m=f.displayName||null,m!==null?m:Se(f.type)||"Memo";case q:m=f._payload,f=f._init;try{return Se(f(m))}catch{}}return null}function Re(f){var m=f.type;switch(f.tag){case 24:return"Cache";case 9:return(m.displayName||"Context")+".Consumer";case 10:return(m._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return f=m.render,f=f.displayName||f.name||"",m.displayName||(f!==""?"ForwardRef("+f+")":"ForwardRef");case 7:return"Fragment";case 5:return m;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Se(m);case 8:return m===L?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof m=="function")return m.displayName||m.name||null;if(typeof m=="string")return m}return null}function Oe(f){switch(typeof f){case"boolean":case"number":case"string":case"undefined":return f;case"object":return f;default:return""}}function Ke(f){var m=f.type;return(f=f.nodeName)&&f.toLowerCase()==="input"&&(m==="checkbox"||m==="radio")}function st(f){var m=Ke(f)?"checked":"value",S=Object.getOwnPropertyDescriptor(f.constructor.prototype,m),I=""+f[m];if(!f.hasOwnProperty(m)&&typeof S<"u"&&typeof S.get=="function"&&typeof S.set=="function"){var D=S.get,F=S.set;return Object.defineProperty(f,m,{configurable:!0,get:function(){return D.call(this)},set:function(Y){I=""+Y,F.call(this,Y)}}),Object.defineProperty(f,m,{enumerable:S.enumerable}),{getValue:function(){return I},setValue:function(Y){I=""+Y},stopTracking:function(){f._valueTracker=null,delete f[m]}}}}function ct(f){f._valueTracker||(f._valueTracker=st(f))}function fe(f){if(!f)return!1;var m=f._valueTracker;if(!m)return!0;var S=m.getValue(),I="";return f&&(I=Ke(f)?f.checked?"true":"false":f.value),f=I,f!==S?(m.setValue(f),!0):!1}function nt(f){if(f=f||(typeof document<"u"?document:void 0),typeof f>"u")return null;try{return f.activeElement||f.body}catch{return f.body}}function Xe(f,m){var S=m.checked;return K({},m,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:S??f._wrapperState.initialChecked})}function it(f,m){var S=m.defaultValue==null?"":m.defaultValue,I=m.checked!=null?m.checked:m.defaultChecked;S=Oe(m.value!=null?m.value:S),f._wrapperState={initialChecked:I,initialValue:S,controlled:m.type==="checkbox"||m.type==="radio"?m.checked!=null:m.value!=null}}function He(f,m){m=m.checked,m!=null&&T(f,"checked",m,!1)}function _t(f,m){He(f,m);var S=Oe(m.value),I=m.type;if(S!=null)I==="number"?(S===0&&f.value===""||f.value!=S)&&(f.value=""+S):f.value!==""+S&&(f.value=""+S);else if(I==="submit"||I==="reset"){f.removeAttribute("value");return}m.hasOwnProperty("value")?oe(f,m.type,S):m.hasOwnProperty("defaultValue")&&oe(f,m.type,Oe(m.defaultValue)),m.checked==null&&m.defaultChecked!=null&&(f.defaultChecked=!!m.defaultChecked)}function mt(f,m,S){if(m.hasOwnProperty("value")||m.hasOwnProperty("defaultValue")){var I=m.type;if(!(I!=="submit"&&I!=="reset"||m.value!==void 0&&m.value!==null))return;m=""+f._wrapperState.initialValue,S||m===f.value||(f.value=m),f.defaultValue=m}S=f.name,S!==""&&(f.name=""),f.defaultChecked=!!f._wrapperState.initialChecked,S!==""&&(f.name=S)}function oe(f,m,S){(m!=="number"||nt(f.ownerDocument)!==f)&&(S==null?f.defaultValue=""+f._wrapperState.initialValue:f.defaultValue!==""+S&&(f.defaultValue=""+S))}var ee=Array.isArray;function Le(f,m,S,I){if(f=f.options,m){m={};for(var D=0;D<S.length;D++)m["$"+S[D]]=!0;for(S=0;S<f.length;S++)D=m.hasOwnProperty("$"+f[S].value),f[S].selected!==D&&(f[S].selected=D),D&&I&&(f[S].defaultSelected=!0)}else{for(S=""+Oe(S),m=null,D=0;D<f.length;D++){if(f[D].value===S){f[D].selected=!0,I&&(f[D].defaultSelected=!0);return}m!==null||f[D].disabled||(m=f[D])}m!==null&&(m.selected=!0)}}function at(f,m){if(m.dangerouslySetInnerHTML!=null)throw Error(t(91));return K({},m,{value:void 0,defaultValue:void 0,children:""+f._wrapperState.initialValue})}function ut(f,m){var S=m.value;if(S==null){if(S=m.children,m=m.defaultValue,S!=null){if(m!=null)throw Error(t(92));if(ee(S)){if(1<S.length)throw Error(t(93));S=S[0]}m=S}m==null&&(m=""),S=m}f._wrapperState={initialValue:Oe(S)}}function ot(f,m){var S=Oe(m.value),I=Oe(m.defaultValue);S!=null&&(S=""+S,S!==f.value&&(f.value=S),m.defaultValue==null&&f.defaultValue!==S&&(f.defaultValue=S)),I!=null&&(f.defaultValue=""+I)}function $t(f){var m=f.textContent;m===f._wrapperState.initialValue&&m!==""&&m!==null&&(f.value=m)}function bt(f){switch(f){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function It(f,m){return f==null||f==="http://www.w3.org/1999/xhtml"?bt(m):f==="http://www.w3.org/2000/svg"&&m==="foreignObject"?"http://www.w3.org/1999/xhtml":f}var Gt,rn=(function(f){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(m,S,I,D){MSApp.execUnsafeLocalFunction(function(){return f(m,S,I,D)})}:f})(function(f,m){if(f.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in f)f.innerHTML=m;else{for(Gt=Gt||document.createElement("div"),Gt.innerHTML="<svg>"+m.valueOf().toString()+"</svg>",m=Gt.firstChild;f.firstChild;)f.removeChild(f.firstChild);for(;m.firstChild;)f.appendChild(m.firstChild)}});function ht(f,m){if(m){var S=f.firstChild;if(S&&S===f.lastChild&&S.nodeType===3){S.nodeValue=m;return}}f.textContent=m}var Nn={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},An=["Webkit","ms","Moz","O"];Object.keys(Nn).forEach(function(f){An.forEach(function(m){m=m+f.charAt(0).toUpperCase()+f.substring(1),Nn[m]=Nn[f]})});function en(f,m,S){return m==null||typeof m=="boolean"||m===""?"":S||typeof m!="number"||m===0||Nn.hasOwnProperty(f)&&Nn[f]?(""+m).trim():m+"px"}function Ft(f,m){f=f.style;for(var S in m)if(m.hasOwnProperty(S)){var I=S.indexOf("--")===0,D=en(S,m[S],I);S==="float"&&(S="cssFloat"),I?f.setProperty(S,D):f[S]=D}}var Vt=K({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function cn(f,m){if(m){if(Vt[f]&&(m.children!=null||m.dangerouslySetInnerHTML!=null))throw Error(t(137,f));if(m.dangerouslySetInnerHTML!=null){if(m.children!=null)throw Error(t(60));if(typeof m.dangerouslySetInnerHTML!="object"||!("__html"in m.dangerouslySetInnerHTML))throw Error(t(61))}if(m.style!=null&&typeof m.style!="object")throw Error(t(62))}}function bn(f,m){if(f.indexOf("-")===-1)return typeof m.is=="string";switch(f){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Mn=null;function Tn(f){return f=f.target||f.srcElement||window,f.correspondingUseElement&&(f=f.correspondingUseElement),f.nodeType===3?f.parentNode:f}var Ge=null,_e=null,Tt=null;function Mt(f){if(f=Ol(f)){if(typeof Ge!="function")throw Error(t(280));var m=f.stateNode;m&&(m=Jm(m),Ge(f.stateNode,f.type,m))}}function ln(f){_e?Tt?Tt.push(f):Tt=[f]:_e=f}function sn(){if(_e){var f=_e,m=Tt;if(Tt=_e=null,Mt(f),m)for(f=0;f<m.length;f++)Mt(m[f])}}function pr(f,m){return f(m)}function ur(){}var Vr=!1;function ms(f,m,S){if(Vr)return f(m,S);Vr=!0;try{return pr(f,m,S)}finally{Vr=!1,(_e!==null||Tt!==null)&&(ur(),sn())}}function er(f,m){var S=f.stateNode;if(S===null)return null;var I=Jm(S);if(I===null)return null;S=I[m];e:switch(m){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(I=!I.disabled)||(f=f.type,I=!(f==="button"||f==="input"||f==="select"||f==="textarea")),f=!I;break e;default:f=!1}if(f)return null;if(S&&typeof S!="function")throw Error(t(231,m,typeof S));return S}var gs=!1;if(a)try{var Ws={};Object.defineProperty(Ws,"passive",{get:function(){gs=!0}}),window.addEventListener("test",Ws,Ws),window.removeEventListener("test",Ws,Ws)}catch{gs=!1}function Qa(f,m,S,I,D,F,Y,pe,Te){var qe=Array.prototype.slice.call(arguments,3);try{m.apply(S,qe)}catch(yt){this.onError(yt)}}var Na=!1,zi=null,ii=!1,En=null,uc={onError:function(f){Na=!0,zi=f}};function Sh(f,m,S,I,D,F,Y,pe,Te){Na=!1,zi=null,Qa.apply(uc,arguments)}function j(f,m,S,I,D,F,Y,pe,Te){if(Sh.apply(this,arguments),Na){if(Na){var qe=zi;Na=!1,zi=null}else throw Error(t(198));ii||(ii=!0,En=qe)}}function re(f){var m=f,S=f;if(f.alternate)for(;m.return;)m=m.return;else{f=m;do m=f,(m.flags&4098)!==0&&(S=m.return),f=m.return;while(f)}return m.tag===3?S:null}function be(f){if(f.tag===13){var m=f.memoizedState;if(m===null&&(f=f.alternate,f!==null&&(m=f.memoizedState)),m!==null)return m.dehydrated}return null}function H(f){if(re(f)!==f)throw Error(t(188))}function ae(f){var m=f.alternate;if(!m){if(m=re(f),m===null)throw Error(t(188));return m!==f?null:f}for(var S=f,I=m;;){var D=S.return;if(D===null)break;var F=D.alternate;if(F===null){if(I=D.return,I!==null){S=I;continue}break}if(D.child===F.child){for(F=D.child;F;){if(F===S)return H(D),f;if(F===I)return H(D),m;F=F.sibling}throw Error(t(188))}if(S.return!==I.return)S=D,I=F;else{for(var Y=!1,pe=D.child;pe;){if(pe===S){Y=!0,S=D,I=F;break}if(pe===I){Y=!0,I=D,S=F;break}pe=pe.sibling}if(!Y){for(pe=F.child;pe;){if(pe===S){Y=!0,S=F,I=D;break}if(pe===I){Y=!0,I=F,S=D;break}pe=pe.sibling}if(!Y)throw Error(t(189))}}if(S.alternate!==I)throw Error(t(190))}if(S.tag!==3)throw Error(t(188));return S.stateNode.current===S?f:m}function ue(f){return f=ae(f),f!==null?xe(f):null}function xe(f){if(f.tag===5||f.tag===6)return f;for(f=f.child;f!==null;){var m=xe(f);if(m!==null)return m;f=f.sibling}return null}var me=e.unstable_scheduleCallback,We=e.unstable_cancelCallback,Ye=e.unstable_shouldYield,et=e.unstable_requestPaint,Ue=e.unstable_now,Bt=e.unstable_getCurrentPriorityLevel,dt=e.unstable_ImmediatePriority,gt=e.unstable_UserBlockingPriority,Ut=e.unstable_NormalPriority,tn=e.unstable_LowPriority,on=e.unstable_IdlePriority,vn=null,kt=null;function Ct(f){if(kt&&typeof kt.onCommitFiberRoot=="function")try{kt.onCommitFiberRoot(vn,f,void 0,(f.current.flags&128)===128)}catch{}}var mn=Math.clz32?Math.clz32:Tr,dn=Math.log,xn=Math.LN2;function Tr(f){return f>>>=0,f===0?32:31-(dn(f)/xn|0)|0}var Wr=64,kr=4194304;function Gn(f){switch(f&-f){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return f&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return f&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return f}}function Pn(f,m){var S=f.pendingLanes;if(S===0)return 0;var I=0,D=f.suspendedLanes,F=f.pingedLanes,Y=S&268435455;if(Y!==0){var pe=Y&~D;pe!==0?I=Gn(pe):(F&=Y,F!==0&&(I=Gn(F)))}else Y=S&~D,Y!==0?I=Gn(Y):F!==0&&(I=Gn(F));if(I===0)return 0;if(m!==0&&m!==I&&(m&D)===0&&(D=I&-I,F=m&-m,D>=F||D===16&&(F&4194240)!==0))return m;if((I&4)!==0&&(I|=S&16),m=f.entangledLanes,m!==0)for(f=f.entanglements,m&=I;0<m;)S=31-mn(m),D=1<<S,I|=f[S],m&=~D;return I}function es(f,m){switch(f){case 1:case 2:case 4:return m+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return m+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Rn(f,m){for(var S=f.suspendedLanes,I=f.pingedLanes,D=f.expirationTimes,F=f.pendingLanes;0<F;){var Y=31-mn(F),pe=1<<Y,Te=D[Y];Te===-1?((pe&S)===0||(pe&I)!==0)&&(D[Y]=es(pe,m)):Te<=m&&(f.expiredLanes|=pe),F&=~pe}}function Hn(f){return f=f.pendingLanes&-1073741825,f!==0?f:f&1073741824?1073741824:0}function Rr(){var f=Wr;return Wr<<=1,(Wr&4194240)===0&&(Wr=64),f}function eo(f){for(var m=[],S=0;31>S;S++)m.push(f);return m}function Ds(f,m,S){f.pendingLanes|=m,m!==536870912&&(f.suspendedLanes=0,f.pingedLanes=0),f=f.eventTimes,m=31-mn(m),f[m]=S}function el(f,m){var S=f.pendingLanes&~m;f.pendingLanes=m,f.suspendedLanes=0,f.pingedLanes=0,f.expiredLanes&=m,f.mutableReadLanes&=m,f.entangledLanes&=m,m=f.entanglements;var I=f.eventTimes;for(f=f.expirationTimes;0<S;){var D=31-mn(S),F=1<<D;m[D]=0,I[D]=-1,f[D]=-1,S&=~F}}function _h(f,m){var S=f.entangledLanes|=m;for(f=f.entanglements;S;){var I=31-mn(S),D=1<<I;D&m|f[I]&m&&(f[I]|=m),S&=~D}}var cr=0;function Th(f){return f&=-f,1<f?4<f?(f&268435455)!==0?16:536870912:4:1}var uf,d0,bw,wm,bm,cc=!1,Sm=[],tl=null,Bn=null,Al=null,hc=new Map,Eh=new Map,Tu=[],QE="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function $s(f,m){switch(f){case"focusin":case"focusout":tl=null;break;case"dragenter":case"dragleave":Bn=null;break;case"mouseover":case"mouseout":Al=null;break;case"pointerover":case"pointerout":hc.delete(m.pointerId);break;case"gotpointercapture":case"lostpointercapture":Eh.delete(m.pointerId)}}function dc(f,m,S,I,D,F){return f===null||f.nativeEvent!==F?(f={blockedOn:m,domEventName:S,eventSystemFlags:I,nativeEvent:F,targetContainers:[D]},m!==null&&(m=Ol(m),m!==null&&d0(m)),f):(f.eventSystemFlags|=I,m=f.targetContainers,D!==null&&m.indexOf(D)===-1&&m.push(D),f)}function eC(f,m,S,I,D){switch(m){case"focusin":return tl=dc(tl,f,m,S,I,D),!0;case"dragenter":return Bn=dc(Bn,f,m,S,I,D),!0;case"mouseover":return Al=dc(Al,f,m,S,I,D),!0;case"pointerover":var F=D.pointerId;return hc.set(F,dc(hc.get(F)||null,f,m,S,I,D)),!0;case"gotpointercapture":return F=D.pointerId,Eh.set(F,dc(Eh.get(F)||null,f,m,S,I,D)),!0}return!1}function _m(f){var m=ku(f.target);if(m!==null){var S=re(m);if(S!==null){if(m=S.tag,m===13){if(m=be(S),m!==null){f.blockedOn=m,bm(f.priority,function(){bw(S)});return}}else if(m===3&&S.stateNode.current.memoizedState.isDehydrated){f.blockedOn=S.tag===3?S.stateNode.containerInfo:null;return}}}f.blockedOn=null}function Tm(f){if(f.blockedOn!==null)return!1;for(var m=f.targetContainers;0<m.length;){var S=na(f.domEventName,f.eventSystemFlags,m[0],f.nativeEvent);if(S===null){S=f.nativeEvent;var I=new S.constructor(S.type,S);Mn=I,S.target.dispatchEvent(I),Mn=null}else return m=Ol(S),m!==null&&d0(m),f.blockedOn=S,!1;m.shift()}return!0}function cf(f,m,S){Tm(f)&&S.delete(m)}function nl(){cc=!1,tl!==null&&Tm(tl)&&(tl=null),Bn!==null&&Tm(Bn)&&(Bn=null),Al!==null&&Tm(Al)&&(Al=null),hc.forEach(cf),Eh.forEach(cf)}function hf(f,m){f.blockedOn===m&&(f.blockedOn=null,cc||(cc=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,nl)))}function df(f){function m(D){return hf(D,f)}if(0<Sm.length){hf(Sm[0],f);for(var S=1;S<Sm.length;S++){var I=Sm[S];I.blockedOn===f&&(I.blockedOn=null)}}for(tl!==null&&hf(tl,f),Bn!==null&&hf(Bn,f),Al!==null&&hf(Al,f),hc.forEach(m),Eh.forEach(m),S=0;S<Tu.length;S++)I=Tu[S],I.blockedOn===f&&(I.blockedOn=null);for(;0<Tu.length&&(S=Tu[0],S.blockedOn===null);)_m(S),S.blockedOn===null&&Tu.shift()}var Bi=E.ReactCurrentBatchConfig,ta=!0;function Em(f,m,S,I){var D=cr,F=Bi.transition;Bi.transition=null;try{cr=1,Cm(f,m,S,I)}finally{cr=D,Bi.transition=F}}function f0(f,m,S,I){var D=cr,F=Bi.transition;Bi.transition=null;try{cr=4,Cm(f,m,S,I)}finally{cr=D,Bi.transition=F}}function Cm(f,m,S,I){if(ta){var D=na(f,m,S,I);if(D===null)jm(f,m,I,Im,S),$s(f,I);else if(eC(D,f,m,S,I))I.stopPropagation();else if($s(f,I),m&4&&-1<QE.indexOf(f)){for(;D!==null;){var F=Ol(D);if(F!==null&&uf(F),F=na(f,m,S,I),F===null&&jm(f,m,I,Im,S),F===D)break;D=F}D!==null&&I.stopPropagation()}else jm(f,m,I,null,S)}}var Im=null;function na(f,m,S,I){if(Im=null,f=Tn(I),f=ku(f),f!==null)if(m=re(f),m===null)f=null;else if(S=m.tag,S===13){if(f=be(m),f!==null)return f;f=null}else if(S===3){if(m.stateNode.current.memoizedState.isDehydrated)return m.tag===3?m.stateNode.containerInfo:null;f=null}else m!==f&&(f=null);return Im=f,null}function Sw(f){switch(f){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Bt()){case dt:return 1;case gt:return 4;case Ut:case tn:return 16;case on:return 536870912;default:return 16}default:return 16}}var Aa=null,p0=null,to=null;function ff(){if(to)return to;var f,m=p0,S=m.length,I,D="value"in Aa?Aa.value:Aa.textContent,F=D.length;for(f=0;f<S&&m[f]===D[f];f++);var Y=S-f;for(I=1;I<=Y&&m[S-I]===D[F-I];I++);return to=D.slice(f,1<I?1-I:void 0)}function fc(f){var m=f.keyCode;return"charCode"in f?(f=f.charCode,f===0&&m===13&&(f=13)):f=m,f===10&&(f=13),32<=f||f===13?f:0}function Ml(){return!0}function Nm(){return!1}function Ui(f){function m(S,I,D,F,Y){this._reactName=S,this._targetInst=D,this.type=I,this.nativeEvent=F,this.target=Y,this.currentTarget=null;for(var pe in f)f.hasOwnProperty(pe)&&(S=f[pe],this[pe]=S?S(F):F[pe]);return this.isDefaultPrevented=(F.defaultPrevented!=null?F.defaultPrevented:F.returnValue===!1)?Ml:Nm,this.isPropagationStopped=Nm,this}return K(m.prototype,{preventDefault:function(){this.defaultPrevented=!0;var S=this.nativeEvent;S&&(S.preventDefault?S.preventDefault():typeof S.returnValue!="unknown"&&(S.returnValue=!1),this.isDefaultPrevented=Ml)},stopPropagation:function(){var S=this.nativeEvent;S&&(S.stopPropagation?S.stopPropagation():typeof S.cancelBubble!="unknown"&&(S.cancelBubble=!0),this.isPropagationStopped=Ml)},persist:function(){},isPersistent:Ml}),m}var pc={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(f){return f.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},pf=Ui(pc),mc=K({},pc,{view:0,detail:0}),Ch=Ui(mc),no,ra,sa,Ih=K({},mc,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Cu,button:0,buttons:0,relatedTarget:function(f){return f.relatedTarget===void 0?f.fromElement===f.srcElement?f.toElement:f.fromElement:f.relatedTarget},movementX:function(f){return"movementX"in f?f.movementX:(f!==sa&&(sa&&f.type==="mousemove"?(no=f.screenX-sa.screenX,ra=f.screenY-sa.screenY):ra=no=0,sa=f),no)},movementY:function(f){return"movementY"in f?f.movementY:ra}}),m0=Ui(Ih),kl=K({},Ih,{dataTransfer:0}),Eu=Ui(kl),Am=K({},mc,{relatedTarget:0}),Mm=Ui(Am),km=K({},pc,{animationName:0,elapsedTime:0,pseudoElement:0}),_w=Ui(km),Tw=K({},pc,{clipboardData:function(f){return"clipboardData"in f?f.clipboardData:window.clipboardData}}),g0=Ui(Tw),Rm=K({},pc,{data:0}),y0=Ui(Rm),Ew={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Cw={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},v0={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Nh(f){var m=this.nativeEvent;return m.getModifierState?m.getModifierState(f):(f=v0[f])?!!m[f]:!1}function Cu(){return Nh}var Dm=K({},mc,{key:function(f){if(f.key){var m=Ew[f.key]||f.key;if(m!=="Unidentified")return m}return f.type==="keypress"?(f=fc(f),f===13?"Enter":String.fromCharCode(f)):f.type==="keydown"||f.type==="keyup"?Cw[f.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Cu,charCode:function(f){return f.type==="keypress"?fc(f):0},keyCode:function(f){return f.type==="keydown"||f.type==="keyup"?f.keyCode:0},which:function(f){return f.type==="keypress"?fc(f):f.type==="keydown"||f.type==="keyup"?f.keyCode:0}}),$m=Ui(Dm),ia=K({},Ih,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),No=Ui(ia),gc=K({},mc,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Cu}),Rl=Ui(gc),Dl=K({},pc,{propertyName:0,elapsedTime:0,pseudoElement:0}),yc=Ui(Dl),Iw=K({},Ih,{deltaX:function(f){return"deltaX"in f?f.deltaX:"wheelDeltaX"in f?-f.wheelDeltaX:0},deltaY:function(f){return"deltaY"in f?f.deltaY:"wheelDeltaY"in f?-f.wheelDeltaY:"wheelDelta"in f?-f.wheelDelta:0},deltaZ:0,deltaMode:0}),x0=Ui(Iw),w0=[9,13,27,32],Vi=a&&"CompositionEvent"in window,oi=null;a&&"documentMode"in document&&(oi=document.documentMode);var Kr=a&&"TextEvent"in window&&!oi,Ah=a&&(!Vi||oi&&8<oi&&11>=oi),oa=" ",b0=!1;function S0(f,m){switch(f){case"keyup":return w0.indexOf(m.keyCode)!==-1;case"keydown":return m.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Pm(f){return f=f.detail,typeof f=="object"&&"data"in f?f.data:null}var Iu=!1;function Nw(f,m){switch(f){case"compositionend":return Pm(m);case"keypress":return m.which!==32?null:(b0=!0,oa);case"textInput":return f=m.data,f===oa&&b0?null:f;default:return null}}function mf(f,m){if(Iu)return f==="compositionend"||!Vi&&S0(f,m)?(f=ff(),to=p0=Aa=null,Iu=!1,f):null;switch(f){case"paste":return null;case"keypress":if(!(m.ctrlKey||m.altKey||m.metaKey)||m.ctrlKey&&m.altKey){if(m.char&&1<m.char.length)return m.char;if(m.which)return String.fromCharCode(m.which)}return null;case"compositionend":return Ah&&m.locale!=="ko"?null:m.data;default:return null}}var Mh={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Lm(f){var m=f&&f.nodeName&&f.nodeName.toLowerCase();return m==="input"?!!Mh[f.type]:m==="textarea"}function kh(f,m,S,I){ln(I),m=Xm(m,"onChange"),0<m.length&&(S=new pf("onChange","change",null,S,I),f.push({event:S,listeners:m}))}var Nu=null,Rh=null;function Aw(f){Lh(f,0)}function $l(f){var m=ys(f);if(fe(m))return f}function Mw(f,m){if(f==="change")return m}var Dh=!1;if(a){var ro;if(a){var vc="oninput"in document;if(!vc){var xc=document.createElement("div");xc.setAttribute("oninput","return;"),vc=typeof xc.oninput=="function"}ro=vc}else ro=!1;Dh=ro&&(!document.documentMode||9<document.documentMode)}function Ma(){Nu&&(Nu.detachEvent("onpropertychange",Om),Rh=Nu=null)}function Om(f){if(f.propertyName==="value"&&$l(Rh)){var m=[];kh(m,Rh,f,Tn(f)),ms(Aw,m)}}function $h(f,m,S){f==="focusin"?(Ma(),Nu=m,Rh=S,Nu.attachEvent("onpropertychange",Om)):f==="focusout"&&Ma()}function kw(f){if(f==="selectionchange"||f==="keyup"||f==="keydown")return $l(Rh)}function _0(f,m){if(f==="click")return $l(m)}function ts(f,m){if(f==="input"||f==="change")return $l(m)}function Fm(f,m){return f===m&&(f!==0||1/f===1/m)||f!==f&&m!==m}var Ao=typeof Object.is=="function"?Object.is:Fm;function wc(f,m){if(Ao(f,m))return!0;if(typeof f!="object"||f===null||typeof m!="object"||m===null)return!1;var S=Object.keys(f),I=Object.keys(m);if(S.length!==I.length)return!1;for(I=0;I<S.length;I++){var D=S[I];if(!l.call(m,D)||!Ao(f[D],m[D]))return!1}return!0}function gf(f){for(;f&&f.firstChild;)f=f.firstChild;return f}function Mo(f,m){var S=gf(f);f=0;for(var I;S;){if(S.nodeType===3){if(I=f+S.textContent.length,f<=m&&I>=m)return{node:S,offset:m-f};f=I}e:{for(;S;){if(S.nextSibling){S=S.nextSibling;break e}S=S.parentNode}S=void 0}S=gf(S)}}function bc(f,m){return f&&m?f===m?!0:f&&f.nodeType===3?!1:m&&m.nodeType===3?bc(f,m.parentNode):"contains"in f?f.contains(m):f.compareDocumentPosition?!!(f.compareDocumentPosition(m)&16):!1:!1}function ns(){for(var f=window,m=nt();m instanceof f.HTMLIFrameElement;){try{var S=typeof m.contentWindow.location.href=="string"}catch{S=!1}if(S)f=m.contentWindow;else break;m=nt(f.document)}return m}function Gs(f){var m=f&&f.nodeName&&f.nodeName.toLowerCase();return m&&(m==="input"&&(f.type==="text"||f.type==="search"||f.type==="tel"||f.type==="url"||f.type==="password")||m==="textarea"||f.contentEditable==="true")}function Hs(f){var m=ns(),S=f.focusedElem,I=f.selectionRange;if(m!==S&&S&&S.ownerDocument&&bc(S.ownerDocument.documentElement,S)){if(I!==null&&Gs(S)){if(m=I.start,f=I.end,f===void 0&&(f=m),"selectionStart"in S)S.selectionStart=m,S.selectionEnd=Math.min(f,S.value.length);else if(f=(m=S.ownerDocument||document)&&m.defaultView||window,f.getSelection){f=f.getSelection();var D=S.textContent.length,F=Math.min(I.start,D);I=I.end===void 0?F:Math.min(I.end,D),!f.extend&&F>I&&(D=I,I=F,F=D),D=Mo(S,F);var Y=Mo(S,I);D&&Y&&(f.rangeCount!==1||f.anchorNode!==D.node||f.anchorOffset!==D.offset||f.focusNode!==Y.node||f.focusOffset!==Y.offset)&&(m=m.createRange(),m.setStart(D.node,D.offset),f.removeAllRanges(),F>I?(f.addRange(m),f.extend(Y.node,Y.offset)):(m.setEnd(Y.node,Y.offset),f.addRange(m)))}}for(m=[],f=S;f=f.parentNode;)f.nodeType===1&&m.push({element:f,left:f.scrollLeft,top:f.scrollTop});for(typeof S.focus=="function"&&S.focus(),S=0;S<m.length;S++)f=m[S],f.element.scrollLeft=f.left,f.element.scrollTop=f.top}}var zm=a&&"documentMode"in document&&11>=document.documentMode,rl=null,Sc=null,yf=null,js=!1;function Bm(f,m,S){var I=S.window===S?S.document:S.nodeType===9?S:S.ownerDocument;js||rl==null||rl!==nt(I)||(I=rl,"selectionStart"in I&&Gs(I)?I={start:I.selectionStart,end:I.selectionEnd}:(I=(I.ownerDocument&&I.ownerDocument.defaultView||window).getSelection(),I={anchorNode:I.anchorNode,anchorOffset:I.anchorOffset,focusNode:I.focusNode,focusOffset:I.focusOffset}),yf&&wc(yf,I)||(yf=I,I=Xm(Sc,"onSelect"),0<I.length&&(m=new pf("onSelect","select",null,m,S),f.push({event:m,listeners:I}),m.target=rl)))}function Ph(f,m){var S={};return S[f.toLowerCase()]=m.toLowerCase(),S["Webkit"+f]="webkit"+m,S["Moz"+f]="moz"+m,S}var Au={animationend:Ph("Animation","AnimationEnd"),animationiteration:Ph("Animation","AnimationIteration"),animationstart:Ph("Animation","AnimationStart"),transitionend:Ph("Transition","TransitionEnd")},ka={},Ra={};a&&(Ra=document.createElement("div").style,"AnimationEvent"in window||(delete Au.animationend.animation,delete Au.animationiteration.animation,delete Au.animationstart.animation),"TransitionEvent"in window||delete Au.transitionend.transition);function sl(f){if(ka[f])return ka[f];if(!Au[f])return f;var m=Au[f],S;for(S in m)if(m.hasOwnProperty(S)&&S in Ra)return ka[f]=m[S];return f}var vf=sl("animationend"),xf=sl("animationiteration"),T0=sl("animationstart"),E0=sl("transitionend"),C0=new Map,I0="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Pl(f,m){C0.set(f,m),i(m,[f])}for(var Um=0;Um<I0.length;Um++){var wf=I0[Um],bf=wf.toLowerCase(),Rw=wf[0].toUpperCase()+wf.slice(1);Pl(bf,"on"+Rw)}Pl(vf,"onAnimationEnd"),Pl(xf,"onAnimationIteration"),Pl(T0,"onAnimationStart"),Pl("dblclick","onDoubleClick"),Pl("focusin","onFocus"),Pl("focusout","onBlur"),Pl(E0,"onTransitionEnd"),o("onMouseEnter",["mouseout","mouseover"]),o("onMouseLeave",["mouseout","mouseover"]),o("onPointerEnter",["pointerout","pointerover"]),o("onPointerLeave",["pointerout","pointerover"]),i("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),i("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),i("onBeforeInput",["compositionend","keypress","textInput","paste"]),i("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),i("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),i("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Mu="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Vm=new Set("cancel close invalid load scroll toggle".split(" ").concat(Mu));function Wm(f,m,S){var I=f.type||"unknown-event";f.currentTarget=S,j(I,m,void 0,f),f.currentTarget=null}function Lh(f,m){m=(m&4)!==0;for(var S=0;S<f.length;S++){var I=f[S],D=I.event;I=I.listeners;e:{var F=void 0;if(m)for(var Y=I.length-1;0<=Y;Y--){var pe=I[Y],Te=pe.instance,qe=pe.currentTarget;if(pe=pe.listener,Te!==F&&D.isPropagationStopped())break e;Wm(D,pe,qe),F=Te}else for(Y=0;Y<I.length;Y++){if(pe=I[Y],Te=pe.instance,qe=pe.currentTarget,pe=pe.listener,Te!==F&&D.isPropagationStopped())break e;Wm(D,pe,qe),F=Te}}}if(ii)throw f=En,ii=!1,En=null,f}function Fr(f,m){var S=m[Ec];S===void 0&&(S=m[Ec]=new Set);var I=f+"__bubble";S.has(I)||(Hm(m,f,2,!1),S.add(I))}function Gm(f,m,S){var I=0;m&&(I|=4),Hm(S,f,I,m)}var Sf="_reactListening"+Math.random().toString(36).slice(2);function Oh(f){if(!f[Sf]){f[Sf]=!0,r.forEach(function(S){S!=="selectionchange"&&(Vm.has(S)||Gm(S,!1,f),Gm(S,!0,f))});var m=f.nodeType===9?f:f.ownerDocument;m===null||m[Sf]||(m[Sf]=!0,Gm("selectionchange",!1,m))}}function Hm(f,m,S,I){switch(Sw(m)){case 1:var D=Em;break;case 4:D=f0;break;default:D=Cm}S=D.bind(null,m,S,f),D=void 0,!gs||m!=="touchstart"&&m!=="touchmove"&&m!=="wheel"||(D=!0),I?D!==void 0?f.addEventListener(m,S,{capture:!0,passive:D}):f.addEventListener(m,S,!0):D!==void 0?f.addEventListener(m,S,{passive:D}):f.addEventListener(m,S,!1)}function jm(f,m,S,I,D){var F=I;if((m&1)===0&&(m&2)===0&&I!==null)e:for(;;){if(I===null)return;var Y=I.tag;if(Y===3||Y===4){var pe=I.stateNode.containerInfo;if(pe===D||pe.nodeType===8&&pe.parentNode===D)break;if(Y===4)for(Y=I.return;Y!==null;){var Te=Y.tag;if((Te===3||Te===4)&&(Te=Y.stateNode.containerInfo,Te===D||Te.nodeType===8&&Te.parentNode===D))return;Y=Y.return}for(;pe!==null;){if(Y=ku(pe),Y===null)return;if(Te=Y.tag,Te===5||Te===6){I=F=Y;continue e}pe=pe.parentNode}}I=I.return}ms(function(){var qe=F,yt=Tn(S),vt=[];e:{var pt=C0.get(f);if(pt!==void 0){var Wt=pf,qt=f;switch(f){case"keypress":if(fc(S)===0)break e;case"keydown":case"keyup":Wt=$m;break;case"focusin":qt="focus",Wt=Mm;break;case"focusout":qt="blur",Wt=Mm;break;case"beforeblur":case"afterblur":Wt=Mm;break;case"click":if(S.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Wt=m0;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Wt=Eu;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Wt=Rl;break;case vf:case xf:case T0:Wt=_w;break;case E0:Wt=yc;break;case"scroll":Wt=Ch;break;case"wheel":Wt=x0;break;case"copy":case"cut":case"paste":Wt=g0;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Wt=No}var Yt=(m&4)!==0,Ls=!Yt&&f==="scroll",Fe=Yt?pt!==null?pt+"Capture":null:pt;Yt=[];for(var Ne=qe,Be;Ne!==null;){Be=Ne;var St=Be.stateNode;if(Be.tag===5&&St!==null&&(Be=St,Fe!==null&&(St=er(Ne,Fe),St!=null&&Yt.push(Fh(Ne,St,Be)))),Ls)break;Ne=Ne.return}0<Yt.length&&(pt=new Wt(pt,qt,null,S,yt),vt.push({event:pt,listeners:Yt}))}}if((m&7)===0){e:{if(pt=f==="mouseover"||f==="pointerover",Wt=f==="mouseout"||f==="pointerout",pt&&S!==Mn&&(qt=S.relatedTarget||S.fromElement)&&(ku(qt)||qt[ko]))break e;if((Wt||pt)&&(pt=yt.window===yt?yt:(pt=yt.ownerDocument)?pt.defaultView||pt.parentWindow:window,Wt?(qt=S.relatedTarget||S.toElement,Wt=qe,qt=qt?ku(qt):null,qt!==null&&(Ls=re(qt),qt!==Ls||qt.tag!==5&&qt.tag!==6)&&(qt=null)):(Wt=null,qt=qe),Wt!==qt)){if(Yt=m0,St="onMouseLeave",Fe="onMouseEnter",Ne="mouse",(f==="pointerout"||f==="pointerover")&&(Yt=No,St="onPointerLeave",Fe="onPointerEnter",Ne="pointer"),Ls=Wt==null?pt:ys(Wt),Be=qt==null?pt:ys(qt),pt=new Yt(St,Ne+"leave",Wt,S,yt),pt.target=Ls,pt.relatedTarget=Be,St=null,ku(yt)===qe&&(Yt=new Yt(Fe,Ne+"enter",qt,S,yt),Yt.target=Be,Yt.relatedTarget=Ls,St=Yt),Ls=St,Wt&&qt)t:{for(Yt=Wt,Fe=qt,Ne=0,Be=Yt;Be;Be=_c(Be))Ne++;for(Be=0,St=Fe;St;St=_c(St))Be++;for(;0<Ne-Be;)Yt=_c(Yt),Ne--;for(;0<Be-Ne;)Fe=_c(Fe),Be--;for(;Ne--;){if(Yt===Fe||Fe!==null&&Yt===Fe.alternate)break t;Yt=_c(Yt),Fe=_c(Fe)}Yt=null}else Yt=null;Wt!==null&&Dw(vt,pt,Wt,Yt,!1),qt!==null&&Ls!==null&&Dw(vt,Ls,qt,Yt,!0)}}e:{if(pt=qe?ys(qe):window,Wt=pt.nodeName&&pt.nodeName.toLowerCase(),Wt==="select"||Wt==="input"&&pt.type==="file")var Qt=Mw;else if(Lm(pt))if(Dh)Qt=ts;else{Qt=kw;var fn=$h}else(Wt=pt.nodeName)&&Wt.toLowerCase()==="input"&&(pt.type==="checkbox"||pt.type==="radio")&&(Qt=_0);if(Qt&&(Qt=Qt(f,qe))){kh(vt,Qt,S,yt);break e}fn&&fn(f,pt,qe),f==="focusout"&&(fn=pt._wrapperState)&&fn.controlled&&pt.type==="number"&&oe(pt,"number",pt.value)}switch(fn=qe?ys(qe):window,f){case"focusin":(Lm(fn)||fn.contentEditable==="true")&&(rl=fn,Sc=qe,yf=null);break;case"focusout":yf=Sc=rl=null;break;case"mousedown":js=!0;break;case"contextmenu":case"mouseup":case"dragend":js=!1,Bm(vt,S,yt);break;case"selectionchange":if(zm)break;case"keydown":case"keyup":Bm(vt,S,yt)}var pn;if(Vi)e:{switch(f){case"compositionstart":var Sn="onCompositionStart";break e;case"compositionend":Sn="onCompositionEnd";break e;case"compositionupdate":Sn="onCompositionUpdate";break e}Sn=void 0}else Iu?S0(f,S)&&(Sn="onCompositionEnd"):f==="keydown"&&S.keyCode===229&&(Sn="onCompositionStart");Sn&&(Ah&&S.locale!=="ko"&&(Iu||Sn!=="onCompositionStart"?Sn==="onCompositionEnd"&&Iu&&(pn=ff()):(Aa=yt,p0="value"in Aa?Aa.value:Aa.textContent,Iu=!0)),fn=Xm(qe,Sn),0<fn.length&&(Sn=new y0(Sn,f,null,S,yt),vt.push({event:Sn,listeners:fn}),pn?Sn.data=pn:(pn=Pm(S),pn!==null&&(Sn.data=pn)))),(pn=Kr?Nw(f,S):mf(f,S))&&(qe=Xm(qe,"onBeforeInput"),0<qe.length&&(yt=new y0("onBeforeInput","beforeinput",null,S,yt),vt.push({event:yt,listeners:qe}),yt.data=pn))}Lh(vt,m)})}function Fh(f,m,S){return{instance:f,listener:m,currentTarget:S}}function Xm(f,m){for(var S=m+"Capture",I=[];f!==null;){var D=f,F=D.stateNode;D.tag===5&&F!==null&&(D=F,F=er(f,S),F!=null&&I.unshift(Fh(f,F,D)),F=er(f,m),F!=null&&I.push(Fh(f,F,D))),f=f.return}return I}function _c(f){if(f===null)return null;do f=f.return;while(f&&f.tag!==5);return f||null}function Dw(f,m,S,I,D){for(var F=m._reactName,Y=[];S!==null&&S!==I;){var pe=S,Te=pe.alternate,qe=pe.stateNode;if(Te!==null&&Te===I)break;pe.tag===5&&qe!==null&&(pe=qe,D?(Te=er(S,F),Te!=null&&Y.unshift(Fh(S,Te,pe))):D||(Te=er(S,F),Te!=null&&Y.push(Fh(S,Te,pe)))),S=S.return}Y.length!==0&&f.push({event:m,listeners:Y})}var tC=/\r\n?/g,$w=/\u0000|\uFFFD/g;function N0(f){return(typeof f=="string"?f:""+f).replace(tC,`
`).replace($w,"")}function _f(f,m,S){if(m=N0(m),N0(f)!==m&&S)throw Error(t(425))}function Tf(){}var zh=null,A0=null;function M0(f,m){return f==="textarea"||f==="noscript"||typeof m.children=="string"||typeof m.children=="number"||typeof m.dangerouslySetInnerHTML=="object"&&m.dangerouslySetInnerHTML!==null&&m.dangerouslySetInnerHTML.__html!=null}var k0=typeof setTimeout=="function"?setTimeout:void 0,R0=typeof clearTimeout=="function"?clearTimeout:void 0,qm=typeof Promise=="function"?Promise:void 0,nC=typeof queueMicrotask=="function"?queueMicrotask:typeof qm<"u"?function(f){return qm.resolve(null).then(f).catch(Pw)}:k0;function Pw(f){setTimeout(function(){throw f})}function Km(f,m){var S=m,I=0;do{var D=S.nextSibling;if(f.removeChild(S),D&&D.nodeType===8)if(S=D.data,S==="/$"){if(I===0){f.removeChild(D),df(m);return}I--}else S!=="$"&&S!=="$?"&&S!=="$!"||I++;S=D}while(S);df(m)}function Ll(f){for(;f!=null;f=f.nextSibling){var m=f.nodeType;if(m===1||m===3)break;if(m===8){if(m=f.data,m==="$"||m==="$!"||m==="$?")break;if(m==="/$")return null}}return f}function D0(f){f=f.previousSibling;for(var m=0;f;){if(f.nodeType===8){var S=f.data;if(S==="$"||S==="$!"||S==="$?"){if(m===0)return f;m--}else S==="/$"&&m++}f=f.previousSibling}return null}var Tc=Math.random().toString(36).slice(2),Ps="__reactFiber$"+Tc,Bh="__reactProps$"+Tc,ko="__reactContainer$"+Tc,Ec="__reactEvents$"+Tc,Ym="__reactListeners$"+Tc,Zm="__reactHandles$"+Tc;function ku(f){var m=f[Ps];if(m)return m;for(var S=f.parentNode;S;){if(m=S[ko]||S[Ps]){if(S=m.alternate,m.child!==null||S!==null&&S.child!==null)for(f=D0(f);f!==null;){if(S=f[Ps])return S;f=D0(f)}return m}f=S,S=f.parentNode}return null}function Ol(f){return f=f[Ps]||f[ko],!f||f.tag!==5&&f.tag!==6&&f.tag!==13&&f.tag!==3?null:f}function ys(f){if(f.tag===5||f.tag===6)return f.stateNode;throw Error(t(33))}function Jm(f){return f[Bh]||null}var $0=[],Xs=-1;function ls(f){return{current:f}}function zr(f){0>Xs||(f.current=$0[Xs],$0[Xs]=null,Xs--)}function Dr(f,m){Xs++,$0[Xs]=f.current,f.current=m}var Fl={},ai=ls(Fl),Wi=ls(!1),zl=Fl;function Cc(f,m){var S=f.type.contextTypes;if(!S)return Fl;var I=f.stateNode;if(I&&I.__reactInternalMemoizedUnmaskedChildContext===m)return I.__reactInternalMemoizedMaskedChildContext;var D={},F;for(F in S)D[F]=m[F];return I&&(f=f.stateNode,f.__reactInternalMemoizedUnmaskedChildContext=m,f.__reactInternalMemoizedMaskedChildContext=D),D}function Ti(f){return f=f.childContextTypes,f!=null}function Ef(){zr(Wi),zr(ai)}function P0(f,m,S){if(ai.current!==Fl)throw Error(t(168));Dr(ai,m),Dr(Wi,S)}function Cf(f,m,S){var I=f.stateNode;if(m=m.childContextTypes,typeof I.getChildContext!="function")return S;I=I.getChildContext();for(var D in I)if(!(D in m))throw Error(t(108,Re(f)||"Unknown",D));return K({},S,I)}function Ic(f){return f=(f=f.stateNode)&&f.__reactInternalMemoizedMergedChildContext||Fl,zl=ai.current,Dr(ai,f),Dr(Wi,Wi.current),!0}function L0(f,m,S){var I=f.stateNode;if(!I)throw Error(t(169));S?(f=Cf(f,m,zl),I.__reactInternalMemoizedMergedChildContext=f,zr(Wi),zr(ai),Dr(ai,f)):zr(Wi),Dr(Wi,S)}var Da=null,If=!1,Qm=!1;function Nf(f){Da===null?Da=[f]:Da.push(f)}function Lw(f){If=!0,Nf(f)}function il(){if(!Qm&&Da!==null){Qm=!0;var f=0,m=cr;try{var S=Da;for(cr=1;f<S.length;f++){var I=S[f];do I=I(!0);while(I!==null)}Da=null,If=!1}catch(D){throw Da!==null&&(Da=Da.slice(f+1)),me(dt,il),D}finally{cr=m,Qm=!1}}return null}var Nc=[],so=0,eg=null,tg=0,Gi=[],qs=0,Ac=null,Et=1,aa="";function Bl(f,m){Nc[so++]=tg,Nc[so++]=eg,eg=f,tg=m}function O0(f,m,S){Gi[qs++]=Et,Gi[qs++]=aa,Gi[qs++]=Ac,Ac=f;var I=Et;f=aa;var D=32-mn(I)-1;I&=~(1<<D),S+=1;var F=32-mn(m)+D;if(30<F){var Y=D-D%5;F=(I&(1<<Y)-1).toString(32),I>>=Y,D-=Y,Et=1<<32-mn(m)+D|S<<D|I,aa=F+f}else Et=1<<F|S<<D|I,aa=f}function F0(f){f.return!==null&&(Bl(f,1),O0(f,1,0))}function Ul(f){for(;f===eg;)eg=Nc[--so],Nc[so]=null,tg=Nc[--so],Nc[so]=null;for(;f===Ac;)Ac=Gi[--qs],Gi[qs]=null,aa=Gi[--qs],Gi[qs]=null,Et=Gi[--qs],Gi[qs]=null}var li=null,Hi=null,Gr=!1,la=null;function z0(f,m){var S=cl(5,null,null,0);S.elementType="DELETED",S.stateNode=m,S.return=f,m=f.deletions,m===null?(f.deletions=[S],f.flags|=16):m.push(S)}function B0(f,m){switch(f.tag){case 5:var S=f.type;return m=m.nodeType!==1||S.toLowerCase()!==m.nodeName.toLowerCase()?null:m,m!==null?(f.stateNode=m,li=f,Hi=Ll(m.firstChild),!0):!1;case 6:return m=f.pendingProps===""||m.nodeType!==3?null:m,m!==null?(f.stateNode=m,li=f,Hi=null,!0):!1;case 13:return m=m.nodeType!==8?null:m,m!==null?(S=Ac!==null?{id:Et,overflow:aa}:null,f.memoizedState={dehydrated:m,treeContext:S,retryLane:1073741824},S=cl(18,null,null,0),S.stateNode=m,S.return=f,f.child=S,li=f,Hi=null,!0):!1;default:return!1}}function ng(f){return(f.mode&1)!==0&&(f.flags&128)===0}function rg(f){if(Gr){var m=Hi;if(m){var S=m;if(!B0(f,m)){if(ng(f))throw Error(t(418));m=Ll(S.nextSibling);var I=li;m&&B0(f,m)?z0(I,S):(f.flags=f.flags&-4097|2,Gr=!1,li=f)}}else{if(ng(f))throw Error(t(418));f.flags=f.flags&-4097|2,Gr=!1,li=f}}}function sg(f){for(f=f.return;f!==null&&f.tag!==5&&f.tag!==3&&f.tag!==13;)f=f.return;li=f}function Uh(f){if(f!==li)return!1;if(!Gr)return sg(f),Gr=!0,!1;var m;if((m=f.tag!==3)&&!(m=f.tag!==5)&&(m=f.type,m=m!=="head"&&m!=="body"&&!M0(f.type,f.memoizedProps)),m&&(m=Hi)){if(ng(f))throw U0(),Error(t(418));for(;m;)z0(f,m),m=Ll(m.nextSibling)}if(sg(f),f.tag===13){if(f=f.memoizedState,f=f!==null?f.dehydrated:null,!f)throw Error(t(317));e:{for(f=f.nextSibling,m=0;f;){if(f.nodeType===8){var S=f.data;if(S==="/$"){if(m===0){Hi=Ll(f.nextSibling);break e}m--}else S!=="$"&&S!=="$!"&&S!=="$?"||m++}f=f.nextSibling}Hi=null}}else Hi=li?Ll(f.stateNode.nextSibling):null;return!0}function U0(){for(var f=Hi;f;)f=Ll(f.nextSibling)}function Ru(){Hi=li=null,Gr=!1}function Vh(f){la===null?la=[f]:la.push(f)}var rC=E.ReactCurrentBatchConfig;function Af(f,m,S){if(f=S.ref,f!==null&&typeof f!="function"&&typeof f!="object"){if(S._owner){if(S=S._owner,S){if(S.tag!==1)throw Error(t(309));var I=S.stateNode}if(!I)throw Error(t(147,f));var D=I,F=""+f;return m!==null&&m.ref!==null&&typeof m.ref=="function"&&m.ref._stringRef===F?m.ref:(m=function(Y){var pe=D.refs;Y===null?delete pe[F]:pe[F]=Y},m._stringRef=F,m)}if(typeof f!="string")throw Error(t(284));if(!S._owner)throw Error(t(290,f))}return f}function Mf(f,m){throw f=Object.prototype.toString.call(m),Error(t(31,f==="[object Object]"?"object with keys {"+Object.keys(m).join(", ")+"}":f))}function V0(f){var m=f._init;return m(f._payload)}function W0(f){function m(Fe,Ne){if(f){var Be=Fe.deletions;Be===null?(Fe.deletions=[Ne],Fe.flags|=16):Be.push(Ne)}}function S(Fe,Ne){if(!f)return null;for(;Ne!==null;)m(Fe,Ne),Ne=Ne.sibling;return null}function I(Fe,Ne){for(Fe=new Map;Ne!==null;)Ne.key!==null?Fe.set(Ne.key,Ne):Fe.set(Ne.index,Ne),Ne=Ne.sibling;return Fe}function D(Fe,Ne){return Fe=Qh(Fe,Ne),Fe.index=0,Fe.sibling=null,Fe}function F(Fe,Ne,Be){return Fe.index=Be,f?(Be=Fe.alternate,Be!==null?(Be=Be.index,Be<Ne?(Fe.flags|=2,Ne):Be):(Fe.flags|=2,Ne)):(Fe.flags|=1048576,Ne)}function Y(Fe){return f&&Fe.alternate===null&&(Fe.flags|=2),Fe}function pe(Fe,Ne,Be,St){return Ne===null||Ne.tag!==6?(Ne=SC(Be,Fe.mode,St),Ne.return=Fe,Ne):(Ne=D(Ne,Be),Ne.return=Fe,Ne)}function Te(Fe,Ne,Be,St){var Qt=Be.type;return Qt===$?yt(Fe,Ne,Be.props.children,St,Be.key):Ne!==null&&(Ne.elementType===Qt||typeof Qt=="object"&&Qt!==null&&Qt.$$typeof===q&&V0(Qt)===Ne.type)?(St=D(Ne,Be.props),St.ref=Af(Fe,Ne,Be),St.return=Fe,St):(St=ib(Be.type,Be.key,Be.props,null,Fe.mode,St),St.ref=Af(Fe,Ne,Be),St.return=Fe,St)}function qe(Fe,Ne,Be,St){return Ne===null||Ne.tag!==4||Ne.stateNode.containerInfo!==Be.containerInfo||Ne.stateNode.implementation!==Be.implementation?(Ne=_C(Be,Fe.mode,St),Ne.return=Fe,Ne):(Ne=D(Ne,Be.children||[]),Ne.return=Fe,Ne)}function yt(Fe,Ne,Be,St,Qt){return Ne===null||Ne.tag!==7?(Ne=Xf(Be,Fe.mode,St,Qt),Ne.return=Fe,Ne):(Ne=D(Ne,Be),Ne.return=Fe,Ne)}function vt(Fe,Ne,Be){if(typeof Ne=="string"&&Ne!==""||typeof Ne=="number")return Ne=SC(""+Ne,Fe.mode,Be),Ne.return=Fe,Ne;if(typeof Ne=="object"&&Ne!==null){switch(Ne.$$typeof){case N:return Be=ib(Ne.type,Ne.key,Ne.props,null,Fe.mode,Be),Be.ref=Af(Fe,null,Ne),Be.return=Fe,Be;case M:return Ne=_C(Ne,Fe.mode,Be),Ne.return=Fe,Ne;case q:var St=Ne._init;return vt(Fe,St(Ne._payload),Be)}if(ee(Ne)||J(Ne))return Ne=Xf(Ne,Fe.mode,Be,null),Ne.return=Fe,Ne;Mf(Fe,Ne)}return null}function pt(Fe,Ne,Be,St){var Qt=Ne!==null?Ne.key:null;if(typeof Be=="string"&&Be!==""||typeof Be=="number")return Qt!==null?null:pe(Fe,Ne,""+Be,St);if(typeof Be=="object"&&Be!==null){switch(Be.$$typeof){case N:return Be.key===Qt?Te(Fe,Ne,Be,St):null;case M:return Be.key===Qt?qe(Fe,Ne,Be,St):null;case q:return Qt=Be._init,pt(Fe,Ne,Qt(Be._payload),St)}if(ee(Be)||J(Be))return Qt!==null?null:yt(Fe,Ne,Be,St,null);Mf(Fe,Be)}return null}function Wt(Fe,Ne,Be,St,Qt){if(typeof St=="string"&&St!==""||typeof St=="number")return Fe=Fe.get(Be)||null,pe(Ne,Fe,""+St,Qt);if(typeof St=="object"&&St!==null){switch(St.$$typeof){case N:return Fe=Fe.get(St.key===null?Be:St.key)||null,Te(Ne,Fe,St,Qt);case M:return Fe=Fe.get(St.key===null?Be:St.key)||null,qe(Ne,Fe,St,Qt);case q:var fn=St._init;return Wt(Fe,Ne,Be,fn(St._payload),Qt)}if(ee(St)||J(St))return Fe=Fe.get(Be)||null,yt(Ne,Fe,St,Qt,null);Mf(Ne,St)}return null}function qt(Fe,Ne,Be,St){for(var Qt=null,fn=null,pn=Ne,Sn=Ne=0,Ni=null;pn!==null&&Sn<Be.length;Sn++){pn.index>Sn?(Ni=pn,pn=null):Ni=pn.sibling;var vr=pt(Fe,pn,Be[Sn],St);if(vr===null){pn===null&&(pn=Ni);break}f&&pn&&vr.alternate===null&&m(Fe,pn),Ne=F(vr,Ne,Sn),fn===null?Qt=vr:fn.sibling=vr,fn=vr,pn=Ni}if(Sn===Be.length)return S(Fe,pn),Gr&&Bl(Fe,Sn),Qt;if(pn===null){for(;Sn<Be.length;Sn++)pn=vt(Fe,Be[Sn],St),pn!==null&&(Ne=F(pn,Ne,Sn),fn===null?Qt=pn:fn.sibling=pn,fn=pn);return Gr&&Bl(Fe,Sn),Qt}for(pn=I(Fe,pn);Sn<Be.length;Sn++)Ni=Wt(pn,Fe,Sn,Be[Sn],St),Ni!==null&&(f&&Ni.alternate!==null&&pn.delete(Ni.key===null?Sn:Ni.key),Ne=F(Ni,Ne,Sn),fn===null?Qt=Ni:fn.sibling=Ni,fn=Ni);return f&&pn.forEach(function(ed){return m(Fe,ed)}),Gr&&Bl(Fe,Sn),Qt}function Yt(Fe,Ne,Be,St){var Qt=J(Be);if(typeof Qt!="function")throw Error(t(150));if(Be=Qt.call(Be),Be==null)throw Error(t(151));for(var fn=Qt=null,pn=Ne,Sn=Ne=0,Ni=null,vr=Be.next();pn!==null&&!vr.done;Sn++,vr=Be.next()){pn.index>Sn?(Ni=pn,pn=null):Ni=pn.sibling;var ed=pt(Fe,pn,vr.value,St);if(ed===null){pn===null&&(pn=Ni);break}f&&pn&&ed.alternate===null&&m(Fe,pn),Ne=F(ed,Ne,Sn),fn===null?Qt=ed:fn.sibling=ed,fn=ed,pn=Ni}if(vr.done)return S(Fe,pn),Gr&&Bl(Fe,Sn),Qt;if(pn===null){for(;!vr.done;Sn++,vr=Be.next())vr=vt(Fe,vr.value,St),vr!==null&&(Ne=F(vr,Ne,Sn),fn===null?Qt=vr:fn.sibling=vr,fn=vr);return Gr&&Bl(Fe,Sn),Qt}for(pn=I(Fe,pn);!vr.done;Sn++,vr=Be.next())vr=Wt(pn,Fe,Sn,vr.value,St),vr!==null&&(f&&vr.alternate!==null&&pn.delete(vr.key===null?Sn:vr.key),Ne=F(vr,Ne,Sn),fn===null?Qt=vr:fn.sibling=vr,fn=vr);return f&&pn.forEach(function(f8){return m(Fe,f8)}),Gr&&Bl(Fe,Sn),Qt}function Ls(Fe,Ne,Be,St){if(typeof Be=="object"&&Be!==null&&Be.type===$&&Be.key===null&&(Be=Be.props.children),typeof Be=="object"&&Be!==null){switch(Be.$$typeof){case N:e:{for(var Qt=Be.key,fn=Ne;fn!==null;){if(fn.key===Qt){if(Qt=Be.type,Qt===$){if(fn.tag===7){S(Fe,fn.sibling),Ne=D(fn,Be.props.children),Ne.return=Fe,Fe=Ne;break e}}else if(fn.elementType===Qt||typeof Qt=="object"&&Qt!==null&&Qt.$$typeof===q&&V0(Qt)===fn.type){S(Fe,fn.sibling),Ne=D(fn,Be.props),Ne.ref=Af(Fe,fn,Be),Ne.return=Fe,Fe=Ne;break e}S(Fe,fn);break}else m(Fe,fn);fn=fn.sibling}Be.type===$?(Ne=Xf(Be.props.children,Fe.mode,St,Be.key),Ne.return=Fe,Fe=Ne):(St=ib(Be.type,Be.key,Be.props,null,Fe.mode,St),St.ref=Af(Fe,Ne,Be),St.return=Fe,Fe=St)}return Y(Fe);case M:e:{for(fn=Be.key;Ne!==null;){if(Ne.key===fn)if(Ne.tag===4&&Ne.stateNode.containerInfo===Be.containerInfo&&Ne.stateNode.implementation===Be.implementation){S(Fe,Ne.sibling),Ne=D(Ne,Be.children||[]),Ne.return=Fe,Fe=Ne;break e}else{S(Fe,Ne);break}else m(Fe,Ne);Ne=Ne.sibling}Ne=_C(Be,Fe.mode,St),Ne.return=Fe,Fe=Ne}return Y(Fe);case q:return fn=Be._init,Ls(Fe,Ne,fn(Be._payload),St)}if(ee(Be))return qt(Fe,Ne,Be,St);if(J(Be))return Yt(Fe,Ne,Be,St);Mf(Fe,Be)}return typeof Be=="string"&&Be!==""||typeof Be=="number"?(Be=""+Be,Ne!==null&&Ne.tag===6?(S(Fe,Ne.sibling),Ne=D(Ne,Be),Ne.return=Fe,Fe=Ne):(S(Fe,Ne),Ne=SC(Be,Fe.mode,St),Ne.return=Fe,Fe=Ne),Y(Fe)):S(Fe,Ne)}return Ls}var Mc=W0(!0),kf=W0(!1),kc=ls(null),Rc=null,Vl=null,Wh=null;function Dc(){Wh=Vl=Rc=null}function Rf(f){var m=kc.current;zr(kc),f._currentValue=m}function Df(f,m,S){for(;f!==null;){var I=f.alternate;if((f.childLanes&m)!==m?(f.childLanes|=m,I!==null&&(I.childLanes|=m)):I!==null&&(I.childLanes&m)!==m&&(I.childLanes|=m),f===S)break;f=f.return}}function Du(f,m){Rc=f,Wh=Vl=null,f=f.dependencies,f!==null&&f.firstContext!==null&&((f.lanes&m)!==0&&(On=!0),f.firstContext=null)}function Ro(f){var m=f._currentValue;if(Wh!==f)if(f={context:f,memoizedValue:m,next:null},Vl===null){if(Rc===null)throw Error(t(308));Vl=f,Rc.dependencies={lanes:0,firstContext:f}}else Vl=Vl.next=f;return m}var Wl=null;function G0(f){Wl===null?Wl=[f]:Wl.push(f)}function $f(f,m,S,I){var D=m.interleaved;return D===null?(S.next=S,G0(m)):(S.next=D.next,D.next=S),m.interleaved=S,$a(f,I)}function $a(f,m){f.lanes|=m;var S=f.alternate;for(S!==null&&(S.lanes|=m),S=f,f=f.return;f!==null;)f.childLanes|=m,S=f.alternate,S!==null&&(S.childLanes|=m),S=f,f=f.return;return S.tag===3?S.stateNode:null}var Ir=!1;function Ln(f){f.updateQueue={baseState:f.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function vs(f,m){f=f.updateQueue,m.updateQueue===f&&(m.updateQueue={baseState:f.baseState,firstBaseUpdate:f.firstBaseUpdate,lastBaseUpdate:f.lastBaseUpdate,shared:f.shared,effects:f.effects})}function Nr(f,m){return{eventTime:f,lane:m,tag:0,payload:null,callback:null,next:null}}function Yr(f,m,S){var I=f.updateQueue;if(I===null)return null;if(I=I.shared,(mr&2)!==0){var D=I.pending;return D===null?m.next=m:(m.next=D.next,D.next=m),I.pending=m,$a(f,S)}return D=I.interleaved,D===null?(m.next=m,G0(I)):(m.next=D.next,D.next=m),I.interleaved=m,$a(f,S)}function Ei(f,m,S){if(m=m.updateQueue,m!==null&&(m=m.shared,(S&4194240)!==0)){var I=m.lanes;I&=f.pendingLanes,S|=I,m.lanes=S,_h(f,S)}}function $c(f,m){var S=f.updateQueue,I=f.alternate;if(I!==null&&(I=I.updateQueue,S===I)){var D=null,F=null;if(S=S.firstBaseUpdate,S!==null){do{var Y={eventTime:S.eventTime,lane:S.lane,tag:S.tag,payload:S.payload,callback:S.callback,next:null};F===null?D=F=Y:F=F.next=Y,S=S.next}while(S!==null);F===null?D=F=m:F=F.next=m}else D=F=m;S={baseState:I.baseState,firstBaseUpdate:D,lastBaseUpdate:F,shared:I.shared,effects:I.effects},f.updateQueue=S;return}f=S.lastBaseUpdate,f===null?S.firstBaseUpdate=m:f.next=m,S.lastBaseUpdate=m}function us(f,m,S,I){var D=f.updateQueue;Ir=!1;var F=D.firstBaseUpdate,Y=D.lastBaseUpdate,pe=D.shared.pending;if(pe!==null){D.shared.pending=null;var Te=pe,qe=Te.next;Te.next=null,Y===null?F=qe:Y.next=qe,Y=Te;var yt=f.alternate;yt!==null&&(yt=yt.updateQueue,pe=yt.lastBaseUpdate,pe!==Y&&(pe===null?yt.firstBaseUpdate=qe:pe.next=qe,yt.lastBaseUpdate=Te))}if(F!==null){var vt=D.baseState;Y=0,yt=qe=Te=null,pe=F;do{var pt=pe.lane,Wt=pe.eventTime;if((I&pt)===pt){yt!==null&&(yt=yt.next={eventTime:Wt,lane:0,tag:pe.tag,payload:pe.payload,callback:pe.callback,next:null});e:{var qt=f,Yt=pe;switch(pt=m,Wt=S,Yt.tag){case 1:if(qt=Yt.payload,typeof qt=="function"){vt=qt.call(Wt,vt,pt);break e}vt=qt;break e;case 3:qt.flags=qt.flags&-65537|128;case 0:if(qt=Yt.payload,pt=typeof qt=="function"?qt.call(Wt,vt,pt):qt,pt==null)break e;vt=K({},vt,pt);break e;case 2:Ir=!0}}pe.callback!==null&&pe.lane!==0&&(f.flags|=64,pt=D.effects,pt===null?D.effects=[pe]:pt.push(pe))}else Wt={eventTime:Wt,lane:pt,tag:pe.tag,payload:pe.payload,callback:pe.callback,next:null},yt===null?(qe=yt=Wt,Te=vt):yt=yt.next=Wt,Y|=pt;if(pe=pe.next,pe===null){if(pe=D.shared.pending,pe===null)break;pt=pe,pe=pt.next,pt.next=null,D.lastBaseUpdate=pt,D.shared.pending=null}}while(!0);if(yt===null&&(Te=vt),D.baseState=Te,D.firstBaseUpdate=qe,D.lastBaseUpdate=yt,m=D.shared.interleaved,m!==null){D=m;do Y|=D.lane,D=D.next;while(D!==m)}else F===null&&(D.shared.lanes=0);Wf|=Y,f.lanes=Y,f.memoizedState=vt}}function Gh(f,m,S){if(f=m.effects,m.effects=null,f!==null)for(m=0;m<f.length;m++){var I=f[m],D=I.callback;if(D!==null){if(I.callback=null,I=S,typeof D!="function")throw Error(t(191,D));D.call(I)}}}var ol={},Do=ls(ol),Pc=ls(ol),Gl=ls(ol);function bs(f){if(f===ol)throw Error(t(174));return f}function Pf(f,m){switch(Dr(Gl,m),Dr(Pc,f),Dr(Do,ol),f=m.nodeType,f){case 9:case 11:m=(m=m.documentElement)?m.namespaceURI:It(null,"");break;default:f=f===8?m.parentNode:m,m=f.namespaceURI||null,f=f.tagName,m=It(m,f)}zr(Do),Dr(Do,m)}function $u(){zr(Do),zr(Pc),zr(Gl)}function Lc(f){bs(Gl.current);var m=bs(Do.current),S=It(m,f.type);m!==S&&(Dr(Pc,f),Dr(Do,S))}function Hh(f){Pc.current===f&&(zr(Do),zr(Pc))}var Hr=ls(0);function Pa(f){for(var m=f;m!==null;){if(m.tag===13){var S=m.memoizedState;if(S!==null&&(S=S.dehydrated,S===null||S.data==="$?"||S.data==="$!"))return m}else if(m.tag===19&&m.memoizedProps.revealOrder!==void 0){if((m.flags&128)!==0)return m}else if(m.child!==null){m.child.return=m,m=m.child;continue}if(m===f)break;for(;m.sibling===null;){if(m.return===null||m.return===f)return null;m=m.return}m.sibling.return=m.return,m=m.sibling}return null}var jh=[];function al(){for(var f=0;f<jh.length;f++)jh[f]._workInProgressVersionPrimary=null;jh.length=0}var Oc=E.ReactCurrentDispatcher,Fc=E.ReactCurrentBatchConfig,Hl=0,Br=null,cs=null,hr=null,La=!1,Ci=!1,Pu=0,io=0;function ui(){throw Error(t(321))}function Lf(f,m){if(m===null)return!1;for(var S=0;S<m.length&&S<f.length;S++)if(!Ao(f[S],m[S]))return!1;return!0}function Of(f,m,S,I,D,F){if(Hl=F,Br=m,m.memoizedState=null,m.updateQueue=null,m.lanes=0,Oc.current=f===null||f.memoizedState===null?Ww:Gw,f=S(I,D),Ci){F=0;do{if(Ci=!1,Pu=0,25<=F)throw Error(t(301));F+=1,hr=cs=null,m.updateQueue=null,Oc.current=Hw,f=S(I,D)}while(Ci)}if(Oc.current=hg,m=cs!==null&&cs.next!==null,Hl=0,hr=cs=Br=null,La=!1,m)throw Error(t(300));return f}function H0(){var f=Pu!==0;return Pu=0,f}function ci(){var f={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return hr===null?Br.memoizedState=hr=f:hr=hr.next=f,hr}function $o(){if(cs===null){var f=Br.alternate;f=f!==null?f.memoizedState:null}else f=cs.next;var m=hr===null?Br.memoizedState:hr.next;if(m!==null)hr=m,cs=f;else{if(f===null)throw Error(t(310));cs=f,f={memoizedState:cs.memoizedState,baseState:cs.baseState,baseQueue:cs.baseQueue,queue:cs.queue,next:null},hr===null?Br.memoizedState=hr=f:hr=hr.next=f}return hr}function Xh(f,m){return typeof m=="function"?m(f):m}function Ff(f){var m=$o(),S=m.queue;if(S===null)throw Error(t(311));S.lastRenderedReducer=f;var I=cs,D=I.baseQueue,F=S.pending;if(F!==null){if(D!==null){var Y=D.next;D.next=F.next,F.next=Y}I.baseQueue=D=F,S.pending=null}if(D!==null){F=D.next,I=I.baseState;var pe=Y=null,Te=null,qe=F;do{var yt=qe.lane;if((Hl&yt)===yt)Te!==null&&(Te=Te.next={lane:0,action:qe.action,hasEagerState:qe.hasEagerState,eagerState:qe.eagerState,next:null}),I=qe.hasEagerState?qe.eagerState:f(I,qe.action);else{var vt={lane:yt,action:qe.action,hasEagerState:qe.hasEagerState,eagerState:qe.eagerState,next:null};Te===null?(pe=Te=vt,Y=I):Te=Te.next=vt,Br.lanes|=yt,Wf|=yt}qe=qe.next}while(qe!==null&&qe!==F);Te===null?Y=I:Te.next=pe,Ao(I,m.memoizedState)||(On=!0),m.memoizedState=I,m.baseState=Y,m.baseQueue=Te,S.lastRenderedState=I}if(f=S.interleaved,f!==null){D=f;do F=D.lane,Br.lanes|=F,Wf|=F,D=D.next;while(D!==f)}else D===null&&(S.lanes=0);return[m.memoizedState,S.dispatch]}function jl(f){var m=$o(),S=m.queue;if(S===null)throw Error(t(311));S.lastRenderedReducer=f;var I=S.dispatch,D=S.pending,F=m.memoizedState;if(D!==null){S.pending=null;var Y=D=D.next;do F=f(F,Y.action),Y=Y.next;while(Y!==D);Ao(F,m.memoizedState)||(On=!0),m.memoizedState=F,m.baseQueue===null&&(m.baseState=F),S.lastRenderedState=F}return[F,I]}function j0(){}function X0(f,m){var S=Br,I=$o(),D=m(),F=!Ao(I.memoizedState,D);if(F&&(I.memoizedState=D,On=!0),I=I.queue,Y0(Ow.bind(null,S,I,f),[f]),I.getSnapshot!==m||F||hr!==null&&hr.memoizedState.tag&1){if(S.flags|=2048,Oa(9,zf.bind(null,S,I,D,m),void 0,null),Ii===null)throw Error(t(349));(Hl&30)!==0||ig(S,m,D)}return D}function ig(f,m,S){f.flags|=16384,f={getSnapshot:m,value:S},m=Br.updateQueue,m===null?(m={lastEffect:null,stores:null},Br.updateQueue=m,m.stores=[f]):(S=m.stores,S===null?m.stores=[f]:S.push(f))}function zf(f,m,S,I){m.value=S,m.getSnapshot=I,Fw(m)&&q0(f)}function Ow(f,m,S){return S(function(){Fw(m)&&q0(f)})}function Fw(f){var m=f.getSnapshot;f=f.value;try{var S=m();return!Ao(f,S)}catch{return!0}}function q0(f){var m=$a(f,1);m!==null&&Zl(m,f,1,-1)}function K0(f){var m=ci();return typeof f=="function"&&(f=f()),m.memoizedState=m.baseState=f,f={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Xh,lastRenderedState:f},m.queue=f,f=f.dispatch=zc.bind(null,Br,f),[m.memoizedState,f]}function Oa(f,m,S,I){return f={tag:f,create:m,destroy:S,deps:I,next:null},m=Br.updateQueue,m===null?(m={lastEffect:null,stores:null},Br.updateQueue=m,m.lastEffect=f.next=f):(S=m.lastEffect,S===null?m.lastEffect=f.next=f:(I=S.next,S.next=f,f.next=I,m.lastEffect=f)),f}function zw(){return $o().memoizedState}function ll(f,m,S,I){var D=ci();Br.flags|=f,D.memoizedState=Oa(1|m,S,void 0,I===void 0?null:I)}function Bf(f,m,S,I){var D=$o();I=I===void 0?null:I;var F=void 0;if(cs!==null){var Y=cs.memoizedState;if(F=Y.destroy,I!==null&&Lf(I,Y.deps)){D.memoizedState=Oa(m,S,F,I);return}}Br.flags|=f,D.memoizedState=Oa(1|m,S,F,I)}function ji(f,m){return ll(8390656,8,f,m)}function Y0(f,m){return Bf(2048,8,f,m)}function Z0(f,m){return Bf(4,2,f,m)}function Bw(f,m){return Bf(4,4,f,m)}function Uw(f,m){if(typeof m=="function")return f=f(),m(f),function(){m(null)};if(m!=null)return f=f(),m.current=f,function(){m.current=null}}function J0(f,m,S){return S=S!=null?S.concat([f]):null,Bf(4,4,Uw.bind(null,m,f),S)}function og(){}function Vw(f,m){var S=$o();m=m===void 0?null:m;var I=S.memoizedState;return I!==null&&m!==null&&Lf(m,I[1])?I[0]:(S.memoizedState=[f,m],f)}function Po(f,m){var S=$o();m=m===void 0?null:m;var I=S.memoizedState;return I!==null&&m!==null&&Lf(m,I[1])?I[0]:(f=f(),S.memoizedState=[f,m],f)}function ag(f,m,S){return(Hl&21)===0?(f.baseState&&(f.baseState=!1,On=!0),f.memoizedState=S):(Ao(S,m)||(S=Rr(),Br.lanes|=S,Wf|=S,f.baseState=!0),m)}function sC(f,m){var S=cr;cr=S!==0&&4>S?S:4,f(!0);var I=Fc.transition;Fc.transition={};try{f(!1),m()}finally{cr=S,Fc.transition=I}}function Xl(){return $o().memoizedState}function lg(f,m,S){var I=Zh(f);if(S={lane:I,action:S,hasEagerState:!1,eagerState:null,next:null},Uf(f))ug(m,S);else if(S=$f(f,m,S,I),S!==null){var D=Oo();Zl(S,f,I,D),cg(S,m,I)}}function zc(f,m,S){var I=Zh(f),D={lane:I,action:S,hasEagerState:!1,eagerState:null,next:null};if(Uf(f))ug(m,D);else{var F=f.alternate;if(f.lanes===0&&(F===null||F.lanes===0)&&(F=m.lastRenderedReducer,F!==null))try{var Y=m.lastRenderedState,pe=F(Y,S);if(D.hasEagerState=!0,D.eagerState=pe,Ao(pe,Y)){var Te=m.interleaved;Te===null?(D.next=D,G0(m)):(D.next=Te.next,Te.next=D),m.interleaved=D;return}}catch{}finally{}S=$f(f,m,D,I),S!==null&&(D=Oo(),Zl(S,f,I,D),cg(S,m,I))}}function Uf(f){var m=f.alternate;return f===Br||m!==null&&m===Br}function ug(f,m){Ci=La=!0;var S=f.pending;S===null?m.next=m:(m.next=S.next,S.next=m),f.pending=m}function cg(f,m,S){if((S&4194240)!==0){var I=m.lanes;I&=f.pendingLanes,S|=I,m.lanes=S,_h(f,S)}}var hg={readContext:Ro,useCallback:ui,useContext:ui,useEffect:ui,useImperativeHandle:ui,useInsertionEffect:ui,useLayoutEffect:ui,useMemo:ui,useReducer:ui,useRef:ui,useState:ui,useDebugValue:ui,useDeferredValue:ui,useTransition:ui,useMutableSource:ui,useSyncExternalStore:ui,useId:ui,unstable_isNewReconciler:!1},Ww={readContext:Ro,useCallback:function(f,m){return ci().memoizedState=[f,m===void 0?null:m],f},useContext:Ro,useEffect:ji,useImperativeHandle:function(f,m,S){return S=S!=null?S.concat([f]):null,ll(4194308,4,Uw.bind(null,m,f),S)},useLayoutEffect:function(f,m){return ll(4194308,4,f,m)},useInsertionEffect:function(f,m){return ll(4,2,f,m)},useMemo:function(f,m){var S=ci();return m=m===void 0?null:m,f=f(),S.memoizedState=[f,m],f},useReducer:function(f,m,S){var I=ci();return m=S!==void 0?S(m):m,I.memoizedState=I.baseState=m,f={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:f,lastRenderedState:m},I.queue=f,f=f.dispatch=lg.bind(null,Br,f),[I.memoizedState,f]},useRef:function(f){var m=ci();return f={current:f},m.memoizedState=f},useState:K0,useDebugValue:og,useDeferredValue:function(f){return ci().memoizedState=f},useTransition:function(){var f=K0(!1),m=f[0];return f=sC.bind(null,f[1]),ci().memoizedState=f,[m,f]},useMutableSource:function(){},useSyncExternalStore:function(f,m,S){var I=Br,D=ci();if(Gr){if(S===void 0)throw Error(t(407));S=S()}else{if(S=m(),Ii===null)throw Error(t(349));(Hl&30)!==0||ig(I,m,S)}D.memoizedState=S;var F={value:S,getSnapshot:m};return D.queue=F,ji(Ow.bind(null,I,F,f),[f]),I.flags|=2048,Oa(9,zf.bind(null,I,F,S,m),void 0,null),S},useId:function(){var f=ci(),m=Ii.identifierPrefix;if(Gr){var S=aa,I=Et;S=(I&~(1<<32-mn(I)-1)).toString(32)+S,m=":"+m+"R"+S,S=Pu++,0<S&&(m+="H"+S.toString(32)),m+=":"}else S=io++,m=":"+m+"r"+S.toString(32)+":";return f.memoizedState=m},unstable_isNewReconciler:!1},Gw={readContext:Ro,useCallback:Vw,useContext:Ro,useEffect:Y0,useImperativeHandle:J0,useInsertionEffect:Z0,useLayoutEffect:Bw,useMemo:Po,useReducer:Ff,useRef:zw,useState:function(){return Ff(Xh)},useDebugValue:og,useDeferredValue:function(f){var m=$o();return ag(m,cs.memoizedState,f)},useTransition:function(){var f=Ff(Xh)[0],m=$o().memoizedState;return[f,m]},useMutableSource:j0,useSyncExternalStore:X0,useId:Xl,unstable_isNewReconciler:!1},Hw={readContext:Ro,useCallback:Vw,useContext:Ro,useEffect:Y0,useImperativeHandle:J0,useInsertionEffect:Z0,useLayoutEffect:Bw,useMemo:Po,useReducer:jl,useRef:zw,useState:function(){return jl(Xh)},useDebugValue:og,useDeferredValue:function(f){var m=$o();return cs===null?m.memoizedState=f:ag(m,cs.memoizedState,f)},useTransition:function(){var f=jl(Xh)[0],m=$o().memoizedState;return[f,m]},useMutableSource:j0,useSyncExternalStore:X0,useId:Xl,unstable_isNewReconciler:!1};function ua(f,m){if(f&&f.defaultProps){m=K({},m),f=f.defaultProps;for(var S in f)m[S]===void 0&&(m[S]=f[S]);return m}return m}function Vf(f,m,S,I){m=f.memoizedState,S=S(I,m),S=S==null?m:K({},m,S),f.memoizedState=S,f.lanes===0&&(f.updateQueue.baseState=S)}var dg={isMounted:function(f){return(f=f._reactInternals)?re(f)===f:!1},enqueueSetState:function(f,m,S){f=f._reactInternals;var I=Oo(),D=Zh(f),F=Nr(I,D);F.payload=m,S!=null&&(F.callback=S),m=Yr(f,F,D),m!==null&&(Zl(m,f,D,I),Ei(m,f,D))},enqueueReplaceState:function(f,m,S){f=f._reactInternals;var I=Oo(),D=Zh(f),F=Nr(I,D);F.tag=1,F.payload=m,S!=null&&(F.callback=S),m=Yr(f,F,D),m!==null&&(Zl(m,f,D,I),Ei(m,f,D))},enqueueForceUpdate:function(f,m){f=f._reactInternals;var S=Oo(),I=Zh(f),D=Nr(S,I);D.tag=2,m!=null&&(D.callback=m),m=Yr(f,D,I),m!==null&&(Zl(m,f,I,S),Ei(m,f,I))}};function jw(f,m,S,I,D,F,Y){return f=f.stateNode,typeof f.shouldComponentUpdate=="function"?f.shouldComponentUpdate(I,F,Y):m.prototype&&m.prototype.isPureReactComponent?!wc(S,I)||!wc(D,F):!0}function v(f,m,S){var I=!1,D=Fl,F=m.contextType;return typeof F=="object"&&F!==null?F=Ro(F):(D=Ti(m)?zl:ai.current,I=m.contextTypes,F=(I=I!=null)?Cc(f,D):Fl),m=new m(S,F),f.memoizedState=m.state!==null&&m.state!==void 0?m.state:null,m.updater=dg,f.stateNode=m,m._reactInternals=f,I&&(f=f.stateNode,f.__reactInternalMemoizedUnmaskedChildContext=D,f.__reactInternalMemoizedMaskedChildContext=F),m}function b(f,m,S,I){f=m.state,typeof m.componentWillReceiveProps=="function"&&m.componentWillReceiveProps(S,I),typeof m.UNSAFE_componentWillReceiveProps=="function"&&m.UNSAFE_componentWillReceiveProps(S,I),m.state!==f&&dg.enqueueReplaceState(m,m.state,null)}function C(f,m,S,I){var D=f.stateNode;D.props=S,D.state=f.memoizedState,D.refs={},Ln(f);var F=m.contextType;typeof F=="object"&&F!==null?D.context=Ro(F):(F=Ti(m)?zl:ai.current,D.context=Cc(f,F)),D.state=f.memoizedState,F=m.getDerivedStateFromProps,typeof F=="function"&&(Vf(f,m,F,S),D.state=f.memoizedState),typeof m.getDerivedStateFromProps=="function"||typeof D.getSnapshotBeforeUpdate=="function"||typeof D.UNSAFE_componentWillMount!="function"&&typeof D.componentWillMount!="function"||(m=D.state,typeof D.componentWillMount=="function"&&D.componentWillMount(),typeof D.UNSAFE_componentWillMount=="function"&&D.UNSAFE_componentWillMount(),m!==D.state&&dg.enqueueReplaceState(D,D.state,null),us(f,S,D,I),D.state=f.memoizedState),typeof D.componentDidMount=="function"&&(f.flags|=4194308)}function A(f,m){try{var S="",I=m;do S+=ye(I),I=I.return;while(I);var D=S}catch(F){D=`
Error generating stack: `+F.message+`
`+F.stack}return{value:f,source:m,stack:D,digest:null}}function O(f,m,S){return{value:f,source:null,stack:S??null,digest:m??null}}function U(f,m){try{console.error(m.value)}catch(S){setTimeout(function(){throw S})}}var he=typeof WeakMap=="function"?WeakMap:Map;function ke(f,m,S){S=Nr(-1,S),S.tag=3,S.payload={element:null};var I=m.value;return S.callback=function(){Qw||(Qw=!0,pC=I),U(f,m)},S}function tt(f,m,S){S=Nr(-1,S),S.tag=3;var I=f.type.getDerivedStateFromError;if(typeof I=="function"){var D=m.value;S.payload=function(){return I(D)},S.callback=function(){U(f,m)}}var F=f.stateNode;return F!==null&&typeof F.componentDidCatch=="function"&&(S.callback=function(){U(f,m),typeof I!="function"&&(Kh===null?Kh=new Set([this]):Kh.add(this));var Y=m.stack;this.componentDidCatch(m.value,{componentStack:Y!==null?Y:""})}),S}function wt(f,m,S){var I=f.pingCache;if(I===null){I=f.pingCache=new he;var D=new Set;I.set(m,D)}else D=I.get(m),D===void 0&&(D=new Set,I.set(m,D));D.has(S)||(D.add(S),f=n8.bind(null,f,m,S),m.then(f,f))}function Ht(f){do{var m;if((m=f.tag===13)&&(m=f.memoizedState,m=m!==null?m.dehydrated!==null:!0),m)return f;f=f.return}while(f!==null);return null}function Cn(f,m,S,I,D){return(f.mode&1)===0?(f===m?f.flags|=65536:(f.flags|=128,S.flags|=131072,S.flags&=-52805,S.tag===1&&(S.alternate===null?S.tag=17:(m=Nr(-1,1),m.tag=2,Yr(S,m,1))),S.lanes|=1),f):(f.flags|=65536,f.lanes=D,f)}var un=E.ReactCurrentOwner,On=!1;function zt(f,m,S,I){m.child=f===null?kf(m,null,S,I):Mc(m,f.child,S,I)}function hi(f,m,S,I,D){S=S.render;var F=m.ref;return Du(m,D),I=Of(f,m,S,I,F,D),S=H0(),f!==null&&!On?(m.updateQueue=f.updateQueue,m.flags&=-2053,f.lanes&=~D,Bc(f,m,D)):(Gr&&S&&F0(m),m.flags|=1,zt(f,m,I,D),m.child)}function Lo(f,m,S,I,D){if(f===null){var F=S.type;return typeof F=="function"&&!bC(F)&&F.defaultProps===void 0&&S.compare===null&&S.defaultProps===void 0?(m.tag=15,m.type=F,Ve(f,m,F,I,D)):(f=ib(S.type,null,I,m,m.mode,D),f.ref=m.ref,f.return=m,m.child=f)}if(F=f.child,(f.lanes&D)===0){var Y=F.memoizedProps;if(S=S.compare,S=S!==null?S:wc,S(Y,I)&&f.ref===m.ref)return Bc(f,m,D)}return m.flags|=1,f=Qh(F,I),f.ref=m.ref,f.return=m,m.child=f}function Ve(f,m,S,I,D){if(f!==null){var F=f.memoizedProps;if(wc(F,I)&&f.ref===m.ref)if(On=!1,m.pendingProps=I=F,(f.lanes&D)!==0)(f.flags&131072)!==0&&(On=!0);else return m.lanes=f.lanes,Bc(f,m,D)}return Pt(f,m,S,I,D)}function De(f,m,S){var I=m.pendingProps,D=I.children,F=f!==null?f.memoizedState:null;if(I.mode==="hidden")if((m.mode&1)===0)m.memoizedState={baseLanes:0,cachePool:null,transitions:null},Dr(pg,Fa),Fa|=S;else{if((S&1073741824)===0)return f=F!==null?F.baseLanes|S:S,m.lanes=m.childLanes=1073741824,m.memoizedState={baseLanes:f,cachePool:null,transitions:null},m.updateQueue=null,Dr(pg,Fa),Fa|=f,null;m.memoizedState={baseLanes:0,cachePool:null,transitions:null},I=F!==null?F.baseLanes:S,Dr(pg,Fa),Fa|=I}else F!==null?(I=F.baseLanes|S,m.memoizedState=null):I=S,Dr(pg,Fa),Fa|=I;return zt(f,m,D,S),m.child}function Ze(f,m){var S=m.ref;(f===null&&S!==null||f!==null&&f.ref!==S)&&(m.flags|=512,m.flags|=2097152)}function Pt(f,m,S,I,D){var F=Ti(S)?zl:ai.current;return F=Cc(m,F),Du(m,D),S=Of(f,m,S,I,F,D),I=H0(),f!==null&&!On?(m.updateQueue=f.updateQueue,m.flags&=-2053,f.lanes&=~D,Bc(f,m,D)):(Gr&&I&&F0(m),m.flags|=1,zt(f,m,S,D),m.child)}function Zt(f,m,S,I,D){if(Ti(S)){var F=!0;Ic(m)}else F=!1;if(Du(m,D),m.stateNode===null)qw(f,m),v(m,S,I),C(m,S,I,D),I=!0;else if(f===null){var Y=m.stateNode,pe=m.memoizedProps;Y.props=pe;var Te=Y.context,qe=S.contextType;typeof qe=="object"&&qe!==null?qe=Ro(qe):(qe=Ti(S)?zl:ai.current,qe=Cc(m,qe));var yt=S.getDerivedStateFromProps,vt=typeof yt=="function"||typeof Y.getSnapshotBeforeUpdate=="function";vt||typeof Y.UNSAFE_componentWillReceiveProps!="function"&&typeof Y.componentWillReceiveProps!="function"||(pe!==I||Te!==qe)&&b(m,Y,I,qe),Ir=!1;var pt=m.memoizedState;Y.state=pt,us(m,I,Y,D),Te=m.memoizedState,pe!==I||pt!==Te||Wi.current||Ir?(typeof yt=="function"&&(Vf(m,S,yt,I),Te=m.memoizedState),(pe=Ir||jw(m,S,pe,I,pt,Te,qe))?(vt||typeof Y.UNSAFE_componentWillMount!="function"&&typeof Y.componentWillMount!="function"||(typeof Y.componentWillMount=="function"&&Y.componentWillMount(),typeof Y.UNSAFE_componentWillMount=="function"&&Y.UNSAFE_componentWillMount()),typeof Y.componentDidMount=="function"&&(m.flags|=4194308)):(typeof Y.componentDidMount=="function"&&(m.flags|=4194308),m.memoizedProps=I,m.memoizedState=Te),Y.props=I,Y.state=Te,Y.context=qe,I=pe):(typeof Y.componentDidMount=="function"&&(m.flags|=4194308),I=!1)}else{Y=m.stateNode,vs(f,m),pe=m.memoizedProps,qe=m.type===m.elementType?pe:ua(m.type,pe),Y.props=qe,vt=m.pendingProps,pt=Y.context,Te=S.contextType,typeof Te=="object"&&Te!==null?Te=Ro(Te):(Te=Ti(S)?zl:ai.current,Te=Cc(m,Te));var Wt=S.getDerivedStateFromProps;(yt=typeof Wt=="function"||typeof Y.getSnapshotBeforeUpdate=="function")||typeof Y.UNSAFE_componentWillReceiveProps!="function"&&typeof Y.componentWillReceiveProps!="function"||(pe!==vt||pt!==Te)&&b(m,Y,I,Te),Ir=!1,pt=m.memoizedState,Y.state=pt,us(m,I,Y,D);var qt=m.memoizedState;pe!==vt||pt!==qt||Wi.current||Ir?(typeof Wt=="function"&&(Vf(m,S,Wt,I),qt=m.memoizedState),(qe=Ir||jw(m,S,qe,I,pt,qt,Te)||!1)?(yt||typeof Y.UNSAFE_componentWillUpdate!="function"&&typeof Y.componentWillUpdate!="function"||(typeof Y.componentWillUpdate=="function"&&Y.componentWillUpdate(I,qt,Te),typeof Y.UNSAFE_componentWillUpdate=="function"&&Y.UNSAFE_componentWillUpdate(I,qt,Te)),typeof Y.componentDidUpdate=="function"&&(m.flags|=4),typeof Y.getSnapshotBeforeUpdate=="function"&&(m.flags|=1024)):(typeof Y.componentDidUpdate!="function"||pe===f.memoizedProps&&pt===f.memoizedState||(m.flags|=4),typeof Y.getSnapshotBeforeUpdate!="function"||pe===f.memoizedProps&&pt===f.memoizedState||(m.flags|=1024),m.memoizedProps=I,m.memoizedState=qt),Y.props=I,Y.state=qt,Y.context=Te,I=qe):(typeof Y.componentDidUpdate!="function"||pe===f.memoizedProps&&pt===f.memoizedState||(m.flags|=4),typeof Y.getSnapshotBeforeUpdate!="function"||pe===f.memoizedProps&&pt===f.memoizedState||(m.flags|=1024),I=!1)}return Dn(f,m,S,I,F,D)}function Dn(f,m,S,I,D,F){Ze(f,m);var Y=(m.flags&128)!==0;if(!I&&!Y)return D&&L0(m,S,!1),Bc(f,m,F);I=m.stateNode,un.current=m;var pe=Y&&typeof S.getDerivedStateFromError!="function"?null:I.render();return m.flags|=1,f!==null&&Y?(m.child=Mc(m,f.child,null,F),m.child=Mc(m,null,pe,F)):zt(f,m,pe,F),m.memoizedState=I.state,D&&L0(m,S,!0),m.child}function In(f){var m=f.stateNode;m.pendingContext?P0(f,m.pendingContext,m.pendingContext!==m.context):m.context&&P0(f,m.context,!1),Pf(f,m.containerInfo)}function rr(f,m,S,I,D){return Ru(),Vh(D),m.flags|=256,zt(f,m,S,I),m.child}var Ss={dehydrated:null,treeContext:null,retryLane:0};function tr(f){return{baseLanes:f,cachePool:null,transitions:null}}function ql(f,m,S){var I=m.pendingProps,D=Hr.current,F=!1,Y=(m.flags&128)!==0,pe;if((pe=Y)||(pe=f!==null&&f.memoizedState===null?!1:(D&2)!==0),pe?(F=!0,m.flags&=-129):(f===null||f.memoizedState!==null)&&(D|=1),Dr(Hr,D&1),f===null)return rg(m),f=m.memoizedState,f!==null&&(f=f.dehydrated,f!==null)?((m.mode&1)===0?m.lanes=1:f.data==="$!"?m.lanes=8:m.lanes=1073741824,null):(Y=I.children,f=I.fallback,F?(I=m.mode,F=m.child,Y={mode:"hidden",children:Y},(I&1)===0&&F!==null?(F.childLanes=0,F.pendingProps=Y):F=ob(Y,I,0,null),f=Xf(f,I,S,null),F.return=m,f.return=m,F.sibling=f,m.child=F,m.child.memoizedState=tr(S),m.memoizedState=Ss,f):Q0(m,Y));if(D=f.memoizedState,D!==null&&(pe=D.dehydrated,pe!==null))return G6(f,m,Y,I,pe,D,S);if(F){F=I.fallback,Y=m.mode,D=f.child,pe=D.sibling;var Te={mode:"hidden",children:I.children};return(Y&1)===0&&m.child!==D?(I=m.child,I.childLanes=0,I.pendingProps=Te,m.deletions=null):(I=Qh(D,Te),I.subtreeFlags=D.subtreeFlags&14680064),pe!==null?F=Qh(pe,F):(F=Xf(F,Y,S,null),F.flags|=2),F.return=m,I.return=m,I.sibling=F,m.child=I,I=F,F=m.child,Y=f.child.memoizedState,Y=Y===null?tr(S):{baseLanes:Y.baseLanes|S,cachePool:null,transitions:Y.transitions},F.memoizedState=Y,F.childLanes=f.childLanes&~S,m.memoizedState=Ss,I}return F=f.child,f=F.sibling,I=Qh(F,{mode:"visible",children:I.children}),(m.mode&1)===0&&(I.lanes=S),I.return=m,I.sibling=null,f!==null&&(S=m.deletions,S===null?(m.deletions=[f],m.flags|=16):S.push(f)),m.child=I,m.memoizedState=null,I}function Q0(f,m){return m=ob({mode:"visible",children:m},f.mode,0,null),m.return=f,f.child=m}function Xw(f,m,S,I){return I!==null&&Vh(I),Mc(m,f.child,null,S),f=Q0(m,m.pendingProps.children),f.flags|=2,m.memoizedState=null,f}function G6(f,m,S,I,D,F,Y){if(S)return m.flags&256?(m.flags&=-257,I=O(Error(t(422))),Xw(f,m,Y,I)):m.memoizedState!==null?(m.child=f.child,m.flags|=128,null):(F=I.fallback,D=m.mode,I=ob({mode:"visible",children:I.children},D,0,null),F=Xf(F,D,Y,null),F.flags|=2,I.return=m,F.return=m,I.sibling=F,m.child=I,(m.mode&1)!==0&&Mc(m,f.child,null,Y),m.child.memoizedState=tr(Y),m.memoizedState=Ss,F);if((m.mode&1)===0)return Xw(f,m,Y,null);if(D.data==="$!"){if(I=D.nextSibling&&D.nextSibling.dataset,I)var pe=I.dgst;return I=pe,F=Error(t(419)),I=O(F,I,void 0),Xw(f,m,Y,I)}if(pe=(Y&f.childLanes)!==0,On||pe){if(I=Ii,I!==null){switch(Y&-Y){case 4:D=2;break;case 16:D=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:D=32;break;case 536870912:D=268435456;break;default:D=0}D=(D&(I.suspendedLanes|Y))!==0?0:D,D!==0&&D!==F.retryLane&&(F.retryLane=D,$a(f,D),Zl(I,f,D,-1))}return wC(),I=O(Error(t(421))),Xw(f,m,Y,I)}return D.data==="$?"?(m.flags|=128,m.child=f.child,m=r8.bind(null,f),D._reactRetry=m,null):(f=F.treeContext,Hi=Ll(D.nextSibling),li=m,Gr=!0,la=null,f!==null&&(Gi[qs++]=Et,Gi[qs++]=aa,Gi[qs++]=Ac,Et=f.id,aa=f.overflow,Ac=m),m=Q0(m,I.children),m.flags|=4096,m)}function ID(f,m,S){f.lanes|=m;var I=f.alternate;I!==null&&(I.lanes|=m),Df(f.return,m,S)}function iC(f,m,S,I,D){var F=f.memoizedState;F===null?f.memoizedState={isBackwards:m,rendering:null,renderingStartTime:0,last:I,tail:S,tailMode:D}:(F.isBackwards=m,F.rendering=null,F.renderingStartTime=0,F.last=I,F.tail=S,F.tailMode=D)}function ND(f,m,S){var I=m.pendingProps,D=I.revealOrder,F=I.tail;if(zt(f,m,I.children,S),I=Hr.current,(I&2)!==0)I=I&1|2,m.flags|=128;else{if(f!==null&&(f.flags&128)!==0)e:for(f=m.child;f!==null;){if(f.tag===13)f.memoizedState!==null&&ID(f,S,m);else if(f.tag===19)ID(f,S,m);else if(f.child!==null){f.child.return=f,f=f.child;continue}if(f===m)break e;for(;f.sibling===null;){if(f.return===null||f.return===m)break e;f=f.return}f.sibling.return=f.return,f=f.sibling}I&=1}if(Dr(Hr,I),(m.mode&1)===0)m.memoizedState=null;else switch(D){case"forwards":for(S=m.child,D=null;S!==null;)f=S.alternate,f!==null&&Pa(f)===null&&(D=S),S=S.sibling;S=D,S===null?(D=m.child,m.child=null):(D=S.sibling,S.sibling=null),iC(m,!1,D,S,F);break;case"backwards":for(S=null,D=m.child,m.child=null;D!==null;){if(f=D.alternate,f!==null&&Pa(f)===null){m.child=D;break}f=D.sibling,D.sibling=S,S=D,D=f}iC(m,!0,S,null,F);break;case"together":iC(m,!1,null,null,void 0);break;default:m.memoizedState=null}return m.child}function qw(f,m){(m.mode&1)===0&&f!==null&&(f.alternate=null,m.alternate=null,m.flags|=2)}function Bc(f,m,S){if(f!==null&&(m.dependencies=f.dependencies),Wf|=m.lanes,(S&m.childLanes)===0)return null;if(f!==null&&m.child!==f.child)throw Error(t(153));if(m.child!==null){for(f=m.child,S=Qh(f,f.pendingProps),m.child=S,S.return=m;f.sibling!==null;)f=f.sibling,S=S.sibling=Qh(f,f.pendingProps),S.return=m;S.sibling=null}return m.child}function H6(f,m,S){switch(m.tag){case 3:In(m),Ru();break;case 5:Lc(m);break;case 1:Ti(m.type)&&Ic(m);break;case 4:Pf(m,m.stateNode.containerInfo);break;case 10:var I=m.type._context,D=m.memoizedProps.value;Dr(kc,I._currentValue),I._currentValue=D;break;case 13:if(I=m.memoizedState,I!==null)return I.dehydrated!==null?(Dr(Hr,Hr.current&1),m.flags|=128,null):(S&m.child.childLanes)!==0?ql(f,m,S):(Dr(Hr,Hr.current&1),f=Bc(f,m,S),f!==null?f.sibling:null);Dr(Hr,Hr.current&1);break;case 19:if(I=(S&m.childLanes)!==0,(f.flags&128)!==0){if(I)return ND(f,m,S);m.flags|=128}if(D=m.memoizedState,D!==null&&(D.rendering=null,D.tail=null,D.lastEffect=null),Dr(Hr,Hr.current),I)break;return null;case 22:case 23:return m.lanes=0,De(f,m,S)}return Bc(f,m,S)}var AD,oC,MD,kD;AD=function(f,m){for(var S=m.child;S!==null;){if(S.tag===5||S.tag===6)f.appendChild(S.stateNode);else if(S.tag!==4&&S.child!==null){S.child.return=S,S=S.child;continue}if(S===m)break;for(;S.sibling===null;){if(S.return===null||S.return===m)return;S=S.return}S.sibling.return=S.return,S=S.sibling}},oC=function(){},MD=function(f,m,S,I){var D=f.memoizedProps;if(D!==I){f=m.stateNode,bs(Do.current);var F=null;switch(S){case"input":D=Xe(f,D),I=Xe(f,I),F=[];break;case"select":D=K({},D,{value:void 0}),I=K({},I,{value:void 0}),F=[];break;case"textarea":D=at(f,D),I=at(f,I),F=[];break;default:typeof D.onClick!="function"&&typeof I.onClick=="function"&&(f.onclick=Tf)}cn(S,I);var Y;S=null;for(qe in D)if(!I.hasOwnProperty(qe)&&D.hasOwnProperty(qe)&&D[qe]!=null)if(qe==="style"){var pe=D[qe];for(Y in pe)pe.hasOwnProperty(Y)&&(S||(S={}),S[Y]="")}else qe!=="dangerouslySetInnerHTML"&&qe!=="children"&&qe!=="suppressContentEditableWarning"&&qe!=="suppressHydrationWarning"&&qe!=="autoFocus"&&(s.hasOwnProperty(qe)?F||(F=[]):(F=F||[]).push(qe,null));for(qe in I){var Te=I[qe];if(pe=D!=null?D[qe]:void 0,I.hasOwnProperty(qe)&&Te!==pe&&(Te!=null||pe!=null))if(qe==="style")if(pe){for(Y in pe)!pe.hasOwnProperty(Y)||Te&&Te.hasOwnProperty(Y)||(S||(S={}),S[Y]="");for(Y in Te)Te.hasOwnProperty(Y)&&pe[Y]!==Te[Y]&&(S||(S={}),S[Y]=Te[Y])}else S||(F||(F=[]),F.push(qe,S)),S=Te;else qe==="dangerouslySetInnerHTML"?(Te=Te?Te.__html:void 0,pe=pe?pe.__html:void 0,Te!=null&&pe!==Te&&(F=F||[]).push(qe,Te)):qe==="children"?typeof Te!="string"&&typeof Te!="number"||(F=F||[]).push(qe,""+Te):qe!=="suppressContentEditableWarning"&&qe!=="suppressHydrationWarning"&&(s.hasOwnProperty(qe)?(Te!=null&&qe==="onScroll"&&Fr("scroll",f),F||pe===Te||(F=[])):(F=F||[]).push(qe,Te))}S&&(F=F||[]).push("style",S);var qe=F;(m.updateQueue=qe)&&(m.flags|=4)}},kD=function(f,m,S,I){S!==I&&(m.flags|=4)};function ev(f,m){if(!Gr)switch(f.tailMode){case"hidden":m=f.tail;for(var S=null;m!==null;)m.alternate!==null&&(S=m),m=m.sibling;S===null?f.tail=null:S.sibling=null;break;case"collapsed":S=f.tail;for(var I=null;S!==null;)S.alternate!==null&&(I=S),S=S.sibling;I===null?m||f.tail===null?f.tail=null:f.tail.sibling=null:I.sibling=null}}function oo(f){var m=f.alternate!==null&&f.alternate.child===f.child,S=0,I=0;if(m)for(var D=f.child;D!==null;)S|=D.lanes|D.childLanes,I|=D.subtreeFlags&14680064,I|=D.flags&14680064,D.return=f,D=D.sibling;else for(D=f.child;D!==null;)S|=D.lanes|D.childLanes,I|=D.subtreeFlags,I|=D.flags,D.return=f,D=D.sibling;return f.subtreeFlags|=I,f.childLanes=S,m}function j6(f,m,S){var I=m.pendingProps;switch(Ul(m),m.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return oo(m),null;case 1:return Ti(m.type)&&Ef(),oo(m),null;case 3:return I=m.stateNode,$u(),zr(Wi),zr(ai),al(),I.pendingContext&&(I.context=I.pendingContext,I.pendingContext=null),(f===null||f.child===null)&&(Uh(m)?m.flags|=4:f===null||f.memoizedState.isDehydrated&&(m.flags&256)===0||(m.flags|=1024,la!==null&&(yC(la),la=null))),oC(f,m),oo(m),null;case 5:Hh(m);var D=bs(Gl.current);if(S=m.type,f!==null&&m.stateNode!=null)MD(f,m,S,I,D),f.ref!==m.ref&&(m.flags|=512,m.flags|=2097152);else{if(!I){if(m.stateNode===null)throw Error(t(166));return oo(m),null}if(f=bs(Do.current),Uh(m)){I=m.stateNode,S=m.type;var F=m.memoizedProps;switch(I[Ps]=m,I[Bh]=F,f=(m.mode&1)!==0,S){case"dialog":Fr("cancel",I),Fr("close",I);break;case"iframe":case"object":case"embed":Fr("load",I);break;case"video":case"audio":for(D=0;D<Mu.length;D++)Fr(Mu[D],I);break;case"source":Fr("error",I);break;case"img":case"image":case"link":Fr("error",I),Fr("load",I);break;case"details":Fr("toggle",I);break;case"input":it(I,F),Fr("invalid",I);break;case"select":I._wrapperState={wasMultiple:!!F.multiple},Fr("invalid",I);break;case"textarea":ut(I,F),Fr("invalid",I)}cn(S,F),D=null;for(var Y in F)if(F.hasOwnProperty(Y)){var pe=F[Y];Y==="children"?typeof pe=="string"?I.textContent!==pe&&(F.suppressHydrationWarning!==!0&&_f(I.textContent,pe,f),D=["children",pe]):typeof pe=="number"&&I.textContent!==""+pe&&(F.suppressHydrationWarning!==!0&&_f(I.textContent,pe,f),D=["children",""+pe]):s.hasOwnProperty(Y)&&pe!=null&&Y==="onScroll"&&Fr("scroll",I)}switch(S){case"input":ct(I),mt(I,F,!0);break;case"textarea":ct(I),$t(I);break;case"select":case"option":break;default:typeof F.onClick=="function"&&(I.onclick=Tf)}I=D,m.updateQueue=I,I!==null&&(m.flags|=4)}else{Y=D.nodeType===9?D:D.ownerDocument,f==="http://www.w3.org/1999/xhtml"&&(f=bt(S)),f==="http://www.w3.org/1999/xhtml"?S==="script"?(f=Y.createElement("div"),f.innerHTML="<script><\/script>",f=f.removeChild(f.firstChild)):typeof I.is=="string"?f=Y.createElement(S,{is:I.is}):(f=Y.createElement(S),S==="select"&&(Y=f,I.multiple?Y.multiple=!0:I.size&&(Y.size=I.size))):f=Y.createElementNS(f,S),f[Ps]=m,f[Bh]=I,AD(f,m,!1,!1),m.stateNode=f;e:{switch(Y=bn(S,I),S){case"dialog":Fr("cancel",f),Fr("close",f),D=I;break;case"iframe":case"object":case"embed":Fr("load",f),D=I;break;case"video":case"audio":for(D=0;D<Mu.length;D++)Fr(Mu[D],f);D=I;break;case"source":Fr("error",f),D=I;break;case"img":case"image":case"link":Fr("error",f),Fr("load",f),D=I;break;case"details":Fr("toggle",f),D=I;break;case"input":it(f,I),D=Xe(f,I),Fr("invalid",f);break;case"option":D=I;break;case"select":f._wrapperState={wasMultiple:!!I.multiple},D=K({},I,{value:void 0}),Fr("invalid",f);break;case"textarea":ut(f,I),D=at(f,I),Fr("invalid",f);break;default:D=I}cn(S,D),pe=D;for(F in pe)if(pe.hasOwnProperty(F)){var Te=pe[F];F==="style"?Ft(f,Te):F==="dangerouslySetInnerHTML"?(Te=Te?Te.__html:void 0,Te!=null&&rn(f,Te)):F==="children"?typeof Te=="string"?(S!=="textarea"||Te!=="")&&ht(f,Te):typeof Te=="number"&&ht(f,""+Te):F!=="suppressContentEditableWarning"&&F!=="suppressHydrationWarning"&&F!=="autoFocus"&&(s.hasOwnProperty(F)?Te!=null&&F==="onScroll"&&Fr("scroll",f):Te!=null&&T(f,F,Te,Y))}switch(S){case"input":ct(f),mt(f,I,!1);break;case"textarea":ct(f),$t(f);break;case"option":I.value!=null&&f.setAttribute("value",""+Oe(I.value));break;case"select":f.multiple=!!I.multiple,F=I.value,F!=null?Le(f,!!I.multiple,F,!1):I.defaultValue!=null&&Le(f,!!I.multiple,I.defaultValue,!0);break;default:typeof D.onClick=="function"&&(f.onclick=Tf)}switch(S){case"button":case"input":case"select":case"textarea":I=!!I.autoFocus;break e;case"img":I=!0;break e;default:I=!1}}I&&(m.flags|=4)}m.ref!==null&&(m.flags|=512,m.flags|=2097152)}return oo(m),null;case 6:if(f&&m.stateNode!=null)kD(f,m,f.memoizedProps,I);else{if(typeof I!="string"&&m.stateNode===null)throw Error(t(166));if(S=bs(Gl.current),bs(Do.current),Uh(m)){if(I=m.stateNode,S=m.memoizedProps,I[Ps]=m,(F=I.nodeValue!==S)&&(f=li,f!==null))switch(f.tag){case 3:_f(I.nodeValue,S,(f.mode&1)!==0);break;case 5:f.memoizedProps.suppressHydrationWarning!==!0&&_f(I.nodeValue,S,(f.mode&1)!==0)}F&&(m.flags|=4)}else I=(S.nodeType===9?S:S.ownerDocument).createTextNode(I),I[Ps]=m,m.stateNode=I}return oo(m),null;case 13:if(zr(Hr),I=m.memoizedState,f===null||f.memoizedState!==null&&f.memoizedState.dehydrated!==null){if(Gr&&Hi!==null&&(m.mode&1)!==0&&(m.flags&128)===0)U0(),Ru(),m.flags|=98560,F=!1;else if(F=Uh(m),I!==null&&I.dehydrated!==null){if(f===null){if(!F)throw Error(t(318));if(F=m.memoizedState,F=F!==null?F.dehydrated:null,!F)throw Error(t(317));F[Ps]=m}else Ru(),(m.flags&128)===0&&(m.memoizedState=null),m.flags|=4;oo(m),F=!1}else la!==null&&(yC(la),la=null),F=!0;if(!F)return m.flags&65536?m:null}return(m.flags&128)!==0?(m.lanes=S,m):(I=I!==null,I!==(f!==null&&f.memoizedState!==null)&&I&&(m.child.flags|=8192,(m.mode&1)!==0&&(f===null||(Hr.current&1)!==0?di===0&&(di=3):wC())),m.updateQueue!==null&&(m.flags|=4),oo(m),null);case 4:return $u(),oC(f,m),f===null&&Oh(m.stateNode.containerInfo),oo(m),null;case 10:return Rf(m.type._context),oo(m),null;case 17:return Ti(m.type)&&Ef(),oo(m),null;case 19:if(zr(Hr),F=m.memoizedState,F===null)return oo(m),null;if(I=(m.flags&128)!==0,Y=F.rendering,Y===null)if(I)ev(F,!1);else{if(di!==0||f!==null&&(f.flags&128)!==0)for(f=m.child;f!==null;){if(Y=Pa(f),Y!==null){for(m.flags|=128,ev(F,!1),I=Y.updateQueue,I!==null&&(m.updateQueue=I,m.flags|=4),m.subtreeFlags=0,I=S,S=m.child;S!==null;)F=S,f=I,F.flags&=14680066,Y=F.alternate,Y===null?(F.childLanes=0,F.lanes=f,F.child=null,F.subtreeFlags=0,F.memoizedProps=null,F.memoizedState=null,F.updateQueue=null,F.dependencies=null,F.stateNode=null):(F.childLanes=Y.childLanes,F.lanes=Y.lanes,F.child=Y.child,F.subtreeFlags=0,F.deletions=null,F.memoizedProps=Y.memoizedProps,F.memoizedState=Y.memoizedState,F.updateQueue=Y.updateQueue,F.type=Y.type,f=Y.dependencies,F.dependencies=f===null?null:{lanes:f.lanes,firstContext:f.firstContext}),S=S.sibling;return Dr(Hr,Hr.current&1|2),m.child}f=f.sibling}F.tail!==null&&Ue()>mg&&(m.flags|=128,I=!0,ev(F,!1),m.lanes=4194304)}else{if(!I)if(f=Pa(Y),f!==null){if(m.flags|=128,I=!0,S=f.updateQueue,S!==null&&(m.updateQueue=S,m.flags|=4),ev(F,!0),F.tail===null&&F.tailMode==="hidden"&&!Y.alternate&&!Gr)return oo(m),null}else 2*Ue()-F.renderingStartTime>mg&&S!==1073741824&&(m.flags|=128,I=!0,ev(F,!1),m.lanes=4194304);F.isBackwards?(Y.sibling=m.child,m.child=Y):(S=F.last,S!==null?S.sibling=Y:m.child=Y,F.last=Y)}return F.tail!==null?(m=F.tail,F.rendering=m,F.tail=m.sibling,F.renderingStartTime=Ue(),m.sibling=null,S=Hr.current,Dr(Hr,I?S&1|2:S&1),m):(oo(m),null);case 22:case 23:return xC(),I=m.memoizedState!==null,f!==null&&f.memoizedState!==null!==I&&(m.flags|=8192),I&&(m.mode&1)!==0?(Fa&1073741824)!==0&&(oo(m),m.subtreeFlags&6&&(m.flags|=8192)):oo(m),null;case 24:return null;case 25:return null}throw Error(t(156,m.tag))}function X6(f,m){switch(Ul(m),m.tag){case 1:return Ti(m.type)&&Ef(),f=m.flags,f&65536?(m.flags=f&-65537|128,m):null;case 3:return $u(),zr(Wi),zr(ai),al(),f=m.flags,(f&65536)!==0&&(f&128)===0?(m.flags=f&-65537|128,m):null;case 5:return Hh(m),null;case 13:if(zr(Hr),f=m.memoizedState,f!==null&&f.dehydrated!==null){if(m.alternate===null)throw Error(t(340));Ru()}return f=m.flags,f&65536?(m.flags=f&-65537|128,m):null;case 19:return zr(Hr),null;case 4:return $u(),null;case 10:return Rf(m.type._context),null;case 22:case 23:return xC(),null;case 24:return null;default:return null}}var Kw=!1,ao=!1,q6=typeof WeakSet=="function"?WeakSet:Set,jt=null;function fg(f,m){var S=f.ref;if(S!==null)if(typeof S=="function")try{S(null)}catch(I){_s(f,m,I)}else S.current=null}function aC(f,m,S){try{S()}catch(I){_s(f,m,I)}}var RD=!1;function K6(f,m){if(zh=ta,f=ns(),Gs(f)){if("selectionStart"in f)var S={start:f.selectionStart,end:f.selectionEnd};else e:{S=(S=f.ownerDocument)&&S.defaultView||window;var I=S.getSelection&&S.getSelection();if(I&&I.rangeCount!==0){S=I.anchorNode;var D=I.anchorOffset,F=I.focusNode;I=I.focusOffset;try{S.nodeType,F.nodeType}catch{S=null;break e}var Y=0,pe=-1,Te=-1,qe=0,yt=0,vt=f,pt=null;t:for(;;){for(var Wt;vt!==S||D!==0&&vt.nodeType!==3||(pe=Y+D),vt!==F||I!==0&&vt.nodeType!==3||(Te=Y+I),vt.nodeType===3&&(Y+=vt.nodeValue.length),(Wt=vt.firstChild)!==null;)pt=vt,vt=Wt;for(;;){if(vt===f)break t;if(pt===S&&++qe===D&&(pe=Y),pt===F&&++yt===I&&(Te=Y),(Wt=vt.nextSibling)!==null)break;vt=pt,pt=vt.parentNode}vt=Wt}S=pe===-1||Te===-1?null:{start:pe,end:Te}}else S=null}S=S||{start:0,end:0}}else S=null;for(A0={focusedElem:f,selectionRange:S},ta=!1,jt=m;jt!==null;)if(m=jt,f=m.child,(m.subtreeFlags&1028)!==0&&f!==null)f.return=m,jt=f;else for(;jt!==null;){m=jt;try{var qt=m.alternate;if((m.flags&1024)!==0)switch(m.tag){case 0:case 11:case 15:break;case 1:if(qt!==null){var Yt=qt.memoizedProps,Ls=qt.memoizedState,Fe=m.stateNode,Ne=Fe.getSnapshotBeforeUpdate(m.elementType===m.type?Yt:ua(m.type,Yt),Ls);Fe.__reactInternalSnapshotBeforeUpdate=Ne}break;case 3:var Be=m.stateNode.containerInfo;Be.nodeType===1?Be.textContent="":Be.nodeType===9&&Be.documentElement&&Be.removeChild(Be.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(t(163))}}catch(St){_s(m,m.return,St)}if(f=m.sibling,f!==null){f.return=m.return,jt=f;break}jt=m.return}return qt=RD,RD=!1,qt}function tv(f,m,S){var I=m.updateQueue;if(I=I!==null?I.lastEffect:null,I!==null){var D=I=I.next;do{if((D.tag&f)===f){var F=D.destroy;D.destroy=void 0,F!==void 0&&aC(m,S,F)}D=D.next}while(D!==I)}}function Yw(f,m){if(m=m.updateQueue,m=m!==null?m.lastEffect:null,m!==null){var S=m=m.next;do{if((S.tag&f)===f){var I=S.create;S.destroy=I()}S=S.next}while(S!==m)}}function lC(f){var m=f.ref;if(m!==null){var S=f.stateNode;switch(f.tag){case 5:f=S;break;default:f=S}typeof m=="function"?m(f):m.current=f}}function DD(f){var m=f.alternate;m!==null&&(f.alternate=null,DD(m)),f.child=null,f.deletions=null,f.sibling=null,f.tag===5&&(m=f.stateNode,m!==null&&(delete m[Ps],delete m[Bh],delete m[Ec],delete m[Ym],delete m[Zm])),f.stateNode=null,f.return=null,f.dependencies=null,f.memoizedProps=null,f.memoizedState=null,f.pendingProps=null,f.stateNode=null,f.updateQueue=null}function $D(f){return f.tag===5||f.tag===3||f.tag===4}function PD(f){e:for(;;){for(;f.sibling===null;){if(f.return===null||$D(f.return))return null;f=f.return}for(f.sibling.return=f.return,f=f.sibling;f.tag!==5&&f.tag!==6&&f.tag!==18;){if(f.flags&2||f.child===null||f.tag===4)continue e;f.child.return=f,f=f.child}if(!(f.flags&2))return f.stateNode}}function uC(f,m,S){var I=f.tag;if(I===5||I===6)f=f.stateNode,m?S.nodeType===8?S.parentNode.insertBefore(f,m):S.insertBefore(f,m):(S.nodeType===8?(m=S.parentNode,m.insertBefore(f,S)):(m=S,m.appendChild(f)),S=S._reactRootContainer,S!=null||m.onclick!==null||(m.onclick=Tf));else if(I!==4&&(f=f.child,f!==null))for(uC(f,m,S),f=f.sibling;f!==null;)uC(f,m,S),f=f.sibling}function cC(f,m,S){var I=f.tag;if(I===5||I===6)f=f.stateNode,m?S.insertBefore(f,m):S.appendChild(f);else if(I!==4&&(f=f.child,f!==null))for(cC(f,m,S),f=f.sibling;f!==null;)cC(f,m,S),f=f.sibling}var Xi=null,Kl=!1;function qh(f,m,S){for(S=S.child;S!==null;)LD(f,m,S),S=S.sibling}function LD(f,m,S){if(kt&&typeof kt.onCommitFiberUnmount=="function")try{kt.onCommitFiberUnmount(vn,S)}catch{}switch(S.tag){case 5:ao||fg(S,m);case 6:var I=Xi,D=Kl;Xi=null,qh(f,m,S),Xi=I,Kl=D,Xi!==null&&(Kl?(f=Xi,S=S.stateNode,f.nodeType===8?f.parentNode.removeChild(S):f.removeChild(S)):Xi.removeChild(S.stateNode));break;case 18:Xi!==null&&(Kl?(f=Xi,S=S.stateNode,f.nodeType===8?Km(f.parentNode,S):f.nodeType===1&&Km(f,S),df(f)):Km(Xi,S.stateNode));break;case 4:I=Xi,D=Kl,Xi=S.stateNode.containerInfo,Kl=!0,qh(f,m,S),Xi=I,Kl=D;break;case 0:case 11:case 14:case 15:if(!ao&&(I=S.updateQueue,I!==null&&(I=I.lastEffect,I!==null))){D=I=I.next;do{var F=D,Y=F.destroy;F=F.tag,Y!==void 0&&((F&2)!==0||(F&4)!==0)&&aC(S,m,Y),D=D.next}while(D!==I)}qh(f,m,S);break;case 1:if(!ao&&(fg(S,m),I=S.stateNode,typeof I.componentWillUnmount=="function"))try{I.props=S.memoizedProps,I.state=S.memoizedState,I.componentWillUnmount()}catch(pe){_s(S,m,pe)}qh(f,m,S);break;case 21:qh(f,m,S);break;case 22:S.mode&1?(ao=(I=ao)||S.memoizedState!==null,qh(f,m,S),ao=I):qh(f,m,S);break;default:qh(f,m,S)}}function OD(f){var m=f.updateQueue;if(m!==null){f.updateQueue=null;var S=f.stateNode;S===null&&(S=f.stateNode=new q6),m.forEach(function(I){var D=s8.bind(null,f,I);S.has(I)||(S.add(I),I.then(D,D))})}}function Yl(f,m){var S=m.deletions;if(S!==null)for(var I=0;I<S.length;I++){var D=S[I];try{var F=f,Y=m,pe=Y;e:for(;pe!==null;){switch(pe.tag){case 5:Xi=pe.stateNode,Kl=!1;break e;case 3:Xi=pe.stateNode.containerInfo,Kl=!0;break e;case 4:Xi=pe.stateNode.containerInfo,Kl=!0;break e}pe=pe.return}if(Xi===null)throw Error(t(160));LD(F,Y,D),Xi=null,Kl=!1;var Te=D.alternate;Te!==null&&(Te.return=null),D.return=null}catch(qe){_s(D,m,qe)}}if(m.subtreeFlags&12854)for(m=m.child;m!==null;)FD(m,f),m=m.sibling}function FD(f,m){var S=f.alternate,I=f.flags;switch(f.tag){case 0:case 11:case 14:case 15:if(Yl(m,f),Lu(f),I&4){try{tv(3,f,f.return),Yw(3,f)}catch(Yt){_s(f,f.return,Yt)}try{tv(5,f,f.return)}catch(Yt){_s(f,f.return,Yt)}}break;case 1:Yl(m,f),Lu(f),I&512&&S!==null&&fg(S,S.return);break;case 5:if(Yl(m,f),Lu(f),I&512&&S!==null&&fg(S,S.return),f.flags&32){var D=f.stateNode;try{ht(D,"")}catch(Yt){_s(f,f.return,Yt)}}if(I&4&&(D=f.stateNode,D!=null)){var F=f.memoizedProps,Y=S!==null?S.memoizedProps:F,pe=f.type,Te=f.updateQueue;if(f.updateQueue=null,Te!==null)try{pe==="input"&&F.type==="radio"&&F.name!=null&&He(D,F),bn(pe,Y);var qe=bn(pe,F);for(Y=0;Y<Te.length;Y+=2){var yt=Te[Y],vt=Te[Y+1];yt==="style"?Ft(D,vt):yt==="dangerouslySetInnerHTML"?rn(D,vt):yt==="children"?ht(D,vt):T(D,yt,vt,qe)}switch(pe){case"input":_t(D,F);break;case"textarea":ot(D,F);break;case"select":var pt=D._wrapperState.wasMultiple;D._wrapperState.wasMultiple=!!F.multiple;var Wt=F.value;Wt!=null?Le(D,!!F.multiple,Wt,!1):pt!==!!F.multiple&&(F.defaultValue!=null?Le(D,!!F.multiple,F.defaultValue,!0):Le(D,!!F.multiple,F.multiple?[]:"",!1))}D[Bh]=F}catch(Yt){_s(f,f.return,Yt)}}break;case 6:if(Yl(m,f),Lu(f),I&4){if(f.stateNode===null)throw Error(t(162));D=f.stateNode,F=f.memoizedProps;try{D.nodeValue=F}catch(Yt){_s(f,f.return,Yt)}}break;case 3:if(Yl(m,f),Lu(f),I&4&&S!==null&&S.memoizedState.isDehydrated)try{df(m.containerInfo)}catch(Yt){_s(f,f.return,Yt)}break;case 4:Yl(m,f),Lu(f);break;case 13:Yl(m,f),Lu(f),D=f.child,D.flags&8192&&(F=D.memoizedState!==null,D.stateNode.isHidden=F,!F||D.alternate!==null&&D.alternate.memoizedState!==null||(fC=Ue())),I&4&&OD(f);break;case 22:if(yt=S!==null&&S.memoizedState!==null,f.mode&1?(ao=(qe=ao)||yt,Yl(m,f),ao=qe):Yl(m,f),Lu(f),I&8192){if(qe=f.memoizedState!==null,(f.stateNode.isHidden=qe)&&!yt&&(f.mode&1)!==0)for(jt=f,yt=f.child;yt!==null;){for(vt=jt=yt;jt!==null;){switch(pt=jt,Wt=pt.child,pt.tag){case 0:case 11:case 14:case 15:tv(4,pt,pt.return);break;case 1:fg(pt,pt.return);var qt=pt.stateNode;if(typeof qt.componentWillUnmount=="function"){I=pt,S=pt.return;try{m=I,qt.props=m.memoizedProps,qt.state=m.memoizedState,qt.componentWillUnmount()}catch(Yt){_s(I,S,Yt)}}break;case 5:fg(pt,pt.return);break;case 22:if(pt.memoizedState!==null){UD(vt);continue}}Wt!==null?(Wt.return=pt,jt=Wt):UD(vt)}yt=yt.sibling}e:for(yt=null,vt=f;;){if(vt.tag===5){if(yt===null){yt=vt;try{D=vt.stateNode,qe?(F=D.style,typeof F.setProperty=="function"?F.setProperty("display","none","important"):F.display="none"):(pe=vt.stateNode,Te=vt.memoizedProps.style,Y=Te!=null&&Te.hasOwnProperty("display")?Te.display:null,pe.style.display=en("display",Y))}catch(Yt){_s(f,f.return,Yt)}}}else if(vt.tag===6){if(yt===null)try{vt.stateNode.nodeValue=qe?"":vt.memoizedProps}catch(Yt){_s(f,f.return,Yt)}}else if((vt.tag!==22&&vt.tag!==23||vt.memoizedState===null||vt===f)&&vt.child!==null){vt.child.return=vt,vt=vt.child;continue}if(vt===f)break e;for(;vt.sibling===null;){if(vt.return===null||vt.return===f)break e;yt===vt&&(yt=null),vt=vt.return}yt===vt&&(yt=null),vt.sibling.return=vt.return,vt=vt.sibling}}break;case 19:Yl(m,f),Lu(f),I&4&&OD(f);break;case 21:break;default:Yl(m,f),Lu(f)}}function Lu(f){var m=f.flags;if(m&2){try{e:{for(var S=f.return;S!==null;){if($D(S)){var I=S;break e}S=S.return}throw Error(t(160))}switch(I.tag){case 5:var D=I.stateNode;I.flags&32&&(ht(D,""),I.flags&=-33);var F=PD(f);cC(f,F,D);break;case 3:case 4:var Y=I.stateNode.containerInfo,pe=PD(f);uC(f,pe,Y);break;default:throw Error(t(161))}}catch(Te){_s(f,f.return,Te)}f.flags&=-3}m&4096&&(f.flags&=-4097)}function Y6(f,m,S){jt=f,zD(f)}function zD(f,m,S){for(var I=(f.mode&1)!==0;jt!==null;){var D=jt,F=D.child;if(D.tag===22&&I){var Y=D.memoizedState!==null||Kw;if(!Y){var pe=D.alternate,Te=pe!==null&&pe.memoizedState!==null||ao;pe=Kw;var qe=ao;if(Kw=Y,(ao=Te)&&!qe)for(jt=D;jt!==null;)Y=jt,Te=Y.child,Y.tag===22&&Y.memoizedState!==null?VD(D):Te!==null?(Te.return=Y,jt=Te):VD(D);for(;F!==null;)jt=F,zD(F),F=F.sibling;jt=D,Kw=pe,ao=qe}BD(f)}else(D.subtreeFlags&8772)!==0&&F!==null?(F.return=D,jt=F):BD(f)}}function BD(f){for(;jt!==null;){var m=jt;if((m.flags&8772)!==0){var S=m.alternate;try{if((m.flags&8772)!==0)switch(m.tag){case 0:case 11:case 15:ao||Yw(5,m);break;case 1:var I=m.stateNode;if(m.flags&4&&!ao)if(S===null)I.componentDidMount();else{var D=m.elementType===m.type?S.memoizedProps:ua(m.type,S.memoizedProps);I.componentDidUpdate(D,S.memoizedState,I.__reactInternalSnapshotBeforeUpdate)}var F=m.updateQueue;F!==null&&Gh(m,F,I);break;case 3:var Y=m.updateQueue;if(Y!==null){if(S=null,m.child!==null)switch(m.child.tag){case 5:S=m.child.stateNode;break;case 1:S=m.child.stateNode}Gh(m,Y,S)}break;case 5:var pe=m.stateNode;if(S===null&&m.flags&4){S=pe;var Te=m.memoizedProps;switch(m.type){case"button":case"input":case"select":case"textarea":Te.autoFocus&&S.focus();break;case"img":Te.src&&(S.src=Te.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(m.memoizedState===null){var qe=m.alternate;if(qe!==null){var yt=qe.memoizedState;if(yt!==null){var vt=yt.dehydrated;vt!==null&&df(vt)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(t(163))}ao||m.flags&512&&lC(m)}catch(pt){_s(m,m.return,pt)}}if(m===f){jt=null;break}if(S=m.sibling,S!==null){S.return=m.return,jt=S;break}jt=m.return}}function UD(f){for(;jt!==null;){var m=jt;if(m===f){jt=null;break}var S=m.sibling;if(S!==null){S.return=m.return,jt=S;break}jt=m.return}}function VD(f){for(;jt!==null;){var m=jt;try{switch(m.tag){case 0:case 11:case 15:var S=m.return;try{Yw(4,m)}catch(Te){_s(m,S,Te)}break;case 1:var I=m.stateNode;if(typeof I.componentDidMount=="function"){var D=m.return;try{I.componentDidMount()}catch(Te){_s(m,D,Te)}}var F=m.return;try{lC(m)}catch(Te){_s(m,F,Te)}break;case 5:var Y=m.return;try{lC(m)}catch(Te){_s(m,Y,Te)}}}catch(Te){_s(m,m.return,Te)}if(m===f){jt=null;break}var pe=m.sibling;if(pe!==null){pe.return=m.return,jt=pe;break}jt=m.return}}var Z6=Math.ceil,Zw=E.ReactCurrentDispatcher,hC=E.ReactCurrentOwner,ul=E.ReactCurrentBatchConfig,mr=0,Ii=null,Ks=null,qi=0,Fa=0,pg=ls(0),di=0,nv=null,Wf=0,Jw=0,dC=0,rv=null,ca=null,fC=0,mg=1/0,Uc=null,Qw=!1,pC=null,Kh=null,eb=!1,Yh=null,tb=0,sv=0,mC=null,nb=-1,rb=0;function Oo(){return(mr&6)!==0?Ue():nb!==-1?nb:nb=Ue()}function Zh(f){return(f.mode&1)===0?1:(mr&2)!==0&&qi!==0?qi&-qi:rC.transition!==null?(rb===0&&(rb=Rr()),rb):(f=cr,f!==0||(f=window.event,f=f===void 0?16:Sw(f.type)),f)}function Zl(f,m,S,I){if(50<sv)throw sv=0,mC=null,Error(t(185));Ds(f,S,I),((mr&2)===0||f!==Ii)&&(f===Ii&&((mr&2)===0&&(Jw|=S),di===4&&Jh(f,qi)),ha(f,I),S===1&&mr===0&&(m.mode&1)===0&&(mg=Ue()+500,If&&il()))}function ha(f,m){var S=f.callbackNode;Rn(f,m);var I=Pn(f,f===Ii?qi:0);if(I===0)S!==null&&We(S),f.callbackNode=null,f.callbackPriority=0;else if(m=I&-I,f.callbackPriority!==m){if(S!=null&&We(S),m===1)f.tag===0?Lw(GD.bind(null,f)):Nf(GD.bind(null,f)),nC(function(){(mr&6)===0&&il()}),S=null;else{switch(Th(I)){case 1:S=dt;break;case 4:S=gt;break;case 16:S=Ut;break;case 536870912:S=on;break;default:S=Ut}S=JD(S,WD.bind(null,f))}f.callbackPriority=m,f.callbackNode=S}}function WD(f,m){if(nb=-1,rb=0,(mr&6)!==0)throw Error(t(327));var S=f.callbackNode;if(gg()&&f.callbackNode!==S)return null;var I=Pn(f,f===Ii?qi:0);if(I===0)return null;if((I&30)!==0||(I&f.expiredLanes)!==0||m)m=sb(f,I);else{m=I;var D=mr;mr|=2;var F=jD();(Ii!==f||qi!==m)&&(Uc=null,mg=Ue()+500,Hf(f,m));do try{e8();break}catch(pe){HD(f,pe)}while(!0);Dc(),Zw.current=F,mr=D,Ks!==null?m=0:(Ii=null,qi=0,m=di)}if(m!==0){if(m===2&&(D=Hn(f),D!==0&&(I=D,m=gC(f,D))),m===1)throw S=nv,Hf(f,0),Jh(f,I),ha(f,Ue()),S;if(m===6)Jh(f,I);else{if(D=f.current.alternate,(I&30)===0&&!J6(D)&&(m=sb(f,I),m===2&&(F=Hn(f),F!==0&&(I=F,m=gC(f,F))),m===1))throw S=nv,Hf(f,0),Jh(f,I),ha(f,Ue()),S;switch(f.finishedWork=D,f.finishedLanes=I,m){case 0:case 1:throw Error(t(345));case 2:jf(f,ca,Uc);break;case 3:if(Jh(f,I),(I&130023424)===I&&(m=fC+500-Ue(),10<m)){if(Pn(f,0)!==0)break;if(D=f.suspendedLanes,(D&I)!==I){Oo(),f.pingedLanes|=f.suspendedLanes&D;break}f.timeoutHandle=k0(jf.bind(null,f,ca,Uc),m);break}jf(f,ca,Uc);break;case 4:if(Jh(f,I),(I&4194240)===I)break;for(m=f.eventTimes,D=-1;0<I;){var Y=31-mn(I);F=1<<Y,Y=m[Y],Y>D&&(D=Y),I&=~F}if(I=D,I=Ue()-I,I=(120>I?120:480>I?480:1080>I?1080:1920>I?1920:3e3>I?3e3:4320>I?4320:1960*Z6(I/1960))-I,10<I){f.timeoutHandle=k0(jf.bind(null,f,ca,Uc),I);break}jf(f,ca,Uc);break;case 5:jf(f,ca,Uc);break;default:throw Error(t(329))}}}return ha(f,Ue()),f.callbackNode===S?WD.bind(null,f):null}function gC(f,m){var S=rv;return f.current.memoizedState.isDehydrated&&(Hf(f,m).flags|=256),f=sb(f,m),f!==2&&(m=ca,ca=S,m!==null&&yC(m)),f}function yC(f){ca===null?ca=f:ca.push.apply(ca,f)}function J6(f){for(var m=f;;){if(m.flags&16384){var S=m.updateQueue;if(S!==null&&(S=S.stores,S!==null))for(var I=0;I<S.length;I++){var D=S[I],F=D.getSnapshot;D=D.value;try{if(!Ao(F(),D))return!1}catch{return!1}}}if(S=m.child,m.subtreeFlags&16384&&S!==null)S.return=m,m=S;else{if(m===f)break;for(;m.sibling===null;){if(m.return===null||m.return===f)return!0;m=m.return}m.sibling.return=m.return,m=m.sibling}}return!0}function Jh(f,m){for(m&=~dC,m&=~Jw,f.suspendedLanes|=m,f.pingedLanes&=~m,f=f.expirationTimes;0<m;){var S=31-mn(m),I=1<<S;f[S]=-1,m&=~I}}function GD(f){if((mr&6)!==0)throw Error(t(327));gg();var m=Pn(f,0);if((m&1)===0)return ha(f,Ue()),null;var S=sb(f,m);if(f.tag!==0&&S===2){var I=Hn(f);I!==0&&(m=I,S=gC(f,I))}if(S===1)throw S=nv,Hf(f,0),Jh(f,m),ha(f,Ue()),S;if(S===6)throw Error(t(345));return f.finishedWork=f.current.alternate,f.finishedLanes=m,jf(f,ca,Uc),ha(f,Ue()),null}function vC(f,m){var S=mr;mr|=1;try{return f(m)}finally{mr=S,mr===0&&(mg=Ue()+500,If&&il())}}function Gf(f){Yh!==null&&Yh.tag===0&&(mr&6)===0&&gg();var m=mr;mr|=1;var S=ul.transition,I=cr;try{if(ul.transition=null,cr=1,f)return f()}finally{cr=I,ul.transition=S,mr=m,(mr&6)===0&&il()}}function xC(){Fa=pg.current,zr(pg)}function Hf(f,m){f.finishedWork=null,f.finishedLanes=0;var S=f.timeoutHandle;if(S!==-1&&(f.timeoutHandle=-1,R0(S)),Ks!==null)for(S=Ks.return;S!==null;){var I=S;switch(Ul(I),I.tag){case 1:I=I.type.childContextTypes,I!=null&&Ef();break;case 3:$u(),zr(Wi),zr(ai),al();break;case 5:Hh(I);break;case 4:$u();break;case 13:zr(Hr);break;case 19:zr(Hr);break;case 10:Rf(I.type._context);break;case 22:case 23:xC()}S=S.return}if(Ii=f,Ks=f=Qh(f.current,null),qi=Fa=m,di=0,nv=null,dC=Jw=Wf=0,ca=rv=null,Wl!==null){for(m=0;m<Wl.length;m++)if(S=Wl[m],I=S.interleaved,I!==null){S.interleaved=null;var D=I.next,F=S.pending;if(F!==null){var Y=F.next;F.next=D,I.next=Y}S.pending=I}Wl=null}return f}function HD(f,m){do{var S=Ks;try{if(Dc(),Oc.current=hg,La){for(var I=Br.memoizedState;I!==null;){var D=I.queue;D!==null&&(D.pending=null),I=I.next}La=!1}if(Hl=0,hr=cs=Br=null,Ci=!1,Pu=0,hC.current=null,S===null||S.return===null){di=1,nv=m,Ks=null;break}e:{var F=f,Y=S.return,pe=S,Te=m;if(m=qi,pe.flags|=32768,Te!==null&&typeof Te=="object"&&typeof Te.then=="function"){var qe=Te,yt=pe,vt=yt.tag;if((yt.mode&1)===0&&(vt===0||vt===11||vt===15)){var pt=yt.alternate;pt?(yt.updateQueue=pt.updateQueue,yt.memoizedState=pt.memoizedState,yt.lanes=pt.lanes):(yt.updateQueue=null,yt.memoizedState=null)}var Wt=Ht(Y);if(Wt!==null){Wt.flags&=-257,Cn(Wt,Y,pe,F,m),Wt.mode&1&&wt(F,qe,m),m=Wt,Te=qe;var qt=m.updateQueue;if(qt===null){var Yt=new Set;Yt.add(Te),m.updateQueue=Yt}else qt.add(Te);break e}else{if((m&1)===0){wt(F,qe,m),wC();break e}Te=Error(t(426))}}else if(Gr&&pe.mode&1){var Ls=Ht(Y);if(Ls!==null){(Ls.flags&65536)===0&&(Ls.flags|=256),Cn(Ls,Y,pe,F,m),Vh(A(Te,pe));break e}}F=Te=A(Te,pe),di!==4&&(di=2),rv===null?rv=[F]:rv.push(F),F=Y;do{switch(F.tag){case 3:F.flags|=65536,m&=-m,F.lanes|=m;var Fe=ke(F,Te,m);$c(F,Fe);break e;case 1:pe=Te;var Ne=F.type,Be=F.stateNode;if((F.flags&128)===0&&(typeof Ne.getDerivedStateFromError=="function"||Be!==null&&typeof Be.componentDidCatch=="function"&&(Kh===null||!Kh.has(Be)))){F.flags|=65536,m&=-m,F.lanes|=m;var St=tt(F,pe,m);$c(F,St);break e}}F=F.return}while(F!==null)}qD(S)}catch(Qt){m=Qt,Ks===S&&S!==null&&(Ks=S=S.return);continue}break}while(!0)}function jD(){var f=Zw.current;return Zw.current=hg,f===null?hg:f}function wC(){(di===0||di===3||di===2)&&(di=4),Ii===null||(Wf&268435455)===0&&(Jw&268435455)===0||Jh(Ii,qi)}function sb(f,m){var S=mr;mr|=2;var I=jD();(Ii!==f||qi!==m)&&(Uc=null,Hf(f,m));do try{Q6();break}catch(D){HD(f,D)}while(!0);if(Dc(),mr=S,Zw.current=I,Ks!==null)throw Error(t(261));return Ii=null,qi=0,di}function Q6(){for(;Ks!==null;)XD(Ks)}function e8(){for(;Ks!==null&&!Ye();)XD(Ks)}function XD(f){var m=ZD(f.alternate,f,Fa);f.memoizedProps=f.pendingProps,m===null?qD(f):Ks=m,hC.current=null}function qD(f){var m=f;do{var S=m.alternate;if(f=m.return,(m.flags&32768)===0){if(S=j6(S,m,Fa),S!==null){Ks=S;return}}else{if(S=X6(S,m),S!==null){S.flags&=32767,Ks=S;return}if(f!==null)f.flags|=32768,f.subtreeFlags=0,f.deletions=null;else{di=6,Ks=null;return}}if(m=m.sibling,m!==null){Ks=m;return}Ks=m=f}while(m!==null);di===0&&(di=5)}function jf(f,m,S){var I=cr,D=ul.transition;try{ul.transition=null,cr=1,t8(f,m,S,I)}finally{ul.transition=D,cr=I}return null}function t8(f,m,S,I){do gg();while(Yh!==null);if((mr&6)!==0)throw Error(t(327));S=f.finishedWork;var D=f.finishedLanes;if(S===null)return null;if(f.finishedWork=null,f.finishedLanes=0,S===f.current)throw Error(t(177));f.callbackNode=null,f.callbackPriority=0;var F=S.lanes|S.childLanes;if(el(f,F),f===Ii&&(Ks=Ii=null,qi=0),(S.subtreeFlags&2064)===0&&(S.flags&2064)===0||eb||(eb=!0,JD(Ut,function(){return gg(),null})),F=(S.flags&15990)!==0,(S.subtreeFlags&15990)!==0||F){F=ul.transition,ul.transition=null;var Y=cr;cr=1;var pe=mr;mr|=4,hC.current=null,K6(f,S),FD(S,f),Hs(A0),ta=!!zh,A0=zh=null,f.current=S,Y6(S),et(),mr=pe,cr=Y,ul.transition=F}else f.current=S;if(eb&&(eb=!1,Yh=f,tb=D),F=f.pendingLanes,F===0&&(Kh=null),Ct(S.stateNode),ha(f,Ue()),m!==null)for(I=f.onRecoverableError,S=0;S<m.length;S++)D=m[S],I(D.value,{componentStack:D.stack,digest:D.digest});if(Qw)throw Qw=!1,f=pC,pC=null,f;return(tb&1)!==0&&f.tag!==0&&gg(),F=f.pendingLanes,(F&1)!==0?f===mC?sv++:(sv=0,mC=f):sv=0,il(),null}function gg(){if(Yh!==null){var f=Th(tb),m=ul.transition,S=cr;try{if(ul.transition=null,cr=16>f?16:f,Yh===null)var I=!1;else{if(f=Yh,Yh=null,tb=0,(mr&6)!==0)throw Error(t(331));var D=mr;for(mr|=4,jt=f.current;jt!==null;){var F=jt,Y=F.child;if((jt.flags&16)!==0){var pe=F.deletions;if(pe!==null){for(var Te=0;Te<pe.length;Te++){var qe=pe[Te];for(jt=qe;jt!==null;){var yt=jt;switch(yt.tag){case 0:case 11:case 15:tv(8,yt,F)}var vt=yt.child;if(vt!==null)vt.return=yt,jt=vt;else for(;jt!==null;){yt=jt;var pt=yt.sibling,Wt=yt.return;if(DD(yt),yt===qe){jt=null;break}if(pt!==null){pt.return=Wt,jt=pt;break}jt=Wt}}}var qt=F.alternate;if(qt!==null){var Yt=qt.child;if(Yt!==null){qt.child=null;do{var Ls=Yt.sibling;Yt.sibling=null,Yt=Ls}while(Yt!==null)}}jt=F}}if((F.subtreeFlags&2064)!==0&&Y!==null)Y.return=F,jt=Y;else e:for(;jt!==null;){if(F=jt,(F.flags&2048)!==0)switch(F.tag){case 0:case 11:case 15:tv(9,F,F.return)}var Fe=F.sibling;if(Fe!==null){Fe.return=F.return,jt=Fe;break e}jt=F.return}}var Ne=f.current;for(jt=Ne;jt!==null;){Y=jt;var Be=Y.child;if((Y.subtreeFlags&2064)!==0&&Be!==null)Be.return=Y,jt=Be;else e:for(Y=Ne;jt!==null;){if(pe=jt,(pe.flags&2048)!==0)try{switch(pe.tag){case 0:case 11:case 15:Yw(9,pe)}}catch(Qt){_s(pe,pe.return,Qt)}if(pe===Y){jt=null;break e}var St=pe.sibling;if(St!==null){St.return=pe.return,jt=St;break e}jt=pe.return}}if(mr=D,il(),kt&&typeof kt.onPostCommitFiberRoot=="function")try{kt.onPostCommitFiberRoot(vn,f)}catch{}I=!0}return I}finally{cr=S,ul.transition=m}}return!1}function KD(f,m,S){m=A(S,m),m=ke(f,m,1),f=Yr(f,m,1),m=Oo(),f!==null&&(Ds(f,1,m),ha(f,m))}function _s(f,m,S){if(f.tag===3)KD(f,f,S);else for(;m!==null;){if(m.tag===3){KD(m,f,S);break}else if(m.tag===1){var I=m.stateNode;if(typeof m.type.getDerivedStateFromError=="function"||typeof I.componentDidCatch=="function"&&(Kh===null||!Kh.has(I))){f=A(S,f),f=tt(m,f,1),m=Yr(m,f,1),f=Oo(),m!==null&&(Ds(m,1,f),ha(m,f));break}}m=m.return}}function n8(f,m,S){var I=f.pingCache;I!==null&&I.delete(m),m=Oo(),f.pingedLanes|=f.suspendedLanes&S,Ii===f&&(qi&S)===S&&(di===4||di===3&&(qi&130023424)===qi&&500>Ue()-fC?Hf(f,0):dC|=S),ha(f,m)}function YD(f,m){m===0&&((f.mode&1)===0?m=1:(m=kr,kr<<=1,(kr&130023424)===0&&(kr=4194304)));var S=Oo();f=$a(f,m),f!==null&&(Ds(f,m,S),ha(f,S))}function r8(f){var m=f.memoizedState,S=0;m!==null&&(S=m.retryLane),YD(f,S)}function s8(f,m){var S=0;switch(f.tag){case 13:var I=f.stateNode,D=f.memoizedState;D!==null&&(S=D.retryLane);break;case 19:I=f.stateNode;break;default:throw Error(t(314))}I!==null&&I.delete(m),YD(f,S)}var ZD;ZD=function(f,m,S){if(f!==null)if(f.memoizedProps!==m.pendingProps||Wi.current)On=!0;else{if((f.lanes&S)===0&&(m.flags&128)===0)return On=!1,H6(f,m,S);On=(f.flags&131072)!==0}else On=!1,Gr&&(m.flags&1048576)!==0&&O0(m,tg,m.index);switch(m.lanes=0,m.tag){case 2:var I=m.type;qw(f,m),f=m.pendingProps;var D=Cc(m,ai.current);Du(m,S),D=Of(null,m,I,f,D,S);var F=H0();return m.flags|=1,typeof D=="object"&&D!==null&&typeof D.render=="function"&&D.$$typeof===void 0?(m.tag=1,m.memoizedState=null,m.updateQueue=null,Ti(I)?(F=!0,Ic(m)):F=!1,m.memoizedState=D.state!==null&&D.state!==void 0?D.state:null,Ln(m),D.updater=dg,m.stateNode=D,D._reactInternals=m,C(m,I,f,S),m=Dn(null,m,I,!0,F,S)):(m.tag=0,Gr&&F&&F0(m),zt(null,m,D,S),m=m.child),m;case 16:I=m.elementType;e:{switch(qw(f,m),f=m.pendingProps,D=I._init,I=D(I._payload),m.type=I,D=m.tag=o8(I),f=ua(I,f),D){case 0:m=Pt(null,m,I,f,S);break e;case 1:m=Zt(null,m,I,f,S);break e;case 11:m=hi(null,m,I,f,S);break e;case 14:m=Lo(null,m,I,ua(I.type,f),S);break e}throw Error(t(306,I,""))}return m;case 0:return I=m.type,D=m.pendingProps,D=m.elementType===I?D:ua(I,D),Pt(f,m,I,D,S);case 1:return I=m.type,D=m.pendingProps,D=m.elementType===I?D:ua(I,D),Zt(f,m,I,D,S);case 3:e:{if(In(m),f===null)throw Error(t(387));I=m.pendingProps,F=m.memoizedState,D=F.element,vs(f,m),us(m,I,null,S);var Y=m.memoizedState;if(I=Y.element,F.isDehydrated)if(F={element:I,isDehydrated:!1,cache:Y.cache,pendingSuspenseBoundaries:Y.pendingSuspenseBoundaries,transitions:Y.transitions},m.updateQueue.baseState=F,m.memoizedState=F,m.flags&256){D=A(Error(t(423)),m),m=rr(f,m,I,S,D);break e}else if(I!==D){D=A(Error(t(424)),m),m=rr(f,m,I,S,D);break e}else for(Hi=Ll(m.stateNode.containerInfo.firstChild),li=m,Gr=!0,la=null,S=kf(m,null,I,S),m.child=S;S;)S.flags=S.flags&-3|4096,S=S.sibling;else{if(Ru(),I===D){m=Bc(f,m,S);break e}zt(f,m,I,S)}m=m.child}return m;case 5:return Lc(m),f===null&&rg(m),I=m.type,D=m.pendingProps,F=f!==null?f.memoizedProps:null,Y=D.children,M0(I,D)?Y=null:F!==null&&M0(I,F)&&(m.flags|=32),Ze(f,m),zt(f,m,Y,S),m.child;case 6:return f===null&&rg(m),null;case 13:return ql(f,m,S);case 4:return Pf(m,m.stateNode.containerInfo),I=m.pendingProps,f===null?m.child=Mc(m,null,I,S):zt(f,m,I,S),m.child;case 11:return I=m.type,D=m.pendingProps,D=m.elementType===I?D:ua(I,D),hi(f,m,I,D,S);case 7:return zt(f,m,m.pendingProps,S),m.child;case 8:return zt(f,m,m.pendingProps.children,S),m.child;case 12:return zt(f,m,m.pendingProps.children,S),m.child;case 10:e:{if(I=m.type._context,D=m.pendingProps,F=m.memoizedProps,Y=D.value,Dr(kc,I._currentValue),I._currentValue=Y,F!==null)if(Ao(F.value,Y)){if(F.children===D.children&&!Wi.current){m=Bc(f,m,S);break e}}else for(F=m.child,F!==null&&(F.return=m);F!==null;){var pe=F.dependencies;if(pe!==null){Y=F.child;for(var Te=pe.firstContext;Te!==null;){if(Te.context===I){if(F.tag===1){Te=Nr(-1,S&-S),Te.tag=2;var qe=F.updateQueue;if(qe!==null){qe=qe.shared;var yt=qe.pending;yt===null?Te.next=Te:(Te.next=yt.next,yt.next=Te),qe.pending=Te}}F.lanes|=S,Te=F.alternate,Te!==null&&(Te.lanes|=S),Df(F.return,S,m),pe.lanes|=S;break}Te=Te.next}}else if(F.tag===10)Y=F.type===m.type?null:F.child;else if(F.tag===18){if(Y=F.return,Y===null)throw Error(t(341));Y.lanes|=S,pe=Y.alternate,pe!==null&&(pe.lanes|=S),Df(Y,S,m),Y=F.sibling}else Y=F.child;if(Y!==null)Y.return=F;else for(Y=F;Y!==null;){if(Y===m){Y=null;break}if(F=Y.sibling,F!==null){F.return=Y.return,Y=F;break}Y=Y.return}F=Y}zt(f,m,D.children,S),m=m.child}return m;case 9:return D=m.type,I=m.pendingProps.children,Du(m,S),D=Ro(D),I=I(D),m.flags|=1,zt(f,m,I,S),m.child;case 14:return I=m.type,D=ua(I,m.pendingProps),D=ua(I.type,D),Lo(f,m,I,D,S);case 15:return Ve(f,m,m.type,m.pendingProps,S);case 17:return I=m.type,D=m.pendingProps,D=m.elementType===I?D:ua(I,D),qw(f,m),m.tag=1,Ti(I)?(f=!0,Ic(m)):f=!1,Du(m,S),v(m,I,D),C(m,I,D,S),Dn(null,m,I,!0,f,S);case 19:return ND(f,m,S);case 22:return De(f,m,S)}throw Error(t(156,m.tag))};function JD(f,m){return me(f,m)}function i8(f,m,S,I){this.tag=f,this.key=S,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=m,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=I,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function cl(f,m,S,I){return new i8(f,m,S,I)}function bC(f){return f=f.prototype,!(!f||!f.isReactComponent)}function o8(f){if(typeof f=="function")return bC(f)?1:0;if(f!=null){if(f=f.$$typeof,f===B)return 11;if(f===X)return 14}return 2}function Qh(f,m){var S=f.alternate;return S===null?(S=cl(f.tag,m,f.key,f.mode),S.elementType=f.elementType,S.type=f.type,S.stateNode=f.stateNode,S.alternate=f,f.alternate=S):(S.pendingProps=m,S.type=f.type,S.flags=0,S.subtreeFlags=0,S.deletions=null),S.flags=f.flags&14680064,S.childLanes=f.childLanes,S.lanes=f.lanes,S.child=f.child,S.memoizedProps=f.memoizedProps,S.memoizedState=f.memoizedState,S.updateQueue=f.updateQueue,m=f.dependencies,S.dependencies=m===null?null:{lanes:m.lanes,firstContext:m.firstContext},S.sibling=f.sibling,S.index=f.index,S.ref=f.ref,S}function ib(f,m,S,I,D,F){var Y=2;if(I=f,typeof f=="function")bC(f)&&(Y=1);else if(typeof f=="string")Y=5;else e:switch(f){case $:return Xf(S.children,D,F,m);case L:Y=8,D|=8;break;case k:return f=cl(12,S,m,D|2),f.elementType=k,f.lanes=F,f;case Z:return f=cl(13,S,m,D),f.elementType=Z,f.lanes=F,f;case V:return f=cl(19,S,m,D),f.elementType=V,f.lanes=F,f;case se:return ob(S,D,F,m);default:if(typeof f=="object"&&f!==null)switch(f.$$typeof){case R:Y=10;break e;case P:Y=9;break e;case B:Y=11;break e;case X:Y=14;break e;case q:Y=16,I=null;break e}throw Error(t(130,f==null?f:typeof f,""))}return m=cl(Y,S,m,D),m.elementType=f,m.type=I,m.lanes=F,m}function Xf(f,m,S,I){return f=cl(7,f,I,m),f.lanes=S,f}function ob(f,m,S,I){return f=cl(22,f,I,m),f.elementType=se,f.lanes=S,f.stateNode={isHidden:!1},f}function SC(f,m,S){return f=cl(6,f,null,m),f.lanes=S,f}function _C(f,m,S){return m=cl(4,f.children!==null?f.children:[],f.key,m),m.lanes=S,m.stateNode={containerInfo:f.containerInfo,pendingChildren:null,implementation:f.implementation},m}function a8(f,m,S,I,D){this.tag=m,this.containerInfo=f,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=eo(0),this.expirationTimes=eo(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=eo(0),this.identifierPrefix=I,this.onRecoverableError=D,this.mutableSourceEagerHydrationData=null}function TC(f,m,S,I,D,F,Y,pe,Te){return f=new a8(f,m,S,pe,Te),m===1?(m=1,F===!0&&(m|=8)):m=0,F=cl(3,null,null,m),f.current=F,F.stateNode=f,F.memoizedState={element:I,isDehydrated:S,cache:null,transitions:null,pendingSuspenseBoundaries:null},Ln(F),f}function l8(f,m,S){var I=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:M,key:I==null?null:""+I,children:f,containerInfo:m,implementation:S}}function QD(f){if(!f)return Fl;f=f._reactInternals;e:{if(re(f)!==f||f.tag!==1)throw Error(t(170));var m=f;do{switch(m.tag){case 3:m=m.stateNode.context;break e;case 1:if(Ti(m.type)){m=m.stateNode.__reactInternalMemoizedMergedChildContext;break e}}m=m.return}while(m!==null);throw Error(t(171))}if(f.tag===1){var S=f.type;if(Ti(S))return Cf(f,S,m)}return m}function e$(f,m,S,I,D,F,Y,pe,Te){return f=TC(S,I,!0,f,D,F,Y,pe,Te),f.context=QD(null),S=f.current,I=Oo(),D=Zh(S),F=Nr(I,D),F.callback=m??null,Yr(S,F,D),f.current.lanes=D,Ds(f,D,I),ha(f,I),f}function ab(f,m,S,I){var D=m.current,F=Oo(),Y=Zh(D);return S=QD(S),m.context===null?m.context=S:m.pendingContext=S,m=Nr(F,Y),m.payload={element:f},I=I===void 0?null:I,I!==null&&(m.callback=I),f=Yr(D,m,Y),f!==null&&(Zl(f,D,Y,F),Ei(f,D,Y)),Y}function lb(f){if(f=f.current,!f.child)return null;switch(f.child.tag){case 5:return f.child.stateNode;default:return f.child.stateNode}}function t$(f,m){if(f=f.memoizedState,f!==null&&f.dehydrated!==null){var S=f.retryLane;f.retryLane=S!==0&&S<m?S:m}}function EC(f,m){t$(f,m),(f=f.alternate)&&t$(f,m)}function u8(){return null}var n$=typeof reportError=="function"?reportError:function(f){console.error(f)};function CC(f){this._internalRoot=f}ub.prototype.render=CC.prototype.render=function(f){var m=this._internalRoot;if(m===null)throw Error(t(409));ab(f,m,null,null)},ub.prototype.unmount=CC.prototype.unmount=function(){var f=this._internalRoot;if(f!==null){this._internalRoot=null;var m=f.containerInfo;Gf(function(){ab(null,f,null,null)}),m[ko]=null}};function ub(f){this._internalRoot=f}ub.prototype.unstable_scheduleHydration=function(f){if(f){var m=wm();f={blockedOn:null,target:f,priority:m};for(var S=0;S<Tu.length&&m!==0&&m<Tu[S].priority;S++);Tu.splice(S,0,f),S===0&&_m(f)}};function IC(f){return!(!f||f.nodeType!==1&&f.nodeType!==9&&f.nodeType!==11)}function cb(f){return!(!f||f.nodeType!==1&&f.nodeType!==9&&f.nodeType!==11&&(f.nodeType!==8||f.nodeValue!==" react-mount-point-unstable "))}function r$(){}function c8(f,m,S,I,D){if(D){if(typeof I=="function"){var F=I;I=function(){var qe=lb(Y);F.call(qe)}}var Y=e$(m,I,f,0,null,!1,!1,"",r$);return f._reactRootContainer=Y,f[ko]=Y.current,Oh(f.nodeType===8?f.parentNode:f),Gf(),Y}for(;D=f.lastChild;)f.removeChild(D);if(typeof I=="function"){var pe=I;I=function(){var qe=lb(Te);pe.call(qe)}}var Te=TC(f,0,!1,null,null,!1,!1,"",r$);return f._reactRootContainer=Te,f[ko]=Te.current,Oh(f.nodeType===8?f.parentNode:f),Gf(function(){ab(m,Te,S,I)}),Te}function hb(f,m,S,I,D){var F=S._reactRootContainer;if(F){var Y=F;if(typeof D=="function"){var pe=D;D=function(){var Te=lb(Y);pe.call(Te)}}ab(m,Y,f,D)}else Y=c8(S,m,f,D,I);return lb(Y)}uf=function(f){switch(f.tag){case 3:var m=f.stateNode;if(m.current.memoizedState.isDehydrated){var S=Gn(m.pendingLanes);S!==0&&(_h(m,S|1),ha(m,Ue()),(mr&6)===0&&(mg=Ue()+500,il()))}break;case 13:Gf(function(){var I=$a(f,1);if(I!==null){var D=Oo();Zl(I,f,1,D)}}),EC(f,1)}},d0=function(f){if(f.tag===13){var m=$a(f,134217728);if(m!==null){var S=Oo();Zl(m,f,134217728,S)}EC(f,134217728)}},bw=function(f){if(f.tag===13){var m=Zh(f),S=$a(f,m);if(S!==null){var I=Oo();Zl(S,f,m,I)}EC(f,m)}},wm=function(){return cr},bm=function(f,m){var S=cr;try{return cr=f,m()}finally{cr=S}},Ge=function(f,m,S){switch(m){case"input":if(_t(f,S),m=S.name,S.type==="radio"&&m!=null){for(S=f;S.parentNode;)S=S.parentNode;for(S=S.querySelectorAll("input[name="+JSON.stringify(""+m)+'][type="radio"]'),m=0;m<S.length;m++){var I=S[m];if(I!==f&&I.form===f.form){var D=Jm(I);if(!D)throw Error(t(90));fe(I),_t(I,D)}}}break;case"textarea":ot(f,S);break;case"select":m=S.value,m!=null&&Le(f,!!S.multiple,m,!1)}},pr=vC,ur=Gf;var h8={usingClientEntryPoint:!1,Events:[Ol,ys,Jm,ln,sn,vC]},iv={findFiberByHostInstance:ku,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},d8={bundleType:iv.bundleType,version:iv.version,rendererPackageName:iv.rendererPackageName,rendererConfig:iv.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:E.ReactCurrentDispatcher,findHostInstanceByFiber:function(f){return f=ue(f),f===null?null:f.stateNode},findFiberByHostInstance:iv.findFiberByHostInstance||u8,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var db=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!db.isDisabled&&db.supportsFiber)try{vn=db.inject(d8),kt=db}catch{}}return da.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=h8,da.createPortal=function(f,m){var S=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!IC(m))throw Error(t(200));return l8(f,m,null,S)},da.createRoot=function(f,m){if(!IC(f))throw Error(t(299));var S=!1,I="",D=n$;return m!=null&&(m.unstable_strictMode===!0&&(S=!0),m.identifierPrefix!==void 0&&(I=m.identifierPrefix),m.onRecoverableError!==void 0&&(D=m.onRecoverableError)),m=TC(f,1,!1,null,null,S,!1,I,D),f[ko]=m.current,Oh(f.nodeType===8?f.parentNode:f),new CC(m)},da.findDOMNode=function(f){if(f==null)return null;if(f.nodeType===1)return f;var m=f._reactInternals;if(m===void 0)throw typeof f.render=="function"?Error(t(188)):(f=Object.keys(f).join(","),Error(t(268,f)));return f=ue(m),f=f===null?null:f.stateNode,f},da.flushSync=function(f){return Gf(f)},da.hydrate=function(f,m,S){if(!cb(m))throw Error(t(200));return hb(null,f,m,!0,S)},da.hydrateRoot=function(f,m,S){if(!IC(f))throw Error(t(405));var I=S!=null&&S.hydratedSources||null,D=!1,F="",Y=n$;if(S!=null&&(S.unstable_strictMode===!0&&(D=!0),S.identifierPrefix!==void 0&&(F=S.identifierPrefix),S.onRecoverableError!==void 0&&(Y=S.onRecoverableError)),m=e$(m,null,f,1,S??null,D,!1,F,Y),f[ko]=m.current,Oh(f),I)for(f=0;f<I.length;f++)S=I[f],D=S._getVersion,D=D(S._source),m.mutableSourceEagerHydrationData==null?m.mutableSourceEagerHydrationData=[S,D]:m.mutableSourceEagerHydrationData.push(S,D);return new ub(m)},da.render=function(f,m,S){if(!cb(m))throw Error(t(200));return hb(null,f,m,!1,S)},da.unmountComponentAtNode=function(f){if(!cb(f))throw Error(t(40));return f._reactRootContainer?(Gf(function(){hb(null,null,f,!1,function(){f._reactRootContainer=null,f[ko]=null})}),!0):!1},da.unstable_batchedUpdates=vC,da.unstable_renderSubtreeIntoContainer=function(f,m,S,I){if(!cb(S))throw Error(t(200));if(f==null||f._reactInternals===void 0)throw Error(t(38));return hb(f,m,S,!1,I)},da.version="18.3.1-next-f1338f8080-20240426",da}var h$;function S8(){if(h$)return MC.exports;h$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),MC.exports=b8(),MC.exports}var d$;function _8(){if(d$)return fb;d$=1;var n=S8();return fb.createRoot=n.createRoot,fb.hydrateRoot=n.hydrateRoot,fb}var T8=_8();const E8=Ux(T8);/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Vd="160",C8={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},I8={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},GO=0,uI=1,HO=2,N8=3,jO=0,B_=1,Bv=2,iu=3,ec=0,yi=1,Wo=2,A8=2,wo=0,Ip=1,cI=2,hI=3,dI=4,XO=5,pd=100,qO=101,KO=102,fI=103,pI=104,YO=200,ZO=201,JO=202,QO=203,XS=204,qS=205,eF=206,tF=207,nF=208,rF=209,sF=210,iF=211,oF=212,aF=213,lF=214,uF=0,yA=1,cF=2,Zv=3,hF=4,dF=5,fF=6,pF=7,Wx=0,mF=1,gF=2,Hu=0,yF=1,vF=2,xF=3,U_=4,wF=5,bF=6,mI="attached",SF="detached",V_=300,tc=301,Nd=302,my=303,Jv=304,Ly=306,Pp=1e3,mo=1001,Qv=1002,ss=1003,KS=1004,M8=1004,Uv=1005,k8=1005,Lr=1006,vA=1007,R8=1007,Ad=1008,D8=1008,Ki=1009,_F=1010,TF=1011,W_=1012,xA=1013,Vu=1014,Di=1015,vo=1016,wA=1017,bA=1018,rh=1020,EF=1021,go=1023,CF=1024,IF=1025,wd=1026,Md=1027,SA=1028,_A=1029,NF=1030,TA=1031,EA=1033,TS=33776,ES=33777,CS=33778,IS=33779,gI=35840,yI=35841,vI=35842,xI=35843,CA=36196,wI=37492,bI=37496,SI=37808,_I=37809,TI=37810,EI=37811,CI=37812,II=37813,NI=37814,AI=37815,MI=37816,kI=37817,RI=37818,DI=37819,$I=37820,PI=37821,NS=36492,LI=36494,OI=36495,AF=36283,FI=36284,zI=36285,BI=36286,MF=2200,kF=2201,RF=2202,ex=2300,tx=2301,AS=2302,gp=2400,yp=2401,nx=2402,G_=2500,IA=2501,$8=0,P8=1,L8=2,NA=3e3,bd=3001,Wd=3200,DF=3201,Gd=0,$F=1,Go="",sr="srgb",xl="srgb-linear",H_="display-p3",Gx="display-p3-linear",rx="linear",Zr="srgb",sx="rec709",ix="p3",O8=0,ap=7680,F8=7681,z8=7682,B8=7683,U8=34055,V8=34056,W8=5386,G8=512,H8=513,j8=514,X8=515,q8=516,K8=517,Y8=518,UI=519,PF=512,LF=513,OF=514,AA=515,FF=516,zF=517,BF=518,UF=519,ox=35044,Z8=35048,J8=35040,Q8=35045,ej=35049,tj=35041,nj=35046,rj=35050,sj=35042,ij="100",VI="300 es",YS=1035,cu=2e3,gy=2001;class Tl{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const r=this._listeners;r[e]===void 0&&(r[e]=[]),r[e].indexOf(t)===-1&&r[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const r=this._listeners;return r[e]!==void 0&&r[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const s=this._listeners[e];if(s!==void 0){const i=s.indexOf(t);i!==-1&&s.splice(i,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const r=this._listeners[e.type];if(r!==void 0){e.target=this;const s=r.slice(0);for(let i=0,o=s.length;i<o;i++)s[i].call(this,e);e.target=null}}}const lo=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let f$=1234567;const Np=Math.PI/180,yy=180/Math.PI;function Ha(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,r=Math.random()*4294967295|0;return(lo[n&255]+lo[n>>8&255]+lo[n>>16&255]+lo[n>>24&255]+"-"+lo[e&255]+lo[e>>8&255]+"-"+lo[e>>16&15|64]+lo[e>>24&255]+"-"+lo[t&63|128]+lo[t>>8&255]+"-"+lo[t>>16&255]+lo[t>>24&255]+lo[r&255]+lo[r>>8&255]+lo[r>>16&255]+lo[r>>24&255]).toLowerCase()}function Es(n,e,t){return Math.max(e,Math.min(t,n))}function MA(n,e){return(n%e+e)%e}function oj(n,e,t,r,s){return r+(n-e)*(s-r)/(t-e)}function aj(n,e,t){return n!==e?(t-n)/(e-n):0}function Vv(n,e,t){return(1-t)*n+t*e}function lj(n,e,t,r){return Vv(n,e,1-Math.exp(-t*r))}function uj(n,e=1){return e-Math.abs(MA(n,e*2)-e)}function cj(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function hj(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function dj(n,e){return n+Math.floor(Math.random()*(e-n+1))}function fj(n,e){return n+Math.random()*(e-n)}function pj(n){return n*(.5-Math.random())}function mj(n){n!==void 0&&(f$=n);let e=f$+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function gj(n){return n*Np}function yj(n){return n*yy}function WI(n){return(n&n-1)===0&&n!==0}function vj(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function ZS(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function xj(n,e,t,r,s){const i=Math.cos,o=Math.sin,a=i(t/2),l=o(t/2),u=i((e+r)/2),c=o((e+r)/2),h=i((e-r)/2),d=o((e-r)/2),p=i((r-e)/2),g=o((r-e)/2);switch(s){case"XYX":n.set(a*c,l*h,l*d,a*u);break;case"YZY":n.set(l*d,a*c,l*h,a*u);break;case"ZXZ":n.set(l*h,l*d,a*c,a*u);break;case"XZX":n.set(a*c,l*g,l*p,a*u);break;case"YXY":n.set(l*p,a*c,l*g,a*u);break;case"ZYZ":n.set(l*g,l*p,a*c,a*u);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}}function xa(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function Vn(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}const Ua={DEG2RAD:Np,RAD2DEG:yy,generateUUID:Ha,clamp:Es,euclideanModulo:MA,mapLinear:oj,inverseLerp:aj,lerp:Vv,damp:lj,pingpong:uj,smoothstep:cj,smootherstep:hj,randInt:dj,randFloat:fj,randFloatSpread:pj,seededRandom:mj,degToRad:gj,radToDeg:yj,isPowerOfTwo:WI,ceilPowerOfTwo:vj,floorPowerOfTwo:ZS,setQuaternionFromProperEuler:xj,normalize:Vn,denormalize:xa};class rt{constructor(e=0,t=0){rt.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,r=this.y,s=e.elements;return this.x=s[0]*t+s[3]*r+s[6],this.y=s[1]*t+s[4]*r+s[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const r=this.dot(e)/t;return Math.acos(Es(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y;return t*t+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const r=Math.cos(t),s=Math.sin(t),i=this.x-e.x,o=this.y-e.y;return this.x=i*r-o*s+e.x,this.y=i*s+o*r+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class jn{constructor(e,t,r,s,i,o,a,l,u){jn.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,r,s,i,o,a,l,u)}set(e,t,r,s,i,o,a,l,u){const c=this.elements;return c[0]=e,c[1]=s,c[2]=a,c[3]=t,c[4]=i,c[5]=l,c[6]=r,c[7]=o,c[8]=u,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],this}extractBasis(e,t,r){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,s=t.elements,i=this.elements,o=r[0],a=r[3],l=r[6],u=r[1],c=r[4],h=r[7],d=r[2],p=r[5],g=r[8],w=s[0],y=s[3],x=s[6],_=s[1],T=s[4],E=s[7],N=s[2],M=s[5],$=s[8];return i[0]=o*w+a*_+l*N,i[3]=o*y+a*T+l*M,i[6]=o*x+a*E+l*$,i[1]=u*w+c*_+h*N,i[4]=u*y+c*T+h*M,i[7]=u*x+c*E+h*$,i[2]=d*w+p*_+g*N,i[5]=d*y+p*T+g*M,i[8]=d*x+p*E+g*$,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8];return t*o*c-t*a*u-r*i*c+r*a*l+s*i*u-s*o*l}invert(){const e=this.elements,t=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8],h=c*o-a*u,d=a*l-c*i,p=u*i-o*l,g=t*h+r*d+s*p;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const w=1/g;return e[0]=h*w,e[1]=(s*u-c*r)*w,e[2]=(a*r-s*o)*w,e[3]=d*w,e[4]=(c*t-s*l)*w,e[5]=(s*i-a*t)*w,e[6]=p*w,e[7]=(r*l-u*t)*w,e[8]=(o*t-r*i)*w,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,r,s,i,o,a){const l=Math.cos(i),u=Math.sin(i);return this.set(r*l,r*u,-r*(l*o+u*a)+o+e,-s*u,s*l,-s*(-u*o+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(DC.makeScale(e,t)),this}rotate(e){return this.premultiply(DC.makeRotation(-e)),this}translate(e,t){return this.premultiply(DC.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,-r,0,r,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,r=e.elements;for(let s=0;s<9;s++)if(t[s]!==r[s])return!1;return!0}fromArray(e,t=0){for(let r=0;r<9;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const DC=new jn;function VF(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}const wj={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function ey(n,e){return new wj[n](e)}function ax(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function WF(){const n=ax("canvas");return n.style.display="block",n}const p$={};function Wv(n){n in p$||(p$[n]=!0,console.warn(n))}const m$=new jn().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),g$=new jn().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),pb={[xl]:{transfer:rx,primaries:sx,toReference:n=>n,fromReference:n=>n},[sr]:{transfer:Zr,primaries:sx,toReference:n=>n.convertSRGBToLinear(),fromReference:n=>n.convertLinearToSRGB()},[Gx]:{transfer:rx,primaries:ix,toReference:n=>n.applyMatrix3(g$),fromReference:n=>n.applyMatrix3(m$)},[H_]:{transfer:Zr,primaries:ix,toReference:n=>n.convertSRGBToLinear().applyMatrix3(g$),fromReference:n=>n.applyMatrix3(m$).convertLinearToSRGB()}},bj=new Set([xl,Gx]),$r={enabled:!0,_workingColorSpace:xl,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(n){if(!bj.has(n))throw new Error(`Unsupported working color space, "${n}".`);this._workingColorSpace=n},convert:function(n,e,t){if(this.enabled===!1||e===t||!e||!t)return n;const r=pb[e].toReference,s=pb[t].fromReference;return s(r(n))},fromWorkingColorSpace:function(n,e){return this.convert(n,this._workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this._workingColorSpace)},getPrimaries:function(n){return pb[n].primaries},getTransfer:function(n){return n===Go?rx:pb[n].transfer}};function oy(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function $C(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let yg;class kA{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{yg===void 0&&(yg=ax("canvas")),yg.width=e.width,yg.height=e.height;const r=yg.getContext("2d");e instanceof ImageData?r.putImageData(e,0,0):r.drawImage(e,0,0,e.width,e.height),t=yg}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=ax("canvas");t.width=e.width,t.height=e.height;const r=t.getContext("2d");r.drawImage(e,0,0,e.width,e.height);const s=r.getImageData(0,0,e.width,e.height),i=s.data;for(let o=0;o<i.length;o++)i[o]=oy(i[o]/255)*255;return r.putImageData(s,0,0),t}else if(e.data){const t=e.data.slice(0);for(let r=0;r<t.length;r++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[r]=Math.floor(oy(t[r]/255)*255):t[r]=oy(t[r]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let Sj=0;class vp{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Sj++}),this.uuid=Ha(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const r={uuid:this.uuid,url:""},s=this.data;if(s!==null){let i;if(Array.isArray(s)){i=[];for(let o=0,a=s.length;o<a;o++)s[o].isDataTexture?i.push(PC(s[o].image)):i.push(PC(s[o]))}else i=PC(s);r.url=i}return t||(e.images[this.uuid]=r),r}}function PC(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?kA.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let _j=0;class fs extends Tl{constructor(e=fs.DEFAULT_IMAGE,t=fs.DEFAULT_MAPPING,r=mo,s=mo,i=Lr,o=Ad,a=go,l=Ki,u=fs.DEFAULT_ANISOTROPY,c=Go){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:_j++}),this.uuid=Ha(),this.name="",this.source=new vp(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=r,this.wrapT=s,this.magFilter=i,this.minFilter=o,this.anisotropy=u,this.format=a,this.internalFormat=null,this.type=l,this.offset=new rt(0,0),this.repeat=new rt(1,1),this.center=new rt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new jn,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof c=="string"?this.colorSpace=c:(Wv("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=c===bd?sr:Go),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const r={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(r.userData=this.userData),t||(e.textures[this.uuid]=r),r}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==V_)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Pp:e.x=e.x-Math.floor(e.x);break;case mo:e.x=e.x<0?0:1;break;case Qv:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Pp:e.y=e.y-Math.floor(e.y);break;case mo:e.y=e.y<0?0:1;break;case Qv:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return Wv("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===sr?bd:NA}set encoding(e){Wv("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=e===bd?sr:Go}}fs.DEFAULT_IMAGE=null;fs.DEFAULT_MAPPING=V_;fs.DEFAULT_ANISOTROPY=1;class br{constructor(e=0,t=0,r=0,s=1){br.prototype.isVector4=!0,this.x=e,this.y=t,this.z=r,this.w=s}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,r,s){return this.x=e,this.y=t,this.z=r,this.w=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,r=this.y,s=this.z,i=this.w,o=e.elements;return this.x=o[0]*t+o[4]*r+o[8]*s+o[12]*i,this.y=o[1]*t+o[5]*r+o[9]*s+o[13]*i,this.z=o[2]*t+o[6]*r+o[10]*s+o[14]*i,this.w=o[3]*t+o[7]*r+o[11]*s+o[15]*i,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,r,s,i;const l=e.elements,u=l[0],c=l[4],h=l[8],d=l[1],p=l[5],g=l[9],w=l[2],y=l[6],x=l[10];if(Math.abs(c-d)<.01&&Math.abs(h-w)<.01&&Math.abs(g-y)<.01){if(Math.abs(c+d)<.1&&Math.abs(h+w)<.1&&Math.abs(g+y)<.1&&Math.abs(u+p+x-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const T=(u+1)/2,E=(p+1)/2,N=(x+1)/2,M=(c+d)/4,$=(h+w)/4,L=(g+y)/4;return T>E&&T>N?T<.01?(r=0,s=.707106781,i=.707106781):(r=Math.sqrt(T),s=M/r,i=$/r):E>N?E<.01?(r=.707106781,s=0,i=.707106781):(s=Math.sqrt(E),r=M/s,i=L/s):N<.01?(r=.707106781,s=.707106781,i=0):(i=Math.sqrt(N),r=$/i,s=L/i),this.set(r,s,i,t),this}let _=Math.sqrt((y-g)*(y-g)+(h-w)*(h-w)+(d-c)*(d-c));return Math.abs(_)<.001&&(_=1),this.x=(y-g)/_,this.y=(h-w)/_,this.z=(d-c)/_,this.w=Math.acos((u+p+x-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this.w=e.w+(t.w-e.w)*r,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class GF extends Tl{constructor(e=1,t=1,r={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new br(0,0,e,t),this.scissorTest=!1,this.viewport=new br(0,0,e,t);const s={width:e,height:t,depth:1};r.encoding!==void 0&&(Wv("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),r.colorSpace=r.encoding===bd?sr:Go),r=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Lr,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0},r),this.texture=new fs(s,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=r.generateMipmaps,this.texture.internalFormat=r.internalFormat,this.depthBuffer=r.depthBuffer,this.stencilBuffer=r.stencilBuffer,this.depthTexture=r.depthTexture,this.samples=r.samples}setSize(e,t,r=1){(this.width!==e||this.height!==t||this.depth!==r)&&(this.width=e,this.height=t,this.depth=r,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=r,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new vp(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Us extends GF{constructor(e=1,t=1,r={}){super(e,t,r),this.isWebGLRenderTarget=!0}}class j_ extends fs{constructor(e=null,t=1,r=1,s=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:r,depth:s},this.magFilter=ss,this.minFilter=ss,this.wrapR=mo,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Tj extends Us{constructor(e=1,t=1,r=1,s={}){super(e,t,s),this.isWebGLArrayRenderTarget=!0,this.depth=r,this.texture=new j_(null,e,t,r),this.texture.isRenderTargetTexture=!0}}class RA extends fs{constructor(e=null,t=1,r=1,s=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:r,depth:s},this.magFilter=ss,this.minFilter=ss,this.wrapR=mo,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Ej extends Us{constructor(e=1,t=1,r=1,s={}){super(e,t,s),this.isWebGL3DRenderTarget=!0,this.depth=r,this.texture=new RA(null,e,t,r),this.texture.isRenderTargetTexture=!0}}class Cj extends Us{constructor(e=1,t=1,r=1,s={}){super(e,t,s),this.isWebGLMultipleRenderTargets=!0;const i=this.texture;this.texture=[];for(let o=0;o<r;o++)this.texture[o]=i.clone(),this.texture[o].isRenderTargetTexture=!0}setSize(e,t,r=1){if(this.width!==e||this.height!==t||this.depth!==r){this.width=e,this.height=t,this.depth=r;for(let s=0,i=this.texture.length;s<i;s++)this.texture[s].image.width=e,this.texture[s].image.height=t,this.texture[s].image.depth=r;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,r=e.texture.length;t<r;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}}class bo{constructor(e=0,t=0,r=0,s=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=r,this._w=s}static slerpFlat(e,t,r,s,i,o,a){let l=r[s+0],u=r[s+1],c=r[s+2],h=r[s+3];const d=i[o+0],p=i[o+1],g=i[o+2],w=i[o+3];if(a===0){e[t+0]=l,e[t+1]=u,e[t+2]=c,e[t+3]=h;return}if(a===1){e[t+0]=d,e[t+1]=p,e[t+2]=g,e[t+3]=w;return}if(h!==w||l!==d||u!==p||c!==g){let y=1-a;const x=l*d+u*p+c*g+h*w,_=x>=0?1:-1,T=1-x*x;if(T>Number.EPSILON){const N=Math.sqrt(T),M=Math.atan2(N,x*_);y=Math.sin(y*M)/N,a=Math.sin(a*M)/N}const E=a*_;if(l=l*y+d*E,u=u*y+p*E,c=c*y+g*E,h=h*y+w*E,y===1-a){const N=1/Math.sqrt(l*l+u*u+c*c+h*h);l*=N,u*=N,c*=N,h*=N}}e[t]=l,e[t+1]=u,e[t+2]=c,e[t+3]=h}static multiplyQuaternionsFlat(e,t,r,s,i,o){const a=r[s],l=r[s+1],u=r[s+2],c=r[s+3],h=i[o],d=i[o+1],p=i[o+2],g=i[o+3];return e[t]=a*g+c*h+l*p-u*d,e[t+1]=l*g+c*d+u*h-a*p,e[t+2]=u*g+c*p+a*d-l*h,e[t+3]=c*g-a*h-l*d-u*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,r,s){return this._x=e,this._y=t,this._z=r,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const r=e._x,s=e._y,i=e._z,o=e._order,a=Math.cos,l=Math.sin,u=a(r/2),c=a(s/2),h=a(i/2),d=l(r/2),p=l(s/2),g=l(i/2);switch(o){case"XYZ":this._x=d*c*h+u*p*g,this._y=u*p*h-d*c*g,this._z=u*c*g+d*p*h,this._w=u*c*h-d*p*g;break;case"YXZ":this._x=d*c*h+u*p*g,this._y=u*p*h-d*c*g,this._z=u*c*g-d*p*h,this._w=u*c*h+d*p*g;break;case"ZXY":this._x=d*c*h-u*p*g,this._y=u*p*h+d*c*g,this._z=u*c*g+d*p*h,this._w=u*c*h-d*p*g;break;case"ZYX":this._x=d*c*h-u*p*g,this._y=u*p*h+d*c*g,this._z=u*c*g-d*p*h,this._w=u*c*h+d*p*g;break;case"YZX":this._x=d*c*h+u*p*g,this._y=u*p*h+d*c*g,this._z=u*c*g-d*p*h,this._w=u*c*h-d*p*g;break;case"XZY":this._x=d*c*h-u*p*g,this._y=u*p*h-d*c*g,this._z=u*c*g+d*p*h,this._w=u*c*h+d*p*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const r=t/2,s=Math.sin(r);return this._x=e.x*s,this._y=e.y*s,this._z=e.z*s,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,r=t[0],s=t[4],i=t[8],o=t[1],a=t[5],l=t[9],u=t[2],c=t[6],h=t[10],d=r+a+h;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(c-l)*p,this._y=(i-u)*p,this._z=(o-s)*p}else if(r>a&&r>h){const p=2*Math.sqrt(1+r-a-h);this._w=(c-l)/p,this._x=.25*p,this._y=(s+o)/p,this._z=(i+u)/p}else if(a>h){const p=2*Math.sqrt(1+a-r-h);this._w=(i-u)/p,this._x=(s+o)/p,this._y=.25*p,this._z=(l+c)/p}else{const p=2*Math.sqrt(1+h-r-a);this._w=(o-s)/p,this._x=(i+u)/p,this._y=(l+c)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let r=e.dot(t)+1;return r<Number.EPSILON?(r=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=r):(this._x=0,this._y=-e.z,this._z=e.y,this._w=r)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=r),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Es(this.dot(e),-1,1)))}rotateTowards(e,t){const r=this.angleTo(e);if(r===0)return this;const s=Math.min(1,t/r);return this.slerp(e,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const r=e._x,s=e._y,i=e._z,o=e._w,a=t._x,l=t._y,u=t._z,c=t._w;return this._x=r*c+o*a+s*u-i*l,this._y=s*c+o*l+i*a-r*u,this._z=i*c+o*u+r*l-s*a,this._w=o*c-r*a-s*l-i*u,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const r=this._x,s=this._y,i=this._z,o=this._w;let a=o*e._w+r*e._x+s*e._y+i*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=r,this._y=s,this._z=i,this;const l=1-a*a;if(l<=Number.EPSILON){const p=1-t;return this._w=p*o+t*this._w,this._x=p*r+t*this._x,this._y=p*s+t*this._y,this._z=p*i+t*this._z,this.normalize(),this}const u=Math.sqrt(l),c=Math.atan2(u,a),h=Math.sin((1-t)*c)/u,d=Math.sin(t*c)/u;return this._w=o*h+this._w*d,this._x=r*h+this._x*d,this._y=s*h+this._y*d,this._z=i*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,r){return this.copy(e).slerp(t,r)}random(){const e=Math.random(),t=Math.sqrt(1-e),r=Math.sqrt(e),s=2*Math.PI*Math.random(),i=2*Math.PI*Math.random();return this.set(t*Math.cos(s),r*Math.sin(i),r*Math.cos(i),t*Math.sin(s))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class le{constructor(e=0,t=0,r=0){le.prototype.isVector3=!0,this.x=e,this.y=t,this.z=r}set(e,t,r){return r===void 0&&(r=this.z),this.x=e,this.y=t,this.z=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(y$.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(y$.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,r=this.y,s=this.z,i=e.elements;return this.x=i[0]*t+i[3]*r+i[6]*s,this.y=i[1]*t+i[4]*r+i[7]*s,this.z=i[2]*t+i[5]*r+i[8]*s,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,r=this.y,s=this.z,i=e.elements,o=1/(i[3]*t+i[7]*r+i[11]*s+i[15]);return this.x=(i[0]*t+i[4]*r+i[8]*s+i[12])*o,this.y=(i[1]*t+i[5]*r+i[9]*s+i[13])*o,this.z=(i[2]*t+i[6]*r+i[10]*s+i[14])*o,this}applyQuaternion(e){const t=this.x,r=this.y,s=this.z,i=e.x,o=e.y,a=e.z,l=e.w,u=2*(o*s-a*r),c=2*(a*t-i*s),h=2*(i*r-o*t);return this.x=t+l*u+o*h-a*c,this.y=r+l*c+a*u-i*h,this.z=s+l*h+i*c-o*u,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,r=this.y,s=this.z,i=e.elements;return this.x=i[0]*t+i[4]*r+i[8]*s,this.y=i[1]*t+i[5]*r+i[9]*s,this.z=i[2]*t+i[6]*r+i[10]*s,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const r=e.x,s=e.y,i=e.z,o=t.x,a=t.y,l=t.z;return this.x=s*l-i*a,this.y=i*o-r*l,this.z=r*a-s*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const r=e.dot(this)/t;return this.copy(e).multiplyScalar(r)}projectOnPlane(e){return LC.copy(this).projectOnVector(e),this.sub(LC)}reflect(e){return this.sub(LC.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const r=this.dot(e)/t;return Math.acos(Es(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y,s=this.z-e.z;return t*t+r*r+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,r){const s=Math.sin(t)*e;return this.x=s*Math.sin(r),this.y=Math.cos(t)*e,this.z=s*Math.cos(r),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,r){return this.x=e*Math.sin(t),this.y=r,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),r=this.setFromMatrixColumn(e,1).length(),s=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=r,this.z=s,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,r=Math.sqrt(1-e**2);return this.x=r*Math.cos(t),this.y=r*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const LC=new le,y$=new bo;class jo{constructor(e=new le(1/0,1/0,1/0),t=new le(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t+=3)this.expandByPoint(Jl.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,r=e.count;t<r;t++)this.expandByPoint(Jl.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=Jl.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const r=e.geometry;if(r!==void 0){const i=r.getAttribute("position");if(t===!0&&i!==void 0&&e.isInstancedMesh!==!0)for(let o=0,a=i.count;o<a;o++)e.isMesh===!0?e.getVertexPosition(o,Jl):Jl.fromBufferAttribute(i,o),Jl.applyMatrix4(e.matrixWorld),this.expandByPoint(Jl);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),mb.copy(e.boundingBox)):(r.boundingBox===null&&r.computeBoundingBox(),mb.copy(r.boundingBox)),mb.applyMatrix4(e.matrixWorld),this.union(mb)}const s=e.children;for(let i=0,o=s.length;i<o;i++)this.expandByObject(s[i],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Jl),Jl.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,r;return e.normal.x>0?(t=e.normal.x*this.min.x,r=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,r=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,r+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,r+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,r+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,r+=e.normal.z*this.min.z),t<=-e.constant&&r>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(av),gb.subVectors(this.max,av),vg.subVectors(e.a,av),xg.subVectors(e.b,av),wg.subVectors(e.c,av),td.subVectors(xg,vg),nd.subVectors(wg,xg),qf.subVectors(vg,wg);let t=[0,-td.z,td.y,0,-nd.z,nd.y,0,-qf.z,qf.y,td.z,0,-td.x,nd.z,0,-nd.x,qf.z,0,-qf.x,-td.y,td.x,0,-nd.y,nd.x,0,-qf.y,qf.x,0];return!OC(t,vg,xg,wg,gb)||(t=[1,0,0,0,1,0,0,0,1],!OC(t,vg,xg,wg,gb))?!1:(yb.crossVectors(td,nd),t=[yb.x,yb.y,yb.z],OC(t,vg,xg,wg,gb))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Jl).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Jl).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Vc[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Vc[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Vc[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Vc[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Vc[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Vc[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Vc[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Vc[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Vc),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Vc=[new le,new le,new le,new le,new le,new le,new le,new le],Jl=new le,mb=new jo,vg=new le,xg=new le,wg=new le,td=new le,nd=new le,qf=new le,av=new le,gb=new le,yb=new le,Kf=new le;function OC(n,e,t,r,s){for(let i=0,o=n.length-3;i<=o;i+=3){Kf.fromArray(n,i);const a=s.x*Math.abs(Kf.x)+s.y*Math.abs(Kf.y)+s.z*Math.abs(Kf.z),l=e.dot(Kf),u=t.dot(Kf),c=r.dot(Kf);if(Math.max(-Math.max(l,u,c),Math.min(l,u,c))>a)return!1}return!0}const Ij=new jo,lv=new le,FC=new le;class So{constructor(e=new le,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const r=this.center;t!==void 0?r.copy(t):Ij.setFromPoints(e).getCenter(r);let s=0;for(let i=0,o=e.length;i<o;i++)s=Math.max(s,r.distanceToSquared(e[i]));return this.radius=Math.sqrt(s),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const r=this.center.distanceToSquared(e);return t.copy(e),r>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;lv.subVectors(e,this.center);const t=lv.lengthSq();if(t>this.radius*this.radius){const r=Math.sqrt(t),s=(r-this.radius)*.5;this.center.addScaledVector(lv,s/r),this.radius+=s}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(FC.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(lv.copy(e.center).add(FC)),this.expandByPoint(lv.copy(e.center).sub(FC))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Wc=new le,zC=new le,vb=new le,rd=new le,BC=new le,xb=new le,UC=new le;class Oy{constructor(e=new le,t=new le(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Wc)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const r=t.dot(this.direction);return r<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,r)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Wc.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Wc.copy(this.origin).addScaledVector(this.direction,t),Wc.distanceToSquared(e))}distanceSqToSegment(e,t,r,s){zC.copy(e).add(t).multiplyScalar(.5),vb.copy(t).sub(e).normalize(),rd.copy(this.origin).sub(zC);const i=e.distanceTo(t)*.5,o=-this.direction.dot(vb),a=rd.dot(this.direction),l=-rd.dot(vb),u=rd.lengthSq(),c=Math.abs(1-o*o);let h,d,p,g;if(c>0)if(h=o*l-a,d=o*a-l,g=i*c,h>=0)if(d>=-g)if(d<=g){const w=1/c;h*=w,d*=w,p=h*(h+o*d+2*a)+d*(o*h+d+2*l)+u}else d=i,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+u;else d=-i,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+u;else d<=-g?(h=Math.max(0,-(-o*i+a)),d=h>0?-i:Math.min(Math.max(-i,-l),i),p=-h*h+d*(d+2*l)+u):d<=g?(h=0,d=Math.min(Math.max(-i,-l),i),p=d*(d+2*l)+u):(h=Math.max(0,-(o*i+a)),d=h>0?i:Math.min(Math.max(-i,-l),i),p=-h*h+d*(d+2*l)+u);else d=o>0?-i:i,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+u;return r&&r.copy(this.origin).addScaledVector(this.direction,h),s&&s.copy(zC).addScaledVector(vb,d),p}intersectSphere(e,t){Wc.subVectors(e.center,this.origin);const r=Wc.dot(this.direction),s=Wc.dot(Wc)-r*r,i=e.radius*e.radius;if(s>i)return null;const o=Math.sqrt(i-s),a=r-o,l=r+o;return l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const r=-(this.origin.dot(e.normal)+e.constant)/t;return r>=0?r:null}intersectPlane(e,t){const r=this.distanceToPlane(e);return r===null?null:this.at(r,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let r,s,i,o,a,l;const u=1/this.direction.x,c=1/this.direction.y,h=1/this.direction.z,d=this.origin;return u>=0?(r=(e.min.x-d.x)*u,s=(e.max.x-d.x)*u):(r=(e.max.x-d.x)*u,s=(e.min.x-d.x)*u),c>=0?(i=(e.min.y-d.y)*c,o=(e.max.y-d.y)*c):(i=(e.max.y-d.y)*c,o=(e.min.y-d.y)*c),r>o||i>s||((i>r||isNaN(r))&&(r=i),(o<s||isNaN(s))&&(s=o),h>=0?(a=(e.min.z-d.z)*h,l=(e.max.z-d.z)*h):(a=(e.max.z-d.z)*h,l=(e.min.z-d.z)*h),r>l||a>s)||((a>r||r!==r)&&(r=a),(l<s||s!==s)&&(s=l),s<0)?null:this.at(r>=0?r:s,t)}intersectsBox(e){return this.intersectBox(e,Wc)!==null}intersectTriangle(e,t,r,s,i){BC.subVectors(t,e),xb.subVectors(r,e),UC.crossVectors(BC,xb);let o=this.direction.dot(UC),a;if(o>0){if(s)return null;a=1}else if(o<0)a=-1,o=-o;else return null;rd.subVectors(this.origin,e);const l=a*this.direction.dot(xb.crossVectors(rd,xb));if(l<0)return null;const u=a*this.direction.dot(BC.cross(rd));if(u<0||l+u>o)return null;const c=-a*rd.dot(UC);return c<0?null:this.at(c/o,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class _n{constructor(e,t,r,s,i,o,a,l,u,c,h,d,p,g,w,y){_n.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,r,s,i,o,a,l,u,c,h,d,p,g,w,y)}set(e,t,r,s,i,o,a,l,u,c,h,d,p,g,w,y){const x=this.elements;return x[0]=e,x[4]=t,x[8]=r,x[12]=s,x[1]=i,x[5]=o,x[9]=a,x[13]=l,x[2]=u,x[6]=c,x[10]=h,x[14]=d,x[3]=p,x[7]=g,x[11]=w,x[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new _n().fromArray(this.elements)}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],this}copyPosition(e){const t=this.elements,r=e.elements;return t[12]=r[12],t[13]=r[13],t[14]=r[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,r){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(e,t,r){return this.set(e.x,t.x,r.x,0,e.y,t.y,r.y,0,e.z,t.z,r.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,r=e.elements,s=1/bg.setFromMatrixColumn(e,0).length(),i=1/bg.setFromMatrixColumn(e,1).length(),o=1/bg.setFromMatrixColumn(e,2).length();return t[0]=r[0]*s,t[1]=r[1]*s,t[2]=r[2]*s,t[3]=0,t[4]=r[4]*i,t[5]=r[5]*i,t[6]=r[6]*i,t[7]=0,t[8]=r[8]*o,t[9]=r[9]*o,t[10]=r[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,r=e.x,s=e.y,i=e.z,o=Math.cos(r),a=Math.sin(r),l=Math.cos(s),u=Math.sin(s),c=Math.cos(i),h=Math.sin(i);if(e.order==="XYZ"){const d=o*c,p=o*h,g=a*c,w=a*h;t[0]=l*c,t[4]=-l*h,t[8]=u,t[1]=p+g*u,t[5]=d-w*u,t[9]=-a*l,t[2]=w-d*u,t[6]=g+p*u,t[10]=o*l}else if(e.order==="YXZ"){const d=l*c,p=l*h,g=u*c,w=u*h;t[0]=d+w*a,t[4]=g*a-p,t[8]=o*u,t[1]=o*h,t[5]=o*c,t[9]=-a,t[2]=p*a-g,t[6]=w+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*c,p=l*h,g=u*c,w=u*h;t[0]=d-w*a,t[4]=-o*h,t[8]=g+p*a,t[1]=p+g*a,t[5]=o*c,t[9]=w-d*a,t[2]=-o*u,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*c,p=o*h,g=a*c,w=a*h;t[0]=l*c,t[4]=g*u-p,t[8]=d*u+w,t[1]=l*h,t[5]=w*u+d,t[9]=p*u-g,t[2]=-u,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,p=o*u,g=a*l,w=a*u;t[0]=l*c,t[4]=w-d*h,t[8]=g*h+p,t[1]=h,t[5]=o*c,t[9]=-a*c,t[2]=-u*c,t[6]=p*h+g,t[10]=d-w*h}else if(e.order==="XZY"){const d=o*l,p=o*u,g=a*l,w=a*u;t[0]=l*c,t[4]=-h,t[8]=u*c,t[1]=d*h+w,t[5]=o*c,t[9]=p*h-g,t[2]=g*h-p,t[6]=a*c,t[10]=w*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Nj,e,Aj)}lookAt(e,t,r){const s=this.elements;return za.subVectors(e,t),za.lengthSq()===0&&(za.z=1),za.normalize(),sd.crossVectors(r,za),sd.lengthSq()===0&&(Math.abs(r.z)===1?za.x+=1e-4:za.z+=1e-4,za.normalize(),sd.crossVectors(r,za)),sd.normalize(),wb.crossVectors(za,sd),s[0]=sd.x,s[4]=wb.x,s[8]=za.x,s[1]=sd.y,s[5]=wb.y,s[9]=za.y,s[2]=sd.z,s[6]=wb.z,s[10]=za.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,s=t.elements,i=this.elements,o=r[0],a=r[4],l=r[8],u=r[12],c=r[1],h=r[5],d=r[9],p=r[13],g=r[2],w=r[6],y=r[10],x=r[14],_=r[3],T=r[7],E=r[11],N=r[15],M=s[0],$=s[4],L=s[8],k=s[12],R=s[1],P=s[5],B=s[9],Z=s[13],V=s[2],X=s[6],q=s[10],se=s[14],W=s[3],J=s[7],K=s[11],G=s[15];return i[0]=o*M+a*R+l*V+u*W,i[4]=o*$+a*P+l*X+u*J,i[8]=o*L+a*B+l*q+u*K,i[12]=o*k+a*Z+l*se+u*G,i[1]=c*M+h*R+d*V+p*W,i[5]=c*$+h*P+d*X+p*J,i[9]=c*L+h*B+d*q+p*K,i[13]=c*k+h*Z+d*se+p*G,i[2]=g*M+w*R+y*V+x*W,i[6]=g*$+w*P+y*X+x*J,i[10]=g*L+w*B+y*q+x*K,i[14]=g*k+w*Z+y*se+x*G,i[3]=_*M+T*R+E*V+N*W,i[7]=_*$+T*P+E*X+N*J,i[11]=_*L+T*B+E*q+N*K,i[15]=_*k+T*Z+E*se+N*G,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[4],s=e[8],i=e[12],o=e[1],a=e[5],l=e[9],u=e[13],c=e[2],h=e[6],d=e[10],p=e[14],g=e[3],w=e[7],y=e[11],x=e[15];return g*(+i*l*h-s*u*h-i*a*d+r*u*d+s*a*p-r*l*p)+w*(+t*l*p-t*u*d+i*o*d-s*o*p+s*u*c-i*l*c)+y*(+t*u*h-t*a*p-i*o*h+r*o*p+i*a*c-r*u*c)+x*(-s*a*c-t*l*h+t*a*d+s*o*h-r*o*d+r*l*c)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,r){const s=this.elements;return e.isVector3?(s[12]=e.x,s[13]=e.y,s[14]=e.z):(s[12]=e,s[13]=t,s[14]=r),this}invert(){const e=this.elements,t=e[0],r=e[1],s=e[2],i=e[3],o=e[4],a=e[5],l=e[6],u=e[7],c=e[8],h=e[9],d=e[10],p=e[11],g=e[12],w=e[13],y=e[14],x=e[15],_=h*y*u-w*d*u+w*l*p-a*y*p-h*l*x+a*d*x,T=g*d*u-c*y*u-g*l*p+o*y*p+c*l*x-o*d*x,E=c*w*u-g*h*u+g*a*p-o*w*p-c*a*x+o*h*x,N=g*h*l-c*w*l-g*a*d+o*w*d+c*a*y-o*h*y,M=t*_+r*T+s*E+i*N;if(M===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const $=1/M;return e[0]=_*$,e[1]=(w*d*i-h*y*i-w*s*p+r*y*p+h*s*x-r*d*x)*$,e[2]=(a*y*i-w*l*i+w*s*u-r*y*u-a*s*x+r*l*x)*$,e[3]=(h*l*i-a*d*i-h*s*u+r*d*u+a*s*p-r*l*p)*$,e[4]=T*$,e[5]=(c*y*i-g*d*i+g*s*p-t*y*p-c*s*x+t*d*x)*$,e[6]=(g*l*i-o*y*i-g*s*u+t*y*u+o*s*x-t*l*x)*$,e[7]=(o*d*i-c*l*i+c*s*u-t*d*u-o*s*p+t*l*p)*$,e[8]=E*$,e[9]=(g*h*i-c*w*i-g*r*p+t*w*p+c*r*x-t*h*x)*$,e[10]=(o*w*i-g*a*i+g*r*u-t*w*u-o*r*x+t*a*x)*$,e[11]=(c*a*i-o*h*i-c*r*u+t*h*u+o*r*p-t*a*p)*$,e[12]=N*$,e[13]=(c*w*s-g*h*s+g*r*d-t*w*d-c*r*y+t*h*y)*$,e[14]=(g*a*s-o*w*s-g*r*l+t*w*l+o*r*y-t*a*y)*$,e[15]=(o*h*s-c*a*s+c*r*l-t*h*l-o*r*d+t*a*d)*$,this}scale(e){const t=this.elements,r=e.x,s=e.y,i=e.z;return t[0]*=r,t[4]*=s,t[8]*=i,t[1]*=r,t[5]*=s,t[9]*=i,t[2]*=r,t[6]*=s,t[10]*=i,t[3]*=r,t[7]*=s,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],s=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,s))}makeTranslation(e,t,r){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,r,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),r=Math.sin(e);return this.set(1,0,0,0,0,t,-r,0,0,r,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,0,r,0,0,1,0,0,-r,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,-r,0,0,r,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const r=Math.cos(t),s=Math.sin(t),i=1-r,o=e.x,a=e.y,l=e.z,u=i*o,c=i*a;return this.set(u*o+r,u*a-s*l,u*l+s*a,0,u*a+s*l,c*a+r,c*l-s*o,0,u*l-s*a,c*l+s*o,i*l*l+r,0,0,0,0,1),this}makeScale(e,t,r){return this.set(e,0,0,0,0,t,0,0,0,0,r,0,0,0,0,1),this}makeShear(e,t,r,s,i,o){return this.set(1,r,i,0,e,1,o,0,t,s,1,0,0,0,0,1),this}compose(e,t,r){const s=this.elements,i=t._x,o=t._y,a=t._z,l=t._w,u=i+i,c=o+o,h=a+a,d=i*u,p=i*c,g=i*h,w=o*c,y=o*h,x=a*h,_=l*u,T=l*c,E=l*h,N=r.x,M=r.y,$=r.z;return s[0]=(1-(w+x))*N,s[1]=(p+E)*N,s[2]=(g-T)*N,s[3]=0,s[4]=(p-E)*M,s[5]=(1-(d+x))*M,s[6]=(y+_)*M,s[7]=0,s[8]=(g+T)*$,s[9]=(y-_)*$,s[10]=(1-(d+w))*$,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1,this}decompose(e,t,r){const s=this.elements;let i=bg.set(s[0],s[1],s[2]).length();const o=bg.set(s[4],s[5],s[6]).length(),a=bg.set(s[8],s[9],s[10]).length();this.determinant()<0&&(i=-i),e.x=s[12],e.y=s[13],e.z=s[14],Ql.copy(this);const u=1/i,c=1/o,h=1/a;return Ql.elements[0]*=u,Ql.elements[1]*=u,Ql.elements[2]*=u,Ql.elements[4]*=c,Ql.elements[5]*=c,Ql.elements[6]*=c,Ql.elements[8]*=h,Ql.elements[9]*=h,Ql.elements[10]*=h,t.setFromRotationMatrix(Ql),r.x=i,r.y=o,r.z=a,this}makePerspective(e,t,r,s,i,o,a=cu){const l=this.elements,u=2*i/(t-e),c=2*i/(r-s),h=(t+e)/(t-e),d=(r+s)/(r-s);let p,g;if(a===cu)p=-(o+i)/(o-i),g=-2*o*i/(o-i);else if(a===gy)p=-o/(o-i),g=-o*i/(o-i);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return l[0]=u,l[4]=0,l[8]=h,l[12]=0,l[1]=0,l[5]=c,l[9]=d,l[13]=0,l[2]=0,l[6]=0,l[10]=p,l[14]=g,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,r,s,i,o,a=cu){const l=this.elements,u=1/(t-e),c=1/(r-s),h=1/(o-i),d=(t+e)*u,p=(r+s)*c;let g,w;if(a===cu)g=(o+i)*h,w=-2*h;else if(a===gy)g=i*h,w=-1*h;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return l[0]=2*u,l[4]=0,l[8]=0,l[12]=-d,l[1]=0,l[5]=2*c,l[9]=0,l[13]=-p,l[2]=0,l[6]=0,l[10]=w,l[14]=-g,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,r=e.elements;for(let s=0;s<16;s++)if(t[s]!==r[s])return!1;return!0}fromArray(e,t=0){for(let r=0;r<16;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e[t+9]=r[9],e[t+10]=r[10],e[t+11]=r[11],e[t+12]=r[12],e[t+13]=r[13],e[t+14]=r[14],e[t+15]=r[15],e}}const bg=new le,Ql=new _n,Nj=new le(0,0,0),Aj=new le(1,1,1),sd=new le,wb=new le,za=new le,v$=new _n,x$=new bo;class Fy{constructor(e=0,t=0,r=0,s=Fy.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=r,this._order=s}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,r,s=this._order){return this._x=e,this._y=t,this._z=r,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,r=!0){const s=e.elements,i=s[0],o=s[4],a=s[8],l=s[1],u=s[5],c=s[9],h=s[2],d=s[6],p=s[10];switch(t){case"XYZ":this._y=Math.asin(Es(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-c,p),this._z=Math.atan2(-o,i)):(this._x=Math.atan2(d,u),this._z=0);break;case"YXZ":this._x=Math.asin(-Es(c,-1,1)),Math.abs(c)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,u)):(this._y=Math.atan2(-h,i),this._z=0);break;case"ZXY":this._x=Math.asin(Es(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-o,u)):(this._y=0,this._z=Math.atan2(l,i));break;case"ZYX":this._y=Math.asin(-Es(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,i)):(this._x=0,this._z=Math.atan2(-o,u));break;case"YZX":this._z=Math.asin(Es(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-c,u),this._y=Math.atan2(-h,i)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-Es(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,u),this._y=Math.atan2(a,i)):(this._x=Math.atan2(-c,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,r===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,r){return v$.makeRotationFromQuaternion(e),this.setFromRotationMatrix(v$,t,r)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return x$.setFromEuler(this),this.setFromQuaternion(x$,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Fy.DEFAULT_ORDER="XYZ";class Ap{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let Mj=0;const w$=new le,Sg=new bo,Gc=new _n,bb=new le,uv=new le,kj=new le,Rj=new bo,b$=new le(1,0,0),S$=new le(0,1,0),_$=new le(0,0,1),Dj={type:"added"},$j={type:"removed"};class dr extends Tl{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Mj++}),this.uuid=Ha(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=dr.DEFAULT_UP.clone();const e=new le,t=new Fy,r=new bo,s=new le(1,1,1);function i(){r.setFromEuler(t,!1)}function o(){t.setFromQuaternion(r,void 0,!1)}t._onChange(i),r._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:r},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new _n},normalMatrix:{value:new jn}}),this.matrix=new _n,this.matrixWorld=new _n,this.matrixAutoUpdate=dr.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=dr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Ap,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Sg.setFromAxisAngle(e,t),this.quaternion.multiply(Sg),this}rotateOnWorldAxis(e,t){return Sg.setFromAxisAngle(e,t),this.quaternion.premultiply(Sg),this}rotateX(e){return this.rotateOnAxis(b$,e)}rotateY(e){return this.rotateOnAxis(S$,e)}rotateZ(e){return this.rotateOnAxis(_$,e)}translateOnAxis(e,t){return w$.copy(e).applyQuaternion(this.quaternion),this.position.add(w$.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(b$,e)}translateY(e){return this.translateOnAxis(S$,e)}translateZ(e){return this.translateOnAxis(_$,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(Gc.copy(this.matrixWorld).invert())}lookAt(e,t,r){e.isVector3?bb.copy(e):bb.set(e,t,r);const s=this.parent;this.updateWorldMatrix(!0,!1),uv.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Gc.lookAt(uv,bb,this.up):Gc.lookAt(bb,uv,this.up),this.quaternion.setFromRotationMatrix(Gc),s&&(Gc.extractRotation(s.matrixWorld),Sg.setFromRotationMatrix(Gc),this.quaternion.premultiply(Sg.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(Dj)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let r=0;r<arguments.length;r++)this.remove(arguments[r]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent($j)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),Gc.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Gc.multiply(e.parent.matrixWorld)),e.applyMatrix4(Gc),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let r=0,s=this.children.length;r<s;r++){const o=this.children[r].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t,r=[]){this[e]===t&&r.push(this);const s=this.children;for(let i=0,o=s.length;i<o;i++)s[i].getObjectsByProperty(e,t,r);return r}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(uv,e,kj),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(uv,Rj,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let r=0,s=t.length;r<s;r++)t[r].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let r=0,s=t.length;r<s;r++)t[r].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let r=0,s=t.length;r<s;r++){const i=t[r];(i.matrixWorldAutoUpdate===!0||e===!0)&&i.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const r=this.parent;if(e===!0&&r!==null&&r.matrixWorldAutoUpdate===!0&&r.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const s=this.children;for(let i=0,o=s.length;i<o;i++){const a=s[i];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",r={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},r.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const s={};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.castShadow===!0&&(s.castShadow=!0),this.receiveShadow===!0&&(s.receiveShadow=!0),this.visible===!1&&(s.visible=!1),this.frustumCulled===!1&&(s.frustumCulled=!1),this.renderOrder!==0&&(s.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),s.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(s.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(s.type="BatchedMesh",s.perObjectFrustumCulled=this.perObjectFrustumCulled,s.sortObjects=this.sortObjects,s.drawRanges=this._drawRanges,s.reservedRanges=this._reservedRanges,s.visibility=this._visibility,s.active=this._active,s.bounds=this._bounds.map(a=>({boxInitialized:a.boxInitialized,boxMin:a.box.min.toArray(),boxMax:a.box.max.toArray(),sphereInitialized:a.sphereInitialized,sphereRadius:a.sphere.radius,sphereCenter:a.sphere.center.toArray()})),s.maxGeometryCount=this._maxGeometryCount,s.maxVertexCount=this._maxVertexCount,s.maxIndexCount=this._maxIndexCount,s.geometryInitialized=this._geometryInitialized,s.geometryCount=this._geometryCount,s.matricesTexture=this._matricesTexture.toJSON(e),this.boundingSphere!==null&&(s.boundingSphere={center:s.boundingSphere.center.toArray(),radius:s.boundingSphere.radius}),this.boundingBox!==null&&(s.boundingBox={min:s.boundingBox.min.toArray(),max:s.boundingBox.max.toArray()}));function i(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(s.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=i(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let u=0,c=l.length;u<c;u++){const h=l[u];i(e.shapes,h)}else i(e.shapes,l)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(i(e.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,u=this.material.length;l<u;l++)a.push(i(e.materials,this.material[l]));s.material=a}else s.material=i(e.materials,this.material);if(this.children.length>0){s.children=[];for(let a=0;a<this.children.length;a++)s.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){s.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];s.animations.push(i(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),u=o(e.textures),c=o(e.images),h=o(e.shapes),d=o(e.skeletons),p=o(e.animations),g=o(e.nodes);a.length>0&&(r.geometries=a),l.length>0&&(r.materials=l),u.length>0&&(r.textures=u),c.length>0&&(r.images=c),h.length>0&&(r.shapes=h),d.length>0&&(r.skeletons=d),p.length>0&&(r.animations=p),g.length>0&&(r.nodes=g)}return r.object=s,r;function o(a){const l=[];for(const u in a){const c=a[u];delete c.metadata,l.push(c)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let r=0;r<e.children.length;r++){const s=e.children[r];this.add(s.clone())}return this}}dr.DEFAULT_UP=new le(0,1,0);dr.DEFAULT_MATRIX_AUTO_UPDATE=!0;dr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const eu=new le,Hc=new le,VC=new le,jc=new le,_g=new le,Tg=new le,T$=new le,WC=new le,GC=new le,HC=new le;let Sb=!1;class va{constructor(e=new le,t=new le,r=new le){this.a=e,this.b=t,this.c=r}static getNormal(e,t,r,s){s.subVectors(r,t),eu.subVectors(e,t),s.cross(eu);const i=s.lengthSq();return i>0?s.multiplyScalar(1/Math.sqrt(i)):s.set(0,0,0)}static getBarycoord(e,t,r,s,i){eu.subVectors(s,t),Hc.subVectors(r,t),VC.subVectors(e,t);const o=eu.dot(eu),a=eu.dot(Hc),l=eu.dot(VC),u=Hc.dot(Hc),c=Hc.dot(VC),h=o*u-a*a;if(h===0)return i.set(0,0,0),null;const d=1/h,p=(u*l-a*c)*d,g=(o*c-a*l)*d;return i.set(1-p-g,g,p)}static containsPoint(e,t,r,s){return this.getBarycoord(e,t,r,s,jc)===null?!1:jc.x>=0&&jc.y>=0&&jc.x+jc.y<=1}static getUV(e,t,r,s,i,o,a,l){return Sb===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),Sb=!0),this.getInterpolation(e,t,r,s,i,o,a,l)}static getInterpolation(e,t,r,s,i,o,a,l){return this.getBarycoord(e,t,r,s,jc)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(i,jc.x),l.addScaledVector(o,jc.y),l.addScaledVector(a,jc.z),l)}static isFrontFacing(e,t,r,s){return eu.subVectors(r,t),Hc.subVectors(e,t),eu.cross(Hc).dot(s)<0}set(e,t,r){return this.a.copy(e),this.b.copy(t),this.c.copy(r),this}setFromPointsAndIndices(e,t,r,s){return this.a.copy(e[t]),this.b.copy(e[r]),this.c.copy(e[s]),this}setFromAttributeAndIndices(e,t,r,s){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,r),this.c.fromBufferAttribute(e,s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return eu.subVectors(this.c,this.b),Hc.subVectors(this.a,this.b),eu.cross(Hc).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return va.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return va.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,r,s,i){return Sb===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),Sb=!0),va.getInterpolation(e,this.a,this.b,this.c,t,r,s,i)}getInterpolation(e,t,r,s,i){return va.getInterpolation(e,this.a,this.b,this.c,t,r,s,i)}containsPoint(e){return va.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return va.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const r=this.a,s=this.b,i=this.c;let o,a;_g.subVectors(s,r),Tg.subVectors(i,r),WC.subVectors(e,r);const l=_g.dot(WC),u=Tg.dot(WC);if(l<=0&&u<=0)return t.copy(r);GC.subVectors(e,s);const c=_g.dot(GC),h=Tg.dot(GC);if(c>=0&&h<=c)return t.copy(s);const d=l*h-c*u;if(d<=0&&l>=0&&c<=0)return o=l/(l-c),t.copy(r).addScaledVector(_g,o);HC.subVectors(e,i);const p=_g.dot(HC),g=Tg.dot(HC);if(g>=0&&p<=g)return t.copy(i);const w=p*u-l*g;if(w<=0&&u>=0&&g<=0)return a=u/(u-g),t.copy(r).addScaledVector(Tg,a);const y=c*g-p*h;if(y<=0&&h-c>=0&&p-g>=0)return T$.subVectors(i,s),a=(h-c)/(h-c+(p-g)),t.copy(s).addScaledVector(T$,a);const x=1/(y+w+d);return o=w*x,a=d*x,t.copy(r).addScaledVector(_g,o).addScaledVector(Tg,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const HF={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},id={h:0,s:0,l:0},_b={h:0,s:0,l:0};function jC(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}class Nt{constructor(e,t,r){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,r)}set(e,t,r){if(t===void 0&&r===void 0){const s=e;s&&s.isColor?this.copy(s):typeof s=="number"?this.setHex(s):typeof s=="string"&&this.setStyle(s)}else this.setRGB(e,t,r);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=sr){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,$r.toWorkingColorSpace(this,t),this}setRGB(e,t,r,s=$r.workingColorSpace){return this.r=e,this.g=t,this.b=r,$r.toWorkingColorSpace(this,s),this}setHSL(e,t,r,s=$r.workingColorSpace){if(e=MA(e,1),t=Es(t,0,1),r=Es(r,0,1),t===0)this.r=this.g=this.b=r;else{const i=r<=.5?r*(1+t):r+t-r*t,o=2*r-i;this.r=jC(o,i,e+1/3),this.g=jC(o,i,e),this.b=jC(o,i,e-1/3)}return $r.toWorkingColorSpace(this,s),this}setStyle(e,t=sr){function r(i){i!==void 0&&parseFloat(i)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let s;if(s=/^(\w+)\(([^\)]*)\)/.exec(e)){let i;const o=s[1],a=s[2];switch(o){case"rgb":case"rgba":if(i=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return r(i[4]),this.setRGB(Math.min(255,parseInt(i[1],10))/255,Math.min(255,parseInt(i[2],10))/255,Math.min(255,parseInt(i[3],10))/255,t);if(i=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return r(i[4]),this.setRGB(Math.min(100,parseInt(i[1],10))/100,Math.min(100,parseInt(i[2],10))/100,Math.min(100,parseInt(i[3],10))/100,t);break;case"hsl":case"hsla":if(i=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return r(i[4]),this.setHSL(parseFloat(i[1])/360,parseFloat(i[2])/100,parseFloat(i[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(s=/^\#([A-Fa-f\d]+)$/.exec(e)){const i=s[1],o=i.length;if(o===3)return this.setRGB(parseInt(i.charAt(0),16)/15,parseInt(i.charAt(1),16)/15,parseInt(i.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(i,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=sr){const r=HF[e.toLowerCase()];return r!==void 0?this.setHex(r,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=oy(e.r),this.g=oy(e.g),this.b=oy(e.b),this}copyLinearToSRGB(e){return this.r=$C(e.r),this.g=$C(e.g),this.b=$C(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=sr){return $r.fromWorkingColorSpace(uo.copy(this),e),Math.round(Es(uo.r*255,0,255))*65536+Math.round(Es(uo.g*255,0,255))*256+Math.round(Es(uo.b*255,0,255))}getHexString(e=sr){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=$r.workingColorSpace){$r.fromWorkingColorSpace(uo.copy(this),t);const r=uo.r,s=uo.g,i=uo.b,o=Math.max(r,s,i),a=Math.min(r,s,i);let l,u;const c=(a+o)/2;if(a===o)l=0,u=0;else{const h=o-a;switch(u=c<=.5?h/(o+a):h/(2-o-a),o){case r:l=(s-i)/h+(s<i?6:0);break;case s:l=(i-r)/h+2;break;case i:l=(r-s)/h+4;break}l/=6}return e.h=l,e.s=u,e.l=c,e}getRGB(e,t=$r.workingColorSpace){return $r.fromWorkingColorSpace(uo.copy(this),t),e.r=uo.r,e.g=uo.g,e.b=uo.b,e}getStyle(e=sr){$r.fromWorkingColorSpace(uo.copy(this),e);const t=uo.r,r=uo.g,s=uo.b;return e!==sr?`color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${s.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(r*255)},${Math.round(s*255)})`}offsetHSL(e,t,r){return this.getHSL(id),this.setHSL(id.h+e,id.s+t,id.l+r)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,r){return this.r=e.r+(t.r-e.r)*r,this.g=e.g+(t.g-e.g)*r,this.b=e.b+(t.b-e.b)*r,this}lerpHSL(e,t){this.getHSL(id),e.getHSL(_b);const r=Vv(id.h,_b.h,t),s=Vv(id.s,_b.s,t),i=Vv(id.l,_b.l,t);return this.setHSL(r,s,i),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,r=this.g,s=this.b,i=e.elements;return this.r=i[0]*t+i[3]*r+i[6]*s,this.g=i[1]*t+i[4]*r+i[7]*s,this.b=i[2]*t+i[5]*r+i[8]*s,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const uo=new Nt;Nt.NAMES=HF;let Pj=0;class Si extends Tl{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Pj++}),this.uuid=Ha(),this.name="",this.type="Material",this.blending=Ip,this.side=ec,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=XS,this.blendDst=qS,this.blendEquation=pd,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Nt(0,0,0),this.blendAlpha=0,this.depthFunc=Zv,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=UI,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=ap,this.stencilZFail=ap,this.stencilZPass=ap,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const r=e[t];if(r===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const s=this[t];if(s===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}s&&s.isColor?s.set(r):s&&s.isVector3&&r&&r.isVector3?s.copy(r):this[t]=r}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const r={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.color&&this.color.isColor&&(r.color=this.color.getHex()),this.roughness!==void 0&&(r.roughness=this.roughness),this.metalness!==void 0&&(r.metalness=this.metalness),this.sheen!==void 0&&(r.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(r.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(r.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(r.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(r.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(r.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(r.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(r.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(r.shininess=this.shininess),this.clearcoat!==void 0&&(r.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(r.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(r.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(r.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,r.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(r.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(r.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(r.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(r.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(r.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(r.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(r.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(r.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(r.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(r.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(r.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(r.lightMap=this.lightMap.toJSON(e).uuid,r.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(r.aoMap=this.aoMap.toJSON(e).uuid,r.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(r.bumpMap=this.bumpMap.toJSON(e).uuid,r.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(r.normalMap=this.normalMap.toJSON(e).uuid,r.normalMapType=this.normalMapType,r.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(r.displacementMap=this.displacementMap.toJSON(e).uuid,r.displacementScale=this.displacementScale,r.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(r.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(r.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(r.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(r.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(r.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(r.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(r.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(r.combine=this.combine)),this.envMapIntensity!==void 0&&(r.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(r.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(r.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(r.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(r.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(r.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(r.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(r.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(r.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(r.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(r.size=this.size),this.shadowSide!==null&&(r.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(r.sizeAttenuation=this.sizeAttenuation),this.blending!==Ip&&(r.blending=this.blending),this.side!==ec&&(r.side=this.side),this.vertexColors===!0&&(r.vertexColors=!0),this.opacity<1&&(r.opacity=this.opacity),this.transparent===!0&&(r.transparent=!0),this.blendSrc!==XS&&(r.blendSrc=this.blendSrc),this.blendDst!==qS&&(r.blendDst=this.blendDst),this.blendEquation!==pd&&(r.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(r.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(r.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(r.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(r.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(r.blendAlpha=this.blendAlpha),this.depthFunc!==Zv&&(r.depthFunc=this.depthFunc),this.depthTest===!1&&(r.depthTest=this.depthTest),this.depthWrite===!1&&(r.depthWrite=this.depthWrite),this.colorWrite===!1&&(r.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(r.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==UI&&(r.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(r.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(r.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==ap&&(r.stencilFail=this.stencilFail),this.stencilZFail!==ap&&(r.stencilZFail=this.stencilZFail),this.stencilZPass!==ap&&(r.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(r.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(r.rotation=this.rotation),this.polygonOffset===!0&&(r.polygonOffset=!0),this.polygonOffsetFactor!==0&&(r.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(r.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(r.linewidth=this.linewidth),this.dashSize!==void 0&&(r.dashSize=this.dashSize),this.gapSize!==void 0&&(r.gapSize=this.gapSize),this.scale!==void 0&&(r.scale=this.scale),this.dithering===!0&&(r.dithering=!0),this.alphaTest>0&&(r.alphaTest=this.alphaTest),this.alphaHash===!0&&(r.alphaHash=!0),this.alphaToCoverage===!0&&(r.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(r.premultipliedAlpha=!0),this.forceSinglePass===!0&&(r.forceSinglePass=!0),this.wireframe===!0&&(r.wireframe=!0),this.wireframeLinewidth>1&&(r.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(r.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(r.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(r.flatShading=!0),this.visible===!1&&(r.visible=!1),this.toneMapped===!1&&(r.toneMapped=!1),this.fog===!1&&(r.fog=!1),Object.keys(this.userData).length>0&&(r.userData=this.userData);function s(i){const o=[];for(const a in i){const l=i[a];delete l.metadata,o.push(l)}return o}if(t){const i=s(e.textures),o=s(e.images);i.length>0&&(r.textures=i),o.length>0&&(r.images=o)}return r}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let r=null;if(t!==null){const s=t.length;r=new Array(s);for(let i=0;i!==s;++i)r[i]=t[i].clone()}return this.clippingPlanes=r,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class Hd extends Si{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Nt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Wx,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Jc=Lj();function Lj(){const n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),r=new Uint32Array(512),s=new Uint32Array(512);for(let l=0;l<256;++l){const u=l-127;u<-27?(r[l]=0,r[l|256]=32768,s[l]=24,s[l|256]=24):u<-14?(r[l]=1024>>-u-14,r[l|256]=1024>>-u-14|32768,s[l]=-u-1,s[l|256]=-u-1):u<=15?(r[l]=u+15<<10,r[l|256]=u+15<<10|32768,s[l]=13,s[l|256]=13):u<128?(r[l]=31744,r[l|256]=64512,s[l]=24,s[l|256]=24):(r[l]=31744,r[l|256]=64512,s[l]=13,s[l|256]=13)}const i=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let l=1;l<1024;++l){let u=l<<13,c=0;for(;(u&8388608)===0;)u<<=1,c-=8388608;u&=-8388609,c+=947912704,i[l]=u|c}for(let l=1024;l<2048;++l)i[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)o[l]=l<<23;o[31]=1199570944,o[32]=2147483648;for(let l=33;l<63;++l)o[l]=2147483648+(l-32<<23);o[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(a[l]=1024);return{floatView:e,uint32View:t,baseTable:r,shiftTable:s,mantissaTable:i,exponentTable:o,offsetTable:a}}function ma(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=Es(n,-65504,65504),Jc.floatView[0]=n;const e=Jc.uint32View[0],t=e>>23&511;return Jc.baseTable[t]+((e&8388607)>>Jc.shiftTable[t])}function kv(n){const e=n>>10;return Jc.uint32View[0]=Jc.mantissaTable[Jc.offsetTable[e]+(n&1023)]+Jc.exponentTable[e],Jc.floatView[0]}const xp={toHalfFloat:ma,fromHalfFloat:kv},Ys=new le,Tb=new rt;class Cr{constructor(e,t,r=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=r,this.usage=ox,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=Di,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,r){e*=this.itemSize,r*=t.itemSize;for(let s=0,i=this.itemSize;s<i;s++)this.array[e+s]=t.array[r+s];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,r=this.count;t<r;t++)Tb.fromBufferAttribute(this,t),Tb.applyMatrix3(e),this.setXY(t,Tb.x,Tb.y);else if(this.itemSize===3)for(let t=0,r=this.count;t<r;t++)Ys.fromBufferAttribute(this,t),Ys.applyMatrix3(e),this.setXYZ(t,Ys.x,Ys.y,Ys.z);return this}applyMatrix4(e){for(let t=0,r=this.count;t<r;t++)Ys.fromBufferAttribute(this,t),Ys.applyMatrix4(e),this.setXYZ(t,Ys.x,Ys.y,Ys.z);return this}applyNormalMatrix(e){for(let t=0,r=this.count;t<r;t++)Ys.fromBufferAttribute(this,t),Ys.applyNormalMatrix(e),this.setXYZ(t,Ys.x,Ys.y,Ys.z);return this}transformDirection(e){for(let t=0,r=this.count;t<r;t++)Ys.fromBufferAttribute(this,t),Ys.transformDirection(e),this.setXYZ(t,Ys.x,Ys.y,Ys.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let r=this.array[e*this.itemSize+t];return this.normalized&&(r=xa(r,this.array)),r}setComponent(e,t,r){return this.normalized&&(r=Vn(r,this.array)),this.array[e*this.itemSize+t]=r,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=xa(t,this.array)),t}setX(e,t){return this.normalized&&(t=Vn(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=xa(t,this.array)),t}setY(e,t){return this.normalized&&(t=Vn(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=xa(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Vn(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=xa(t,this.array)),t}setW(e,t){return this.normalized&&(t=Vn(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,r){return e*=this.itemSize,this.normalized&&(t=Vn(t,this.array),r=Vn(r,this.array)),this.array[e+0]=t,this.array[e+1]=r,this}setXYZ(e,t,r,s){return e*=this.itemSize,this.normalized&&(t=Vn(t,this.array),r=Vn(r,this.array),s=Vn(s,this.array)),this.array[e+0]=t,this.array[e+1]=r,this.array[e+2]=s,this}setXYZW(e,t,r,s,i){return e*=this.itemSize,this.normalized&&(t=Vn(t,this.array),r=Vn(r,this.array),s=Vn(s,this.array),i=Vn(i,this.array)),this.array[e+0]=t,this.array[e+1]=r,this.array[e+2]=s,this.array[e+3]=i,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==ox&&(e.usage=this.usage),e}}class Oj extends Cr{constructor(e,t,r){super(new Int8Array(e),t,r)}}class Fj extends Cr{constructor(e,t,r){super(new Uint8Array(e),t,r)}}class zj extends Cr{constructor(e,t,r){super(new Uint8ClampedArray(e),t,r)}}class Bj extends Cr{constructor(e,t,r){super(new Int16Array(e),t,r)}}class DA extends Cr{constructor(e,t,r){super(new Uint16Array(e),t,r)}}class Uj extends Cr{constructor(e,t,r){super(new Int32Array(e),t,r)}}class $A extends Cr{constructor(e,t,r){super(new Uint32Array(e),t,r)}}class Vj extends Cr{constructor(e,t,r){super(new Uint16Array(e),t,r),this.isFloat16BufferAttribute=!0}getX(e){let t=kv(this.array[e*this.itemSize]);return this.normalized&&(t=xa(t,this.array)),t}setX(e,t){return this.normalized&&(t=Vn(t,this.array)),this.array[e*this.itemSize]=ma(t),this}getY(e){let t=kv(this.array[e*this.itemSize+1]);return this.normalized&&(t=xa(t,this.array)),t}setY(e,t){return this.normalized&&(t=Vn(t,this.array)),this.array[e*this.itemSize+1]=ma(t),this}getZ(e){let t=kv(this.array[e*this.itemSize+2]);return this.normalized&&(t=xa(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Vn(t,this.array)),this.array[e*this.itemSize+2]=ma(t),this}getW(e){let t=kv(this.array[e*this.itemSize+3]);return this.normalized&&(t=xa(t,this.array)),t}setW(e,t){return this.normalized&&(t=Vn(t,this.array)),this.array[e*this.itemSize+3]=ma(t),this}setXY(e,t,r){return e*=this.itemSize,this.normalized&&(t=Vn(t,this.array),r=Vn(r,this.array)),this.array[e+0]=ma(t),this.array[e+1]=ma(r),this}setXYZ(e,t,r,s){return e*=this.itemSize,this.normalized&&(t=Vn(t,this.array),r=Vn(r,this.array),s=Vn(s,this.array)),this.array[e+0]=ma(t),this.array[e+1]=ma(r),this.array[e+2]=ma(s),this}setXYZW(e,t,r,s,i){return e*=this.itemSize,this.normalized&&(t=Vn(t,this.array),r=Vn(r,this.array),s=Vn(s,this.array),i=Vn(i,this.array)),this.array[e+0]=ma(t),this.array[e+1]=ma(r),this.array[e+2]=ma(s),this.array[e+3]=ma(i),this}}class Jt extends Cr{constructor(e,t,r){super(new Float32Array(e),t,r)}}class Wj extends Cr{constructor(e,t,r){super(new Float64Array(e),t,r)}}let Gj=0;const hl=new _n,XC=new dr,Eg=new le,Ba=new jo,cv=new jo,Ai=new le;class zn extends Tl{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Gj++}),this.uuid=Ha(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(VF(e)?$A:DA)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,r=0){this.groups.push({start:e,count:t,materialIndex:r})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const r=this.attributes.normal;if(r!==void 0){const i=new jn().getNormalMatrix(e);r.applyNormalMatrix(i),r.needsUpdate=!0}const s=this.attributes.tangent;return s!==void 0&&(s.transformDirection(e),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return hl.makeRotationFromQuaternion(e),this.applyMatrix4(hl),this}rotateX(e){return hl.makeRotationX(e),this.applyMatrix4(hl),this}rotateY(e){return hl.makeRotationY(e),this.applyMatrix4(hl),this}rotateZ(e){return hl.makeRotationZ(e),this.applyMatrix4(hl),this}translate(e,t,r){return hl.makeTranslation(e,t,r),this.applyMatrix4(hl),this}scale(e,t,r){return hl.makeScale(e,t,r),this.applyMatrix4(hl),this}lookAt(e){return XC.lookAt(e),XC.updateMatrix(),this.applyMatrix4(XC.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Eg).negate(),this.translate(Eg.x,Eg.y,Eg.z),this}setFromPoints(e){const t=[];for(let r=0,s=e.length;r<s;r++){const i=e[r];t.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new Jt(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new jo);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new le(-1/0,-1/0,-1/0),new le(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let r=0,s=t.length;r<s;r++){const i=t[r];Ba.setFromBufferAttribute(i),this.morphTargetsRelative?(Ai.addVectors(this.boundingBox.min,Ba.min),this.boundingBox.expandByPoint(Ai),Ai.addVectors(this.boundingBox.max,Ba.max),this.boundingBox.expandByPoint(Ai)):(this.boundingBox.expandByPoint(Ba.min),this.boundingBox.expandByPoint(Ba.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new So);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new le,1/0);return}if(e){const r=this.boundingSphere.center;if(Ba.setFromBufferAttribute(e),t)for(let i=0,o=t.length;i<o;i++){const a=t[i];cv.setFromBufferAttribute(a),this.morphTargetsRelative?(Ai.addVectors(Ba.min,cv.min),Ba.expandByPoint(Ai),Ai.addVectors(Ba.max,cv.max),Ba.expandByPoint(Ai)):(Ba.expandByPoint(cv.min),Ba.expandByPoint(cv.max))}Ba.getCenter(r);let s=0;for(let i=0,o=e.count;i<o;i++)Ai.fromBufferAttribute(e,i),s=Math.max(s,r.distanceToSquared(Ai));if(t)for(let i=0,o=t.length;i<o;i++){const a=t[i],l=this.morphTargetsRelative;for(let u=0,c=a.count;u<c;u++)Ai.fromBufferAttribute(a,u),l&&(Eg.fromBufferAttribute(e,u),Ai.add(Eg)),s=Math.max(s,r.distanceToSquared(Ai))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const r=e.array,s=t.position.array,i=t.normal.array,o=t.uv.array,a=s.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Cr(new Float32Array(4*a),4));const l=this.getAttribute("tangent").array,u=[],c=[];for(let R=0;R<a;R++)u[R]=new le,c[R]=new le;const h=new le,d=new le,p=new le,g=new rt,w=new rt,y=new rt,x=new le,_=new le;function T(R,P,B){h.fromArray(s,R*3),d.fromArray(s,P*3),p.fromArray(s,B*3),g.fromArray(o,R*2),w.fromArray(o,P*2),y.fromArray(o,B*2),d.sub(h),p.sub(h),w.sub(g),y.sub(g);const Z=1/(w.x*y.y-y.x*w.y);isFinite(Z)&&(x.copy(d).multiplyScalar(y.y).addScaledVector(p,-w.y).multiplyScalar(Z),_.copy(p).multiplyScalar(w.x).addScaledVector(d,-y.x).multiplyScalar(Z),u[R].add(x),u[P].add(x),u[B].add(x),c[R].add(_),c[P].add(_),c[B].add(_))}let E=this.groups;E.length===0&&(E=[{start:0,count:r.length}]);for(let R=0,P=E.length;R<P;++R){const B=E[R],Z=B.start,V=B.count;for(let X=Z,q=Z+V;X<q;X+=3)T(r[X+0],r[X+1],r[X+2])}const N=new le,M=new le,$=new le,L=new le;function k(R){$.fromArray(i,R*3),L.copy($);const P=u[R];N.copy(P),N.sub($.multiplyScalar($.dot(P))).normalize(),M.crossVectors(L,P);const Z=M.dot(c[R])<0?-1:1;l[R*4]=N.x,l[R*4+1]=N.y,l[R*4+2]=N.z,l[R*4+3]=Z}for(let R=0,P=E.length;R<P;++R){const B=E[R],Z=B.start,V=B.count;for(let X=Z,q=Z+V;X<q;X+=3)k(r[X+0]),k(r[X+1]),k(r[X+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let r=this.getAttribute("normal");if(r===void 0)r=new Cr(new Float32Array(t.count*3),3),this.setAttribute("normal",r);else for(let d=0,p=r.count;d<p;d++)r.setXYZ(d,0,0,0);const s=new le,i=new le,o=new le,a=new le,l=new le,u=new le,c=new le,h=new le;if(e)for(let d=0,p=e.count;d<p;d+=3){const g=e.getX(d+0),w=e.getX(d+1),y=e.getX(d+2);s.fromBufferAttribute(t,g),i.fromBufferAttribute(t,w),o.fromBufferAttribute(t,y),c.subVectors(o,i),h.subVectors(s,i),c.cross(h),a.fromBufferAttribute(r,g),l.fromBufferAttribute(r,w),u.fromBufferAttribute(r,y),a.add(c),l.add(c),u.add(c),r.setXYZ(g,a.x,a.y,a.z),r.setXYZ(w,l.x,l.y,l.z),r.setXYZ(y,u.x,u.y,u.z)}else for(let d=0,p=t.count;d<p;d+=3)s.fromBufferAttribute(t,d+0),i.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),c.subVectors(o,i),h.subVectors(s,i),c.cross(h),r.setXYZ(d+0,c.x,c.y,c.z),r.setXYZ(d+1,c.x,c.y,c.z),r.setXYZ(d+2,c.x,c.y,c.z);this.normalizeNormals(),r.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,r=e.count;t<r;t++)Ai.fromBufferAttribute(e,t),Ai.normalize(),e.setXYZ(t,Ai.x,Ai.y,Ai.z)}toNonIndexed(){function e(a,l){const u=a.array,c=a.itemSize,h=a.normalized,d=new u.constructor(l.length*c);let p=0,g=0;for(let w=0,y=l.length;w<y;w++){a.isInterleavedBufferAttribute?p=l[w]*a.data.stride+a.offset:p=l[w]*c;for(let x=0;x<c;x++)d[g++]=u[p++]}return new Cr(d,c,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new zn,r=this.index.array,s=this.attributes;for(const a in s){const l=s[a],u=e(l,r);t.setAttribute(a,u)}const i=this.morphAttributes;for(const a in i){const l=[],u=i[a];for(let c=0,h=u.length;c<h;c++){const d=u[c],p=e(d,r);l.push(p)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const u=o[a];t.addGroup(u.start,u.count,u.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const u in l)l[u]!==void 0&&(e[u]=l[u]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const r=this.attributes;for(const l in r){const u=r[l];e.data.attributes[l]=u.toJSON(e.data)}const s={};let i=!1;for(const l in this.morphAttributes){const u=this.morphAttributes[l],c=[];for(let h=0,d=u.length;h<d;h++){const p=u[h];c.push(p.toJSON(e.data))}c.length>0&&(s[l]=c,i=!0)}i&&(e.data.morphAttributes=s,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const r=e.index;r!==null&&this.setIndex(r.clone(t));const s=e.attributes;for(const u in s){const c=s[u];this.setAttribute(u,c.clone(t))}const i=e.morphAttributes;for(const u in i){const c=[],h=i[u];for(let d=0,p=h.length;d<p;d++)c.push(h[d].clone(t));this.morphAttributes[u]=c}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let u=0,c=o.length;u<c;u++){const h=o[u];this.addGroup(h.start,h.count,h.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const E$=new _n,Yf=new Oy,Eb=new So,C$=new le,Cg=new le,Ig=new le,Ng=new le,qC=new le,Cb=new le,Ib=new rt,Nb=new rt,Ab=new rt,I$=new le,N$=new le,A$=new le,Mb=new le,kb=new le;class zs extends dr{constructor(e=new zn,t=new Hd){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,r=Object.keys(t);if(r.length>0){const s=t[r[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=s.length;i<o;i++){const a=s[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}getVertexPosition(e,t){const r=this.geometry,s=r.attributes.position,i=r.morphAttributes.position,o=r.morphTargetsRelative;t.fromBufferAttribute(s,e);const a=this.morphTargetInfluences;if(i&&a){Cb.set(0,0,0);for(let l=0,u=i.length;l<u;l++){const c=a[l],h=i[l];c!==0&&(qC.fromBufferAttribute(h,e),o?Cb.addScaledVector(qC,c):Cb.addScaledVector(qC.sub(t),c))}t.add(Cb)}return t}raycast(e,t){const r=this.geometry,s=this.material,i=this.matrixWorld;s!==void 0&&(r.boundingSphere===null&&r.computeBoundingSphere(),Eb.copy(r.boundingSphere),Eb.applyMatrix4(i),Yf.copy(e.ray).recast(e.near),!(Eb.containsPoint(Yf.origin)===!1&&(Yf.intersectSphere(Eb,C$)===null||Yf.origin.distanceToSquared(C$)>(e.far-e.near)**2))&&(E$.copy(i).invert(),Yf.copy(e.ray).applyMatrix4(E$),!(r.boundingBox!==null&&Yf.intersectsBox(r.boundingBox)===!1)&&this._computeIntersections(e,t,Yf)))}_computeIntersections(e,t,r){let s;const i=this.geometry,o=this.material,a=i.index,l=i.attributes.position,u=i.attributes.uv,c=i.attributes.uv1,h=i.attributes.normal,d=i.groups,p=i.drawRange;if(a!==null)if(Array.isArray(o))for(let g=0,w=d.length;g<w;g++){const y=d[g],x=o[y.materialIndex],_=Math.max(y.start,p.start),T=Math.min(a.count,Math.min(y.start+y.count,p.start+p.count));for(let E=_,N=T;E<N;E+=3){const M=a.getX(E),$=a.getX(E+1),L=a.getX(E+2);s=Rb(this,x,e,r,u,c,h,M,$,L),s&&(s.faceIndex=Math.floor(E/3),s.face.materialIndex=y.materialIndex,t.push(s))}}else{const g=Math.max(0,p.start),w=Math.min(a.count,p.start+p.count);for(let y=g,x=w;y<x;y+=3){const _=a.getX(y),T=a.getX(y+1),E=a.getX(y+2);s=Rb(this,o,e,r,u,c,h,_,T,E),s&&(s.faceIndex=Math.floor(y/3),t.push(s))}}else if(l!==void 0)if(Array.isArray(o))for(let g=0,w=d.length;g<w;g++){const y=d[g],x=o[y.materialIndex],_=Math.max(y.start,p.start),T=Math.min(l.count,Math.min(y.start+y.count,p.start+p.count));for(let E=_,N=T;E<N;E+=3){const M=E,$=E+1,L=E+2;s=Rb(this,x,e,r,u,c,h,M,$,L),s&&(s.faceIndex=Math.floor(E/3),s.face.materialIndex=y.materialIndex,t.push(s))}}else{const g=Math.max(0,p.start),w=Math.min(l.count,p.start+p.count);for(let y=g,x=w;y<x;y+=3){const _=y,T=y+1,E=y+2;s=Rb(this,o,e,r,u,c,h,_,T,E),s&&(s.faceIndex=Math.floor(y/3),t.push(s))}}}}function Hj(n,e,t,r,s,i,o,a){let l;if(e.side===yi?l=r.intersectTriangle(o,i,s,!0,a):l=r.intersectTriangle(s,i,o,e.side===ec,a),l===null)return null;kb.copy(a),kb.applyMatrix4(n.matrixWorld);const u=t.ray.origin.distanceTo(kb);return u<t.near||u>t.far?null:{distance:u,point:kb.clone(),object:n}}function Rb(n,e,t,r,s,i,o,a,l,u){n.getVertexPosition(a,Cg),n.getVertexPosition(l,Ig),n.getVertexPosition(u,Ng);const c=Hj(n,e,t,r,Cg,Ig,Ng,Mb);if(c){s&&(Ib.fromBufferAttribute(s,a),Nb.fromBufferAttribute(s,l),Ab.fromBufferAttribute(s,u),c.uv=va.getInterpolation(Mb,Cg,Ig,Ng,Ib,Nb,Ab,new rt)),i&&(Ib.fromBufferAttribute(i,a),Nb.fromBufferAttribute(i,l),Ab.fromBufferAttribute(i,u),c.uv1=va.getInterpolation(Mb,Cg,Ig,Ng,Ib,Nb,Ab,new rt),c.uv2=c.uv1),o&&(I$.fromBufferAttribute(o,a),N$.fromBufferAttribute(o,l),A$.fromBufferAttribute(o,u),c.normal=va.getInterpolation(Mb,Cg,Ig,Ng,I$,N$,A$,new le),c.normal.dot(r.direction)>0&&c.normal.multiplyScalar(-1));const h={a,b:l,c:u,normal:new le,materialIndex:0};va.getNormal(Cg,Ig,Ng,h.normal),c.face=h}return c}class jd extends zn{constructor(e=1,t=1,r=1,s=1,i=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:r,widthSegments:s,heightSegments:i,depthSegments:o};const a=this;s=Math.floor(s),i=Math.floor(i),o=Math.floor(o);const l=[],u=[],c=[],h=[];let d=0,p=0;g("z","y","x",-1,-1,r,t,e,o,i,0),g("z","y","x",1,-1,r,t,-e,o,i,1),g("x","z","y",1,1,e,r,t,s,o,2),g("x","z","y",1,-1,e,r,-t,s,o,3),g("x","y","z",1,-1,e,t,r,s,i,4),g("x","y","z",-1,-1,e,t,-r,s,i,5),this.setIndex(l),this.setAttribute("position",new Jt(u,3)),this.setAttribute("normal",new Jt(c,3)),this.setAttribute("uv",new Jt(h,2));function g(w,y,x,_,T,E,N,M,$,L,k){const R=E/$,P=N/L,B=E/2,Z=N/2,V=M/2,X=$+1,q=L+1;let se=0,W=0;const J=new le;for(let K=0;K<q;K++){const G=K*P-Z;for(let Q=0;Q<X;Q++){const ne=Q*R-B;J[w]=ne*_,J[y]=G*T,J[x]=V,u.push(J.x,J.y,J.z),J[w]=0,J[y]=0,J[x]=M>0?1:-1,c.push(J.x,J.y,J.z),h.push(Q/$),h.push(1-K/L),se+=1}}for(let K=0;K<L;K++)for(let G=0;G<$;G++){const Q=d+G+X*K,ne=d+G+X*(K+1),ce=d+(G+1)+X*(K+1),ye=d+(G+1)+X*K;l.push(Q,ne,ye),l.push(ne,ce,ye),W+=6}a.addGroup(p,W,k),p+=W,d+=se}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new jd(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function vy(n){const e={};for(const t in n){e[t]={};for(const r in n[t]){const s=n[t][r];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?s.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][r]=null):e[t][r]=s.clone():Array.isArray(s)?e[t][r]=s.slice():e[t][r]=s}}return e}function zo(n){const e={};for(let t=0;t<n.length;t++){const r=vy(n[t]);for(const s in r)e[s]=r[s]}return e}function jj(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function jF(n){return n.getRenderTarget()===null?n.outputColorSpace:$r.workingColorSpace}const PA={clone:vy,merge:zo};var Xj=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,qj=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ni extends Si{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=Xj,this.fragmentShader=qj,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1,clipCullDistance:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=vy(e.uniforms),this.uniformsGroups=jj(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const s in this.uniforms){const o=this.uniforms[s].value;o&&o.isTexture?t.uniforms[s]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[s]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[s]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[s]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[s]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[s]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[s]={type:"m4",value:o.toArray()}:t.uniforms[s]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const r={};for(const s in this.extensions)this.extensions[s]===!0&&(r[s]=!0);return Object.keys(r).length>0&&(t.extensions=r),t}}class Hx extends dr{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new _n,this.projectionMatrix=new _n,this.projectionMatrixInverse=new _n,this.coordinateSystem=cu}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class fi extends Hx{constructor(e=50,t=1,r=.1,s=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=r,this.far=s,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=yy*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Np*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return yy*2*Math.atan(Math.tan(Np*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,r,s,i,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=r,this.view.offsetY=s,this.view.width=i,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Np*.5*this.fov)/this.zoom,r=2*t,s=this.aspect*r,i=-.5*s;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,u=o.fullHeight;i+=o.offsetX*s/l,t-=o.offsetY*r/u,s*=o.width/l,r*=o.height/u}const a=this.filmOffset;a!==0&&(i+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+s,t,t-r,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Ag=-90,Mg=1;class XF extends dr{constructor(e,t,r){super(),this.type="CubeCamera",this.renderTarget=r,this.coordinateSystem=null,this.activeMipmapLevel=0;const s=new fi(Ag,Mg,e,t);s.layers=this.layers,this.add(s);const i=new fi(Ag,Mg,e,t);i.layers=this.layers,this.add(i);const o=new fi(Ag,Mg,e,t);o.layers=this.layers,this.add(o);const a=new fi(Ag,Mg,e,t);a.layers=this.layers,this.add(a);const l=new fi(Ag,Mg,e,t);l.layers=this.layers,this.add(l);const u=new fi(Ag,Mg,e,t);u.layers=this.layers,this.add(u)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[r,s,i,o,a,l]=t;for(const u of t)this.remove(u);if(e===cu)r.up.set(0,1,0),r.lookAt(1,0,0),s.up.set(0,1,0),s.lookAt(-1,0,0),i.up.set(0,0,-1),i.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===gy)r.up.set(0,-1,0),r.lookAt(-1,0,0),s.up.set(0,-1,0),s.lookAt(1,0,0),i.up.set(0,0,1),i.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const u of t)this.add(u),u.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:r,activeMipmapLevel:s}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[i,o,a,l,u,c]=this.children,h=e.getRenderTarget(),d=e.getActiveCubeFace(),p=e.getActiveMipmapLevel(),g=e.xr.enabled;e.xr.enabled=!1;const w=r.texture.generateMipmaps;r.texture.generateMipmaps=!1,e.setRenderTarget(r,0,s),e.render(t,i),e.setRenderTarget(r,1,s),e.render(t,o),e.setRenderTarget(r,2,s),e.render(t,a),e.setRenderTarget(r,3,s),e.render(t,l),e.setRenderTarget(r,4,s),e.render(t,u),r.texture.generateMipmaps=w,e.setRenderTarget(r,5,s),e.render(t,c),e.setRenderTarget(h,d,p),e.xr.enabled=g,r.texture.needsPMREMUpdate=!0}}class jx extends fs{constructor(e,t,r,s,i,o,a,l,u,c){e=e!==void 0?e:[],t=t!==void 0?t:tc,super(e,t,r,s,i,o,a,l,u,c),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class LA extends Us{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const r={width:e,height:e,depth:1},s=[r,r,r,r,r,r];t.encoding!==void 0&&(Wv("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),t.colorSpace=t.encoding===bd?sr:Go),this.texture=new jx(s,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Lr}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const r={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},s=new jd(5,5,5),i=new ni({name:"CubemapFromEquirect",uniforms:vy(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,side:yi,blending:wo});i.uniforms.tEquirect.value=t;const o=new zs(s,i),a=t.minFilter;return t.minFilter===Ad&&(t.minFilter=Lr),new XF(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,r,s){const i=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,r,s);e.setRenderTarget(i)}}const KC=new le,Kj=new le,Yj=new jn;class dd{constructor(e=new le(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,r,s){return this.normal.set(e,t,r),this.constant=s,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,r){const s=KC.subVectors(r,t).cross(Kj.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(s,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const r=e.delta(KC),s=this.normal.dot(r);if(s===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const i=-(e.start.dot(this.normal)+this.constant)/s;return i<0||i>1?null:t.copy(e.start).addScaledVector(r,i)}intersectsLine(e){const t=this.distanceToPoint(e.start),r=this.distanceToPoint(e.end);return t<0&&r>0||r<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const r=t||Yj.getNormalMatrix(e),s=this.coplanarPoint(KC).applyMatrix4(e),i=this.normal.applyMatrix3(r).normalize();return this.constant=-s.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Zf=new So,Db=new le;class Xx{constructor(e=new dd,t=new dd,r=new dd,s=new dd,i=new dd,o=new dd){this.planes=[e,t,r,s,i,o]}set(e,t,r,s,i,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(r),a[3].copy(s),a[4].copy(i),a[5].copy(o),this}copy(e){const t=this.planes;for(let r=0;r<6;r++)t[r].copy(e.planes[r]);return this}setFromProjectionMatrix(e,t=cu){const r=this.planes,s=e.elements,i=s[0],o=s[1],a=s[2],l=s[3],u=s[4],c=s[5],h=s[6],d=s[7],p=s[8],g=s[9],w=s[10],y=s[11],x=s[12],_=s[13],T=s[14],E=s[15];if(r[0].setComponents(l-i,d-u,y-p,E-x).normalize(),r[1].setComponents(l+i,d+u,y+p,E+x).normalize(),r[2].setComponents(l+o,d+c,y+g,E+_).normalize(),r[3].setComponents(l-o,d-c,y-g,E-_).normalize(),r[4].setComponents(l-a,d-h,y-w,E-T).normalize(),t===cu)r[5].setComponents(l+a,d+h,y+w,E+T).normalize();else if(t===gy)r[5].setComponents(a,h,w,T).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),Zf.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),Zf.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(Zf)}intersectsSprite(e){return Zf.center.set(0,0,0),Zf.radius=.7071067811865476,Zf.applyMatrix4(e.matrixWorld),this.intersectsSphere(Zf)}intersectsSphere(e){const t=this.planes,r=e.center,s=-e.radius;for(let i=0;i<6;i++)if(t[i].distanceToPoint(r)<s)return!1;return!0}intersectsBox(e){const t=this.planes;for(let r=0;r<6;r++){const s=t[r];if(Db.x=s.normal.x>0?e.max.x:e.min.x,Db.y=s.normal.y>0?e.max.y:e.min.y,Db.z=s.normal.z>0?e.max.z:e.min.z,s.distanceToPoint(Db)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let r=0;r<6;r++)if(t[r].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function qF(){let n=null,e=!1,t=null,r=null;function s(i,o){t(i,o),r=n.requestAnimationFrame(s)}return{start:function(){e!==!0&&t!==null&&(r=n.requestAnimationFrame(s),e=!0)},stop:function(){n.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(i){t=i},setContext:function(i){n=i}}}function Zj(n,e){const t=e.isWebGL2,r=new WeakMap;function s(u,c){const h=u.array,d=u.usage,p=h.byteLength,g=n.createBuffer();n.bindBuffer(c,g),n.bufferData(c,h,d),u.onUploadCallback();let w;if(h instanceof Float32Array)w=n.FLOAT;else if(h instanceof Uint16Array)if(u.isFloat16BufferAttribute)if(t)w=n.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else w=n.UNSIGNED_SHORT;else if(h instanceof Int16Array)w=n.SHORT;else if(h instanceof Uint32Array)w=n.UNSIGNED_INT;else if(h instanceof Int32Array)w=n.INT;else if(h instanceof Int8Array)w=n.BYTE;else if(h instanceof Uint8Array)w=n.UNSIGNED_BYTE;else if(h instanceof Uint8ClampedArray)w=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);return{buffer:g,type:w,bytesPerElement:h.BYTES_PER_ELEMENT,version:u.version,size:p}}function i(u,c,h){const d=c.array,p=c._updateRange,g=c.updateRanges;if(n.bindBuffer(h,u),p.count===-1&&g.length===0&&n.bufferSubData(h,0,d),g.length!==0){for(let w=0,y=g.length;w<y;w++){const x=g[w];t?n.bufferSubData(h,x.start*d.BYTES_PER_ELEMENT,d,x.start,x.count):n.bufferSubData(h,x.start*d.BYTES_PER_ELEMENT,d.subarray(x.start,x.start+x.count))}c.clearUpdateRanges()}p.count!==-1&&(t?n.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d,p.offset,p.count):n.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d.subarray(p.offset,p.offset+p.count)),p.count=-1),c.onUploadCallback()}function o(u){return u.isInterleavedBufferAttribute&&(u=u.data),r.get(u)}function a(u){u.isInterleavedBufferAttribute&&(u=u.data);const c=r.get(u);c&&(n.deleteBuffer(c.buffer),r.delete(u))}function l(u,c){if(u.isGLBufferAttribute){const d=r.get(u);(!d||d.version<u.version)&&r.set(u,{buffer:u.buffer,type:u.type,bytesPerElement:u.elementSize,version:u.version});return}u.isInterleavedBufferAttribute&&(u=u.data);const h=r.get(u);if(h===void 0)r.set(u,s(u,c));else if(h.version<u.version){if(h.size!==u.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");i(h.buffer,u,c),h.version=u.version}}return{get:o,remove:a,update:l}}class qx extends zn{constructor(e=1,t=1,r=1,s=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:r,heightSegments:s};const i=e/2,o=t/2,a=Math.floor(r),l=Math.floor(s),u=a+1,c=l+1,h=e/a,d=t/l,p=[],g=[],w=[],y=[];for(let x=0;x<c;x++){const _=x*d-o;for(let T=0;T<u;T++){const E=T*h-i;g.push(E,-_,0),w.push(0,0,1),y.push(T/a),y.push(1-x/l)}}for(let x=0;x<l;x++)for(let _=0;_<a;_++){const T=_+u*x,E=_+u*(x+1),N=_+1+u*(x+1),M=_+1+u*x;p.push(T,E,M),p.push(E,N,M)}this.setIndex(p),this.setAttribute("position",new Jt(g,3)),this.setAttribute("normal",new Jt(w,3)),this.setAttribute("uv",new Jt(y,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new qx(e.width,e.height,e.widthSegments,e.heightSegments)}}var Jj=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,Qj=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,eX=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,tX=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,nX=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,rX=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,sX=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,iX=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,oX=`#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,aX=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,lX=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,uX=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,cX=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,hX=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,dX=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,fX=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,pX=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,mX=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,gX=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,yX=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,vX=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,xX=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,wX=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,bX=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,SX=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,_X=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,TX=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,EX=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,CX=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,IX=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,NX="gl_FragColor = linearToOutputTexel( gl_FragColor );",AX=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,MX=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,kX=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,RX=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,DX=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,$X=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,PX=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,LX=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,OX=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,FX=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,zX=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,BX=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,UX=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,VX=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,WX=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,GX=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,HX=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,jX=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,XX=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,qX=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,KX=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,YX=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,ZX=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,JX=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,QX=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,eq=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,tq=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,nq=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,rq=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,sq=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,iq=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,oq=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,aq=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,lq=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,uq=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,cq=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,hq=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,dq=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,fq=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,pq=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,mq=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,gq=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,yq=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,vq=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,xq=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,wq=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,bq=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,Sq=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,_q=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,Tq=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,Eq=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,Cq=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,Iq=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Nq=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Aq=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Mq=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,kq=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Rq=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Dq=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,$q=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Pq=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,Lq=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Oq=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Fq=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,zq=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Bq=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Uq=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Vq=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Wq=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Gq=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color *= toneMappingExposure;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Hq=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,jq=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,Xq=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,qq=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,Kq=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,Yq=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Zq=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,Jq=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Qq=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,e7=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,t7=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,n7=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,r7=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,s7=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,i7=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,o7=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,a7=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,l7=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,u7=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,c7=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,h7=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,d7=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,f7=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,p7=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,m7=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,g7=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,y7=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,v7=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,x7=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,w7=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,b7=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,S7=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,_7=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,T7=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,E7=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,C7=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,I7=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,N7=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,A7=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,M7=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Un={alphahash_fragment:Jj,alphahash_pars_fragment:Qj,alphamap_fragment:eX,alphamap_pars_fragment:tX,alphatest_fragment:nX,alphatest_pars_fragment:rX,aomap_fragment:sX,aomap_pars_fragment:iX,batching_pars_vertex:oX,batching_vertex:aX,begin_vertex:lX,beginnormal_vertex:uX,bsdfs:cX,iridescence_fragment:hX,bumpmap_pars_fragment:dX,clipping_planes_fragment:fX,clipping_planes_pars_fragment:pX,clipping_planes_pars_vertex:mX,clipping_planes_vertex:gX,color_fragment:yX,color_pars_fragment:vX,color_pars_vertex:xX,color_vertex:wX,common:bX,cube_uv_reflection_fragment:SX,defaultnormal_vertex:_X,displacementmap_pars_vertex:TX,displacementmap_vertex:EX,emissivemap_fragment:CX,emissivemap_pars_fragment:IX,colorspace_fragment:NX,colorspace_pars_fragment:AX,envmap_fragment:MX,envmap_common_pars_fragment:kX,envmap_pars_fragment:RX,envmap_pars_vertex:DX,envmap_physical_pars_fragment:HX,envmap_vertex:$X,fog_vertex:PX,fog_pars_vertex:LX,fog_fragment:OX,fog_pars_fragment:FX,gradientmap_pars_fragment:zX,lightmap_fragment:BX,lightmap_pars_fragment:UX,lights_lambert_fragment:VX,lights_lambert_pars_fragment:WX,lights_pars_begin:GX,lights_toon_fragment:jX,lights_toon_pars_fragment:XX,lights_phong_fragment:qX,lights_phong_pars_fragment:KX,lights_physical_fragment:YX,lights_physical_pars_fragment:ZX,lights_fragment_begin:JX,lights_fragment_maps:QX,lights_fragment_end:eq,logdepthbuf_fragment:tq,logdepthbuf_pars_fragment:nq,logdepthbuf_pars_vertex:rq,logdepthbuf_vertex:sq,map_fragment:iq,map_pars_fragment:oq,map_particle_fragment:aq,map_particle_pars_fragment:lq,metalnessmap_fragment:uq,metalnessmap_pars_fragment:cq,morphcolor_vertex:hq,morphnormal_vertex:dq,morphtarget_pars_vertex:fq,morphtarget_vertex:pq,normal_fragment_begin:mq,normal_fragment_maps:gq,normal_pars_fragment:yq,normal_pars_vertex:vq,normal_vertex:xq,normalmap_pars_fragment:wq,clearcoat_normal_fragment_begin:bq,clearcoat_normal_fragment_maps:Sq,clearcoat_pars_fragment:_q,iridescence_pars_fragment:Tq,opaque_fragment:Eq,packing:Cq,premultiplied_alpha_fragment:Iq,project_vertex:Nq,dithering_fragment:Aq,dithering_pars_fragment:Mq,roughnessmap_fragment:kq,roughnessmap_pars_fragment:Rq,shadowmap_pars_fragment:Dq,shadowmap_pars_vertex:$q,shadowmap_vertex:Pq,shadowmask_pars_fragment:Lq,skinbase_vertex:Oq,skinning_pars_vertex:Fq,skinning_vertex:zq,skinnormal_vertex:Bq,specularmap_fragment:Uq,specularmap_pars_fragment:Vq,tonemapping_fragment:Wq,tonemapping_pars_fragment:Gq,transmission_fragment:Hq,transmission_pars_fragment:jq,uv_pars_fragment:Xq,uv_pars_vertex:qq,uv_vertex:Kq,worldpos_vertex:Yq,background_vert:Zq,background_frag:Jq,backgroundCube_vert:Qq,backgroundCube_frag:e7,cube_vert:t7,cube_frag:n7,depth_vert:r7,depth_frag:s7,distanceRGBA_vert:i7,distanceRGBA_frag:o7,equirect_vert:a7,equirect_frag:l7,linedashed_vert:u7,linedashed_frag:c7,meshbasic_vert:h7,meshbasic_frag:d7,meshlambert_vert:f7,meshlambert_frag:p7,meshmatcap_vert:m7,meshmatcap_frag:g7,meshnormal_vert:y7,meshnormal_frag:v7,meshphong_vert:x7,meshphong_frag:w7,meshphysical_vert:b7,meshphysical_frag:S7,meshtoon_vert:_7,meshtoon_frag:T7,points_vert:E7,points_frag:C7,shadow_vert:I7,shadow_frag:N7,sprite_vert:A7,sprite_frag:M7},Rt={common:{diffuse:{value:new Nt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new jn},alphaMap:{value:null},alphaMapTransform:{value:new jn},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new jn}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new jn}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new jn}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new jn},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new jn},normalScale:{value:new rt(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new jn},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new jn}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new jn}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new jn}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Nt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Nt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new jn},alphaTest:{value:0},uvTransform:{value:new jn}},sprite:{diffuse:{value:new Nt(16777215)},opacity:{value:1},center:{value:new rt(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new jn},alphaMap:{value:null},alphaMapTransform:{value:new jn},alphaTest:{value:0}}},ou={basic:{uniforms:zo([Rt.common,Rt.specularmap,Rt.envmap,Rt.aomap,Rt.lightmap,Rt.fog]),vertexShader:Un.meshbasic_vert,fragmentShader:Un.meshbasic_frag},lambert:{uniforms:zo([Rt.common,Rt.specularmap,Rt.envmap,Rt.aomap,Rt.lightmap,Rt.emissivemap,Rt.bumpmap,Rt.normalmap,Rt.displacementmap,Rt.fog,Rt.lights,{emissive:{value:new Nt(0)}}]),vertexShader:Un.meshlambert_vert,fragmentShader:Un.meshlambert_frag},phong:{uniforms:zo([Rt.common,Rt.specularmap,Rt.envmap,Rt.aomap,Rt.lightmap,Rt.emissivemap,Rt.bumpmap,Rt.normalmap,Rt.displacementmap,Rt.fog,Rt.lights,{emissive:{value:new Nt(0)},specular:{value:new Nt(1118481)},shininess:{value:30}}]),vertexShader:Un.meshphong_vert,fragmentShader:Un.meshphong_frag},standard:{uniforms:zo([Rt.common,Rt.envmap,Rt.aomap,Rt.lightmap,Rt.emissivemap,Rt.bumpmap,Rt.normalmap,Rt.displacementmap,Rt.roughnessmap,Rt.metalnessmap,Rt.fog,Rt.lights,{emissive:{value:new Nt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Un.meshphysical_vert,fragmentShader:Un.meshphysical_frag},toon:{uniforms:zo([Rt.common,Rt.aomap,Rt.lightmap,Rt.emissivemap,Rt.bumpmap,Rt.normalmap,Rt.displacementmap,Rt.gradientmap,Rt.fog,Rt.lights,{emissive:{value:new Nt(0)}}]),vertexShader:Un.meshtoon_vert,fragmentShader:Un.meshtoon_frag},matcap:{uniforms:zo([Rt.common,Rt.bumpmap,Rt.normalmap,Rt.displacementmap,Rt.fog,{matcap:{value:null}}]),vertexShader:Un.meshmatcap_vert,fragmentShader:Un.meshmatcap_frag},points:{uniforms:zo([Rt.points,Rt.fog]),vertexShader:Un.points_vert,fragmentShader:Un.points_frag},dashed:{uniforms:zo([Rt.common,Rt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Un.linedashed_vert,fragmentShader:Un.linedashed_frag},depth:{uniforms:zo([Rt.common,Rt.displacementmap]),vertexShader:Un.depth_vert,fragmentShader:Un.depth_frag},normal:{uniforms:zo([Rt.common,Rt.bumpmap,Rt.normalmap,Rt.displacementmap,{opacity:{value:1}}]),vertexShader:Un.meshnormal_vert,fragmentShader:Un.meshnormal_frag},sprite:{uniforms:zo([Rt.sprite,Rt.fog]),vertexShader:Un.sprite_vert,fragmentShader:Un.sprite_frag},background:{uniforms:{uvTransform:{value:new jn},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Un.background_vert,fragmentShader:Un.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:Un.backgroundCube_vert,fragmentShader:Un.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Un.cube_vert,fragmentShader:Un.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Un.equirect_vert,fragmentShader:Un.equirect_frag},distanceRGBA:{uniforms:zo([Rt.common,Rt.displacementmap,{referencePosition:{value:new le},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Un.distanceRGBA_vert,fragmentShader:Un.distanceRGBA_frag},shadow:{uniforms:zo([Rt.lights,Rt.fog,{color:{value:new Nt(0)},opacity:{value:1}}]),vertexShader:Un.shadow_vert,fragmentShader:Un.shadow_frag}};ou.physical={uniforms:zo([ou.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new jn},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new jn},clearcoatNormalScale:{value:new rt(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new jn},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new jn},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new jn},sheen:{value:0},sheenColor:{value:new Nt(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new jn},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new jn},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new jn},transmissionSamplerSize:{value:new rt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new jn},attenuationDistance:{value:0},attenuationColor:{value:new Nt(0)},specularColor:{value:new Nt(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new jn},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new jn},anisotropyVector:{value:new rt},anisotropyMap:{value:null},anisotropyMapTransform:{value:new jn}}]),vertexShader:Un.meshphysical_vert,fragmentShader:Un.meshphysical_frag};const $b={r:0,b:0,g:0};function k7(n,e,t,r,s,i,o){const a=new Nt(0);let l=i===!0?0:1,u,c,h=null,d=0,p=null;function g(y,x){let _=!1,T=x.isScene===!0?x.background:null;T&&T.isTexture&&(T=(x.backgroundBlurriness>0?t:e).get(T)),T===null?w(a,l):T&&T.isColor&&(w(T,1),_=!0);const E=n.xr.getEnvironmentBlendMode();E==="additive"?r.buffers.color.setClear(0,0,0,1,o):E==="alpha-blend"&&r.buffers.color.setClear(0,0,0,0,o),(n.autoClear||_)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),T&&(T.isCubeTexture||T.mapping===Ly)?(c===void 0&&(c=new zs(new jd(1,1,1),new ni({name:"BackgroundCubeMaterial",uniforms:vy(ou.backgroundCube.uniforms),vertexShader:ou.backgroundCube.vertexShader,fragmentShader:ou.backgroundCube.fragmentShader,side:yi,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(N,M,$){this.matrixWorld.copyPosition($.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),s.update(c)),c.material.uniforms.envMap.value=T,c.material.uniforms.flipEnvMap.value=T.isCubeTexture&&T.isRenderTargetTexture===!1?-1:1,c.material.uniforms.backgroundBlurriness.value=x.backgroundBlurriness,c.material.uniforms.backgroundIntensity.value=x.backgroundIntensity,c.material.toneMapped=$r.getTransfer(T.colorSpace)!==Zr,(h!==T||d!==T.version||p!==n.toneMapping)&&(c.material.needsUpdate=!0,h=T,d=T.version,p=n.toneMapping),c.layers.enableAll(),y.unshift(c,c.geometry,c.material,0,0,null)):T&&T.isTexture&&(u===void 0&&(u=new zs(new qx(2,2),new ni({name:"BackgroundMaterial",uniforms:vy(ou.background.uniforms),vertexShader:ou.background.vertexShader,fragmentShader:ou.background.fragmentShader,side:ec,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),Object.defineProperty(u.material,"map",{get:function(){return this.uniforms.t2D.value}}),s.update(u)),u.material.uniforms.t2D.value=T,u.material.uniforms.backgroundIntensity.value=x.backgroundIntensity,u.material.toneMapped=$r.getTransfer(T.colorSpace)!==Zr,T.matrixAutoUpdate===!0&&T.updateMatrix(),u.material.uniforms.uvTransform.value.copy(T.matrix),(h!==T||d!==T.version||p!==n.toneMapping)&&(u.material.needsUpdate=!0,h=T,d=T.version,p=n.toneMapping),u.layers.enableAll(),y.unshift(u,u.geometry,u.material,0,0,null))}function w(y,x){y.getRGB($b,jF(n)),r.buffers.color.setClear($b.r,$b.g,$b.b,x,o)}return{getClearColor:function(){return a},setClearColor:function(y,x=1){a.set(y),l=x,w(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(y){l=y,w(a,l)},render:g}}function R7(n,e,t,r){const s=n.getParameter(n.MAX_VERTEX_ATTRIBS),i=r.isWebGL2?null:e.get("OES_vertex_array_object"),o=r.isWebGL2||i!==null,a={},l=y(null);let u=l,c=!1;function h(V,X,q,se,W){let J=!1;if(o){const K=w(se,q,X);u!==K&&(u=K,p(u.object)),J=x(V,se,q,W),J&&_(V,se,q,W)}else{const K=X.wireframe===!0;(u.geometry!==se.id||u.program!==q.id||u.wireframe!==K)&&(u.geometry=se.id,u.program=q.id,u.wireframe=K,J=!0)}W!==null&&t.update(W,n.ELEMENT_ARRAY_BUFFER),(J||c)&&(c=!1,L(V,X,q,se),W!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t.get(W).buffer))}function d(){return r.isWebGL2?n.createVertexArray():i.createVertexArrayOES()}function p(V){return r.isWebGL2?n.bindVertexArray(V):i.bindVertexArrayOES(V)}function g(V){return r.isWebGL2?n.deleteVertexArray(V):i.deleteVertexArrayOES(V)}function w(V,X,q){const se=q.wireframe===!0;let W=a[V.id];W===void 0&&(W={},a[V.id]=W);let J=W[X.id];J===void 0&&(J={},W[X.id]=J);let K=J[se];return K===void 0&&(K=y(d()),J[se]=K),K}function y(V){const X=[],q=[],se=[];for(let W=0;W<s;W++)X[W]=0,q[W]=0,se[W]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:X,enabledAttributes:q,attributeDivisors:se,object:V,attributes:{},index:null}}function x(V,X,q,se){const W=u.attributes,J=X.attributes;let K=0;const G=q.getAttributes();for(const Q in G)if(G[Q].location>=0){const ce=W[Q];let ye=J[Q];if(ye===void 0&&(Q==="instanceMatrix"&&V.instanceMatrix&&(ye=V.instanceMatrix),Q==="instanceColor"&&V.instanceColor&&(ye=V.instanceColor)),ce===void 0||ce.attribute!==ye||ye&&ce.data!==ye.data)return!0;K++}return u.attributesNum!==K||u.index!==se}function _(V,X,q,se){const W={},J=X.attributes;let K=0;const G=q.getAttributes();for(const Q in G)if(G[Q].location>=0){let ce=J[Q];ce===void 0&&(Q==="instanceMatrix"&&V.instanceMatrix&&(ce=V.instanceMatrix),Q==="instanceColor"&&V.instanceColor&&(ce=V.instanceColor));const ye={};ye.attribute=ce,ce&&ce.data&&(ye.data=ce.data),W[Q]=ye,K++}u.attributes=W,u.attributesNum=K,u.index=se}function T(){const V=u.newAttributes;for(let X=0,q=V.length;X<q;X++)V[X]=0}function E(V){N(V,0)}function N(V,X){const q=u.newAttributes,se=u.enabledAttributes,W=u.attributeDivisors;q[V]=1,se[V]===0&&(n.enableVertexAttribArray(V),se[V]=1),W[V]!==X&&((r.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[r.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](V,X),W[V]=X)}function M(){const V=u.newAttributes,X=u.enabledAttributes;for(let q=0,se=X.length;q<se;q++)X[q]!==V[q]&&(n.disableVertexAttribArray(q),X[q]=0)}function $(V,X,q,se,W,J,K){K===!0?n.vertexAttribIPointer(V,X,q,W,J):n.vertexAttribPointer(V,X,q,se,W,J)}function L(V,X,q,se){if(r.isWebGL2===!1&&(V.isInstancedMesh||se.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;T();const W=se.attributes,J=q.getAttributes(),K=X.defaultAttributeValues;for(const G in J){const Q=J[G];if(Q.location>=0){let ne=W[G];if(ne===void 0&&(G==="instanceMatrix"&&V.instanceMatrix&&(ne=V.instanceMatrix),G==="instanceColor"&&V.instanceColor&&(ne=V.instanceColor)),ne!==void 0){const ce=ne.normalized,ye=ne.itemSize,Se=t.get(ne);if(Se===void 0)continue;const Re=Se.buffer,Oe=Se.type,Ke=Se.bytesPerElement,st=r.isWebGL2===!0&&(Oe===n.INT||Oe===n.UNSIGNED_INT||ne.gpuType===xA);if(ne.isInterleavedBufferAttribute){const ct=ne.data,fe=ct.stride,nt=ne.offset;if(ct.isInstancedInterleavedBuffer){for(let Xe=0;Xe<Q.locationSize;Xe++)N(Q.location+Xe,ct.meshPerAttribute);V.isInstancedMesh!==!0&&se._maxInstanceCount===void 0&&(se._maxInstanceCount=ct.meshPerAttribute*ct.count)}else for(let Xe=0;Xe<Q.locationSize;Xe++)E(Q.location+Xe);n.bindBuffer(n.ARRAY_BUFFER,Re);for(let Xe=0;Xe<Q.locationSize;Xe++)$(Q.location+Xe,ye/Q.locationSize,Oe,ce,fe*Ke,(nt+ye/Q.locationSize*Xe)*Ke,st)}else{if(ne.isInstancedBufferAttribute){for(let ct=0;ct<Q.locationSize;ct++)N(Q.location+ct,ne.meshPerAttribute);V.isInstancedMesh!==!0&&se._maxInstanceCount===void 0&&(se._maxInstanceCount=ne.meshPerAttribute*ne.count)}else for(let ct=0;ct<Q.locationSize;ct++)E(Q.location+ct);n.bindBuffer(n.ARRAY_BUFFER,Re);for(let ct=0;ct<Q.locationSize;ct++)$(Q.location+ct,ye/Q.locationSize,Oe,ce,ye*Ke,ye/Q.locationSize*ct*Ke,st)}}else if(K!==void 0){const ce=K[G];if(ce!==void 0)switch(ce.length){case 2:n.vertexAttrib2fv(Q.location,ce);break;case 3:n.vertexAttrib3fv(Q.location,ce);break;case 4:n.vertexAttrib4fv(Q.location,ce);break;default:n.vertexAttrib1fv(Q.location,ce)}}}}M()}function k(){B();for(const V in a){const X=a[V];for(const q in X){const se=X[q];for(const W in se)g(se[W].object),delete se[W];delete X[q]}delete a[V]}}function R(V){if(a[V.id]===void 0)return;const X=a[V.id];for(const q in X){const se=X[q];for(const W in se)g(se[W].object),delete se[W];delete X[q]}delete a[V.id]}function P(V){for(const X in a){const q=a[X];if(q[V.id]===void 0)continue;const se=q[V.id];for(const W in se)g(se[W].object),delete se[W];delete q[V.id]}}function B(){Z(),c=!0,u!==l&&(u=l,p(u.object))}function Z(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:B,resetDefaultState:Z,dispose:k,releaseStatesOfGeometry:R,releaseStatesOfProgram:P,initAttributes:T,enableAttribute:E,disableUnusedAttributes:M}}function D7(n,e,t,r){const s=r.isWebGL2;let i;function o(c){i=c}function a(c,h){n.drawArrays(i,c,h),t.update(h,i,1)}function l(c,h,d){if(d===0)return;let p,g;if(s)p=n,g="drawArraysInstanced";else if(p=e.get("ANGLE_instanced_arrays"),g="drawArraysInstancedANGLE",p===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}p[g](i,c,h,d),t.update(h,i,d)}function u(c,h,d){if(d===0)return;const p=e.get("WEBGL_multi_draw");if(p===null)for(let g=0;g<d;g++)this.render(c[g],h[g]);else{p.multiDrawArraysWEBGL(i,c,0,h,0,d);let g=0;for(let w=0;w<d;w++)g+=h[w];t.update(g,i,1)}}this.setMode=o,this.render=a,this.renderInstances=l,this.renderMultiDraw=u}function $7(n,e,t){let r;function s(){if(r!==void 0)return r;if(e.has("EXT_texture_filter_anisotropic")===!0){const $=e.get("EXT_texture_filter_anisotropic");r=n.getParameter($.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r}function i($){if($==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";$="mediump"}return $==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&n.constructor.name==="WebGL2RenderingContext";let a=t.precision!==void 0?t.precision:"highp";const l=i(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const u=o||e.has("WEBGL_draw_buffers"),c=t.logarithmicDepthBuffer===!0,h=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),d=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),p=n.getParameter(n.MAX_TEXTURE_SIZE),g=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),w=n.getParameter(n.MAX_VERTEX_ATTRIBS),y=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),x=n.getParameter(n.MAX_VARYING_VECTORS),_=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),T=d>0,E=o||e.has("OES_texture_float"),N=T&&E,M=o?n.getParameter(n.MAX_SAMPLES):0;return{isWebGL2:o,drawBuffers:u,getMaxAnisotropy:s,getMaxPrecision:i,precision:a,logarithmicDepthBuffer:c,maxTextures:h,maxVertexTextures:d,maxTextureSize:p,maxCubemapSize:g,maxAttributes:w,maxVertexUniforms:y,maxVaryings:x,maxFragmentUniforms:_,vertexTextures:T,floatFragmentTextures:E,floatVertexTextures:N,maxSamples:M}}function P7(n){const e=this;let t=null,r=0,s=!1,i=!1;const o=new dd,a=new jn,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d){const p=h.length!==0||d||r!==0||s;return s=d,r=h.length,p},this.beginShadows=function(){i=!0,c(null)},this.endShadows=function(){i=!1},this.setGlobalState=function(h,d){t=c(h,d,0)},this.setState=function(h,d,p){const g=h.clippingPlanes,w=h.clipIntersection,y=h.clipShadows,x=n.get(h);if(!s||g===null||g.length===0||i&&!y)i?c(null):u();else{const _=i?0:r,T=_*4;let E=x.clippingState||null;l.value=E,E=c(g,d,T,p);for(let N=0;N!==T;++N)E[N]=t[N];x.clippingState=E,this.numIntersection=w?this.numPlanes:0,this.numPlanes+=_}};function u(){l.value!==t&&(l.value=t,l.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function c(h,d,p,g){const w=h!==null?h.length:0;let y=null;if(w!==0){if(y=l.value,g!==!0||y===null){const x=p+w*4,_=d.matrixWorldInverse;a.getNormalMatrix(_),(y===null||y.length<x)&&(y=new Float32Array(x));for(let T=0,E=p;T!==w;++T,E+=4)o.copy(h[T]).applyMatrix4(_,a),o.normal.toArray(y,E),y[E+3]=o.constant}l.value=y,l.needsUpdate=!0}return e.numPlanes=w,e.numIntersection=0,y}}function L7(n){let e=new WeakMap;function t(o,a){return a===my?o.mapping=tc:a===Jv&&(o.mapping=Nd),o}function r(o){if(o&&o.isTexture){const a=o.mapping;if(a===my||a===Jv)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const u=new LA(l.height/2);return u.fromEquirectangularTexture(n,o),e.set(o,u),o.addEventListener("dispose",s),t(u.texture,o.mapping)}else return null}}return o}function s(o){const a=o.target;a.removeEventListener("dispose",s);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function i(){e=new WeakMap}return{get:r,dispose:i}}class zy extends Hx{constructor(e=-1,t=1,r=1,s=-1,i=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=r,this.bottom=s,this.near=i,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,r,s,i,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=r,this.view.offsetY=s,this.view.width=i,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),r=(this.right+this.left)/2,s=(this.top+this.bottom)/2;let i=r-e,o=r+e,a=s+t,l=s-t;if(this.view!==null&&this.view.enabled){const u=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=u*this.view.offsetX,o=i+u*this.view.width,a-=c*this.view.offsetY,l=a-c*this.view.height}this.projectionMatrix.makeOrthographic(i,o,a,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const ty=4,M$=[.125,.215,.35,.446,.526,.582],cp=20,YC=new zy,k$=new Nt;let ZC=null,JC=0,QC=0;const lp=(1+Math.sqrt(5))/2,kg=1/lp,R$=[new le(1,1,1),new le(-1,1,1),new le(1,1,-1),new le(-1,1,-1),new le(0,lp,kg),new le(0,lp,-kg),new le(kg,0,lp),new le(-kg,0,lp),new le(lp,kg,0),new le(-lp,kg,0)];class GI{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,r=.1,s=100){ZC=this._renderer.getRenderTarget(),JC=this._renderer.getActiveCubeFace(),QC=this._renderer.getActiveMipmapLevel(),this._setSize(256);const i=this._allocateTargets();return i.depthBuffer=!0,this._sceneToCubeUV(e,r,s,i),t>0&&this._blur(i,0,0,t),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=P$(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=$$(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(ZC,JC,QC),e.scissorTest=!1,Pb(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===tc||e.mapping===Nd?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),ZC=this._renderer.getRenderTarget(),JC=this._renderer.getActiveCubeFace(),QC=this._renderer.getActiveMipmapLevel();const r=t||this._allocateTargets();return this._textureToCubeUV(e,r),this._applyPMREM(r),this._cleanup(r),r}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,r={magFilter:Lr,minFilter:Lr,generateMipmaps:!1,type:vo,format:go,colorSpace:xl,depthBuffer:!1},s=D$(e,t,r);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=D$(e,t,r);const{_lodMax:i}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=O7(i)),this._blurMaterial=F7(i,e,t)}return s}_compileMaterial(e){const t=new zs(this._lodPlanes[0],e);this._renderer.compile(t,YC)}_sceneToCubeUV(e,t,r,s){const a=new fi(90,1,t,r),l=[1,-1,1,1,1,1],u=[1,1,1,-1,-1,-1],c=this._renderer,h=c.autoClear,d=c.toneMapping;c.getClearColor(k$),c.toneMapping=Hu,c.autoClear=!1;const p=new Hd({name:"PMREM.Background",side:yi,depthWrite:!1,depthTest:!1}),g=new zs(new jd,p);let w=!1;const y=e.background;y?y.isColor&&(p.color.copy(y),e.background=null,w=!0):(p.color.copy(k$),w=!0);for(let x=0;x<6;x++){const _=x%3;_===0?(a.up.set(0,l[x],0),a.lookAt(u[x],0,0)):_===1?(a.up.set(0,0,l[x]),a.lookAt(0,u[x],0)):(a.up.set(0,l[x],0),a.lookAt(0,0,u[x]));const T=this._cubeSize;Pb(s,_*T,x>2?T:0,T,T),c.setRenderTarget(s),w&&c.render(g,a),c.render(e,a)}g.geometry.dispose(),g.material.dispose(),c.toneMapping=d,c.autoClear=h,e.background=y}_textureToCubeUV(e,t){const r=this._renderer,s=e.mapping===tc||e.mapping===Nd;s?(this._cubemapMaterial===null&&(this._cubemapMaterial=P$()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=$$());const i=s?this._cubemapMaterial:this._equirectMaterial,o=new zs(this._lodPlanes[0],i),a=i.uniforms;a.envMap.value=e;const l=this._cubeSize;Pb(t,0,0,3*l,2*l),r.setRenderTarget(t),r.render(o,YC)}_applyPMREM(e){const t=this._renderer,r=t.autoClear;t.autoClear=!1;for(let s=1;s<this._lodPlanes.length;s++){const i=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),o=R$[(s-1)%R$.length];this._blur(e,s-1,s,i,o)}t.autoClear=r}_blur(e,t,r,s,i){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,r,s,"latitudinal",i),this._halfBlur(o,e,r,r,s,"longitudinal",i)}_halfBlur(e,t,r,s,i,o,a){const l=this._renderer,u=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const c=3,h=new zs(this._lodPlanes[s],u),d=u.uniforms,p=this._sizeLods[r]-1,g=isFinite(i)?Math.PI/(2*p):2*Math.PI/(2*cp-1),w=i/g,y=isFinite(i)?1+Math.floor(c*w):cp;y>cp&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${cp}`);const x=[];let _=0;for(let $=0;$<cp;++$){const L=$/w,k=Math.exp(-L*L/2);x.push(k),$===0?_+=k:$<y&&(_+=2*k)}for(let $=0;$<x.length;$++)x[$]=x[$]/_;d.envMap.value=e.texture,d.samples.value=y,d.weights.value=x,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a);const{_lodMax:T}=this;d.dTheta.value=g,d.mipInt.value=T-r;const E=this._sizeLods[s],N=3*E*(s>T-ty?s-T+ty:0),M=4*(this._cubeSize-E);Pb(t,N,M,3*E,2*E),l.setRenderTarget(t),l.render(h,YC)}}function O7(n){const e=[],t=[],r=[];let s=n;const i=n-ty+1+M$.length;for(let o=0;o<i;o++){const a=Math.pow(2,s);t.push(a);let l=1/a;o>n-ty?l=M$[o-n+ty-1]:o===0&&(l=0),r.push(l);const u=1/(a-2),c=-u,h=1+u,d=[c,c,h,c,h,h,c,c,h,h,c,h],p=6,g=6,w=3,y=2,x=1,_=new Float32Array(w*g*p),T=new Float32Array(y*g*p),E=new Float32Array(x*g*p);for(let M=0;M<p;M++){const $=M%3*2/3-1,L=M>2?0:-1,k=[$,L,0,$+2/3,L,0,$+2/3,L+1,0,$,L,0,$+2/3,L+1,0,$,L+1,0];_.set(k,w*g*M),T.set(d,y*g*M);const R=[M,M,M,M,M,M];E.set(R,x*g*M)}const N=new zn;N.setAttribute("position",new Cr(_,w)),N.setAttribute("uv",new Cr(T,y)),N.setAttribute("faceIndex",new Cr(E,x)),e.push(N),s>ty&&s--}return{lodPlanes:e,sizeLods:t,sigmas:r}}function D$(n,e,t){const r=new Us(n,e,t);return r.texture.mapping=Ly,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function Pb(n,e,t,r,s){n.viewport.set(e,t,r,s),n.scissor.set(e,t,r,s)}function F7(n,e,t){const r=new Float32Array(cp),s=new le(0,1,0);return new ni({name:"SphericalGaussianBlur",defines:{n:cp,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:s}},vertexShader:OA(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:wo,depthTest:!1,depthWrite:!1})}function $$(){return new ni({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:OA(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:wo,depthTest:!1,depthWrite:!1})}function P$(){return new ni({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:OA(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:wo,depthTest:!1,depthWrite:!1})}function OA(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function z7(n){let e=new WeakMap,t=null;function r(a){if(a&&a.isTexture){const l=a.mapping,u=l===my||l===Jv,c=l===tc||l===Nd;if(u||c)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let h=e.get(a);return t===null&&(t=new GI(n)),h=u?t.fromEquirectangular(a,h):t.fromCubemap(a,h),e.set(a,h),h.texture}else{if(e.has(a))return e.get(a).texture;{const h=a.image;if(u&&h&&h.height>0||c&&h&&s(h)){t===null&&(t=new GI(n));const d=u?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,d),a.addEventListener("dispose",i),d.texture}else return null}}}return a}function s(a){let l=0;const u=6;for(let c=0;c<u;c++)a[c]!==void 0&&l++;return l===u}function i(a){const l=a.target;l.removeEventListener("dispose",i);const u=e.get(l);u!==void 0&&(e.delete(l),u.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:r,dispose:o}}function B7(n){const e={};function t(r){if(e[r]!==void 0)return e[r];let s;switch(r){case"WEBGL_depth_texture":s=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=n.getExtension(r)}return e[r]=s,s}return{has:function(r){return t(r)!==null},init:function(r){r.isWebGL2?(t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance")):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(r){const s=t(r);return s===null&&console.warn("THREE.WebGLRenderer: "+r+" extension not supported."),s}}}function U7(n,e,t,r){const s={},i=new WeakMap;function o(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const g in d.attributes)e.remove(d.attributes[g]);for(const g in d.morphAttributes){const w=d.morphAttributes[g];for(let y=0,x=w.length;y<x;y++)e.remove(w[y])}d.removeEventListener("dispose",o),delete s[d.id];const p=i.get(d);p&&(e.remove(p),i.delete(d)),r.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function a(h,d){return s[d.id]===!0||(d.addEventListener("dispose",o),s[d.id]=!0,t.memory.geometries++),d}function l(h){const d=h.attributes;for(const g in d)e.update(d[g],n.ARRAY_BUFFER);const p=h.morphAttributes;for(const g in p){const w=p[g];for(let y=0,x=w.length;y<x;y++)e.update(w[y],n.ARRAY_BUFFER)}}function u(h){const d=[],p=h.index,g=h.attributes.position;let w=0;if(p!==null){const _=p.array;w=p.version;for(let T=0,E=_.length;T<E;T+=3){const N=_[T+0],M=_[T+1],$=_[T+2];d.push(N,M,M,$,$,N)}}else if(g!==void 0){const _=g.array;w=g.version;for(let T=0,E=_.length/3-1;T<E;T+=3){const N=T+0,M=T+1,$=T+2;d.push(N,M,M,$,$,N)}}else return;const y=new(VF(d)?$A:DA)(d,1);y.version=w;const x=i.get(h);x&&e.remove(x),i.set(h,y)}function c(h){const d=i.get(h);if(d){const p=h.index;p!==null&&d.version<p.version&&u(h)}else u(h);return i.get(h)}return{get:a,update:l,getWireframeAttribute:c}}function V7(n,e,t,r){const s=r.isWebGL2;let i;function o(p){i=p}let a,l;function u(p){a=p.type,l=p.bytesPerElement}function c(p,g){n.drawElements(i,g,a,p*l),t.update(g,i,1)}function h(p,g,w){if(w===0)return;let y,x;if(s)y=n,x="drawElementsInstanced";else if(y=e.get("ANGLE_instanced_arrays"),x="drawElementsInstancedANGLE",y===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}y[x](i,g,a,p*l,w),t.update(g,i,w)}function d(p,g,w){if(w===0)return;const y=e.get("WEBGL_multi_draw");if(y===null)for(let x=0;x<w;x++)this.render(p[x]/l,g[x]);else{y.multiDrawElementsWEBGL(i,g,0,a,p,0,w);let x=0;for(let _=0;_<w;_++)x+=g[_];t.update(x,i,1)}}this.setMode=o,this.setIndex=u,this.render=c,this.renderInstances=h,this.renderMultiDraw=d}function W7(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function r(i,o,a){switch(t.calls++,o){case n.TRIANGLES:t.triangles+=a*(i/3);break;case n.LINES:t.lines+=a*(i/2);break;case n.LINE_STRIP:t.lines+=a*(i-1);break;case n.LINE_LOOP:t.lines+=a*i;break;case n.POINTS:t.points+=a*i;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function s(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:s,update:r}}function G7(n,e){return n[0]-e[0]}function H7(n,e){return Math.abs(e[1])-Math.abs(n[1])}function j7(n,e,t){const r={},s=new Float32Array(8),i=new WeakMap,o=new br,a=[];for(let u=0;u<8;u++)a[u]=[u,0];function l(u,c,h){const d=u.morphTargetInfluences;if(e.isWebGL2===!0){const g=c.morphAttributes.position||c.morphAttributes.normal||c.morphAttributes.color,w=g!==void 0?g.length:0;let y=i.get(c);if(y===void 0||y.count!==w){let X=function(){Z.dispose(),i.delete(c),c.removeEventListener("dispose",X)};var p=X;y!==void 0&&y.texture.dispose();const T=c.morphAttributes.position!==void 0,E=c.morphAttributes.normal!==void 0,N=c.morphAttributes.color!==void 0,M=c.morphAttributes.position||[],$=c.morphAttributes.normal||[],L=c.morphAttributes.color||[];let k=0;T===!0&&(k=1),E===!0&&(k=2),N===!0&&(k=3);let R=c.attributes.position.count*k,P=1;R>e.maxTextureSize&&(P=Math.ceil(R/e.maxTextureSize),R=e.maxTextureSize);const B=new Float32Array(R*P*4*w),Z=new j_(B,R,P,w);Z.type=Di,Z.needsUpdate=!0;const V=k*4;for(let q=0;q<w;q++){const se=M[q],W=$[q],J=L[q],K=R*P*4*q;for(let G=0;G<se.count;G++){const Q=G*V;T===!0&&(o.fromBufferAttribute(se,G),B[K+Q+0]=o.x,B[K+Q+1]=o.y,B[K+Q+2]=o.z,B[K+Q+3]=0),E===!0&&(o.fromBufferAttribute(W,G),B[K+Q+4]=o.x,B[K+Q+5]=o.y,B[K+Q+6]=o.z,B[K+Q+7]=0),N===!0&&(o.fromBufferAttribute(J,G),B[K+Q+8]=o.x,B[K+Q+9]=o.y,B[K+Q+10]=o.z,B[K+Q+11]=J.itemSize===4?o.w:1)}}y={count:w,texture:Z,size:new rt(R,P)},i.set(c,y),c.addEventListener("dispose",X)}let x=0;for(let T=0;T<d.length;T++)x+=d[T];const _=c.morphTargetsRelative?1:1-x;h.getUniforms().setValue(n,"morphTargetBaseInfluence",_),h.getUniforms().setValue(n,"morphTargetInfluences",d),h.getUniforms().setValue(n,"morphTargetsTexture",y.texture,t),h.getUniforms().setValue(n,"morphTargetsTextureSize",y.size)}else{const g=d===void 0?0:d.length;let w=r[c.id];if(w===void 0||w.length!==g){w=[];for(let E=0;E<g;E++)w[E]=[E,0];r[c.id]=w}for(let E=0;E<g;E++){const N=w[E];N[0]=E,N[1]=d[E]}w.sort(H7);for(let E=0;E<8;E++)E<g&&w[E][1]?(a[E][0]=w[E][0],a[E][1]=w[E][1]):(a[E][0]=Number.MAX_SAFE_INTEGER,a[E][1]=0);a.sort(G7);const y=c.morphAttributes.position,x=c.morphAttributes.normal;let _=0;for(let E=0;E<8;E++){const N=a[E],M=N[0],$=N[1];M!==Number.MAX_SAFE_INTEGER&&$?(y&&c.getAttribute("morphTarget"+E)!==y[M]&&c.setAttribute("morphTarget"+E,y[M]),x&&c.getAttribute("morphNormal"+E)!==x[M]&&c.setAttribute("morphNormal"+E,x[M]),s[E]=$,_+=$):(y&&c.hasAttribute("morphTarget"+E)===!0&&c.deleteAttribute("morphTarget"+E),x&&c.hasAttribute("morphNormal"+E)===!0&&c.deleteAttribute("morphNormal"+E),s[E]=0)}const T=c.morphTargetsRelative?1:1-_;h.getUniforms().setValue(n,"morphTargetBaseInfluence",T),h.getUniforms().setValue(n,"morphTargetInfluences",s)}}return{update:l}}function X7(n,e,t,r){let s=new WeakMap;function i(l){const u=r.render.frame,c=l.geometry,h=e.get(l,c);if(s.get(h)!==u&&(e.update(h),s.set(h,u)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),s.get(l)!==u&&(t.update(l.instanceMatrix,n.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,n.ARRAY_BUFFER),s.set(l,u))),l.isSkinnedMesh){const d=l.skeleton;s.get(d)!==u&&(d.update(),s.set(d,u))}return h}function o(){s=new WeakMap}function a(l){const u=l.target;u.removeEventListener("dispose",a),t.remove(u.instanceMatrix),u.instanceColor!==null&&t.remove(u.instanceColor)}return{update:i,dispose:o}}class X_ extends fs{constructor(e,t,r,s,i,o,a,l,u,c){if(c=c!==void 0?c:wd,c!==wd&&c!==Md)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");r===void 0&&c===wd&&(r=Vu),r===void 0&&c===Md&&(r=rh),super(null,s,i,o,a,l,c,r,u),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=a!==void 0?a:ss,this.minFilter=l!==void 0?l:ss,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}const KF=new fs,YF=new X_(1,1);YF.compareFunction=AA;const ZF=new j_,JF=new RA,QF=new jx,L$=[],O$=[],F$=new Float32Array(16),z$=new Float32Array(9),B$=new Float32Array(4);function By(n,e,t){const r=n[0];if(r<=0||r>0)return n;const s=e*t;let i=L$[s];if(i===void 0&&(i=new Float32Array(s),L$[s]=i),e!==0){r.toArray(i,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(i,a)}return i}function xi(n,e){if(n.length!==e.length)return!1;for(let t=0,r=n.length;t<r;t++)if(n[t]!==e[t])return!1;return!0}function wi(n,e){for(let t=0,r=e.length;t<r;t++)n[t]=e[t]}function q_(n,e){let t=O$[e];t===void 0&&(t=new Int32Array(e),O$[e]=t);for(let r=0;r!==e;++r)t[r]=n.allocateTextureUnit();return t}function q7(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function K7(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(xi(t,e))return;n.uniform2fv(this.addr,e),wi(t,e)}}function Y7(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(xi(t,e))return;n.uniform3fv(this.addr,e),wi(t,e)}}function Z7(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(xi(t,e))return;n.uniform4fv(this.addr,e),wi(t,e)}}function J7(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(xi(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),wi(t,e)}else{if(xi(t,r))return;B$.set(r),n.uniformMatrix2fv(this.addr,!1,B$),wi(t,r)}}function Q7(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(xi(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),wi(t,e)}else{if(xi(t,r))return;z$.set(r),n.uniformMatrix3fv(this.addr,!1,z$),wi(t,r)}}function e9(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(xi(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),wi(t,e)}else{if(xi(t,r))return;F$.set(r),n.uniformMatrix4fv(this.addr,!1,F$),wi(t,r)}}function t9(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function n9(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(xi(t,e))return;n.uniform2iv(this.addr,e),wi(t,e)}}function r9(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(xi(t,e))return;n.uniform3iv(this.addr,e),wi(t,e)}}function s9(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(xi(t,e))return;n.uniform4iv(this.addr,e),wi(t,e)}}function i9(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function o9(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(xi(t,e))return;n.uniform2uiv(this.addr,e),wi(t,e)}}function a9(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(xi(t,e))return;n.uniform3uiv(this.addr,e),wi(t,e)}}function l9(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(xi(t,e))return;n.uniform4uiv(this.addr,e),wi(t,e)}}function u9(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s);const i=this.type===n.SAMPLER_2D_SHADOW?YF:KF;t.setTexture2D(e||i,s)}function c9(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.setTexture3D(e||JF,s)}function h9(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.setTextureCube(e||QF,s)}function d9(n,e,t){const r=this.cache,s=t.allocateTextureUnit();r[0]!==s&&(n.uniform1i(this.addr,s),r[0]=s),t.setTexture2DArray(e||ZF,s)}function f9(n){switch(n){case 5126:return q7;case 35664:return K7;case 35665:return Y7;case 35666:return Z7;case 35674:return J7;case 35675:return Q7;case 35676:return e9;case 5124:case 35670:return t9;case 35667:case 35671:return n9;case 35668:case 35672:return r9;case 35669:case 35673:return s9;case 5125:return i9;case 36294:return o9;case 36295:return a9;case 36296:return l9;case 35678:case 36198:case 36298:case 36306:case 35682:return u9;case 35679:case 36299:case 36307:return c9;case 35680:case 36300:case 36308:case 36293:return h9;case 36289:case 36303:case 36311:case 36292:return d9}}function p9(n,e){n.uniform1fv(this.addr,e)}function m9(n,e){const t=By(e,this.size,2);n.uniform2fv(this.addr,t)}function g9(n,e){const t=By(e,this.size,3);n.uniform3fv(this.addr,t)}function y9(n,e){const t=By(e,this.size,4);n.uniform4fv(this.addr,t)}function v9(n,e){const t=By(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function x9(n,e){const t=By(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function w9(n,e){const t=By(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function b9(n,e){n.uniform1iv(this.addr,e)}function S9(n,e){n.uniform2iv(this.addr,e)}function _9(n,e){n.uniform3iv(this.addr,e)}function T9(n,e){n.uniform4iv(this.addr,e)}function E9(n,e){n.uniform1uiv(this.addr,e)}function C9(n,e){n.uniform2uiv(this.addr,e)}function I9(n,e){n.uniform3uiv(this.addr,e)}function N9(n,e){n.uniform4uiv(this.addr,e)}function A9(n,e,t){const r=this.cache,s=e.length,i=q_(t,s);xi(r,i)||(n.uniform1iv(this.addr,i),wi(r,i));for(let o=0;o!==s;++o)t.setTexture2D(e[o]||KF,i[o])}function M9(n,e,t){const r=this.cache,s=e.length,i=q_(t,s);xi(r,i)||(n.uniform1iv(this.addr,i),wi(r,i));for(let o=0;o!==s;++o)t.setTexture3D(e[o]||JF,i[o])}function k9(n,e,t){const r=this.cache,s=e.length,i=q_(t,s);xi(r,i)||(n.uniform1iv(this.addr,i),wi(r,i));for(let o=0;o!==s;++o)t.setTextureCube(e[o]||QF,i[o])}function R9(n,e,t){const r=this.cache,s=e.length,i=q_(t,s);xi(r,i)||(n.uniform1iv(this.addr,i),wi(r,i));for(let o=0;o!==s;++o)t.setTexture2DArray(e[o]||ZF,i[o])}function D9(n){switch(n){case 5126:return p9;case 35664:return m9;case 35665:return g9;case 35666:return y9;case 35674:return v9;case 35675:return x9;case 35676:return w9;case 5124:case 35670:return b9;case 35667:case 35671:return S9;case 35668:case 35672:return _9;case 35669:case 35673:return T9;case 5125:return E9;case 36294:return C9;case 36295:return I9;case 36296:return N9;case 35678:case 36198:case 36298:case 36306:case 35682:return A9;case 35679:case 36299:case 36307:return M9;case 35680:case 36300:case 36308:case 36293:return k9;case 36289:case 36303:case 36311:case 36292:return R9}}class $9{constructor(e,t,r){this.id=e,this.addr=r,this.cache=[],this.type=t.type,this.setValue=f9(t.type)}}class P9{constructor(e,t,r){this.id=e,this.addr=r,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=D9(t.type)}}class L9{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,r){const s=this.seq;for(let i=0,o=s.length;i!==o;++i){const a=s[i];a.setValue(e,t[a.id],r)}}}const e2=/(\w+)(\])?(\[|\.)?/g;function U$(n,e){n.seq.push(e),n.map[e.id]=e}function O9(n,e,t){const r=n.name,s=r.length;for(e2.lastIndex=0;;){const i=e2.exec(r),o=e2.lastIndex;let a=i[1];const l=i[2]==="]",u=i[3];if(l&&(a=a|0),u===void 0||u==="["&&o+2===s){U$(t,u===void 0?new $9(a,n,e):new P9(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new L9(a),U$(t,h)),t=h}}}class MS{constructor(e,t){this.seq=[],this.map={};const r=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let s=0;s<r;++s){const i=e.getActiveUniform(t,s),o=e.getUniformLocation(t,i.name);O9(i,o,this)}}setValue(e,t,r,s){const i=this.map[t];i!==void 0&&i.setValue(e,r,s)}setOptional(e,t,r){const s=t[r];s!==void 0&&this.setValue(e,r,s)}static upload(e,t,r,s){for(let i=0,o=t.length;i!==o;++i){const a=t[i],l=r[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,s)}}static seqWithValue(e,t){const r=[];for(let s=0,i=e.length;s!==i;++s){const o=e[s];o.id in t&&r.push(o)}return r}}function V$(n,e,t){const r=n.createShader(e);return n.shaderSource(r,t),n.compileShader(r),r}const F9=37297;let z9=0;function B9(n,e){const t=n.split(`
`),r=[],s=Math.max(e-6,0),i=Math.min(e+6,t.length);for(let o=s;o<i;o++){const a=o+1;r.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return r.join(`
`)}function U9(n){const e=$r.getPrimaries($r.workingColorSpace),t=$r.getPrimaries(n);let r;switch(e===t?r="":e===ix&&t===sx?r="LinearDisplayP3ToLinearSRGB":e===sx&&t===ix&&(r="LinearSRGBToLinearDisplayP3"),n){case xl:case Gx:return[r,"LinearTransferOETF"];case sr:case H_:return[r,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",n),[r,"LinearTransferOETF"]}}function W$(n,e,t){const r=n.getShaderParameter(e,n.COMPILE_STATUS),s=n.getShaderInfoLog(e).trim();if(r&&s==="")return"";const i=/ERROR: 0:(\d+)/.exec(s);if(i){const o=parseInt(i[1]);return t.toUpperCase()+`

`+s+`

`+B9(n.getShaderSource(e),o)}else return s}function V9(n,e){const t=U9(e);return`vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`}function W9(n,e){let t;switch(e){case yF:t="Linear";break;case vF:t="Reinhard";break;case xF:t="OptimizedCineon";break;case U_:t="ACESFilmic";break;case bF:t="AgX";break;case wF:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function G9(n){return[n.extensionDerivatives||n.envMapCubeUVHeight||n.bumpMap||n.normalMapTangentSpace||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(ny).join(`
`)}function H9(n){return[n.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":""].filter(ny).join(`
`)}function j9(n){const e=[];for(const t in n){const r=n[t];r!==!1&&e.push("#define "+t+" "+r)}return e.join(`
`)}function X9(n,e){const t={},r=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let s=0;s<r;s++){const i=n.getActiveAttrib(e,s),o=i.name;let a=1;i.type===n.FLOAT_MAT2&&(a=2),i.type===n.FLOAT_MAT3&&(a=3),i.type===n.FLOAT_MAT4&&(a=4),t[o]={type:i.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function ny(n){return n!==""}function G$(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function H$(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const q9=/^[ \t]*#include +<([\w\d./]+)>/gm;function HI(n){return n.replace(q9,Y9)}const K9=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function Y9(n,e){let t=Un[e];if(t===void 0){const r=K9.get(e);if(r!==void 0)t=Un[r],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,r);else throw new Error("Can not resolve #include <"+e+">")}return HI(t)}const Z9=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function j$(n){return n.replace(Z9,J9)}function J9(n,e,t,r){let s="";for(let i=parseInt(e);i<parseInt(t);i++)s+=r.replace(/\[\s*i\s*\]/g,"[ "+i+" ]").replace(/UNROLLED_LOOP_INDEX/g,i);return s}function X$(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function Q9(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===B_?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===Bv?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===iu&&(e="SHADOWMAP_TYPE_VSM"),e}function eK(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case tc:case Nd:e="ENVMAP_TYPE_CUBE";break;case Ly:e="ENVMAP_TYPE_CUBE_UV";break}return e}function tK(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case Nd:e="ENVMAP_MODE_REFRACTION";break}return e}function nK(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case Wx:e="ENVMAP_BLENDING_MULTIPLY";break;case mF:e="ENVMAP_BLENDING_MIX";break;case gF:e="ENVMAP_BLENDING_ADD";break}return e}function rK(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,r=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:r,maxMip:t}}function sK(n,e,t,r){const s=n.getContext(),i=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=Q9(t),u=eK(t),c=tK(t),h=nK(t),d=rK(t),p=t.isWebGL2?"":G9(t),g=H9(t),w=j9(i),y=s.createProgram();let x,_,T=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(x=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,w].filter(ny).join(`
`),x.length>0&&(x+=`
`),_=[p,"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,w].filter(ny).join(`
`),_.length>0&&(_+=`
`)):(x=[X$(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,w,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(ny).join(`
`),_=[p,X$(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,w,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.envMap?"#define "+c:"",t.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Hu?"#define TONE_MAPPING":"",t.toneMapping!==Hu?Un.tonemapping_pars_fragment:"",t.toneMapping!==Hu?W9("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",Un.colorspace_pars_fragment,V9("linearToOutputTexel",t.outputColorSpace),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(ny).join(`
`)),o=HI(o),o=G$(o,t),o=H$(o,t),a=HI(a),a=G$(a,t),a=H$(a,t),o=j$(o),a=j$(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(T=`#version 300 es
`,x=[g,"precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+x,_=["precision mediump sampler2DArray;","#define varying in",t.glslVersion===VI?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===VI?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+_);const E=T+x+o,N=T+_+a,M=V$(s,s.VERTEX_SHADER,E),$=V$(s,s.FRAGMENT_SHADER,N);s.attachShader(y,M),s.attachShader(y,$),t.index0AttributeName!==void 0?s.bindAttribLocation(y,0,t.index0AttributeName):t.morphTargets===!0&&s.bindAttribLocation(y,0,"position"),s.linkProgram(y);function L(B){if(n.debug.checkShaderErrors){const Z=s.getProgramInfoLog(y).trim(),V=s.getShaderInfoLog(M).trim(),X=s.getShaderInfoLog($).trim();let q=!0,se=!0;if(s.getProgramParameter(y,s.LINK_STATUS)===!1)if(q=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(s,y,M,$);else{const W=W$(s,M,"vertex"),J=W$(s,$,"fragment");console.error("THREE.WebGLProgram: Shader Error "+s.getError()+" - VALIDATE_STATUS "+s.getProgramParameter(y,s.VALIDATE_STATUS)+`

Program Info Log: `+Z+`
`+W+`
`+J)}else Z!==""?console.warn("THREE.WebGLProgram: Program Info Log:",Z):(V===""||X==="")&&(se=!1);se&&(B.diagnostics={runnable:q,programLog:Z,vertexShader:{log:V,prefix:x},fragmentShader:{log:X,prefix:_}})}s.deleteShader(M),s.deleteShader($),k=new MS(s,y),R=X9(s,y)}let k;this.getUniforms=function(){return k===void 0&&L(this),k};let R;this.getAttributes=function(){return R===void 0&&L(this),R};let P=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return P===!1&&(P=s.getProgramParameter(y,F9)),P},this.destroy=function(){r.releaseStatesOfProgram(this),s.deleteProgram(y),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=z9++,this.cacheKey=e,this.usedTimes=1,this.program=y,this.vertexShader=M,this.fragmentShader=$,this}let iK=0;class oK{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,r=e.fragmentShader,s=this._getShaderStage(t),i=this._getShaderStage(r),o=this._getShaderCacheForMaterial(e);return o.has(s)===!1&&(o.add(s),s.usedTimes++),o.has(i)===!1&&(o.add(i),i.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const r of t)r.usedTimes--,r.usedTimes===0&&this.shaderCache.delete(r.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let r=t.get(e);return r===void 0&&(r=new Set,t.set(e,r)),r}_getShaderStage(e){const t=this.shaderCache;let r=t.get(e);return r===void 0&&(r=new aK(e),t.set(e,r)),r}}class aK{constructor(e){this.id=iK++,this.code=e,this.usedTimes=0}}function lK(n,e,t,r,s,i,o){const a=new Ap,l=new oK,u=[],c=s.isWebGL2,h=s.logarithmicDepthBuffer,d=s.vertexTextures;let p=s.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function w(k){return k===0?"uv":`uv${k}`}function y(k,R,P,B,Z){const V=B.fog,X=Z.geometry,q=k.isMeshStandardMaterial?B.environment:null,se=(k.isMeshStandardMaterial?t:e).get(k.envMap||q),W=se&&se.mapping===Ly?se.image.height:null,J=g[k.type];k.precision!==null&&(p=s.getMaxPrecision(k.precision),p!==k.precision&&console.warn("THREE.WebGLProgram.getParameters:",k.precision,"not supported, using",p,"instead."));const K=X.morphAttributes.position||X.morphAttributes.normal||X.morphAttributes.color,G=K!==void 0?K.length:0;let Q=0;X.morphAttributes.position!==void 0&&(Q=1),X.morphAttributes.normal!==void 0&&(Q=2),X.morphAttributes.color!==void 0&&(Q=3);let ne,ce,ye,Se;if(J){const ms=ou[J];ne=ms.vertexShader,ce=ms.fragmentShader}else ne=k.vertexShader,ce=k.fragmentShader,l.update(k),ye=l.getVertexShaderID(k),Se=l.getFragmentShaderID(k);const Re=n.getRenderTarget(),Oe=Z.isInstancedMesh===!0,Ke=Z.isBatchedMesh===!0,st=!!k.map,ct=!!k.matcap,fe=!!se,nt=!!k.aoMap,Xe=!!k.lightMap,it=!!k.bumpMap,He=!!k.normalMap,_t=!!k.displacementMap,mt=!!k.emissiveMap,oe=!!k.metalnessMap,ee=!!k.roughnessMap,Le=k.anisotropy>0,at=k.clearcoat>0,ut=k.iridescence>0,ot=k.sheen>0,$t=k.transmission>0,bt=Le&&!!k.anisotropyMap,It=at&&!!k.clearcoatMap,Gt=at&&!!k.clearcoatNormalMap,rn=at&&!!k.clearcoatRoughnessMap,ht=ut&&!!k.iridescenceMap,Nn=ut&&!!k.iridescenceThicknessMap,An=ot&&!!k.sheenColorMap,en=ot&&!!k.sheenRoughnessMap,Ft=!!k.specularMap,Vt=!!k.specularColorMap,cn=!!k.specularIntensityMap,bn=$t&&!!k.transmissionMap,Mn=$t&&!!k.thicknessMap,Tn=!!k.gradientMap,Ge=!!k.alphaMap,_e=k.alphaTest>0,Tt=!!k.alphaHash,Mt=!!k.extensions,ln=!!X.attributes.uv1,sn=!!X.attributes.uv2,pr=!!X.attributes.uv3;let ur=Hu;return k.toneMapped&&(Re===null||Re.isXRRenderTarget===!0)&&(ur=n.toneMapping),{isWebGL2:c,shaderID:J,shaderType:k.type,shaderName:k.name,vertexShader:ne,fragmentShader:ce,defines:k.defines,customVertexShaderID:ye,customFragmentShaderID:Se,isRawShaderMaterial:k.isRawShaderMaterial===!0,glslVersion:k.glslVersion,precision:p,batching:Ke,instancing:Oe,instancingColor:Oe&&Z.instanceColor!==null,supportsVertexTextures:d,outputColorSpace:Re===null?n.outputColorSpace:Re.isXRRenderTarget===!0?Re.texture.colorSpace:xl,map:st,matcap:ct,envMap:fe,envMapMode:fe&&se.mapping,envMapCubeUVHeight:W,aoMap:nt,lightMap:Xe,bumpMap:it,normalMap:He,displacementMap:d&&_t,emissiveMap:mt,normalMapObjectSpace:He&&k.normalMapType===$F,normalMapTangentSpace:He&&k.normalMapType===Gd,metalnessMap:oe,roughnessMap:ee,anisotropy:Le,anisotropyMap:bt,clearcoat:at,clearcoatMap:It,clearcoatNormalMap:Gt,clearcoatRoughnessMap:rn,iridescence:ut,iridescenceMap:ht,iridescenceThicknessMap:Nn,sheen:ot,sheenColorMap:An,sheenRoughnessMap:en,specularMap:Ft,specularColorMap:Vt,specularIntensityMap:cn,transmission:$t,transmissionMap:bn,thicknessMap:Mn,gradientMap:Tn,opaque:k.transparent===!1&&k.blending===Ip,alphaMap:Ge,alphaTest:_e,alphaHash:Tt,combine:k.combine,mapUv:st&&w(k.map.channel),aoMapUv:nt&&w(k.aoMap.channel),lightMapUv:Xe&&w(k.lightMap.channel),bumpMapUv:it&&w(k.bumpMap.channel),normalMapUv:He&&w(k.normalMap.channel),displacementMapUv:_t&&w(k.displacementMap.channel),emissiveMapUv:mt&&w(k.emissiveMap.channel),metalnessMapUv:oe&&w(k.metalnessMap.channel),roughnessMapUv:ee&&w(k.roughnessMap.channel),anisotropyMapUv:bt&&w(k.anisotropyMap.channel),clearcoatMapUv:It&&w(k.clearcoatMap.channel),clearcoatNormalMapUv:Gt&&w(k.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:rn&&w(k.clearcoatRoughnessMap.channel),iridescenceMapUv:ht&&w(k.iridescenceMap.channel),iridescenceThicknessMapUv:Nn&&w(k.iridescenceThicknessMap.channel),sheenColorMapUv:An&&w(k.sheenColorMap.channel),sheenRoughnessMapUv:en&&w(k.sheenRoughnessMap.channel),specularMapUv:Ft&&w(k.specularMap.channel),specularColorMapUv:Vt&&w(k.specularColorMap.channel),specularIntensityMapUv:cn&&w(k.specularIntensityMap.channel),transmissionMapUv:bn&&w(k.transmissionMap.channel),thicknessMapUv:Mn&&w(k.thicknessMap.channel),alphaMapUv:Ge&&w(k.alphaMap.channel),vertexTangents:!!X.attributes.tangent&&(He||Le),vertexColors:k.vertexColors,vertexAlphas:k.vertexColors===!0&&!!X.attributes.color&&X.attributes.color.itemSize===4,vertexUv1s:ln,vertexUv2s:sn,vertexUv3s:pr,pointsUvs:Z.isPoints===!0&&!!X.attributes.uv&&(st||Ge),fog:!!V,useFog:k.fog===!0,fogExp2:V&&V.isFogExp2,flatShading:k.flatShading===!0,sizeAttenuation:k.sizeAttenuation===!0,logarithmicDepthBuffer:h,skinning:Z.isSkinnedMesh===!0,morphTargets:X.morphAttributes.position!==void 0,morphNormals:X.morphAttributes.normal!==void 0,morphColors:X.morphAttributes.color!==void 0,morphTargetsCount:G,morphTextureStride:Q,numDirLights:R.directional.length,numPointLights:R.point.length,numSpotLights:R.spot.length,numSpotLightMaps:R.spotLightMap.length,numRectAreaLights:R.rectArea.length,numHemiLights:R.hemi.length,numDirLightShadows:R.directionalShadowMap.length,numPointLightShadows:R.pointShadowMap.length,numSpotLightShadows:R.spotShadowMap.length,numSpotLightShadowsWithMaps:R.numSpotLightShadowsWithMaps,numLightProbes:R.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:k.dithering,shadowMapEnabled:n.shadowMap.enabled&&P.length>0,shadowMapType:n.shadowMap.type,toneMapping:ur,useLegacyLights:n._useLegacyLights,decodeVideoTexture:st&&k.map.isVideoTexture===!0&&$r.getTransfer(k.map.colorSpace)===Zr,premultipliedAlpha:k.premultipliedAlpha,doubleSided:k.side===Wo,flipSided:k.side===yi,useDepthPacking:k.depthPacking>=0,depthPacking:k.depthPacking||0,index0AttributeName:k.index0AttributeName,extensionDerivatives:Mt&&k.extensions.derivatives===!0,extensionFragDepth:Mt&&k.extensions.fragDepth===!0,extensionDrawBuffers:Mt&&k.extensions.drawBuffers===!0,extensionShaderTextureLOD:Mt&&k.extensions.shaderTextureLOD===!0,extensionClipCullDistance:Mt&&k.extensions.clipCullDistance&&r.has("WEBGL_clip_cull_distance"),rendererExtensionFragDepth:c||r.has("EXT_frag_depth"),rendererExtensionDrawBuffers:c||r.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:c||r.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:r.has("KHR_parallel_shader_compile"),customProgramCacheKey:k.customProgramCacheKey()}}function x(k){const R=[];if(k.shaderID?R.push(k.shaderID):(R.push(k.customVertexShaderID),R.push(k.customFragmentShaderID)),k.defines!==void 0)for(const P in k.defines)R.push(P),R.push(k.defines[P]);return k.isRawShaderMaterial===!1&&(_(R,k),T(R,k),R.push(n.outputColorSpace)),R.push(k.customProgramCacheKey),R.join()}function _(k,R){k.push(R.precision),k.push(R.outputColorSpace),k.push(R.envMapMode),k.push(R.envMapCubeUVHeight),k.push(R.mapUv),k.push(R.alphaMapUv),k.push(R.lightMapUv),k.push(R.aoMapUv),k.push(R.bumpMapUv),k.push(R.normalMapUv),k.push(R.displacementMapUv),k.push(R.emissiveMapUv),k.push(R.metalnessMapUv),k.push(R.roughnessMapUv),k.push(R.anisotropyMapUv),k.push(R.clearcoatMapUv),k.push(R.clearcoatNormalMapUv),k.push(R.clearcoatRoughnessMapUv),k.push(R.iridescenceMapUv),k.push(R.iridescenceThicknessMapUv),k.push(R.sheenColorMapUv),k.push(R.sheenRoughnessMapUv),k.push(R.specularMapUv),k.push(R.specularColorMapUv),k.push(R.specularIntensityMapUv),k.push(R.transmissionMapUv),k.push(R.thicknessMapUv),k.push(R.combine),k.push(R.fogExp2),k.push(R.sizeAttenuation),k.push(R.morphTargetsCount),k.push(R.morphAttributeCount),k.push(R.numDirLights),k.push(R.numPointLights),k.push(R.numSpotLights),k.push(R.numSpotLightMaps),k.push(R.numHemiLights),k.push(R.numRectAreaLights),k.push(R.numDirLightShadows),k.push(R.numPointLightShadows),k.push(R.numSpotLightShadows),k.push(R.numSpotLightShadowsWithMaps),k.push(R.numLightProbes),k.push(R.shadowMapType),k.push(R.toneMapping),k.push(R.numClippingPlanes),k.push(R.numClipIntersection),k.push(R.depthPacking)}function T(k,R){a.disableAll(),R.isWebGL2&&a.enable(0),R.supportsVertexTextures&&a.enable(1),R.instancing&&a.enable(2),R.instancingColor&&a.enable(3),R.matcap&&a.enable(4),R.envMap&&a.enable(5),R.normalMapObjectSpace&&a.enable(6),R.normalMapTangentSpace&&a.enable(7),R.clearcoat&&a.enable(8),R.iridescence&&a.enable(9),R.alphaTest&&a.enable(10),R.vertexColors&&a.enable(11),R.vertexAlphas&&a.enable(12),R.vertexUv1s&&a.enable(13),R.vertexUv2s&&a.enable(14),R.vertexUv3s&&a.enable(15),R.vertexTangents&&a.enable(16),R.anisotropy&&a.enable(17),R.alphaHash&&a.enable(18),R.batching&&a.enable(19),k.push(a.mask),a.disableAll(),R.fog&&a.enable(0),R.useFog&&a.enable(1),R.flatShading&&a.enable(2),R.logarithmicDepthBuffer&&a.enable(3),R.skinning&&a.enable(4),R.morphTargets&&a.enable(5),R.morphNormals&&a.enable(6),R.morphColors&&a.enable(7),R.premultipliedAlpha&&a.enable(8),R.shadowMapEnabled&&a.enable(9),R.useLegacyLights&&a.enable(10),R.doubleSided&&a.enable(11),R.flipSided&&a.enable(12),R.useDepthPacking&&a.enable(13),R.dithering&&a.enable(14),R.transmission&&a.enable(15),R.sheen&&a.enable(16),R.opaque&&a.enable(17),R.pointsUvs&&a.enable(18),R.decodeVideoTexture&&a.enable(19),k.push(a.mask)}function E(k){const R=g[k.type];let P;if(R){const B=ou[R];P=PA.clone(B.uniforms)}else P=k.uniforms;return P}function N(k,R){let P;for(let B=0,Z=u.length;B<Z;B++){const V=u[B];if(V.cacheKey===R){P=V,++P.usedTimes;break}}return P===void 0&&(P=new sK(n,R,k,i),u.push(P)),P}function M(k){if(--k.usedTimes===0){const R=u.indexOf(k);u[R]=u[u.length-1],u.pop(),k.destroy()}}function $(k){l.remove(k)}function L(){l.dispose()}return{getParameters:y,getProgramCacheKey:x,getUniforms:E,acquireProgram:N,releaseProgram:M,releaseShaderCache:$,programs:u,dispose:L}}function uK(){let n=new WeakMap;function e(i){let o=n.get(i);return o===void 0&&(o={},n.set(i,o)),o}function t(i){n.delete(i)}function r(i,o,a){n.get(i)[o]=a}function s(){n=new WeakMap}return{get:e,remove:t,update:r,dispose:s}}function cK(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function q$(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function K$(){const n=[];let e=0;const t=[],r=[],s=[];function i(){e=0,t.length=0,r.length=0,s.length=0}function o(h,d,p,g,w,y){let x=n[e];return x===void 0?(x={id:h.id,object:h,geometry:d,material:p,groupOrder:g,renderOrder:h.renderOrder,z:w,group:y},n[e]=x):(x.id=h.id,x.object=h,x.geometry=d,x.material=p,x.groupOrder=g,x.renderOrder=h.renderOrder,x.z=w,x.group=y),e++,x}function a(h,d,p,g,w,y){const x=o(h,d,p,g,w,y);p.transmission>0?r.push(x):p.transparent===!0?s.push(x):t.push(x)}function l(h,d,p,g,w,y){const x=o(h,d,p,g,w,y);p.transmission>0?r.unshift(x):p.transparent===!0?s.unshift(x):t.unshift(x)}function u(h,d){t.length>1&&t.sort(h||cK),r.length>1&&r.sort(d||q$),s.length>1&&s.sort(d||q$)}function c(){for(let h=e,d=n.length;h<d;h++){const p=n[h];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.group=null}}return{opaque:t,transmissive:r,transparent:s,init:i,push:a,unshift:l,finish:c,sort:u}}function hK(){let n=new WeakMap;function e(r,s){const i=n.get(r);let o;return i===void 0?(o=new K$,n.set(r,[o])):s>=i.length?(o=new K$,i.push(o)):o=i[s],o}function t(){n=new WeakMap}return{get:e,dispose:t}}function dK(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new le,color:new Nt};break;case"SpotLight":t={position:new le,direction:new le,color:new Nt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new le,color:new Nt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new le,skyColor:new Nt,groundColor:new Nt};break;case"RectAreaLight":t={color:new Nt,position:new le,halfWidth:new le,halfHeight:new le};break}return n[e.id]=t,t}}}function fK(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new rt};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new rt};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new rt,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let pK=0;function mK(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function gK(n,e){const t=new dK,r=fK(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let c=0;c<9;c++)s.probe.push(new le);const i=new le,o=new _n,a=new _n;function l(c,h){let d=0,p=0,g=0;for(let B=0;B<9;B++)s.probe[B].set(0,0,0);let w=0,y=0,x=0,_=0,T=0,E=0,N=0,M=0,$=0,L=0,k=0;c.sort(mK);const R=h===!0?Math.PI:1;for(let B=0,Z=c.length;B<Z;B++){const V=c[B],X=V.color,q=V.intensity,se=V.distance,W=V.shadow&&V.shadow.map?V.shadow.map.texture:null;if(V.isAmbientLight)d+=X.r*q*R,p+=X.g*q*R,g+=X.b*q*R;else if(V.isLightProbe){for(let J=0;J<9;J++)s.probe[J].addScaledVector(V.sh.coefficients[J],q);k++}else if(V.isDirectionalLight){const J=t.get(V);if(J.color.copy(V.color).multiplyScalar(V.intensity*R),V.castShadow){const K=V.shadow,G=r.get(V);G.shadowBias=K.bias,G.shadowNormalBias=K.normalBias,G.shadowRadius=K.radius,G.shadowMapSize=K.mapSize,s.directionalShadow[w]=G,s.directionalShadowMap[w]=W,s.directionalShadowMatrix[w]=V.shadow.matrix,E++}s.directional[w]=J,w++}else if(V.isSpotLight){const J=t.get(V);J.position.setFromMatrixPosition(V.matrixWorld),J.color.copy(X).multiplyScalar(q*R),J.distance=se,J.coneCos=Math.cos(V.angle),J.penumbraCos=Math.cos(V.angle*(1-V.penumbra)),J.decay=V.decay,s.spot[x]=J;const K=V.shadow;if(V.map&&(s.spotLightMap[$]=V.map,$++,K.updateMatrices(V),V.castShadow&&L++),s.spotLightMatrix[x]=K.matrix,V.castShadow){const G=r.get(V);G.shadowBias=K.bias,G.shadowNormalBias=K.normalBias,G.shadowRadius=K.radius,G.shadowMapSize=K.mapSize,s.spotShadow[x]=G,s.spotShadowMap[x]=W,M++}x++}else if(V.isRectAreaLight){const J=t.get(V);J.color.copy(X).multiplyScalar(q),J.halfWidth.set(V.width*.5,0,0),J.halfHeight.set(0,V.height*.5,0),s.rectArea[_]=J,_++}else if(V.isPointLight){const J=t.get(V);if(J.color.copy(V.color).multiplyScalar(V.intensity*R),J.distance=V.distance,J.decay=V.decay,V.castShadow){const K=V.shadow,G=r.get(V);G.shadowBias=K.bias,G.shadowNormalBias=K.normalBias,G.shadowRadius=K.radius,G.shadowMapSize=K.mapSize,G.shadowCameraNear=K.camera.near,G.shadowCameraFar=K.camera.far,s.pointShadow[y]=G,s.pointShadowMap[y]=W,s.pointShadowMatrix[y]=V.shadow.matrix,N++}s.point[y]=J,y++}else if(V.isHemisphereLight){const J=t.get(V);J.skyColor.copy(V.color).multiplyScalar(q*R),J.groundColor.copy(V.groundColor).multiplyScalar(q*R),s.hemi[T]=J,T++}}_>0&&(e.isWebGL2?n.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=Rt.LTC_FLOAT_1,s.rectAreaLTC2=Rt.LTC_FLOAT_2):(s.rectAreaLTC1=Rt.LTC_HALF_1,s.rectAreaLTC2=Rt.LTC_HALF_2):n.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=Rt.LTC_FLOAT_1,s.rectAreaLTC2=Rt.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(s.rectAreaLTC1=Rt.LTC_HALF_1,s.rectAreaLTC2=Rt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),s.ambient[0]=d,s.ambient[1]=p,s.ambient[2]=g;const P=s.hash;(P.directionalLength!==w||P.pointLength!==y||P.spotLength!==x||P.rectAreaLength!==_||P.hemiLength!==T||P.numDirectionalShadows!==E||P.numPointShadows!==N||P.numSpotShadows!==M||P.numSpotMaps!==$||P.numLightProbes!==k)&&(s.directional.length=w,s.spot.length=x,s.rectArea.length=_,s.point.length=y,s.hemi.length=T,s.directionalShadow.length=E,s.directionalShadowMap.length=E,s.pointShadow.length=N,s.pointShadowMap.length=N,s.spotShadow.length=M,s.spotShadowMap.length=M,s.directionalShadowMatrix.length=E,s.pointShadowMatrix.length=N,s.spotLightMatrix.length=M+$-L,s.spotLightMap.length=$,s.numSpotLightShadowsWithMaps=L,s.numLightProbes=k,P.directionalLength=w,P.pointLength=y,P.spotLength=x,P.rectAreaLength=_,P.hemiLength=T,P.numDirectionalShadows=E,P.numPointShadows=N,P.numSpotShadows=M,P.numSpotMaps=$,P.numLightProbes=k,s.version=pK++)}function u(c,h){let d=0,p=0,g=0,w=0,y=0;const x=h.matrixWorldInverse;for(let _=0,T=c.length;_<T;_++){const E=c[_];if(E.isDirectionalLight){const N=s.directional[d];N.direction.setFromMatrixPosition(E.matrixWorld),i.setFromMatrixPosition(E.target.matrixWorld),N.direction.sub(i),N.direction.transformDirection(x),d++}else if(E.isSpotLight){const N=s.spot[g];N.position.setFromMatrixPosition(E.matrixWorld),N.position.applyMatrix4(x),N.direction.setFromMatrixPosition(E.matrixWorld),i.setFromMatrixPosition(E.target.matrixWorld),N.direction.sub(i),N.direction.transformDirection(x),g++}else if(E.isRectAreaLight){const N=s.rectArea[w];N.position.setFromMatrixPosition(E.matrixWorld),N.position.applyMatrix4(x),a.identity(),o.copy(E.matrixWorld),o.premultiply(x),a.extractRotation(o),N.halfWidth.set(E.width*.5,0,0),N.halfHeight.set(0,E.height*.5,0),N.halfWidth.applyMatrix4(a),N.halfHeight.applyMatrix4(a),w++}else if(E.isPointLight){const N=s.point[p];N.position.setFromMatrixPosition(E.matrixWorld),N.position.applyMatrix4(x),p++}else if(E.isHemisphereLight){const N=s.hemi[y];N.direction.setFromMatrixPosition(E.matrixWorld),N.direction.transformDirection(x),y++}}}return{setup:l,setupView:u,state:s}}function Y$(n,e){const t=new gK(n,e),r=[],s=[];function i(){r.length=0,s.length=0}function o(h){r.push(h)}function a(h){s.push(h)}function l(h){t.setup(r,h)}function u(h){t.setupView(r,h)}return{init:i,state:{lightsArray:r,shadowsArray:s,lights:t},setupLights:l,setupLightsView:u,pushLight:o,pushShadow:a}}function yK(n,e){let t=new WeakMap;function r(i,o=0){const a=t.get(i);let l;return a===void 0?(l=new Y$(n,e),t.set(i,[l])):o>=a.length?(l=new Y$(n,e),a.push(l)):l=a[o],l}function s(){t=new WeakMap}return{get:r,dispose:s}}class FA extends Si{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=Wd,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class zA extends Si{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const vK=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,xK=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function wK(n,e,t){let r=new Xx;const s=new rt,i=new rt,o=new br,a=new FA({depthPacking:DF}),l=new zA,u={},c=t.maxTextureSize,h={[ec]:yi,[yi]:ec,[Wo]:Wo},d=new ni({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new rt},radius:{value:4}},vertexShader:vK,fragmentShader:xK}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const g=new zn;g.setAttribute("position",new Cr(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const w=new zs(g,d),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=B_;let x=this.type;this.render=function(M,$,L){if(y.enabled===!1||y.autoUpdate===!1&&y.needsUpdate===!1||M.length===0)return;const k=n.getRenderTarget(),R=n.getActiveCubeFace(),P=n.getActiveMipmapLevel(),B=n.state;B.setBlending(wo),B.buffers.color.setClear(1,1,1,1),B.buffers.depth.setTest(!0),B.setScissorTest(!1);const Z=x!==iu&&this.type===iu,V=x===iu&&this.type!==iu;for(let X=0,q=M.length;X<q;X++){const se=M[X],W=se.shadow;if(W===void 0){console.warn("THREE.WebGLShadowMap:",se,"has no shadow.");continue}if(W.autoUpdate===!1&&W.needsUpdate===!1)continue;s.copy(W.mapSize);const J=W.getFrameExtents();if(s.multiply(J),i.copy(W.mapSize),(s.x>c||s.y>c)&&(s.x>c&&(i.x=Math.floor(c/J.x),s.x=i.x*J.x,W.mapSize.x=i.x),s.y>c&&(i.y=Math.floor(c/J.y),s.y=i.y*J.y,W.mapSize.y=i.y)),W.map===null||Z===!0||V===!0){const G=this.type!==iu?{minFilter:ss,magFilter:ss}:{};W.map!==null&&W.map.dispose(),W.map=new Us(s.x,s.y,G),W.map.texture.name=se.name+".shadowMap",W.camera.updateProjectionMatrix()}n.setRenderTarget(W.map),n.clear();const K=W.getViewportCount();for(let G=0;G<K;G++){const Q=W.getViewport(G);o.set(i.x*Q.x,i.y*Q.y,i.x*Q.z,i.y*Q.w),B.viewport(o),W.updateMatrices(se,G),r=W.getFrustum(),E($,L,W.camera,se,this.type)}W.isPointLightShadow!==!0&&this.type===iu&&_(W,L),W.needsUpdate=!1}x=this.type,y.needsUpdate=!1,n.setRenderTarget(k,R,P)};function _(M,$){const L=e.update(w);d.defines.VSM_SAMPLES!==M.blurSamples&&(d.defines.VSM_SAMPLES=M.blurSamples,p.defines.VSM_SAMPLES=M.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),M.mapPass===null&&(M.mapPass=new Us(s.x,s.y)),d.uniforms.shadow_pass.value=M.map.texture,d.uniforms.resolution.value=M.mapSize,d.uniforms.radius.value=M.radius,n.setRenderTarget(M.mapPass),n.clear(),n.renderBufferDirect($,null,L,d,w,null),p.uniforms.shadow_pass.value=M.mapPass.texture,p.uniforms.resolution.value=M.mapSize,p.uniforms.radius.value=M.radius,n.setRenderTarget(M.map),n.clear(),n.renderBufferDirect($,null,L,p,w,null)}function T(M,$,L,k){let R=null;const P=L.isPointLight===!0?M.customDistanceMaterial:M.customDepthMaterial;if(P!==void 0)R=P;else if(R=L.isPointLight===!0?l:a,n.localClippingEnabled&&$.clipShadows===!0&&Array.isArray($.clippingPlanes)&&$.clippingPlanes.length!==0||$.displacementMap&&$.displacementScale!==0||$.alphaMap&&$.alphaTest>0||$.map&&$.alphaTest>0){const B=R.uuid,Z=$.uuid;let V=u[B];V===void 0&&(V={},u[B]=V);let X=V[Z];X===void 0&&(X=R.clone(),V[Z]=X,$.addEventListener("dispose",N)),R=X}if(R.visible=$.visible,R.wireframe=$.wireframe,k===iu?R.side=$.shadowSide!==null?$.shadowSide:$.side:R.side=$.shadowSide!==null?$.shadowSide:h[$.side],R.alphaMap=$.alphaMap,R.alphaTest=$.alphaTest,R.map=$.map,R.clipShadows=$.clipShadows,R.clippingPlanes=$.clippingPlanes,R.clipIntersection=$.clipIntersection,R.displacementMap=$.displacementMap,R.displacementScale=$.displacementScale,R.displacementBias=$.displacementBias,R.wireframeLinewidth=$.wireframeLinewidth,R.linewidth=$.linewidth,L.isPointLight===!0&&R.isMeshDistanceMaterial===!0){const B=n.properties.get(R);B.light=L}return R}function E(M,$,L,k,R){if(M.visible===!1)return;if(M.layers.test($.layers)&&(M.isMesh||M.isLine||M.isPoints)&&(M.castShadow||M.receiveShadow&&R===iu)&&(!M.frustumCulled||r.intersectsObject(M))){M.modelViewMatrix.multiplyMatrices(L.matrixWorldInverse,M.matrixWorld);const Z=e.update(M),V=M.material;if(Array.isArray(V)){const X=Z.groups;for(let q=0,se=X.length;q<se;q++){const W=X[q],J=V[W.materialIndex];if(J&&J.visible){const K=T(M,J,k,R);M.onBeforeShadow(n,M,$,L,Z,K,W),n.renderBufferDirect(L,null,Z,K,M,W),M.onAfterShadow(n,M,$,L,Z,K,W)}}}else if(V.visible){const X=T(M,V,k,R);M.onBeforeShadow(n,M,$,L,Z,X,null),n.renderBufferDirect(L,null,Z,X,M,null),M.onAfterShadow(n,M,$,L,Z,X,null)}}const B=M.children;for(let Z=0,V=B.length;Z<V;Z++)E(B[Z],$,L,k,R)}function N(M){M.target.removeEventListener("dispose",N);for(const L in u){const k=u[L],R=M.target.uuid;R in k&&(k[R].dispose(),delete k[R])}}}function bK(n,e,t){const r=t.isWebGL2;function s(){let _e=!1;const Tt=new br;let Mt=null;const ln=new br(0,0,0,0);return{setMask:function(sn){Mt!==sn&&!_e&&(n.colorMask(sn,sn,sn,sn),Mt=sn)},setLocked:function(sn){_e=sn},setClear:function(sn,pr,ur,Vr,ms){ms===!0&&(sn*=Vr,pr*=Vr,ur*=Vr),Tt.set(sn,pr,ur,Vr),ln.equals(Tt)===!1&&(n.clearColor(sn,pr,ur,Vr),ln.copy(Tt))},reset:function(){_e=!1,Mt=null,ln.set(-1,0,0,0)}}}function i(){let _e=!1,Tt=null,Mt=null,ln=null;return{setTest:function(sn){sn?Ke(n.DEPTH_TEST):st(n.DEPTH_TEST)},setMask:function(sn){Tt!==sn&&!_e&&(n.depthMask(sn),Tt=sn)},setFunc:function(sn){if(Mt!==sn){switch(sn){case uF:n.depthFunc(n.NEVER);break;case yA:n.depthFunc(n.ALWAYS);break;case cF:n.depthFunc(n.LESS);break;case Zv:n.depthFunc(n.LEQUAL);break;case hF:n.depthFunc(n.EQUAL);break;case dF:n.depthFunc(n.GEQUAL);break;case fF:n.depthFunc(n.GREATER);break;case pF:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}Mt=sn}},setLocked:function(sn){_e=sn},setClear:function(sn){ln!==sn&&(n.clearDepth(sn),ln=sn)},reset:function(){_e=!1,Tt=null,Mt=null,ln=null}}}function o(){let _e=!1,Tt=null,Mt=null,ln=null,sn=null,pr=null,ur=null,Vr=null,ms=null;return{setTest:function(er){_e||(er?Ke(n.STENCIL_TEST):st(n.STENCIL_TEST))},setMask:function(er){Tt!==er&&!_e&&(n.stencilMask(er),Tt=er)},setFunc:function(er,gs,Ws){(Mt!==er||ln!==gs||sn!==Ws)&&(n.stencilFunc(er,gs,Ws),Mt=er,ln=gs,sn=Ws)},setOp:function(er,gs,Ws){(pr!==er||ur!==gs||Vr!==Ws)&&(n.stencilOp(er,gs,Ws),pr=er,ur=gs,Vr=Ws)},setLocked:function(er){_e=er},setClear:function(er){ms!==er&&(n.clearStencil(er),ms=er)},reset:function(){_e=!1,Tt=null,Mt=null,ln=null,sn=null,pr=null,ur=null,Vr=null,ms=null}}}const a=new s,l=new i,u=new o,c=new WeakMap,h=new WeakMap;let d={},p={},g=new WeakMap,w=[],y=null,x=!1,_=null,T=null,E=null,N=null,M=null,$=null,L=null,k=new Nt(0,0,0),R=0,P=!1,B=null,Z=null,V=null,X=null,q=null;const se=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let W=!1,J=0;const K=n.getParameter(n.VERSION);K.indexOf("WebGL")!==-1?(J=parseFloat(/^WebGL (\d)/.exec(K)[1]),W=J>=1):K.indexOf("OpenGL ES")!==-1&&(J=parseFloat(/^OpenGL ES (\d)/.exec(K)[1]),W=J>=2);let G=null,Q={};const ne=n.getParameter(n.SCISSOR_BOX),ce=n.getParameter(n.VIEWPORT),ye=new br().fromArray(ne),Se=new br().fromArray(ce);function Re(_e,Tt,Mt,ln){const sn=new Uint8Array(4),pr=n.createTexture();n.bindTexture(_e,pr),n.texParameteri(_e,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(_e,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let ur=0;ur<Mt;ur++)r&&(_e===n.TEXTURE_3D||_e===n.TEXTURE_2D_ARRAY)?n.texImage3D(Tt,0,n.RGBA,1,1,ln,0,n.RGBA,n.UNSIGNED_BYTE,sn):n.texImage2D(Tt+ur,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,sn);return pr}const Oe={};Oe[n.TEXTURE_2D]=Re(n.TEXTURE_2D,n.TEXTURE_2D,1),Oe[n.TEXTURE_CUBE_MAP]=Re(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),r&&(Oe[n.TEXTURE_2D_ARRAY]=Re(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),Oe[n.TEXTURE_3D]=Re(n.TEXTURE_3D,n.TEXTURE_3D,1,1)),a.setClear(0,0,0,1),l.setClear(1),u.setClear(0),Ke(n.DEPTH_TEST),l.setFunc(Zv),mt(!1),oe(uI),Ke(n.CULL_FACE),He(wo);function Ke(_e){d[_e]!==!0&&(n.enable(_e),d[_e]=!0)}function st(_e){d[_e]!==!1&&(n.disable(_e),d[_e]=!1)}function ct(_e,Tt){return p[_e]!==Tt?(n.bindFramebuffer(_e,Tt),p[_e]=Tt,r&&(_e===n.DRAW_FRAMEBUFFER&&(p[n.FRAMEBUFFER]=Tt),_e===n.FRAMEBUFFER&&(p[n.DRAW_FRAMEBUFFER]=Tt)),!0):!1}function fe(_e,Tt){let Mt=w,ln=!1;if(_e)if(Mt=g.get(Tt),Mt===void 0&&(Mt=[],g.set(Tt,Mt)),_e.isWebGLMultipleRenderTargets){const sn=_e.texture;if(Mt.length!==sn.length||Mt[0]!==n.COLOR_ATTACHMENT0){for(let pr=0,ur=sn.length;pr<ur;pr++)Mt[pr]=n.COLOR_ATTACHMENT0+pr;Mt.length=sn.length,ln=!0}}else Mt[0]!==n.COLOR_ATTACHMENT0&&(Mt[0]=n.COLOR_ATTACHMENT0,ln=!0);else Mt[0]!==n.BACK&&(Mt[0]=n.BACK,ln=!0);ln&&(t.isWebGL2?n.drawBuffers(Mt):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Mt))}function nt(_e){return y!==_e?(n.useProgram(_e),y=_e,!0):!1}const Xe={[pd]:n.FUNC_ADD,[qO]:n.FUNC_SUBTRACT,[KO]:n.FUNC_REVERSE_SUBTRACT};if(r)Xe[fI]=n.MIN,Xe[pI]=n.MAX;else{const _e=e.get("EXT_blend_minmax");_e!==null&&(Xe[fI]=_e.MIN_EXT,Xe[pI]=_e.MAX_EXT)}const it={[YO]:n.ZERO,[ZO]:n.ONE,[JO]:n.SRC_COLOR,[XS]:n.SRC_ALPHA,[sF]:n.SRC_ALPHA_SATURATE,[nF]:n.DST_COLOR,[eF]:n.DST_ALPHA,[QO]:n.ONE_MINUS_SRC_COLOR,[qS]:n.ONE_MINUS_SRC_ALPHA,[rF]:n.ONE_MINUS_DST_COLOR,[tF]:n.ONE_MINUS_DST_ALPHA,[iF]:n.CONSTANT_COLOR,[oF]:n.ONE_MINUS_CONSTANT_COLOR,[aF]:n.CONSTANT_ALPHA,[lF]:n.ONE_MINUS_CONSTANT_ALPHA};function He(_e,Tt,Mt,ln,sn,pr,ur,Vr,ms,er){if(_e===wo){x===!0&&(st(n.BLEND),x=!1);return}if(x===!1&&(Ke(n.BLEND),x=!0),_e!==XO){if(_e!==_||er!==P){if((T!==pd||M!==pd)&&(n.blendEquation(n.FUNC_ADD),T=pd,M=pd),er)switch(_e){case Ip:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case cI:n.blendFunc(n.ONE,n.ONE);break;case hI:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case dI:n.blendFuncSeparate(n.ZERO,n.SRC_COLOR,n.ZERO,n.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",_e);break}else switch(_e){case Ip:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case cI:n.blendFunc(n.SRC_ALPHA,n.ONE);break;case hI:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case dI:n.blendFunc(n.ZERO,n.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",_e);break}E=null,N=null,$=null,L=null,k.set(0,0,0),R=0,_=_e,P=er}return}sn=sn||Tt,pr=pr||Mt,ur=ur||ln,(Tt!==T||sn!==M)&&(n.blendEquationSeparate(Xe[Tt],Xe[sn]),T=Tt,M=sn),(Mt!==E||ln!==N||pr!==$||ur!==L)&&(n.blendFuncSeparate(it[Mt],it[ln],it[pr],it[ur]),E=Mt,N=ln,$=pr,L=ur),(Vr.equals(k)===!1||ms!==R)&&(n.blendColor(Vr.r,Vr.g,Vr.b,ms),k.copy(Vr),R=ms),_=_e,P=!1}function _t(_e,Tt){_e.side===Wo?st(n.CULL_FACE):Ke(n.CULL_FACE);let Mt=_e.side===yi;Tt&&(Mt=!Mt),mt(Mt),_e.blending===Ip&&_e.transparent===!1?He(wo):He(_e.blending,_e.blendEquation,_e.blendSrc,_e.blendDst,_e.blendEquationAlpha,_e.blendSrcAlpha,_e.blendDstAlpha,_e.blendColor,_e.blendAlpha,_e.premultipliedAlpha),l.setFunc(_e.depthFunc),l.setTest(_e.depthTest),l.setMask(_e.depthWrite),a.setMask(_e.colorWrite);const ln=_e.stencilWrite;u.setTest(ln),ln&&(u.setMask(_e.stencilWriteMask),u.setFunc(_e.stencilFunc,_e.stencilRef,_e.stencilFuncMask),u.setOp(_e.stencilFail,_e.stencilZFail,_e.stencilZPass)),Le(_e.polygonOffset,_e.polygonOffsetFactor,_e.polygonOffsetUnits),_e.alphaToCoverage===!0?Ke(n.SAMPLE_ALPHA_TO_COVERAGE):st(n.SAMPLE_ALPHA_TO_COVERAGE)}function mt(_e){B!==_e&&(_e?n.frontFace(n.CW):n.frontFace(n.CCW),B=_e)}function oe(_e){_e!==GO?(Ke(n.CULL_FACE),_e!==Z&&(_e===uI?n.cullFace(n.BACK):_e===HO?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):st(n.CULL_FACE),Z=_e}function ee(_e){_e!==V&&(W&&n.lineWidth(_e),V=_e)}function Le(_e,Tt,Mt){_e?(Ke(n.POLYGON_OFFSET_FILL),(X!==Tt||q!==Mt)&&(n.polygonOffset(Tt,Mt),X=Tt,q=Mt)):st(n.POLYGON_OFFSET_FILL)}function at(_e){_e?Ke(n.SCISSOR_TEST):st(n.SCISSOR_TEST)}function ut(_e){_e===void 0&&(_e=n.TEXTURE0+se-1),G!==_e&&(n.activeTexture(_e),G=_e)}function ot(_e,Tt,Mt){Mt===void 0&&(G===null?Mt=n.TEXTURE0+se-1:Mt=G);let ln=Q[Mt];ln===void 0&&(ln={type:void 0,texture:void 0},Q[Mt]=ln),(ln.type!==_e||ln.texture!==Tt)&&(G!==Mt&&(n.activeTexture(Mt),G=Mt),n.bindTexture(_e,Tt||Oe[_e]),ln.type=_e,ln.texture=Tt)}function $t(){const _e=Q[G];_e!==void 0&&_e.type!==void 0&&(n.bindTexture(_e.type,null),_e.type=void 0,_e.texture=void 0)}function bt(){try{n.compressedTexImage2D.apply(n,arguments)}catch(_e){console.error("THREE.WebGLState:",_e)}}function It(){try{n.compressedTexImage3D.apply(n,arguments)}catch(_e){console.error("THREE.WebGLState:",_e)}}function Gt(){try{n.texSubImage2D.apply(n,arguments)}catch(_e){console.error("THREE.WebGLState:",_e)}}function rn(){try{n.texSubImage3D.apply(n,arguments)}catch(_e){console.error("THREE.WebGLState:",_e)}}function ht(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(_e){console.error("THREE.WebGLState:",_e)}}function Nn(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(_e){console.error("THREE.WebGLState:",_e)}}function An(){try{n.texStorage2D.apply(n,arguments)}catch(_e){console.error("THREE.WebGLState:",_e)}}function en(){try{n.texStorage3D.apply(n,arguments)}catch(_e){console.error("THREE.WebGLState:",_e)}}function Ft(){try{n.texImage2D.apply(n,arguments)}catch(_e){console.error("THREE.WebGLState:",_e)}}function Vt(){try{n.texImage3D.apply(n,arguments)}catch(_e){console.error("THREE.WebGLState:",_e)}}function cn(_e){ye.equals(_e)===!1&&(n.scissor(_e.x,_e.y,_e.z,_e.w),ye.copy(_e))}function bn(_e){Se.equals(_e)===!1&&(n.viewport(_e.x,_e.y,_e.z,_e.w),Se.copy(_e))}function Mn(_e,Tt){let Mt=h.get(Tt);Mt===void 0&&(Mt=new WeakMap,h.set(Tt,Mt));let ln=Mt.get(_e);ln===void 0&&(ln=n.getUniformBlockIndex(Tt,_e.name),Mt.set(_e,ln))}function Tn(_e,Tt){const ln=h.get(Tt).get(_e);c.get(Tt)!==ln&&(n.uniformBlockBinding(Tt,ln,_e.__bindingPointIndex),c.set(Tt,ln))}function Ge(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),r===!0&&(n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),d={},G=null,Q={},p={},g=new WeakMap,w=[],y=null,x=!1,_=null,T=null,E=null,N=null,M=null,$=null,L=null,k=new Nt(0,0,0),R=0,P=!1,B=null,Z=null,V=null,X=null,q=null,ye.set(0,0,n.canvas.width,n.canvas.height),Se.set(0,0,n.canvas.width,n.canvas.height),a.reset(),l.reset(),u.reset()}return{buffers:{color:a,depth:l,stencil:u},enable:Ke,disable:st,bindFramebuffer:ct,drawBuffers:fe,useProgram:nt,setBlending:He,setMaterial:_t,setFlipSided:mt,setCullFace:oe,setLineWidth:ee,setPolygonOffset:Le,setScissorTest:at,activeTexture:ut,bindTexture:ot,unbindTexture:$t,compressedTexImage2D:bt,compressedTexImage3D:It,texImage2D:Ft,texImage3D:Vt,updateUBOMapping:Mn,uniformBlockBinding:Tn,texStorage2D:An,texStorage3D:en,texSubImage2D:Gt,texSubImage3D:rn,compressedTexSubImage2D:ht,compressedTexSubImage3D:Nn,scissor:cn,viewport:bn,reset:Ge}}function SK(n,e,t,r,s,i,o){const a=s.isWebGL2,l=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,u=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),c=new WeakMap;let h;const d=new WeakMap;let p=!1;try{p=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function g(oe,ee){return p?new OffscreenCanvas(oe,ee):ax("canvas")}function w(oe,ee,Le,at){let ut=1;if((oe.width>at||oe.height>at)&&(ut=at/Math.max(oe.width,oe.height)),ut<1||ee===!0)if(typeof HTMLImageElement<"u"&&oe instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&oe instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&oe instanceof ImageBitmap){const ot=ee?ZS:Math.floor,$t=ot(ut*oe.width),bt=ot(ut*oe.height);h===void 0&&(h=g($t,bt));const It=Le?g($t,bt):h;return It.width=$t,It.height=bt,It.getContext("2d").drawImage(oe,0,0,$t,bt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+oe.width+"x"+oe.height+") to ("+$t+"x"+bt+")."),It}else return"data"in oe&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+oe.width+"x"+oe.height+")."),oe;return oe}function y(oe){return WI(oe.width)&&WI(oe.height)}function x(oe){return a?!1:oe.wrapS!==mo||oe.wrapT!==mo||oe.minFilter!==ss&&oe.minFilter!==Lr}function _(oe,ee){return oe.generateMipmaps&&ee&&oe.minFilter!==ss&&oe.minFilter!==Lr}function T(oe){n.generateMipmap(oe)}function E(oe,ee,Le,at,ut=!1){if(a===!1)return ee;if(oe!==null){if(n[oe]!==void 0)return n[oe];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+oe+"'")}let ot=ee;if(ee===n.RED&&(Le===n.FLOAT&&(ot=n.R32F),Le===n.HALF_FLOAT&&(ot=n.R16F),Le===n.UNSIGNED_BYTE&&(ot=n.R8)),ee===n.RED_INTEGER&&(Le===n.UNSIGNED_BYTE&&(ot=n.R8UI),Le===n.UNSIGNED_SHORT&&(ot=n.R16UI),Le===n.UNSIGNED_INT&&(ot=n.R32UI),Le===n.BYTE&&(ot=n.R8I),Le===n.SHORT&&(ot=n.R16I),Le===n.INT&&(ot=n.R32I)),ee===n.RG&&(Le===n.FLOAT&&(ot=n.RG32F),Le===n.HALF_FLOAT&&(ot=n.RG16F),Le===n.UNSIGNED_BYTE&&(ot=n.RG8)),ee===n.RGBA){const $t=ut?rx:$r.getTransfer(at);Le===n.FLOAT&&(ot=n.RGBA32F),Le===n.HALF_FLOAT&&(ot=n.RGBA16F),Le===n.UNSIGNED_BYTE&&(ot=$t===Zr?n.SRGB8_ALPHA8:n.RGBA8),Le===n.UNSIGNED_SHORT_4_4_4_4&&(ot=n.RGBA4),Le===n.UNSIGNED_SHORT_5_5_5_1&&(ot=n.RGB5_A1)}return(ot===n.R16F||ot===n.R32F||ot===n.RG16F||ot===n.RG32F||ot===n.RGBA16F||ot===n.RGBA32F)&&e.get("EXT_color_buffer_float"),ot}function N(oe,ee,Le){return _(oe,Le)===!0||oe.isFramebufferTexture&&oe.minFilter!==ss&&oe.minFilter!==Lr?Math.log2(Math.max(ee.width,ee.height))+1:oe.mipmaps!==void 0&&oe.mipmaps.length>0?oe.mipmaps.length:oe.isCompressedTexture&&Array.isArray(oe.image)?ee.mipmaps.length:1}function M(oe){return oe===ss||oe===KS||oe===Uv?n.NEAREST:n.LINEAR}function $(oe){const ee=oe.target;ee.removeEventListener("dispose",$),k(ee),ee.isVideoTexture&&c.delete(ee)}function L(oe){const ee=oe.target;ee.removeEventListener("dispose",L),P(ee)}function k(oe){const ee=r.get(oe);if(ee.__webglInit===void 0)return;const Le=oe.source,at=d.get(Le);if(at){const ut=at[ee.__cacheKey];ut.usedTimes--,ut.usedTimes===0&&R(oe),Object.keys(at).length===0&&d.delete(Le)}r.remove(oe)}function R(oe){const ee=r.get(oe);n.deleteTexture(ee.__webglTexture);const Le=oe.source,at=d.get(Le);delete at[ee.__cacheKey],o.memory.textures--}function P(oe){const ee=oe.texture,Le=r.get(oe),at=r.get(ee);if(at.__webglTexture!==void 0&&(n.deleteTexture(at.__webglTexture),o.memory.textures--),oe.depthTexture&&oe.depthTexture.dispose(),oe.isWebGLCubeRenderTarget)for(let ut=0;ut<6;ut++){if(Array.isArray(Le.__webglFramebuffer[ut]))for(let ot=0;ot<Le.__webglFramebuffer[ut].length;ot++)n.deleteFramebuffer(Le.__webglFramebuffer[ut][ot]);else n.deleteFramebuffer(Le.__webglFramebuffer[ut]);Le.__webglDepthbuffer&&n.deleteRenderbuffer(Le.__webglDepthbuffer[ut])}else{if(Array.isArray(Le.__webglFramebuffer))for(let ut=0;ut<Le.__webglFramebuffer.length;ut++)n.deleteFramebuffer(Le.__webglFramebuffer[ut]);else n.deleteFramebuffer(Le.__webglFramebuffer);if(Le.__webglDepthbuffer&&n.deleteRenderbuffer(Le.__webglDepthbuffer),Le.__webglMultisampledFramebuffer&&n.deleteFramebuffer(Le.__webglMultisampledFramebuffer),Le.__webglColorRenderbuffer)for(let ut=0;ut<Le.__webglColorRenderbuffer.length;ut++)Le.__webglColorRenderbuffer[ut]&&n.deleteRenderbuffer(Le.__webglColorRenderbuffer[ut]);Le.__webglDepthRenderbuffer&&n.deleteRenderbuffer(Le.__webglDepthRenderbuffer)}if(oe.isWebGLMultipleRenderTargets)for(let ut=0,ot=ee.length;ut<ot;ut++){const $t=r.get(ee[ut]);$t.__webglTexture&&(n.deleteTexture($t.__webglTexture),o.memory.textures--),r.remove(ee[ut])}r.remove(ee),r.remove(oe)}let B=0;function Z(){B=0}function V(){const oe=B;return oe>=s.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+oe+" texture units while this GPU supports only "+s.maxTextures),B+=1,oe}function X(oe){const ee=[];return ee.push(oe.wrapS),ee.push(oe.wrapT),ee.push(oe.wrapR||0),ee.push(oe.magFilter),ee.push(oe.minFilter),ee.push(oe.anisotropy),ee.push(oe.internalFormat),ee.push(oe.format),ee.push(oe.type),ee.push(oe.generateMipmaps),ee.push(oe.premultiplyAlpha),ee.push(oe.flipY),ee.push(oe.unpackAlignment),ee.push(oe.colorSpace),ee.join()}function q(oe,ee){const Le=r.get(oe);if(oe.isVideoTexture&&_t(oe),oe.isRenderTargetTexture===!1&&oe.version>0&&Le.__version!==oe.version){const at=oe.image;if(at===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(at.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{ye(Le,oe,ee);return}}t.bindTexture(n.TEXTURE_2D,Le.__webglTexture,n.TEXTURE0+ee)}function se(oe,ee){const Le=r.get(oe);if(oe.version>0&&Le.__version!==oe.version){ye(Le,oe,ee);return}t.bindTexture(n.TEXTURE_2D_ARRAY,Le.__webglTexture,n.TEXTURE0+ee)}function W(oe,ee){const Le=r.get(oe);if(oe.version>0&&Le.__version!==oe.version){ye(Le,oe,ee);return}t.bindTexture(n.TEXTURE_3D,Le.__webglTexture,n.TEXTURE0+ee)}function J(oe,ee){const Le=r.get(oe);if(oe.version>0&&Le.__version!==oe.version){Se(Le,oe,ee);return}t.bindTexture(n.TEXTURE_CUBE_MAP,Le.__webglTexture,n.TEXTURE0+ee)}const K={[Pp]:n.REPEAT,[mo]:n.CLAMP_TO_EDGE,[Qv]:n.MIRRORED_REPEAT},G={[ss]:n.NEAREST,[KS]:n.NEAREST_MIPMAP_NEAREST,[Uv]:n.NEAREST_MIPMAP_LINEAR,[Lr]:n.LINEAR,[vA]:n.LINEAR_MIPMAP_NEAREST,[Ad]:n.LINEAR_MIPMAP_LINEAR},Q={[PF]:n.NEVER,[UF]:n.ALWAYS,[LF]:n.LESS,[AA]:n.LEQUAL,[OF]:n.EQUAL,[BF]:n.GEQUAL,[FF]:n.GREATER,[zF]:n.NOTEQUAL};function ne(oe,ee,Le){if(Le?(n.texParameteri(oe,n.TEXTURE_WRAP_S,K[ee.wrapS]),n.texParameteri(oe,n.TEXTURE_WRAP_T,K[ee.wrapT]),(oe===n.TEXTURE_3D||oe===n.TEXTURE_2D_ARRAY)&&n.texParameteri(oe,n.TEXTURE_WRAP_R,K[ee.wrapR]),n.texParameteri(oe,n.TEXTURE_MAG_FILTER,G[ee.magFilter]),n.texParameteri(oe,n.TEXTURE_MIN_FILTER,G[ee.minFilter])):(n.texParameteri(oe,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(oe,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),(oe===n.TEXTURE_3D||oe===n.TEXTURE_2D_ARRAY)&&n.texParameteri(oe,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),(ee.wrapS!==mo||ee.wrapT!==mo)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(oe,n.TEXTURE_MAG_FILTER,M(ee.magFilter)),n.texParameteri(oe,n.TEXTURE_MIN_FILTER,M(ee.minFilter)),ee.minFilter!==ss&&ee.minFilter!==Lr&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),ee.compareFunction&&(n.texParameteri(oe,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(oe,n.TEXTURE_COMPARE_FUNC,Q[ee.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){const at=e.get("EXT_texture_filter_anisotropic");if(ee.magFilter===ss||ee.minFilter!==Uv&&ee.minFilter!==Ad||ee.type===Di&&e.has("OES_texture_float_linear")===!1||a===!1&&ee.type===vo&&e.has("OES_texture_half_float_linear")===!1)return;(ee.anisotropy>1||r.get(ee).__currentAnisotropy)&&(n.texParameterf(oe,at.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(ee.anisotropy,s.getMaxAnisotropy())),r.get(ee).__currentAnisotropy=ee.anisotropy)}}function ce(oe,ee){let Le=!1;oe.__webglInit===void 0&&(oe.__webglInit=!0,ee.addEventListener("dispose",$));const at=ee.source;let ut=d.get(at);ut===void 0&&(ut={},d.set(at,ut));const ot=X(ee);if(ot!==oe.__cacheKey){ut[ot]===void 0&&(ut[ot]={texture:n.createTexture(),usedTimes:0},o.memory.textures++,Le=!0),ut[ot].usedTimes++;const $t=ut[oe.__cacheKey];$t!==void 0&&(ut[oe.__cacheKey].usedTimes--,$t.usedTimes===0&&R(ee)),oe.__cacheKey=ot,oe.__webglTexture=ut[ot].texture}return Le}function ye(oe,ee,Le){let at=n.TEXTURE_2D;(ee.isDataArrayTexture||ee.isCompressedArrayTexture)&&(at=n.TEXTURE_2D_ARRAY),ee.isData3DTexture&&(at=n.TEXTURE_3D);const ut=ce(oe,ee),ot=ee.source;t.bindTexture(at,oe.__webglTexture,n.TEXTURE0+Le);const $t=r.get(ot);if(ot.version!==$t.__version||ut===!0){t.activeTexture(n.TEXTURE0+Le);const bt=$r.getPrimaries($r.workingColorSpace),It=ee.colorSpace===Go?null:$r.getPrimaries(ee.colorSpace),Gt=ee.colorSpace===Go||bt===It?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,ee.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,ee.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,ee.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,Gt);const rn=x(ee)&&y(ee.image)===!1;let ht=w(ee.image,rn,!1,s.maxTextureSize);ht=mt(ee,ht);const Nn=y(ht)||a,An=i.convert(ee.format,ee.colorSpace);let en=i.convert(ee.type),Ft=E(ee.internalFormat,An,en,ee.colorSpace,ee.isVideoTexture);ne(at,ee,Nn);let Vt;const cn=ee.mipmaps,bn=a&&ee.isVideoTexture!==!0&&Ft!==CA,Mn=$t.__version===void 0||ut===!0,Tn=N(ee,ht,Nn);if(ee.isDepthTexture)Ft=n.DEPTH_COMPONENT,a?ee.type===Di?Ft=n.DEPTH_COMPONENT32F:ee.type===Vu?Ft=n.DEPTH_COMPONENT24:ee.type===rh?Ft=n.DEPTH24_STENCIL8:Ft=n.DEPTH_COMPONENT16:ee.type===Di&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),ee.format===wd&&Ft===n.DEPTH_COMPONENT&&ee.type!==W_&&ee.type!==Vu&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),ee.type=Vu,en=i.convert(ee.type)),ee.format===Md&&Ft===n.DEPTH_COMPONENT&&(Ft=n.DEPTH_STENCIL,ee.type!==rh&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),ee.type=rh,en=i.convert(ee.type))),Mn&&(bn?t.texStorage2D(n.TEXTURE_2D,1,Ft,ht.width,ht.height):t.texImage2D(n.TEXTURE_2D,0,Ft,ht.width,ht.height,0,An,en,null));else if(ee.isDataTexture)if(cn.length>0&&Nn){bn&&Mn&&t.texStorage2D(n.TEXTURE_2D,Tn,Ft,cn[0].width,cn[0].height);for(let Ge=0,_e=cn.length;Ge<_e;Ge++)Vt=cn[Ge],bn?t.texSubImage2D(n.TEXTURE_2D,Ge,0,0,Vt.width,Vt.height,An,en,Vt.data):t.texImage2D(n.TEXTURE_2D,Ge,Ft,Vt.width,Vt.height,0,An,en,Vt.data);ee.generateMipmaps=!1}else bn?(Mn&&t.texStorage2D(n.TEXTURE_2D,Tn,Ft,ht.width,ht.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,ht.width,ht.height,An,en,ht.data)):t.texImage2D(n.TEXTURE_2D,0,Ft,ht.width,ht.height,0,An,en,ht.data);else if(ee.isCompressedTexture)if(ee.isCompressedArrayTexture){bn&&Mn&&t.texStorage3D(n.TEXTURE_2D_ARRAY,Tn,Ft,cn[0].width,cn[0].height,ht.depth);for(let Ge=0,_e=cn.length;Ge<_e;Ge++)Vt=cn[Ge],ee.format!==go?An!==null?bn?t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,Ge,0,0,0,Vt.width,Vt.height,ht.depth,An,Vt.data,0,0):t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,Ge,Ft,Vt.width,Vt.height,ht.depth,0,Vt.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):bn?t.texSubImage3D(n.TEXTURE_2D_ARRAY,Ge,0,0,0,Vt.width,Vt.height,ht.depth,An,en,Vt.data):t.texImage3D(n.TEXTURE_2D_ARRAY,Ge,Ft,Vt.width,Vt.height,ht.depth,0,An,en,Vt.data)}else{bn&&Mn&&t.texStorage2D(n.TEXTURE_2D,Tn,Ft,cn[0].width,cn[0].height);for(let Ge=0,_e=cn.length;Ge<_e;Ge++)Vt=cn[Ge],ee.format!==go?An!==null?bn?t.compressedTexSubImage2D(n.TEXTURE_2D,Ge,0,0,Vt.width,Vt.height,An,Vt.data):t.compressedTexImage2D(n.TEXTURE_2D,Ge,Ft,Vt.width,Vt.height,0,Vt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):bn?t.texSubImage2D(n.TEXTURE_2D,Ge,0,0,Vt.width,Vt.height,An,en,Vt.data):t.texImage2D(n.TEXTURE_2D,Ge,Ft,Vt.width,Vt.height,0,An,en,Vt.data)}else if(ee.isDataArrayTexture)bn?(Mn&&t.texStorage3D(n.TEXTURE_2D_ARRAY,Tn,Ft,ht.width,ht.height,ht.depth),t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,ht.width,ht.height,ht.depth,An,en,ht.data)):t.texImage3D(n.TEXTURE_2D_ARRAY,0,Ft,ht.width,ht.height,ht.depth,0,An,en,ht.data);else if(ee.isData3DTexture)bn?(Mn&&t.texStorage3D(n.TEXTURE_3D,Tn,Ft,ht.width,ht.height,ht.depth),t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,ht.width,ht.height,ht.depth,An,en,ht.data)):t.texImage3D(n.TEXTURE_3D,0,Ft,ht.width,ht.height,ht.depth,0,An,en,ht.data);else if(ee.isFramebufferTexture){if(Mn)if(bn)t.texStorage2D(n.TEXTURE_2D,Tn,Ft,ht.width,ht.height);else{let Ge=ht.width,_e=ht.height;for(let Tt=0;Tt<Tn;Tt++)t.texImage2D(n.TEXTURE_2D,Tt,Ft,Ge,_e,0,An,en,null),Ge>>=1,_e>>=1}}else if(cn.length>0&&Nn){bn&&Mn&&t.texStorage2D(n.TEXTURE_2D,Tn,Ft,cn[0].width,cn[0].height);for(let Ge=0,_e=cn.length;Ge<_e;Ge++)Vt=cn[Ge],bn?t.texSubImage2D(n.TEXTURE_2D,Ge,0,0,An,en,Vt):t.texImage2D(n.TEXTURE_2D,Ge,Ft,An,en,Vt);ee.generateMipmaps=!1}else bn?(Mn&&t.texStorage2D(n.TEXTURE_2D,Tn,Ft,ht.width,ht.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,An,en,ht)):t.texImage2D(n.TEXTURE_2D,0,Ft,An,en,ht);_(ee,Nn)&&T(at),$t.__version=ot.version,ee.onUpdate&&ee.onUpdate(ee)}oe.__version=ee.version}function Se(oe,ee,Le){if(ee.image.length!==6)return;const at=ce(oe,ee),ut=ee.source;t.bindTexture(n.TEXTURE_CUBE_MAP,oe.__webglTexture,n.TEXTURE0+Le);const ot=r.get(ut);if(ut.version!==ot.__version||at===!0){t.activeTexture(n.TEXTURE0+Le);const $t=$r.getPrimaries($r.workingColorSpace),bt=ee.colorSpace===Go?null:$r.getPrimaries(ee.colorSpace),It=ee.colorSpace===Go||$t===bt?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,ee.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,ee.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,ee.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,It);const Gt=ee.isCompressedTexture||ee.image[0].isCompressedTexture,rn=ee.image[0]&&ee.image[0].isDataTexture,ht=[];for(let Ge=0;Ge<6;Ge++)!Gt&&!rn?ht[Ge]=w(ee.image[Ge],!1,!0,s.maxCubemapSize):ht[Ge]=rn?ee.image[Ge].image:ee.image[Ge],ht[Ge]=mt(ee,ht[Ge]);const Nn=ht[0],An=y(Nn)||a,en=i.convert(ee.format,ee.colorSpace),Ft=i.convert(ee.type),Vt=E(ee.internalFormat,en,Ft,ee.colorSpace),cn=a&&ee.isVideoTexture!==!0,bn=ot.__version===void 0||at===!0;let Mn=N(ee,Nn,An);ne(n.TEXTURE_CUBE_MAP,ee,An);let Tn;if(Gt){cn&&bn&&t.texStorage2D(n.TEXTURE_CUBE_MAP,Mn,Vt,Nn.width,Nn.height);for(let Ge=0;Ge<6;Ge++){Tn=ht[Ge].mipmaps;for(let _e=0;_e<Tn.length;_e++){const Tt=Tn[_e];ee.format!==go?en!==null?cn?t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ge,_e,0,0,Tt.width,Tt.height,en,Tt.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ge,_e,Vt,Tt.width,Tt.height,0,Tt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):cn?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ge,_e,0,0,Tt.width,Tt.height,en,Ft,Tt.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ge,_e,Vt,Tt.width,Tt.height,0,en,Ft,Tt.data)}}}else{Tn=ee.mipmaps,cn&&bn&&(Tn.length>0&&Mn++,t.texStorage2D(n.TEXTURE_CUBE_MAP,Mn,Vt,ht[0].width,ht[0].height));for(let Ge=0;Ge<6;Ge++)if(rn){cn?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ge,0,0,0,ht[Ge].width,ht[Ge].height,en,Ft,ht[Ge].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ge,0,Vt,ht[Ge].width,ht[Ge].height,0,en,Ft,ht[Ge].data);for(let _e=0;_e<Tn.length;_e++){const Mt=Tn[_e].image[Ge].image;cn?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ge,_e+1,0,0,Mt.width,Mt.height,en,Ft,Mt.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ge,_e+1,Vt,Mt.width,Mt.height,0,en,Ft,Mt.data)}}else{cn?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ge,0,0,0,en,Ft,ht[Ge]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ge,0,Vt,en,Ft,ht[Ge]);for(let _e=0;_e<Tn.length;_e++){const Tt=Tn[_e];cn?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ge,_e+1,0,0,en,Ft,Tt.image[Ge]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+Ge,_e+1,Vt,en,Ft,Tt.image[Ge])}}}_(ee,An)&&T(n.TEXTURE_CUBE_MAP),ot.__version=ut.version,ee.onUpdate&&ee.onUpdate(ee)}oe.__version=ee.version}function Re(oe,ee,Le,at,ut,ot){const $t=i.convert(Le.format,Le.colorSpace),bt=i.convert(Le.type),It=E(Le.internalFormat,$t,bt,Le.colorSpace);if(!r.get(ee).__hasExternalTextures){const rn=Math.max(1,ee.width>>ot),ht=Math.max(1,ee.height>>ot);ut===n.TEXTURE_3D||ut===n.TEXTURE_2D_ARRAY?t.texImage3D(ut,ot,It,rn,ht,ee.depth,0,$t,bt,null):t.texImage2D(ut,ot,It,rn,ht,0,$t,bt,null)}t.bindFramebuffer(n.FRAMEBUFFER,oe),He(ee)?l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,at,ut,r.get(Le).__webglTexture,0,it(ee)):(ut===n.TEXTURE_2D||ut>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&ut<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,at,ut,r.get(Le).__webglTexture,ot),t.bindFramebuffer(n.FRAMEBUFFER,null)}function Oe(oe,ee,Le){if(n.bindRenderbuffer(n.RENDERBUFFER,oe),ee.depthBuffer&&!ee.stencilBuffer){let at=a===!0?n.DEPTH_COMPONENT24:n.DEPTH_COMPONENT16;if(Le||He(ee)){const ut=ee.depthTexture;ut&&ut.isDepthTexture&&(ut.type===Di?at=n.DEPTH_COMPONENT32F:ut.type===Vu&&(at=n.DEPTH_COMPONENT24));const ot=it(ee);He(ee)?l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,ot,at,ee.width,ee.height):n.renderbufferStorageMultisample(n.RENDERBUFFER,ot,at,ee.width,ee.height)}else n.renderbufferStorage(n.RENDERBUFFER,at,ee.width,ee.height);n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,oe)}else if(ee.depthBuffer&&ee.stencilBuffer){const at=it(ee);Le&&He(ee)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,at,n.DEPTH24_STENCIL8,ee.width,ee.height):He(ee)?l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,at,n.DEPTH24_STENCIL8,ee.width,ee.height):n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,ee.width,ee.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,oe)}else{const at=ee.isWebGLMultipleRenderTargets===!0?ee.texture:[ee.texture];for(let ut=0;ut<at.length;ut++){const ot=at[ut],$t=i.convert(ot.format,ot.colorSpace),bt=i.convert(ot.type),It=E(ot.internalFormat,$t,bt,ot.colorSpace),Gt=it(ee);Le&&He(ee)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,Gt,It,ee.width,ee.height):He(ee)?l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,Gt,It,ee.width,ee.height):n.renderbufferStorage(n.RENDERBUFFER,It,ee.width,ee.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function Ke(oe,ee){if(ee&&ee.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,oe),!(ee.depthTexture&&ee.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!r.get(ee.depthTexture).__webglTexture||ee.depthTexture.image.width!==ee.width||ee.depthTexture.image.height!==ee.height)&&(ee.depthTexture.image.width=ee.width,ee.depthTexture.image.height=ee.height,ee.depthTexture.needsUpdate=!0),q(ee.depthTexture,0);const at=r.get(ee.depthTexture).__webglTexture,ut=it(ee);if(ee.depthTexture.format===wd)He(ee)?l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,at,0,ut):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,at,0);else if(ee.depthTexture.format===Md)He(ee)?l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,at,0,ut):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,at,0);else throw new Error("Unknown depthTexture format")}function st(oe){const ee=r.get(oe),Le=oe.isWebGLCubeRenderTarget===!0;if(oe.depthTexture&&!ee.__autoAllocateDepthBuffer){if(Le)throw new Error("target.depthTexture not supported in Cube render targets");Ke(ee.__webglFramebuffer,oe)}else if(Le){ee.__webglDepthbuffer=[];for(let at=0;at<6;at++)t.bindFramebuffer(n.FRAMEBUFFER,ee.__webglFramebuffer[at]),ee.__webglDepthbuffer[at]=n.createRenderbuffer(),Oe(ee.__webglDepthbuffer[at],oe,!1)}else t.bindFramebuffer(n.FRAMEBUFFER,ee.__webglFramebuffer),ee.__webglDepthbuffer=n.createRenderbuffer(),Oe(ee.__webglDepthbuffer,oe,!1);t.bindFramebuffer(n.FRAMEBUFFER,null)}function ct(oe,ee,Le){const at=r.get(oe);ee!==void 0&&Re(at.__webglFramebuffer,oe,oe.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),Le!==void 0&&st(oe)}function fe(oe){const ee=oe.texture,Le=r.get(oe),at=r.get(ee);oe.addEventListener("dispose",L),oe.isWebGLMultipleRenderTargets!==!0&&(at.__webglTexture===void 0&&(at.__webglTexture=n.createTexture()),at.__version=ee.version,o.memory.textures++);const ut=oe.isWebGLCubeRenderTarget===!0,ot=oe.isWebGLMultipleRenderTargets===!0,$t=y(oe)||a;if(ut){Le.__webglFramebuffer=[];for(let bt=0;bt<6;bt++)if(a&&ee.mipmaps&&ee.mipmaps.length>0){Le.__webglFramebuffer[bt]=[];for(let It=0;It<ee.mipmaps.length;It++)Le.__webglFramebuffer[bt][It]=n.createFramebuffer()}else Le.__webglFramebuffer[bt]=n.createFramebuffer()}else{if(a&&ee.mipmaps&&ee.mipmaps.length>0){Le.__webglFramebuffer=[];for(let bt=0;bt<ee.mipmaps.length;bt++)Le.__webglFramebuffer[bt]=n.createFramebuffer()}else Le.__webglFramebuffer=n.createFramebuffer();if(ot)if(s.drawBuffers){const bt=oe.texture;for(let It=0,Gt=bt.length;It<Gt;It++){const rn=r.get(bt[It]);rn.__webglTexture===void 0&&(rn.__webglTexture=n.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&oe.samples>0&&He(oe)===!1){const bt=ot?ee:[ee];Le.__webglMultisampledFramebuffer=n.createFramebuffer(),Le.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,Le.__webglMultisampledFramebuffer);for(let It=0;It<bt.length;It++){const Gt=bt[It];Le.__webglColorRenderbuffer[It]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,Le.__webglColorRenderbuffer[It]);const rn=i.convert(Gt.format,Gt.colorSpace),ht=i.convert(Gt.type),Nn=E(Gt.internalFormat,rn,ht,Gt.colorSpace,oe.isXRRenderTarget===!0),An=it(oe);n.renderbufferStorageMultisample(n.RENDERBUFFER,An,Nn,oe.width,oe.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+It,n.RENDERBUFFER,Le.__webglColorRenderbuffer[It])}n.bindRenderbuffer(n.RENDERBUFFER,null),oe.depthBuffer&&(Le.__webglDepthRenderbuffer=n.createRenderbuffer(),Oe(Le.__webglDepthRenderbuffer,oe,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(ut){t.bindTexture(n.TEXTURE_CUBE_MAP,at.__webglTexture),ne(n.TEXTURE_CUBE_MAP,ee,$t);for(let bt=0;bt<6;bt++)if(a&&ee.mipmaps&&ee.mipmaps.length>0)for(let It=0;It<ee.mipmaps.length;It++)Re(Le.__webglFramebuffer[bt][It],oe,ee,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+bt,It);else Re(Le.__webglFramebuffer[bt],oe,ee,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+bt,0);_(ee,$t)&&T(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(ot){const bt=oe.texture;for(let It=0,Gt=bt.length;It<Gt;It++){const rn=bt[It],ht=r.get(rn);t.bindTexture(n.TEXTURE_2D,ht.__webglTexture),ne(n.TEXTURE_2D,rn,$t),Re(Le.__webglFramebuffer,oe,rn,n.COLOR_ATTACHMENT0+It,n.TEXTURE_2D,0),_(rn,$t)&&T(n.TEXTURE_2D)}t.unbindTexture()}else{let bt=n.TEXTURE_2D;if((oe.isWebGL3DRenderTarget||oe.isWebGLArrayRenderTarget)&&(a?bt=oe.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(bt,at.__webglTexture),ne(bt,ee,$t),a&&ee.mipmaps&&ee.mipmaps.length>0)for(let It=0;It<ee.mipmaps.length;It++)Re(Le.__webglFramebuffer[It],oe,ee,n.COLOR_ATTACHMENT0,bt,It);else Re(Le.__webglFramebuffer,oe,ee,n.COLOR_ATTACHMENT0,bt,0);_(ee,$t)&&T(bt),t.unbindTexture()}oe.depthBuffer&&st(oe)}function nt(oe){const ee=y(oe)||a,Le=oe.isWebGLMultipleRenderTargets===!0?oe.texture:[oe.texture];for(let at=0,ut=Le.length;at<ut;at++){const ot=Le[at];if(_(ot,ee)){const $t=oe.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:n.TEXTURE_2D,bt=r.get(ot).__webglTexture;t.bindTexture($t,bt),T($t),t.unbindTexture()}}}function Xe(oe){if(a&&oe.samples>0&&He(oe)===!1){const ee=oe.isWebGLMultipleRenderTargets?oe.texture:[oe.texture],Le=oe.width,at=oe.height;let ut=n.COLOR_BUFFER_BIT;const ot=[],$t=oe.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,bt=r.get(oe),It=oe.isWebGLMultipleRenderTargets===!0;if(It)for(let Gt=0;Gt<ee.length;Gt++)t.bindFramebuffer(n.FRAMEBUFFER,bt.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Gt,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,bt.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+Gt,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,bt.__webglMultisampledFramebuffer),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,bt.__webglFramebuffer);for(let Gt=0;Gt<ee.length;Gt++){ot.push(n.COLOR_ATTACHMENT0+Gt),oe.depthBuffer&&ot.push($t);const rn=bt.__ignoreDepthValues!==void 0?bt.__ignoreDepthValues:!1;if(rn===!1&&(oe.depthBuffer&&(ut|=n.DEPTH_BUFFER_BIT),oe.stencilBuffer&&(ut|=n.STENCIL_BUFFER_BIT)),It&&n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,bt.__webglColorRenderbuffer[Gt]),rn===!0&&(n.invalidateFramebuffer(n.READ_FRAMEBUFFER,[$t]),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[$t])),It){const ht=r.get(ee[Gt]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,ht,0)}n.blitFramebuffer(0,0,Le,at,0,0,Le,at,ut,n.NEAREST),u&&n.invalidateFramebuffer(n.READ_FRAMEBUFFER,ot)}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),It)for(let Gt=0;Gt<ee.length;Gt++){t.bindFramebuffer(n.FRAMEBUFFER,bt.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Gt,n.RENDERBUFFER,bt.__webglColorRenderbuffer[Gt]);const rn=r.get(ee[Gt]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,bt.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+Gt,n.TEXTURE_2D,rn,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,bt.__webglMultisampledFramebuffer)}}function it(oe){return Math.min(s.maxSamples,oe.samples)}function He(oe){const ee=r.get(oe);return a&&oe.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&ee.__useRenderToTexture!==!1}function _t(oe){const ee=o.render.frame;c.get(oe)!==ee&&(c.set(oe,ee),oe.update())}function mt(oe,ee){const Le=oe.colorSpace,at=oe.format,ut=oe.type;return oe.isCompressedTexture===!0||oe.isVideoTexture===!0||oe.format===YS||Le!==xl&&Le!==Go&&($r.getTransfer(Le)===Zr?a===!1?e.has("EXT_sRGB")===!0&&at===go?(oe.format=YS,oe.minFilter=Lr,oe.generateMipmaps=!1):ee=kA.sRGBToLinear(ee):(at!==go||ut!==Ki)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",Le)),ee}this.allocateTextureUnit=V,this.resetTextureUnits=Z,this.setTexture2D=q,this.setTexture2DArray=se,this.setTexture3D=W,this.setTextureCube=J,this.rebindTextures=ct,this.setupRenderTarget=fe,this.updateRenderTargetMipmap=nt,this.updateMultisampleRenderTarget=Xe,this.setupDepthRenderbuffer=st,this.setupFrameBufferTexture=Re,this.useMultisampledRTT=He}function ez(n,e,t){const r=t.isWebGL2;function s(i,o=Go){let a;const l=$r.getTransfer(o);if(i===Ki)return n.UNSIGNED_BYTE;if(i===wA)return n.UNSIGNED_SHORT_4_4_4_4;if(i===bA)return n.UNSIGNED_SHORT_5_5_5_1;if(i===_F)return n.BYTE;if(i===TF)return n.SHORT;if(i===W_)return n.UNSIGNED_SHORT;if(i===xA)return n.INT;if(i===Vu)return n.UNSIGNED_INT;if(i===Di)return n.FLOAT;if(i===vo)return r?n.HALF_FLOAT:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(i===EF)return n.ALPHA;if(i===go)return n.RGBA;if(i===CF)return n.LUMINANCE;if(i===IF)return n.LUMINANCE_ALPHA;if(i===wd)return n.DEPTH_COMPONENT;if(i===Md)return n.DEPTH_STENCIL;if(i===YS)return a=e.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(i===SA)return n.RED;if(i===_A)return n.RED_INTEGER;if(i===NF)return n.RG;if(i===TA)return n.RG_INTEGER;if(i===EA)return n.RGBA_INTEGER;if(i===TS||i===ES||i===CS||i===IS)if(l===Zr)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(i===TS)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(i===ES)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(i===CS)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(i===IS)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(i===TS)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===ES)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===CS)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===IS)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===gI||i===yI||i===vI||i===xI)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(i===gI)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===yI)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===vI)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===xI)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===CA)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(i===wI||i===bI)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(i===wI)return l===Zr?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(i===bI)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(i===SI||i===_I||i===TI||i===EI||i===CI||i===II||i===NI||i===AI||i===MI||i===kI||i===RI||i===DI||i===$I||i===PI)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(i===SI)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(i===_I)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(i===TI)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(i===EI)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(i===CI)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(i===II)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(i===NI)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(i===AI)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(i===MI)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(i===kI)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(i===RI)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(i===DI)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(i===$I)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(i===PI)return l===Zr?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(i===NS||i===LI||i===OI)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(i===NS)return l===Zr?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(i===LI)return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(i===OI)return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(i===AF||i===FI||i===zI||i===BI)if(a=e.get("EXT_texture_compression_rgtc"),a!==null){if(i===NS)return a.COMPRESSED_RED_RGTC1_EXT;if(i===FI)return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(i===zI)return a.COMPRESSED_RED_GREEN_RGTC2_EXT;if(i===BI)return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return i===rh?r?n.UNSIGNED_INT_24_8:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):n[i]!==void 0?n[i]:null}return{convert:s}}class tz extends fi{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class ry extends dr{constructor(){super(),this.isGroup=!0,this.type="Group"}}const _K={type:"move"};class t2{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new ry,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new ry,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new le,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new le),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new ry,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new le,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new le),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const r of e.hand.values())this._getHandJoint(t,r)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,r){let s=null,i=null,o=null;const a=this._targetRay,l=this._grip,u=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(u&&e.hand){o=!0;for(const w of e.hand.values()){const y=t.getJointPose(w,r),x=this._getHandJoint(u,w);y!==null&&(x.matrix.fromArray(y.transform.matrix),x.matrix.decompose(x.position,x.rotation,x.scale),x.matrixWorldNeedsUpdate=!0,x.jointRadius=y.radius),x.visible=y!==null}const c=u.joints["index-finger-tip"],h=u.joints["thumb-tip"],d=c.position.distanceTo(h.position),p=.02,g=.005;u.inputState.pinching&&d>p+g?(u.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!u.inputState.pinching&&d<=p-g&&(u.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(i=t.getPose(e.gripSpace,r),i!==null&&(l.matrix.fromArray(i.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,i.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(i.linearVelocity)):l.hasLinearVelocity=!1,i.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(i.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(s=t.getPose(e.targetRaySpace,r),s===null&&i!==null&&(s=i),s!==null&&(a.matrix.fromArray(s.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,s.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(s.linearVelocity)):a.hasLinearVelocity=!1,s.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(s.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(_K)))}return a!==null&&(a.visible=s!==null),l!==null&&(l.visible=i!==null),u!==null&&(u.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const r=new ry;r.matrixAutoUpdate=!1,r.visible=!1,e.joints[t.jointName]=r,e.add(r)}return e.joints[t.jointName]}}class TK extends Tl{constructor(e,t){super();const r=this;let s=null,i=1,o=null,a="local-floor",l=1,u=null,c=null,h=null,d=null,p=null,g=null;const w=t.getContextAttributes();let y=null,x=null;const _=[],T=[],E=new rt;let N=null;const M=new fi;M.layers.enable(1),M.viewport=new br;const $=new fi;$.layers.enable(2),$.viewport=new br;const L=[M,$],k=new tz;k.layers.enable(1),k.layers.enable(2);let R=null,P=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(ne){let ce=_[ne];return ce===void 0&&(ce=new t2,_[ne]=ce),ce.getTargetRaySpace()},this.getControllerGrip=function(ne){let ce=_[ne];return ce===void 0&&(ce=new t2,_[ne]=ce),ce.getGripSpace()},this.getHand=function(ne){let ce=_[ne];return ce===void 0&&(ce=new t2,_[ne]=ce),ce.getHandSpace()};function B(ne){const ce=T.indexOf(ne.inputSource);if(ce===-1)return;const ye=_[ce];ye!==void 0&&(ye.update(ne.inputSource,ne.frame,u||o),ye.dispatchEvent({type:ne.type,data:ne.inputSource}))}function Z(){s.removeEventListener("select",B),s.removeEventListener("selectstart",B),s.removeEventListener("selectend",B),s.removeEventListener("squeeze",B),s.removeEventListener("squeezestart",B),s.removeEventListener("squeezeend",B),s.removeEventListener("end",Z),s.removeEventListener("inputsourceschange",V);for(let ne=0;ne<_.length;ne++){const ce=T[ne];ce!==null&&(T[ne]=null,_[ne].disconnect(ce))}R=null,P=null,e.setRenderTarget(y),p=null,d=null,h=null,s=null,x=null,Q.stop(),r.isPresenting=!1,e.setPixelRatio(N),e.setSize(E.width,E.height,!1),r.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(ne){i=ne,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(ne){a=ne,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return u||o},this.setReferenceSpace=function(ne){u=ne},this.getBaseLayer=function(){return d!==null?d:p},this.getBinding=function(){return h},this.getFrame=function(){return g},this.getSession=function(){return s},this.setSession=async function(ne){if(s=ne,s!==null){if(y=e.getRenderTarget(),s.addEventListener("select",B),s.addEventListener("selectstart",B),s.addEventListener("selectend",B),s.addEventListener("squeeze",B),s.addEventListener("squeezestart",B),s.addEventListener("squeezeend",B),s.addEventListener("end",Z),s.addEventListener("inputsourceschange",V),w.xrCompatible!==!0&&await t.makeXRCompatible(),N=e.getPixelRatio(),e.getSize(E),s.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const ce={antialias:s.renderState.layers===void 0?w.antialias:!0,alpha:!0,depth:w.depth,stencil:w.stencil,framebufferScaleFactor:i};p=new XRWebGLLayer(s,t,ce),s.updateRenderState({baseLayer:p}),e.setPixelRatio(1),e.setSize(p.framebufferWidth,p.framebufferHeight,!1),x=new Us(p.framebufferWidth,p.framebufferHeight,{format:go,type:Ki,colorSpace:e.outputColorSpace,stencilBuffer:w.stencil})}else{let ce=null,ye=null,Se=null;w.depth&&(Se=w.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,ce=w.stencil?Md:wd,ye=w.stencil?rh:Vu);const Re={colorFormat:t.RGBA8,depthFormat:Se,scaleFactor:i};h=new XRWebGLBinding(s,t),d=h.createProjectionLayer(Re),s.updateRenderState({layers:[d]}),e.setPixelRatio(1),e.setSize(d.textureWidth,d.textureHeight,!1),x=new Us(d.textureWidth,d.textureHeight,{format:go,type:Ki,depthTexture:new X_(d.textureWidth,d.textureHeight,ye,void 0,void 0,void 0,void 0,void 0,void 0,ce),stencilBuffer:w.stencil,colorSpace:e.outputColorSpace,samples:w.antialias?4:0});const Oe=e.properties.get(x);Oe.__ignoreDepthValues=d.ignoreDepthValues}x.isXRRenderTarget=!0,this.setFoveation(l),u=null,o=await s.requestReferenceSpace(a),Q.setContext(s),Q.start(),r.isPresenting=!0,r.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(s!==null)return s.environmentBlendMode};function V(ne){for(let ce=0;ce<ne.removed.length;ce++){const ye=ne.removed[ce],Se=T.indexOf(ye);Se>=0&&(T[Se]=null,_[Se].disconnect(ye))}for(let ce=0;ce<ne.added.length;ce++){const ye=ne.added[ce];let Se=T.indexOf(ye);if(Se===-1){for(let Oe=0;Oe<_.length;Oe++)if(Oe>=T.length){T.push(ye),Se=Oe;break}else if(T[Oe]===null){T[Oe]=ye,Se=Oe;break}if(Se===-1)break}const Re=_[Se];Re&&Re.connect(ye)}}const X=new le,q=new le;function se(ne,ce,ye){X.setFromMatrixPosition(ce.matrixWorld),q.setFromMatrixPosition(ye.matrixWorld);const Se=X.distanceTo(q),Re=ce.projectionMatrix.elements,Oe=ye.projectionMatrix.elements,Ke=Re[14]/(Re[10]-1),st=Re[14]/(Re[10]+1),ct=(Re[9]+1)/Re[5],fe=(Re[9]-1)/Re[5],nt=(Re[8]-1)/Re[0],Xe=(Oe[8]+1)/Oe[0],it=Ke*nt,He=Ke*Xe,_t=Se/(-nt+Xe),mt=_t*-nt;ce.matrixWorld.decompose(ne.position,ne.quaternion,ne.scale),ne.translateX(mt),ne.translateZ(_t),ne.matrixWorld.compose(ne.position,ne.quaternion,ne.scale),ne.matrixWorldInverse.copy(ne.matrixWorld).invert();const oe=Ke+_t,ee=st+_t,Le=it-mt,at=He+(Se-mt),ut=ct*st/ee*oe,ot=fe*st/ee*oe;ne.projectionMatrix.makePerspective(Le,at,ut,ot,oe,ee),ne.projectionMatrixInverse.copy(ne.projectionMatrix).invert()}function W(ne,ce){ce===null?ne.matrixWorld.copy(ne.matrix):ne.matrixWorld.multiplyMatrices(ce.matrixWorld,ne.matrix),ne.matrixWorldInverse.copy(ne.matrixWorld).invert()}this.updateCamera=function(ne){if(s===null)return;k.near=$.near=M.near=ne.near,k.far=$.far=M.far=ne.far,(R!==k.near||P!==k.far)&&(s.updateRenderState({depthNear:k.near,depthFar:k.far}),R=k.near,P=k.far);const ce=ne.parent,ye=k.cameras;W(k,ce);for(let Se=0;Se<ye.length;Se++)W(ye[Se],ce);ye.length===2?se(k,M,$):k.projectionMatrix.copy(M.projectionMatrix),J(ne,k,ce)};function J(ne,ce,ye){ye===null?ne.matrix.copy(ce.matrixWorld):(ne.matrix.copy(ye.matrixWorld),ne.matrix.invert(),ne.matrix.multiply(ce.matrixWorld)),ne.matrix.decompose(ne.position,ne.quaternion,ne.scale),ne.updateMatrixWorld(!0),ne.projectionMatrix.copy(ce.projectionMatrix),ne.projectionMatrixInverse.copy(ce.projectionMatrixInverse),ne.isPerspectiveCamera&&(ne.fov=yy*2*Math.atan(1/ne.projectionMatrix.elements[5]),ne.zoom=1)}this.getCamera=function(){return k},this.getFoveation=function(){if(!(d===null&&p===null))return l},this.setFoveation=function(ne){l=ne,d!==null&&(d.fixedFoveation=ne),p!==null&&p.fixedFoveation!==void 0&&(p.fixedFoveation=ne)};let K=null;function G(ne,ce){if(c=ce.getViewerPose(u||o),g=ce,c!==null){const ye=c.views;p!==null&&(e.setRenderTargetFramebuffer(x,p.framebuffer),e.setRenderTarget(x));let Se=!1;ye.length!==k.cameras.length&&(k.cameras.length=0,Se=!0);for(let Re=0;Re<ye.length;Re++){const Oe=ye[Re];let Ke=null;if(p!==null)Ke=p.getViewport(Oe);else{const ct=h.getViewSubImage(d,Oe);Ke=ct.viewport,Re===0&&(e.setRenderTargetTextures(x,ct.colorTexture,d.ignoreDepthValues?void 0:ct.depthStencilTexture),e.setRenderTarget(x))}let st=L[Re];st===void 0&&(st=new fi,st.layers.enable(Re),st.viewport=new br,L[Re]=st),st.matrix.fromArray(Oe.transform.matrix),st.matrix.decompose(st.position,st.quaternion,st.scale),st.projectionMatrix.fromArray(Oe.projectionMatrix),st.projectionMatrixInverse.copy(st.projectionMatrix).invert(),st.viewport.set(Ke.x,Ke.y,Ke.width,Ke.height),Re===0&&(k.matrix.copy(st.matrix),k.matrix.decompose(k.position,k.quaternion,k.scale)),Se===!0&&k.cameras.push(st)}}for(let ye=0;ye<_.length;ye++){const Se=T[ye],Re=_[ye];Se!==null&&Re!==void 0&&Re.update(Se,ce,u||o)}K&&K(ne,ce),ce.detectedPlanes&&r.dispatchEvent({type:"planesdetected",data:ce}),g=null}const Q=new qF;Q.setAnimationLoop(G),this.setAnimationLoop=function(ne){K=ne},this.dispose=function(){}}}function EK(n,e){function t(y,x){y.matrixAutoUpdate===!0&&y.updateMatrix(),x.value.copy(y.matrix)}function r(y,x){x.color.getRGB(y.fogColor.value,jF(n)),x.isFog?(y.fogNear.value=x.near,y.fogFar.value=x.far):x.isFogExp2&&(y.fogDensity.value=x.density)}function s(y,x,_,T,E){x.isMeshBasicMaterial||x.isMeshLambertMaterial?i(y,x):x.isMeshToonMaterial?(i(y,x),h(y,x)):x.isMeshPhongMaterial?(i(y,x),c(y,x)):x.isMeshStandardMaterial?(i(y,x),d(y,x),x.isMeshPhysicalMaterial&&p(y,x,E)):x.isMeshMatcapMaterial?(i(y,x),g(y,x)):x.isMeshDepthMaterial?i(y,x):x.isMeshDistanceMaterial?(i(y,x),w(y,x)):x.isMeshNormalMaterial?i(y,x):x.isLineBasicMaterial?(o(y,x),x.isLineDashedMaterial&&a(y,x)):x.isPointsMaterial?l(y,x,_,T):x.isSpriteMaterial?u(y,x):x.isShadowMaterial?(y.color.value.copy(x.color),y.opacity.value=x.opacity):x.isShaderMaterial&&(x.uniformsNeedUpdate=!1)}function i(y,x){y.opacity.value=x.opacity,x.color&&y.diffuse.value.copy(x.color),x.emissive&&y.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity),x.map&&(y.map.value=x.map,t(x.map,y.mapTransform)),x.alphaMap&&(y.alphaMap.value=x.alphaMap,t(x.alphaMap,y.alphaMapTransform)),x.bumpMap&&(y.bumpMap.value=x.bumpMap,t(x.bumpMap,y.bumpMapTransform),y.bumpScale.value=x.bumpScale,x.side===yi&&(y.bumpScale.value*=-1)),x.normalMap&&(y.normalMap.value=x.normalMap,t(x.normalMap,y.normalMapTransform),y.normalScale.value.copy(x.normalScale),x.side===yi&&y.normalScale.value.negate()),x.displacementMap&&(y.displacementMap.value=x.displacementMap,t(x.displacementMap,y.displacementMapTransform),y.displacementScale.value=x.displacementScale,y.displacementBias.value=x.displacementBias),x.emissiveMap&&(y.emissiveMap.value=x.emissiveMap,t(x.emissiveMap,y.emissiveMapTransform)),x.specularMap&&(y.specularMap.value=x.specularMap,t(x.specularMap,y.specularMapTransform)),x.alphaTest>0&&(y.alphaTest.value=x.alphaTest);const _=e.get(x).envMap;if(_&&(y.envMap.value=_,y.flipEnvMap.value=_.isCubeTexture&&_.isRenderTargetTexture===!1?-1:1,y.reflectivity.value=x.reflectivity,y.ior.value=x.ior,y.refractionRatio.value=x.refractionRatio),x.lightMap){y.lightMap.value=x.lightMap;const T=n._useLegacyLights===!0?Math.PI:1;y.lightMapIntensity.value=x.lightMapIntensity*T,t(x.lightMap,y.lightMapTransform)}x.aoMap&&(y.aoMap.value=x.aoMap,y.aoMapIntensity.value=x.aoMapIntensity,t(x.aoMap,y.aoMapTransform))}function o(y,x){y.diffuse.value.copy(x.color),y.opacity.value=x.opacity,x.map&&(y.map.value=x.map,t(x.map,y.mapTransform))}function a(y,x){y.dashSize.value=x.dashSize,y.totalSize.value=x.dashSize+x.gapSize,y.scale.value=x.scale}function l(y,x,_,T){y.diffuse.value.copy(x.color),y.opacity.value=x.opacity,y.size.value=x.size*_,y.scale.value=T*.5,x.map&&(y.map.value=x.map,t(x.map,y.uvTransform)),x.alphaMap&&(y.alphaMap.value=x.alphaMap,t(x.alphaMap,y.alphaMapTransform)),x.alphaTest>0&&(y.alphaTest.value=x.alphaTest)}function u(y,x){y.diffuse.value.copy(x.color),y.opacity.value=x.opacity,y.rotation.value=x.rotation,x.map&&(y.map.value=x.map,t(x.map,y.mapTransform)),x.alphaMap&&(y.alphaMap.value=x.alphaMap,t(x.alphaMap,y.alphaMapTransform)),x.alphaTest>0&&(y.alphaTest.value=x.alphaTest)}function c(y,x){y.specular.value.copy(x.specular),y.shininess.value=Math.max(x.shininess,1e-4)}function h(y,x){x.gradientMap&&(y.gradientMap.value=x.gradientMap)}function d(y,x){y.metalness.value=x.metalness,x.metalnessMap&&(y.metalnessMap.value=x.metalnessMap,t(x.metalnessMap,y.metalnessMapTransform)),y.roughness.value=x.roughness,x.roughnessMap&&(y.roughnessMap.value=x.roughnessMap,t(x.roughnessMap,y.roughnessMapTransform)),e.get(x).envMap&&(y.envMapIntensity.value=x.envMapIntensity)}function p(y,x,_){y.ior.value=x.ior,x.sheen>0&&(y.sheenColor.value.copy(x.sheenColor).multiplyScalar(x.sheen),y.sheenRoughness.value=x.sheenRoughness,x.sheenColorMap&&(y.sheenColorMap.value=x.sheenColorMap,t(x.sheenColorMap,y.sheenColorMapTransform)),x.sheenRoughnessMap&&(y.sheenRoughnessMap.value=x.sheenRoughnessMap,t(x.sheenRoughnessMap,y.sheenRoughnessMapTransform))),x.clearcoat>0&&(y.clearcoat.value=x.clearcoat,y.clearcoatRoughness.value=x.clearcoatRoughness,x.clearcoatMap&&(y.clearcoatMap.value=x.clearcoatMap,t(x.clearcoatMap,y.clearcoatMapTransform)),x.clearcoatRoughnessMap&&(y.clearcoatRoughnessMap.value=x.clearcoatRoughnessMap,t(x.clearcoatRoughnessMap,y.clearcoatRoughnessMapTransform)),x.clearcoatNormalMap&&(y.clearcoatNormalMap.value=x.clearcoatNormalMap,t(x.clearcoatNormalMap,y.clearcoatNormalMapTransform),y.clearcoatNormalScale.value.copy(x.clearcoatNormalScale),x.side===yi&&y.clearcoatNormalScale.value.negate())),x.iridescence>0&&(y.iridescence.value=x.iridescence,y.iridescenceIOR.value=x.iridescenceIOR,y.iridescenceThicknessMinimum.value=x.iridescenceThicknessRange[0],y.iridescenceThicknessMaximum.value=x.iridescenceThicknessRange[1],x.iridescenceMap&&(y.iridescenceMap.value=x.iridescenceMap,t(x.iridescenceMap,y.iridescenceMapTransform)),x.iridescenceThicknessMap&&(y.iridescenceThicknessMap.value=x.iridescenceThicknessMap,t(x.iridescenceThicknessMap,y.iridescenceThicknessMapTransform))),x.transmission>0&&(y.transmission.value=x.transmission,y.transmissionSamplerMap.value=_.texture,y.transmissionSamplerSize.value.set(_.width,_.height),x.transmissionMap&&(y.transmissionMap.value=x.transmissionMap,t(x.transmissionMap,y.transmissionMapTransform)),y.thickness.value=x.thickness,x.thicknessMap&&(y.thicknessMap.value=x.thicknessMap,t(x.thicknessMap,y.thicknessMapTransform)),y.attenuationDistance.value=x.attenuationDistance,y.attenuationColor.value.copy(x.attenuationColor)),x.anisotropy>0&&(y.anisotropyVector.value.set(x.anisotropy*Math.cos(x.anisotropyRotation),x.anisotropy*Math.sin(x.anisotropyRotation)),x.anisotropyMap&&(y.anisotropyMap.value=x.anisotropyMap,t(x.anisotropyMap,y.anisotropyMapTransform))),y.specularIntensity.value=x.specularIntensity,y.specularColor.value.copy(x.specularColor),x.specularColorMap&&(y.specularColorMap.value=x.specularColorMap,t(x.specularColorMap,y.specularColorMapTransform)),x.specularIntensityMap&&(y.specularIntensityMap.value=x.specularIntensityMap,t(x.specularIntensityMap,y.specularIntensityMapTransform))}function g(y,x){x.matcap&&(y.matcap.value=x.matcap)}function w(y,x){const _=e.get(x).light;y.referencePosition.value.setFromMatrixPosition(_.matrixWorld),y.nearDistance.value=_.shadow.camera.near,y.farDistance.value=_.shadow.camera.far}return{refreshFogUniforms:r,refreshMaterialUniforms:s}}function CK(n,e,t,r){let s={},i={},o=[];const a=t.isWebGL2?n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS):0;function l(_,T){const E=T.program;r.uniformBlockBinding(_,E)}function u(_,T){let E=s[_.id];E===void 0&&(g(_),E=c(_),s[_.id]=E,_.addEventListener("dispose",y));const N=T.program;r.updateUBOMapping(_,N);const M=e.render.frame;i[_.id]!==M&&(d(_),i[_.id]=M)}function c(_){const T=h();_.__bindingPointIndex=T;const E=n.createBuffer(),N=_.__size,M=_.usage;return n.bindBuffer(n.UNIFORM_BUFFER,E),n.bufferData(n.UNIFORM_BUFFER,N,M),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,T,E),E}function h(){for(let _=0;_<a;_++)if(o.indexOf(_)===-1)return o.push(_),_;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function d(_){const T=s[_.id],E=_.uniforms,N=_.__cache;n.bindBuffer(n.UNIFORM_BUFFER,T);for(let M=0,$=E.length;M<$;M++){const L=Array.isArray(E[M])?E[M]:[E[M]];for(let k=0,R=L.length;k<R;k++){const P=L[k];if(p(P,M,k,N)===!0){const B=P.__offset,Z=Array.isArray(P.value)?P.value:[P.value];let V=0;for(let X=0;X<Z.length;X++){const q=Z[X],se=w(q);typeof q=="number"||typeof q=="boolean"?(P.__data[0]=q,n.bufferSubData(n.UNIFORM_BUFFER,B+V,P.__data)):q.isMatrix3?(P.__data[0]=q.elements[0],P.__data[1]=q.elements[1],P.__data[2]=q.elements[2],P.__data[3]=0,P.__data[4]=q.elements[3],P.__data[5]=q.elements[4],P.__data[6]=q.elements[5],P.__data[7]=0,P.__data[8]=q.elements[6],P.__data[9]=q.elements[7],P.__data[10]=q.elements[8],P.__data[11]=0):(q.toArray(P.__data,V),V+=se.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,B,P.__data)}}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function p(_,T,E,N){const M=_.value,$=T+"_"+E;if(N[$]===void 0)return typeof M=="number"||typeof M=="boolean"?N[$]=M:N[$]=M.clone(),!0;{const L=N[$];if(typeof M=="number"||typeof M=="boolean"){if(L!==M)return N[$]=M,!0}else if(L.equals(M)===!1)return L.copy(M),!0}return!1}function g(_){const T=_.uniforms;let E=0;const N=16;for(let $=0,L=T.length;$<L;$++){const k=Array.isArray(T[$])?T[$]:[T[$]];for(let R=0,P=k.length;R<P;R++){const B=k[R],Z=Array.isArray(B.value)?B.value:[B.value];for(let V=0,X=Z.length;V<X;V++){const q=Z[V],se=w(q),W=E%N;W!==0&&N-W<se.boundary&&(E+=N-W),B.__data=new Float32Array(se.storage/Float32Array.BYTES_PER_ELEMENT),B.__offset=E,E+=se.storage}}}const M=E%N;return M>0&&(E+=N-M),_.__size=E,_.__cache={},this}function w(_){const T={boundary:0,storage:0};return typeof _=="number"||typeof _=="boolean"?(T.boundary=4,T.storage=4):_.isVector2?(T.boundary=8,T.storage=8):_.isVector3||_.isColor?(T.boundary=16,T.storage=12):_.isVector4?(T.boundary=16,T.storage=16):_.isMatrix3?(T.boundary=48,T.storage=48):_.isMatrix4?(T.boundary=64,T.storage=64):_.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",_),T}function y(_){const T=_.target;T.removeEventListener("dispose",y);const E=o.indexOf(T.__bindingPointIndex);o.splice(E,1),n.deleteBuffer(s[T.id]),delete s[T.id],delete i[T.id]}function x(){for(const _ in s)n.deleteBuffer(s[_]);o=[],s={},i={}}return{bind:l,update:u,dispose:x}}class BA{constructor(e={}){const{canvas:t=WF(),context:r=null,depth:s=!0,stencil:i=!0,alpha:o=!1,antialias:a=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:u=!1,powerPreference:c="default",failIfMajorPerformanceCaveat:h=!1}=e;this.isWebGLRenderer=!0;let d;r!==null?d=r.getContextAttributes().alpha:d=o;const p=new Uint32Array(4),g=new Int32Array(4);let w=null,y=null;const x=[],_=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=sr,this._useLegacyLights=!1,this.toneMapping=Hu,this.toneMappingExposure=1;const T=this;let E=!1,N=0,M=0,$=null,L=-1,k=null;const R=new br,P=new br;let B=null;const Z=new Nt(0);let V=0,X=t.width,q=t.height,se=1,W=null,J=null;const K=new br(0,0,X,q),G=new br(0,0,X,q);let Q=!1;const ne=new Xx;let ce=!1,ye=!1,Se=null;const Re=new _n,Oe=new rt,Ke=new le,st={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function ct(){return $===null?se:1}let fe=r;function nt(H,ae){for(let ue=0;ue<H.length;ue++){const xe=H[ue],me=t.getContext(xe,ae);if(me!==null)return me}return null}try{const H={alpha:!0,depth:s,stencil:i,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:u,powerPreference:c,failIfMajorPerformanceCaveat:h};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${Vd}`),t.addEventListener("webglcontextlost",Ge,!1),t.addEventListener("webglcontextrestored",_e,!1),t.addEventListener("webglcontextcreationerror",Tt,!1),fe===null){const ae=["webgl2","webgl","experimental-webgl"];if(T.isWebGL1Renderer===!0&&ae.shift(),fe=nt(ae,H),fe===null)throw nt(ae)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}typeof WebGLRenderingContext<"u"&&fe instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),fe.getShaderPrecisionFormat===void 0&&(fe.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(H){throw console.error("THREE.WebGLRenderer: "+H.message),H}let Xe,it,He,_t,mt,oe,ee,Le,at,ut,ot,$t,bt,It,Gt,rn,ht,Nn,An,en,Ft,Vt,cn,bn;function Mn(){Xe=new B7(fe),it=new $7(fe,Xe,e),Xe.init(it),Vt=new ez(fe,Xe,it),He=new bK(fe,Xe,it),_t=new W7(fe),mt=new uK,oe=new SK(fe,Xe,He,mt,it,Vt,_t),ee=new L7(T),Le=new z7(T),at=new Zj(fe,it),cn=new R7(fe,Xe,at,it),ut=new U7(fe,at,_t,cn),ot=new X7(fe,ut,at,_t),An=new j7(fe,it,oe),rn=new P7(mt),$t=new lK(T,ee,Le,Xe,it,cn,rn),bt=new EK(T,mt),It=new hK,Gt=new yK(Xe,it),Nn=new k7(T,ee,Le,He,ot,d,l),ht=new wK(T,ot,it),bn=new CK(fe,_t,it,He),en=new D7(fe,Xe,_t,it),Ft=new V7(fe,Xe,_t,it),_t.programs=$t.programs,T.capabilities=it,T.extensions=Xe,T.properties=mt,T.renderLists=It,T.shadowMap=ht,T.state=He,T.info=_t}Mn();const Tn=new TK(T,fe);this.xr=Tn,this.getContext=function(){return fe},this.getContextAttributes=function(){return fe.getContextAttributes()},this.forceContextLoss=function(){const H=Xe.get("WEBGL_lose_context");H&&H.loseContext()},this.forceContextRestore=function(){const H=Xe.get("WEBGL_lose_context");H&&H.restoreContext()},this.getPixelRatio=function(){return se},this.setPixelRatio=function(H){H!==void 0&&(se=H,this.setSize(X,q,!1))},this.getSize=function(H){return H.set(X,q)},this.setSize=function(H,ae,ue=!0){if(Tn.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}X=H,q=ae,t.width=Math.floor(H*se),t.height=Math.floor(ae*se),ue===!0&&(t.style.width=H+"px",t.style.height=ae+"px"),this.setViewport(0,0,H,ae)},this.getDrawingBufferSize=function(H){return H.set(X*se,q*se).floor()},this.setDrawingBufferSize=function(H,ae,ue){X=H,q=ae,se=ue,t.width=Math.floor(H*ue),t.height=Math.floor(ae*ue),this.setViewport(0,0,H,ae)},this.getCurrentViewport=function(H){return H.copy(R)},this.getViewport=function(H){return H.copy(K)},this.setViewport=function(H,ae,ue,xe){H.isVector4?K.set(H.x,H.y,H.z,H.w):K.set(H,ae,ue,xe),He.viewport(R.copy(K).multiplyScalar(se).floor())},this.getScissor=function(H){return H.copy(G)},this.setScissor=function(H,ae,ue,xe){H.isVector4?G.set(H.x,H.y,H.z,H.w):G.set(H,ae,ue,xe),He.scissor(P.copy(G).multiplyScalar(se).floor())},this.getScissorTest=function(){return Q},this.setScissorTest=function(H){He.setScissorTest(Q=H)},this.setOpaqueSort=function(H){W=H},this.setTransparentSort=function(H){J=H},this.getClearColor=function(H){return H.copy(Nn.getClearColor())},this.setClearColor=function(){Nn.setClearColor.apply(Nn,arguments)},this.getClearAlpha=function(){return Nn.getClearAlpha()},this.setClearAlpha=function(){Nn.setClearAlpha.apply(Nn,arguments)},this.clear=function(H=!0,ae=!0,ue=!0){let xe=0;if(H){let me=!1;if($!==null){const We=$.texture.format;me=We===EA||We===TA||We===_A}if(me){const We=$.texture.type,Ye=We===Ki||We===Vu||We===W_||We===rh||We===wA||We===bA,et=Nn.getClearColor(),Ue=Nn.getClearAlpha(),Bt=et.r,dt=et.g,gt=et.b;Ye?(p[0]=Bt,p[1]=dt,p[2]=gt,p[3]=Ue,fe.clearBufferuiv(fe.COLOR,0,p)):(g[0]=Bt,g[1]=dt,g[2]=gt,g[3]=Ue,fe.clearBufferiv(fe.COLOR,0,g))}else xe|=fe.COLOR_BUFFER_BIT}ae&&(xe|=fe.DEPTH_BUFFER_BIT),ue&&(xe|=fe.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),fe.clear(xe)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Ge,!1),t.removeEventListener("webglcontextrestored",_e,!1),t.removeEventListener("webglcontextcreationerror",Tt,!1),It.dispose(),Gt.dispose(),mt.dispose(),ee.dispose(),Le.dispose(),ot.dispose(),cn.dispose(),bn.dispose(),$t.dispose(),Tn.dispose(),Tn.removeEventListener("sessionstart",ms),Tn.removeEventListener("sessionend",er),Se&&(Se.dispose(),Se=null),gs.stop()};function Ge(H){H.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),E=!0}function _e(){console.log("THREE.WebGLRenderer: Context Restored."),E=!1;const H=_t.autoReset,ae=ht.enabled,ue=ht.autoUpdate,xe=ht.needsUpdate,me=ht.type;Mn(),_t.autoReset=H,ht.enabled=ae,ht.autoUpdate=ue,ht.needsUpdate=xe,ht.type=me}function Tt(H){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",H.statusMessage)}function Mt(H){const ae=H.target;ae.removeEventListener("dispose",Mt),ln(ae)}function ln(H){sn(H),mt.remove(H)}function sn(H){const ae=mt.get(H).programs;ae!==void 0&&(ae.forEach(function(ue){$t.releaseProgram(ue)}),H.isShaderMaterial&&$t.releaseShaderCache(H))}this.renderBufferDirect=function(H,ae,ue,xe,me,We){ae===null&&(ae=st);const Ye=me.isMesh&&me.matrixWorld.determinant()<0,et=j(H,ae,ue,xe,me);He.setMaterial(xe,Ye);let Ue=ue.index,Bt=1;if(xe.wireframe===!0){if(Ue=ut.getWireframeAttribute(ue),Ue===void 0)return;Bt=2}const dt=ue.drawRange,gt=ue.attributes.position;let Ut=dt.start*Bt,tn=(dt.start+dt.count)*Bt;We!==null&&(Ut=Math.max(Ut,We.start*Bt),tn=Math.min(tn,(We.start+We.count)*Bt)),Ue!==null?(Ut=Math.max(Ut,0),tn=Math.min(tn,Ue.count)):gt!=null&&(Ut=Math.max(Ut,0),tn=Math.min(tn,gt.count));const on=tn-Ut;if(on<0||on===1/0)return;cn.setup(me,xe,et,ue,Ue);let vn,kt=en;if(Ue!==null&&(vn=at.get(Ue),kt=Ft,kt.setIndex(vn)),me.isMesh)xe.wireframe===!0?(He.setLineWidth(xe.wireframeLinewidth*ct()),kt.setMode(fe.LINES)):kt.setMode(fe.TRIANGLES);else if(me.isLine){let Ct=xe.linewidth;Ct===void 0&&(Ct=1),He.setLineWidth(Ct*ct()),me.isLineSegments?kt.setMode(fe.LINES):me.isLineLoop?kt.setMode(fe.LINE_LOOP):kt.setMode(fe.LINE_STRIP)}else me.isPoints?kt.setMode(fe.POINTS):me.isSprite&&kt.setMode(fe.TRIANGLES);if(me.isBatchedMesh)kt.renderMultiDraw(me._multiDrawStarts,me._multiDrawCounts,me._multiDrawCount);else if(me.isInstancedMesh)kt.renderInstances(Ut,on,me.count);else if(ue.isInstancedBufferGeometry){const Ct=ue._maxInstanceCount!==void 0?ue._maxInstanceCount:1/0,mn=Math.min(ue.instanceCount,Ct);kt.renderInstances(Ut,on,mn)}else kt.render(Ut,on)};function pr(H,ae,ue){H.transparent===!0&&H.side===Wo&&H.forceSinglePass===!1?(H.side=yi,H.needsUpdate=!0,En(H,ae,ue),H.side=ec,H.needsUpdate=!0,En(H,ae,ue),H.side=Wo):En(H,ae,ue)}this.compile=function(H,ae,ue=null){ue===null&&(ue=H),y=Gt.get(ue),y.init(),_.push(y),ue.traverseVisible(function(me){me.isLight&&me.layers.test(ae.layers)&&(y.pushLight(me),me.castShadow&&y.pushShadow(me))}),H!==ue&&H.traverseVisible(function(me){me.isLight&&me.layers.test(ae.layers)&&(y.pushLight(me),me.castShadow&&y.pushShadow(me))}),y.setupLights(T._useLegacyLights);const xe=new Set;return H.traverse(function(me){const We=me.material;if(We)if(Array.isArray(We))for(let Ye=0;Ye<We.length;Ye++){const et=We[Ye];pr(et,ue,me),xe.add(et)}else pr(We,ue,me),xe.add(We)}),_.pop(),y=null,xe},this.compileAsync=function(H,ae,ue=null){const xe=this.compile(H,ae,ue);return new Promise(me=>{function We(){if(xe.forEach(function(Ye){mt.get(Ye).currentProgram.isReady()&&xe.delete(Ye)}),xe.size===0){me(H);return}setTimeout(We,10)}Xe.get("KHR_parallel_shader_compile")!==null?We():setTimeout(We,10)})};let ur=null;function Vr(H){ur&&ur(H)}function ms(){gs.stop()}function er(){gs.start()}const gs=new qF;gs.setAnimationLoop(Vr),typeof self<"u"&&gs.setContext(self),this.setAnimationLoop=function(H){ur=H,Tn.setAnimationLoop(H),H===null?gs.stop():gs.start()},Tn.addEventListener("sessionstart",ms),Tn.addEventListener("sessionend",er),this.render=function(H,ae){if(ae!==void 0&&ae.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(E===!0)return;H.matrixWorldAutoUpdate===!0&&H.updateMatrixWorld(),ae.parent===null&&ae.matrixWorldAutoUpdate===!0&&ae.updateMatrixWorld(),Tn.enabled===!0&&Tn.isPresenting===!0&&(Tn.cameraAutoUpdate===!0&&Tn.updateCamera(ae),ae=Tn.getCamera()),H.isScene===!0&&H.onBeforeRender(T,H,ae,$),y=Gt.get(H,_.length),y.init(),_.push(y),Re.multiplyMatrices(ae.projectionMatrix,ae.matrixWorldInverse),ne.setFromProjectionMatrix(Re),ye=this.localClippingEnabled,ce=rn.init(this.clippingPlanes,ye),w=It.get(H,x.length),w.init(),x.push(w),Ws(H,ae,0,T.sortObjects),w.finish(),T.sortObjects===!0&&w.sort(W,J),this.info.render.frame++,ce===!0&&rn.beginShadows();const ue=y.state.shadowsArray;if(ht.render(ue,H,ae),ce===!0&&rn.endShadows(),this.info.autoReset===!0&&this.info.reset(),Nn.render(w,H),y.setupLights(T._useLegacyLights),ae.isArrayCamera){const xe=ae.cameras;for(let me=0,We=xe.length;me<We;me++){const Ye=xe[me];Qa(w,H,Ye,Ye.viewport)}}else Qa(w,H,ae);$!==null&&(oe.updateMultisampleRenderTarget($),oe.updateRenderTargetMipmap($)),H.isScene===!0&&H.onAfterRender(T,H,ae),cn.resetDefaultState(),L=-1,k=null,_.pop(),_.length>0?y=_[_.length-1]:y=null,x.pop(),x.length>0?w=x[x.length-1]:w=null};function Ws(H,ae,ue,xe){if(H.visible===!1)return;if(H.layers.test(ae.layers)){if(H.isGroup)ue=H.renderOrder;else if(H.isLOD)H.autoUpdate===!0&&H.update(ae);else if(H.isLight)y.pushLight(H),H.castShadow&&y.pushShadow(H);else if(H.isSprite){if(!H.frustumCulled||ne.intersectsSprite(H)){xe&&Ke.setFromMatrixPosition(H.matrixWorld).applyMatrix4(Re);const Ye=ot.update(H),et=H.material;et.visible&&w.push(H,Ye,et,ue,Ke.z,null)}}else if((H.isMesh||H.isLine||H.isPoints)&&(!H.frustumCulled||ne.intersectsObject(H))){const Ye=ot.update(H),et=H.material;if(xe&&(H.boundingSphere!==void 0?(H.boundingSphere===null&&H.computeBoundingSphere(),Ke.copy(H.boundingSphere.center)):(Ye.boundingSphere===null&&Ye.computeBoundingSphere(),Ke.copy(Ye.boundingSphere.center)),Ke.applyMatrix4(H.matrixWorld).applyMatrix4(Re)),Array.isArray(et)){const Ue=Ye.groups;for(let Bt=0,dt=Ue.length;Bt<dt;Bt++){const gt=Ue[Bt],Ut=et[gt.materialIndex];Ut&&Ut.visible&&w.push(H,Ye,Ut,ue,Ke.z,gt)}}else et.visible&&w.push(H,Ye,et,ue,Ke.z,null)}}const We=H.children;for(let Ye=0,et=We.length;Ye<et;Ye++)Ws(We[Ye],ae,ue,xe)}function Qa(H,ae,ue,xe){const me=H.opaque,We=H.transmissive,Ye=H.transparent;y.setupLightsView(ue),ce===!0&&rn.setGlobalState(T.clippingPlanes,ue),We.length>0&&Na(me,We,ae,ue),xe&&He.viewport(R.copy(xe)),me.length>0&&zi(me,ae,ue),We.length>0&&zi(We,ae,ue),Ye.length>0&&zi(Ye,ae,ue),He.buffers.depth.setTest(!0),He.buffers.depth.setMask(!0),He.buffers.color.setMask(!0),He.setPolygonOffset(!1)}function Na(H,ae,ue,xe){if((ue.isScene===!0?ue.overrideMaterial:null)!==null)return;const We=it.isWebGL2;Se===null&&(Se=new Us(1,1,{generateMipmaps:!0,type:Xe.has("EXT_color_buffer_half_float")?vo:Ki,minFilter:Ad,samples:We?4:0})),T.getDrawingBufferSize(Oe),We?Se.setSize(Oe.x,Oe.y):Se.setSize(ZS(Oe.x),ZS(Oe.y));const Ye=T.getRenderTarget();T.setRenderTarget(Se),T.getClearColor(Z),V=T.getClearAlpha(),V<1&&T.setClearColor(16777215,.5),T.clear();const et=T.toneMapping;T.toneMapping=Hu,zi(H,ue,xe),oe.updateMultisampleRenderTarget(Se),oe.updateRenderTargetMipmap(Se);let Ue=!1;for(let Bt=0,dt=ae.length;Bt<dt;Bt++){const gt=ae[Bt],Ut=gt.object,tn=gt.geometry,on=gt.material,vn=gt.group;if(on.side===Wo&&Ut.layers.test(xe.layers)){const kt=on.side;on.side=yi,on.needsUpdate=!0,ii(Ut,ue,xe,tn,on,vn),on.side=kt,on.needsUpdate=!0,Ue=!0}}Ue===!0&&(oe.updateMultisampleRenderTarget(Se),oe.updateRenderTargetMipmap(Se)),T.setRenderTarget(Ye),T.setClearColor(Z,V),T.toneMapping=et}function zi(H,ae,ue){const xe=ae.isScene===!0?ae.overrideMaterial:null;for(let me=0,We=H.length;me<We;me++){const Ye=H[me],et=Ye.object,Ue=Ye.geometry,Bt=xe===null?Ye.material:xe,dt=Ye.group;et.layers.test(ue.layers)&&ii(et,ae,ue,Ue,Bt,dt)}}function ii(H,ae,ue,xe,me,We){H.onBeforeRender(T,ae,ue,xe,me,We),H.modelViewMatrix.multiplyMatrices(ue.matrixWorldInverse,H.matrixWorld),H.normalMatrix.getNormalMatrix(H.modelViewMatrix),me.onBeforeRender(T,ae,ue,xe,H,We),me.transparent===!0&&me.side===Wo&&me.forceSinglePass===!1?(me.side=yi,me.needsUpdate=!0,T.renderBufferDirect(ue,ae,xe,me,H,We),me.side=ec,me.needsUpdate=!0,T.renderBufferDirect(ue,ae,xe,me,H,We),me.side=Wo):T.renderBufferDirect(ue,ae,xe,me,H,We),H.onAfterRender(T,ae,ue,xe,me,We)}function En(H,ae,ue){ae.isScene!==!0&&(ae=st);const xe=mt.get(H),me=y.state.lights,We=y.state.shadowsArray,Ye=me.state.version,et=$t.getParameters(H,me.state,We,ae,ue),Ue=$t.getProgramCacheKey(et);let Bt=xe.programs;xe.environment=H.isMeshStandardMaterial?ae.environment:null,xe.fog=ae.fog,xe.envMap=(H.isMeshStandardMaterial?Le:ee).get(H.envMap||xe.environment),Bt===void 0&&(H.addEventListener("dispose",Mt),Bt=new Map,xe.programs=Bt);let dt=Bt.get(Ue);if(dt!==void 0){if(xe.currentProgram===dt&&xe.lightsStateVersion===Ye)return Sh(H,et),dt}else et.uniforms=$t.getUniforms(H),H.onBuild(ue,et,T),H.onBeforeCompile(et,T),dt=$t.acquireProgram(et,Ue),Bt.set(Ue,dt),xe.uniforms=et.uniforms;const gt=xe.uniforms;return(!H.isShaderMaterial&&!H.isRawShaderMaterial||H.clipping===!0)&&(gt.clippingPlanes=rn.uniform),Sh(H,et),xe.needsLights=be(H),xe.lightsStateVersion=Ye,xe.needsLights&&(gt.ambientLightColor.value=me.state.ambient,gt.lightProbe.value=me.state.probe,gt.directionalLights.value=me.state.directional,gt.directionalLightShadows.value=me.state.directionalShadow,gt.spotLights.value=me.state.spot,gt.spotLightShadows.value=me.state.spotShadow,gt.rectAreaLights.value=me.state.rectArea,gt.ltc_1.value=me.state.rectAreaLTC1,gt.ltc_2.value=me.state.rectAreaLTC2,gt.pointLights.value=me.state.point,gt.pointLightShadows.value=me.state.pointShadow,gt.hemisphereLights.value=me.state.hemi,gt.directionalShadowMap.value=me.state.directionalShadowMap,gt.directionalShadowMatrix.value=me.state.directionalShadowMatrix,gt.spotShadowMap.value=me.state.spotShadowMap,gt.spotLightMatrix.value=me.state.spotLightMatrix,gt.spotLightMap.value=me.state.spotLightMap,gt.pointShadowMap.value=me.state.pointShadowMap,gt.pointShadowMatrix.value=me.state.pointShadowMatrix),xe.currentProgram=dt,xe.uniformsList=null,dt}function uc(H){if(H.uniformsList===null){const ae=H.currentProgram.getUniforms();H.uniformsList=MS.seqWithValue(ae.seq,H.uniforms)}return H.uniformsList}function Sh(H,ae){const ue=mt.get(H);ue.outputColorSpace=ae.outputColorSpace,ue.batching=ae.batching,ue.instancing=ae.instancing,ue.instancingColor=ae.instancingColor,ue.skinning=ae.skinning,ue.morphTargets=ae.morphTargets,ue.morphNormals=ae.morphNormals,ue.morphColors=ae.morphColors,ue.morphTargetsCount=ae.morphTargetsCount,ue.numClippingPlanes=ae.numClippingPlanes,ue.numIntersection=ae.numClipIntersection,ue.vertexAlphas=ae.vertexAlphas,ue.vertexTangents=ae.vertexTangents,ue.toneMapping=ae.toneMapping}function j(H,ae,ue,xe,me){ae.isScene!==!0&&(ae=st),oe.resetTextureUnits();const We=ae.fog,Ye=xe.isMeshStandardMaterial?ae.environment:null,et=$===null?T.outputColorSpace:$.isXRRenderTarget===!0?$.texture.colorSpace:xl,Ue=(xe.isMeshStandardMaterial?Le:ee).get(xe.envMap||Ye),Bt=xe.vertexColors===!0&&!!ue.attributes.color&&ue.attributes.color.itemSize===4,dt=!!ue.attributes.tangent&&(!!xe.normalMap||xe.anisotropy>0),gt=!!ue.morphAttributes.position,Ut=!!ue.morphAttributes.normal,tn=!!ue.morphAttributes.color;let on=Hu;xe.toneMapped&&($===null||$.isXRRenderTarget===!0)&&(on=T.toneMapping);const vn=ue.morphAttributes.position||ue.morphAttributes.normal||ue.morphAttributes.color,kt=vn!==void 0?vn.length:0,Ct=mt.get(xe),mn=y.state.lights;if(ce===!0&&(ye===!0||H!==k)){const Rn=H===k&&xe.id===L;rn.setState(xe,H,Rn)}let dn=!1;xe.version===Ct.__version?(Ct.needsLights&&Ct.lightsStateVersion!==mn.state.version||Ct.outputColorSpace!==et||me.isBatchedMesh&&Ct.batching===!1||!me.isBatchedMesh&&Ct.batching===!0||me.isInstancedMesh&&Ct.instancing===!1||!me.isInstancedMesh&&Ct.instancing===!0||me.isSkinnedMesh&&Ct.skinning===!1||!me.isSkinnedMesh&&Ct.skinning===!0||me.isInstancedMesh&&Ct.instancingColor===!0&&me.instanceColor===null||me.isInstancedMesh&&Ct.instancingColor===!1&&me.instanceColor!==null||Ct.envMap!==Ue||xe.fog===!0&&Ct.fog!==We||Ct.numClippingPlanes!==void 0&&(Ct.numClippingPlanes!==rn.numPlanes||Ct.numIntersection!==rn.numIntersection)||Ct.vertexAlphas!==Bt||Ct.vertexTangents!==dt||Ct.morphTargets!==gt||Ct.morphNormals!==Ut||Ct.morphColors!==tn||Ct.toneMapping!==on||it.isWebGL2===!0&&Ct.morphTargetsCount!==kt)&&(dn=!0):(dn=!0,Ct.__version=xe.version);let xn=Ct.currentProgram;dn===!0&&(xn=En(xe,ae,me));let Tr=!1,Wr=!1,kr=!1;const Gn=xn.getUniforms(),Pn=Ct.uniforms;if(He.useProgram(xn.program)&&(Tr=!0,Wr=!0,kr=!0),xe.id!==L&&(L=xe.id,Wr=!0),Tr||k!==H){Gn.setValue(fe,"projectionMatrix",H.projectionMatrix),Gn.setValue(fe,"viewMatrix",H.matrixWorldInverse);const Rn=Gn.map.cameraPosition;Rn!==void 0&&Rn.setValue(fe,Ke.setFromMatrixPosition(H.matrixWorld)),it.logarithmicDepthBuffer&&Gn.setValue(fe,"logDepthBufFC",2/(Math.log(H.far+1)/Math.LN2)),(xe.isMeshPhongMaterial||xe.isMeshToonMaterial||xe.isMeshLambertMaterial||xe.isMeshBasicMaterial||xe.isMeshStandardMaterial||xe.isShaderMaterial)&&Gn.setValue(fe,"isOrthographic",H.isOrthographicCamera===!0),k!==H&&(k=H,Wr=!0,kr=!0)}if(me.isSkinnedMesh){Gn.setOptional(fe,me,"bindMatrix"),Gn.setOptional(fe,me,"bindMatrixInverse");const Rn=me.skeleton;Rn&&(it.floatVertexTextures?(Rn.boneTexture===null&&Rn.computeBoneTexture(),Gn.setValue(fe,"boneTexture",Rn.boneTexture,oe)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}me.isBatchedMesh&&(Gn.setOptional(fe,me,"batchingTexture"),Gn.setValue(fe,"batchingTexture",me._matricesTexture,oe));const es=ue.morphAttributes;if((es.position!==void 0||es.normal!==void 0||es.color!==void 0&&it.isWebGL2===!0)&&An.update(me,ue,xn),(Wr||Ct.receiveShadow!==me.receiveShadow)&&(Ct.receiveShadow=me.receiveShadow,Gn.setValue(fe,"receiveShadow",me.receiveShadow)),xe.isMeshGouraudMaterial&&xe.envMap!==null&&(Pn.envMap.value=Ue,Pn.flipEnvMap.value=Ue.isCubeTexture&&Ue.isRenderTargetTexture===!1?-1:1),Wr&&(Gn.setValue(fe,"toneMappingExposure",T.toneMappingExposure),Ct.needsLights&&re(Pn,kr),We&&xe.fog===!0&&bt.refreshFogUniforms(Pn,We),bt.refreshMaterialUniforms(Pn,xe,se,q,Se),MS.upload(fe,uc(Ct),Pn,oe)),xe.isShaderMaterial&&xe.uniformsNeedUpdate===!0&&(MS.upload(fe,uc(Ct),Pn,oe),xe.uniformsNeedUpdate=!1),xe.isSpriteMaterial&&Gn.setValue(fe,"center",me.center),Gn.setValue(fe,"modelViewMatrix",me.modelViewMatrix),Gn.setValue(fe,"normalMatrix",me.normalMatrix),Gn.setValue(fe,"modelMatrix",me.matrixWorld),xe.isShaderMaterial||xe.isRawShaderMaterial){const Rn=xe.uniformsGroups;for(let Hn=0,Rr=Rn.length;Hn<Rr;Hn++)if(it.isWebGL2){const eo=Rn[Hn];bn.update(eo,xn),bn.bind(eo,xn)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return xn}function re(H,ae){H.ambientLightColor.needsUpdate=ae,H.lightProbe.needsUpdate=ae,H.directionalLights.needsUpdate=ae,H.directionalLightShadows.needsUpdate=ae,H.pointLights.needsUpdate=ae,H.pointLightShadows.needsUpdate=ae,H.spotLights.needsUpdate=ae,H.spotLightShadows.needsUpdate=ae,H.rectAreaLights.needsUpdate=ae,H.hemisphereLights.needsUpdate=ae}function be(H){return H.isMeshLambertMaterial||H.isMeshToonMaterial||H.isMeshPhongMaterial||H.isMeshStandardMaterial||H.isShadowMaterial||H.isShaderMaterial&&H.lights===!0}this.getActiveCubeFace=function(){return N},this.getActiveMipmapLevel=function(){return M},this.getRenderTarget=function(){return $},this.setRenderTargetTextures=function(H,ae,ue){mt.get(H.texture).__webglTexture=ae,mt.get(H.depthTexture).__webglTexture=ue;const xe=mt.get(H);xe.__hasExternalTextures=!0,xe.__hasExternalTextures&&(xe.__autoAllocateDepthBuffer=ue===void 0,xe.__autoAllocateDepthBuffer||Xe.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),xe.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(H,ae){const ue=mt.get(H);ue.__webglFramebuffer=ae,ue.__useDefaultFramebuffer=ae===void 0},this.setRenderTarget=function(H,ae=0,ue=0){$=H,N=ae,M=ue;let xe=!0,me=null,We=!1,Ye=!1;if(H){const Ue=mt.get(H);Ue.__useDefaultFramebuffer!==void 0?(He.bindFramebuffer(fe.FRAMEBUFFER,null),xe=!1):Ue.__webglFramebuffer===void 0?oe.setupRenderTarget(H):Ue.__hasExternalTextures&&oe.rebindTextures(H,mt.get(H.texture).__webglTexture,mt.get(H.depthTexture).__webglTexture);const Bt=H.texture;(Bt.isData3DTexture||Bt.isDataArrayTexture||Bt.isCompressedArrayTexture)&&(Ye=!0);const dt=mt.get(H).__webglFramebuffer;H.isWebGLCubeRenderTarget?(Array.isArray(dt[ae])?me=dt[ae][ue]:me=dt[ae],We=!0):it.isWebGL2&&H.samples>0&&oe.useMultisampledRTT(H)===!1?me=mt.get(H).__webglMultisampledFramebuffer:Array.isArray(dt)?me=dt[ue]:me=dt,R.copy(H.viewport),P.copy(H.scissor),B=H.scissorTest}else R.copy(K).multiplyScalar(se).floor(),P.copy(G).multiplyScalar(se).floor(),B=Q;if(He.bindFramebuffer(fe.FRAMEBUFFER,me)&&it.drawBuffers&&xe&&He.drawBuffers(H,me),He.viewport(R),He.scissor(P),He.setScissorTest(B),We){const Ue=mt.get(H.texture);fe.framebufferTexture2D(fe.FRAMEBUFFER,fe.COLOR_ATTACHMENT0,fe.TEXTURE_CUBE_MAP_POSITIVE_X+ae,Ue.__webglTexture,ue)}else if(Ye){const Ue=mt.get(H.texture),Bt=ae||0;fe.framebufferTextureLayer(fe.FRAMEBUFFER,fe.COLOR_ATTACHMENT0,Ue.__webglTexture,ue||0,Bt)}L=-1},this.readRenderTargetPixels=function(H,ae,ue,xe,me,We,Ye){if(!(H&&H.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let et=mt.get(H).__webglFramebuffer;if(H.isWebGLCubeRenderTarget&&Ye!==void 0&&(et=et[Ye]),et){He.bindFramebuffer(fe.FRAMEBUFFER,et);try{const Ue=H.texture,Bt=Ue.format,dt=Ue.type;if(Bt!==go&&Vt.convert(Bt)!==fe.getParameter(fe.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const gt=dt===vo&&(Xe.has("EXT_color_buffer_half_float")||it.isWebGL2&&Xe.has("EXT_color_buffer_float"));if(dt!==Ki&&Vt.convert(dt)!==fe.getParameter(fe.IMPLEMENTATION_COLOR_READ_TYPE)&&!(dt===Di&&(it.isWebGL2||Xe.has("OES_texture_float")||Xe.has("WEBGL_color_buffer_float")))&&!gt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}ae>=0&&ae<=H.width-xe&&ue>=0&&ue<=H.height-me&&fe.readPixels(ae,ue,xe,me,Vt.convert(Bt),Vt.convert(dt),We)}finally{const Ue=$!==null?mt.get($).__webglFramebuffer:null;He.bindFramebuffer(fe.FRAMEBUFFER,Ue)}}},this.copyFramebufferToTexture=function(H,ae,ue=0){const xe=Math.pow(2,-ue),me=Math.floor(ae.image.width*xe),We=Math.floor(ae.image.height*xe);oe.setTexture2D(ae,0),fe.copyTexSubImage2D(fe.TEXTURE_2D,ue,0,0,H.x,H.y,me,We),He.unbindTexture()},this.copyTextureToTexture=function(H,ae,ue,xe=0){const me=ae.image.width,We=ae.image.height,Ye=Vt.convert(ue.format),et=Vt.convert(ue.type);oe.setTexture2D(ue,0),fe.pixelStorei(fe.UNPACK_FLIP_Y_WEBGL,ue.flipY),fe.pixelStorei(fe.UNPACK_PREMULTIPLY_ALPHA_WEBGL,ue.premultiplyAlpha),fe.pixelStorei(fe.UNPACK_ALIGNMENT,ue.unpackAlignment),ae.isDataTexture?fe.texSubImage2D(fe.TEXTURE_2D,xe,H.x,H.y,me,We,Ye,et,ae.image.data):ae.isCompressedTexture?fe.compressedTexSubImage2D(fe.TEXTURE_2D,xe,H.x,H.y,ae.mipmaps[0].width,ae.mipmaps[0].height,Ye,ae.mipmaps[0].data):fe.texSubImage2D(fe.TEXTURE_2D,xe,H.x,H.y,Ye,et,ae.image),xe===0&&ue.generateMipmaps&&fe.generateMipmap(fe.TEXTURE_2D),He.unbindTexture()},this.copyTextureToTexture3D=function(H,ae,ue,xe,me=0){if(T.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const We=H.max.x-H.min.x+1,Ye=H.max.y-H.min.y+1,et=H.max.z-H.min.z+1,Ue=Vt.convert(xe.format),Bt=Vt.convert(xe.type);let dt;if(xe.isData3DTexture)oe.setTexture3D(xe,0),dt=fe.TEXTURE_3D;else if(xe.isDataArrayTexture||xe.isCompressedArrayTexture)oe.setTexture2DArray(xe,0),dt=fe.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}fe.pixelStorei(fe.UNPACK_FLIP_Y_WEBGL,xe.flipY),fe.pixelStorei(fe.UNPACK_PREMULTIPLY_ALPHA_WEBGL,xe.premultiplyAlpha),fe.pixelStorei(fe.UNPACK_ALIGNMENT,xe.unpackAlignment);const gt=fe.getParameter(fe.UNPACK_ROW_LENGTH),Ut=fe.getParameter(fe.UNPACK_IMAGE_HEIGHT),tn=fe.getParameter(fe.UNPACK_SKIP_PIXELS),on=fe.getParameter(fe.UNPACK_SKIP_ROWS),vn=fe.getParameter(fe.UNPACK_SKIP_IMAGES),kt=ue.isCompressedTexture?ue.mipmaps[me]:ue.image;fe.pixelStorei(fe.UNPACK_ROW_LENGTH,kt.width),fe.pixelStorei(fe.UNPACK_IMAGE_HEIGHT,kt.height),fe.pixelStorei(fe.UNPACK_SKIP_PIXELS,H.min.x),fe.pixelStorei(fe.UNPACK_SKIP_ROWS,H.min.y),fe.pixelStorei(fe.UNPACK_SKIP_IMAGES,H.min.z),ue.isDataTexture||ue.isData3DTexture?fe.texSubImage3D(dt,me,ae.x,ae.y,ae.z,We,Ye,et,Ue,Bt,kt.data):ue.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),fe.compressedTexSubImage3D(dt,me,ae.x,ae.y,ae.z,We,Ye,et,Ue,kt.data)):fe.texSubImage3D(dt,me,ae.x,ae.y,ae.z,We,Ye,et,Ue,Bt,kt),fe.pixelStorei(fe.UNPACK_ROW_LENGTH,gt),fe.pixelStorei(fe.UNPACK_IMAGE_HEIGHT,Ut),fe.pixelStorei(fe.UNPACK_SKIP_PIXELS,tn),fe.pixelStorei(fe.UNPACK_SKIP_ROWS,on),fe.pixelStorei(fe.UNPACK_SKIP_IMAGES,vn),me===0&&xe.generateMipmaps&&fe.generateMipmap(dt),He.unbindTexture()},this.initTexture=function(H){H.isCubeTexture?oe.setTextureCube(H,0):H.isData3DTexture?oe.setTexture3D(H,0):H.isDataArrayTexture||H.isCompressedArrayTexture?oe.setTexture2DArray(H,0):oe.setTexture2D(H,0),He.unbindTexture()},this.resetState=function(){N=0,M=0,$=null,He.reset(),cn.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return cu}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=e===H_?"display-p3":"srgb",t.unpackColorSpace=$r.workingColorSpace===Gx?"display-p3":"srgb"}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===sr?bd:NA}set outputEncoding(e){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=e===bd?sr:xl}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(e){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=e}}class nz extends BA{}nz.prototype.isWebGL1Renderer=!0;class K_{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new Nt(e),this.density=t}clone(){return new K_(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class Y_{constructor(e,t=1,r=1e3){this.isFog=!0,this.name="",this.color=new Nt(e),this.near=t,this.far=r}clone(){return new Y_(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class Lp extends dr{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t}}class Z_{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=ox,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=Ha()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return console.warn("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,r){e*=this.stride,r*=t.stride;for(let s=0,i=this.stride;s<i;s++)this.array[e+s]=t.array[r+s];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ha()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),r=new this.constructor(t,this.stride);return r.setUsage(this.usage),r}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ha()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Fo=new le;class Op{constructor(e,t,r,s=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=r,this.normalized=s}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,r=this.data.count;t<r;t++)Fo.fromBufferAttribute(this,t),Fo.applyMatrix4(e),this.setXYZ(t,Fo.x,Fo.y,Fo.z);return this}applyNormalMatrix(e){for(let t=0,r=this.count;t<r;t++)Fo.fromBufferAttribute(this,t),Fo.applyNormalMatrix(e),this.setXYZ(t,Fo.x,Fo.y,Fo.z);return this}transformDirection(e){for(let t=0,r=this.count;t<r;t++)Fo.fromBufferAttribute(this,t),Fo.transformDirection(e),this.setXYZ(t,Fo.x,Fo.y,Fo.z);return this}setX(e,t){return this.normalized&&(t=Vn(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=Vn(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=Vn(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=Vn(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=xa(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=xa(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=xa(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=xa(t,this.array)),t}setXY(e,t,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=Vn(t,this.array),r=Vn(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=r,this}setXYZ(e,t,r,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=Vn(t,this.array),r=Vn(r,this.array),s=Vn(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=r,this.data.array[e+2]=s,this}setXYZW(e,t,r,s,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=Vn(t,this.array),r=Vn(r,this.array),s=Vn(s,this.array),i=Vn(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=r,this.data.array[e+2]=s,this.data.array[e+3]=i,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let r=0;r<this.count;r++){const s=r*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)t.push(this.data.array[s+i])}return new Cr(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Op(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let r=0;r<this.count;r++){const s=r*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)t.push(this.data.array[s+i])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class UA extends Si{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Nt(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let Rg;const hv=new le,Dg=new le,$g=new le,Pg=new rt,dv=new rt,rz=new _n,Lb=new le,fv=new le,Ob=new le,Z$=new rt,n2=new rt,J$=new rt;class sz extends dr{constructor(e=new UA){if(super(),this.isSprite=!0,this.type="Sprite",Rg===void 0){Rg=new zn;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),r=new Z_(t,5);Rg.setIndex([0,1,2,0,2,3]),Rg.setAttribute("position",new Op(r,3,0,!1)),Rg.setAttribute("uv",new Op(r,2,3,!1))}this.geometry=Rg,this.material=e,this.center=new rt(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Dg.setFromMatrixScale(this.matrixWorld),rz.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),$g.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Dg.multiplyScalar(-$g.z);const r=this.material.rotation;let s,i;r!==0&&(i=Math.cos(r),s=Math.sin(r));const o=this.center;Fb(Lb.set(-.5,-.5,0),$g,o,Dg,s,i),Fb(fv.set(.5,-.5,0),$g,o,Dg,s,i),Fb(Ob.set(.5,.5,0),$g,o,Dg,s,i),Z$.set(0,0),n2.set(1,0),J$.set(1,1);let a=e.ray.intersectTriangle(Lb,fv,Ob,!1,hv);if(a===null&&(Fb(fv.set(-.5,.5,0),$g,o,Dg,s,i),n2.set(0,1),a=e.ray.intersectTriangle(Lb,Ob,fv,!1,hv),a===null))return;const l=e.ray.origin.distanceTo(hv);l<e.near||l>e.far||t.push({distance:l,point:hv.clone(),uv:va.getInterpolation(hv,Lb,fv,Ob,Z$,n2,J$,new rt),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function Fb(n,e,t,r,s,i){Pg.subVectors(n,t).addScalar(.5).multiply(r),s!==void 0?(dv.x=i*Pg.x-s*Pg.y,dv.y=s*Pg.x+i*Pg.y):dv.copy(Pg),n.copy(e),n.x+=dv.x,n.y+=dv.y,n.applyMatrix4(rz)}const zb=new le,Q$=new le;class iz extends dr{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let r=0,s=t.length;r<s;r++){const i=t[r];this.addLevel(i.object.clone(),i.distance,i.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,r=0){t=Math.abs(t);const s=this.levels;let i;for(i=0;i<s.length&&!(t<s[i].distance);i++);return s.splice(i,0,{distance:t,hysteresis:r,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let r,s;for(r=1,s=t.length;r<s;r++){let i=t[r].distance;if(t[r].object.visible&&(i-=i*t[r].hysteresis),e<i)break}return t[r-1].object}return null}raycast(e,t){if(this.levels.length>0){zb.setFromMatrixPosition(this.matrixWorld);const s=e.ray.origin.distanceTo(zb);this.getObjectForDistance(s).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){zb.setFromMatrixPosition(e.matrixWorld),Q$.setFromMatrixPosition(this.matrixWorld);const r=zb.distanceTo(Q$)/e.zoom;t[0].object.visible=!0;let s,i;for(s=1,i=t.length;s<i;s++){let o=t[s].distance;if(t[s].object.visible&&(o-=o*t[s].hysteresis),r>=o)t[s-1].object.visible=!1,t[s].object.visible=!0;else break}for(this._currentLevel=s-1;s<i;s++)t[s].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const r=this.levels;for(let s=0,i=r.length;s<i;s++){const o=r[s];t.object.levels.push({object:o.object.uuid,distance:o.distance,hysteresis:o.hysteresis})}return t}}const e3=new le,t3=new br,n3=new br,IK=new le,r3=new _n,Bb=new le,r2=new So,s3=new _n,s2=new Oy;class oz extends zs{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=mI,this.bindMatrix=new _n,this.bindMatrixInverse=new _n,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new jo),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let r=0;r<t.count;r++)this.getVertexPosition(r,Bb),this.boundingBox.expandByPoint(Bb)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new So),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let r=0;r<t.count;r++)this.getVertexPosition(r,Bb),this.boundingSphere.expandByPoint(Bb)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const r=this.material,s=this.matrixWorld;r!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),r2.copy(this.boundingSphere),r2.applyMatrix4(s),e.ray.intersectsSphere(r2)!==!1&&(s3.copy(s).invert(),s2.copy(e.ray).applyMatrix4(s3),!(this.boundingBox!==null&&s2.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,s2)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new br,t=this.geometry.attributes.skinWeight;for(let r=0,s=t.count;r<s;r++){e.fromBufferAttribute(t,r);const i=1/e.manhattanLength();i!==1/0?e.multiplyScalar(i):e.set(1,0,0,0),t.setXYZW(r,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===mI?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===SF?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const r=this.skeleton,s=this.geometry;t3.fromBufferAttribute(s.attributes.skinIndex,e),n3.fromBufferAttribute(s.attributes.skinWeight,e),e3.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let i=0;i<4;i++){const o=n3.getComponent(i);if(o!==0){const a=t3.getComponent(i);r3.multiplyMatrices(r.bones[a].matrixWorld,r.boneInverses[a]),t.addScaledVector(IK.copy(e3).applyMatrix4(r3),o)}}return t.applyMatrix4(this.bindMatrixInverse)}boneTransform(e,t){return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),this.applyBoneTransform(e,t)}}class VA extends dr{constructor(){super(),this.isBone=!0,this.type="Bone"}}class Mp extends fs{constructor(e=null,t=1,r=1,s,i,o,a,l,u=ss,c=ss,h,d){super(null,o,a,l,u,c,s,i,h,d),this.isDataTexture=!0,this.image={data:e,width:t,height:r},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const i3=new _n,NK=new _n;class J_{constructor(e=[],t=[]){this.uuid=Ha(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let r=0,s=this.bones.length;r<s;r++)this.boneInverses.push(new _n)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const r=new _n;this.bones[e]&&r.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(r)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const r=this.bones[e];r&&r.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const r=this.bones[e];r&&(r.parent&&r.parent.isBone?(r.matrix.copy(r.parent.matrixWorld).invert(),r.matrix.multiply(r.matrixWorld)):r.matrix.copy(r.matrixWorld),r.matrix.decompose(r.position,r.quaternion,r.scale))}}update(){const e=this.bones,t=this.boneInverses,r=this.boneMatrices,s=this.boneTexture;for(let i=0,o=e.length;i<o;i++){const a=e[i]?e[i].matrixWorld:NK;i3.multiplyMatrices(a,t[i]),i3.toArray(r,i*16)}s!==null&&(s.needsUpdate=!0)}clone(){return new J_(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const r=new Mp(t,e,e,go,Di);return r.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=r,this}getBoneByName(e){for(let t=0,r=this.bones.length;t<r;t++){const s=this.bones[t];if(s.name===e)return s}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let r=0,s=e.bones.length;r<s;r++){const i=e.bones[r];let o=t[i];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),o=new VA),this.bones.push(o),this.boneInverses.push(new _n().fromArray(e.boneInverses[r]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,r=this.boneInverses;for(let s=0,i=t.length;s<i;s++){const o=t[s];e.bones.push(o.uuid);const a=r[s];e.boneInverses.push(a.toArray())}return e}}class xy extends Cr{constructor(e,t,r,s=1){super(e,t,r),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=s}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const Lg=new _n,o3=new _n,Ub=[],a3=new jo,AK=new _n,pv=new zs,mv=new So;class az extends zs{constructor(e,t,r){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new xy(new Float32Array(r*16),16),this.instanceColor=null,this.count=r,this.boundingBox=null,this.boundingSphere=null;for(let s=0;s<r;s++)this.setMatrixAt(s,AK)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new jo),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let r=0;r<t;r++)this.getMatrixAt(r,Lg),a3.copy(e.boundingBox).applyMatrix4(Lg),this.boundingBox.union(a3)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new So),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let r=0;r<t;r++)this.getMatrixAt(r,Lg),mv.copy(e.boundingSphere).applyMatrix4(Lg),this.boundingSphere.union(mv)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const r=this.matrixWorld,s=this.count;if(pv.geometry=this.geometry,pv.material=this.material,pv.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),mv.copy(this.boundingSphere),mv.applyMatrix4(r),e.ray.intersectsSphere(mv)!==!1))for(let i=0;i<s;i++){this.getMatrixAt(i,Lg),o3.multiplyMatrices(r,Lg),pv.matrixWorld=o3,pv.raycast(e,Ub);for(let o=0,a=Ub.length;o<a;o++){const l=Ub[o];l.instanceId=i,l.object=this,t.push(l)}Ub.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new xy(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}function MK(n,e){return n.z-e.z}function kK(n,e){return e.z-n.z}class RK{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,t){const r=this.pool,s=this.list;this.index>=r.length&&r.push({start:-1,count:-1,z:-1});const i=r[this.index];s.push(i),this.index++,i.start=e.start,i.count=e.count,i.z=t}reset(){this.list.length=0,this.index=0}}const Og="batchId",od=new _n,l3=new _n,DK=new _n,u3=new _n,i2=new Xx,Vb=new jo,Jf=new So,gv=new le,o2=new RK,co=new zs,Wb=[];function $K(n,e,t=0){const r=e.itemSize;if(n.isInterleavedBufferAttribute||n.array.constructor!==e.array.constructor){const s=n.count;for(let i=0;i<s;i++)for(let o=0;o<r;o++)e.setComponent(i+t,o,n.getComponent(i,o))}else e.array.set(n.array,t*r);e.needsUpdate=!0}class lz extends zs{get maxGeometryCount(){return this._maxGeometryCount}constructor(e,t,r=t*2,s){super(new zn,s),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._drawRanges=[],this._reservedRanges=[],this._visibility=[],this._active=[],this._bounds=[],this._maxGeometryCount=e,this._maxVertexCount=t,this._maxIndexCount=r,this._geometryInitialized=!1,this._geometryCount=0,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._visibilityChanged=!0,this._matricesTexture=null,this._initMatricesTexture()}_initMatricesTexture(){let e=Math.sqrt(this._maxGeometryCount*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4),r=new Mp(t,e,e,go,Di);this._matricesTexture=r}_initializeGeometry(e){const t=this.geometry,r=this._maxVertexCount,s=this._maxGeometryCount,i=this._maxIndexCount;if(this._geometryInitialized===!1){for(const a in e.attributes){const l=e.getAttribute(a),{array:u,itemSize:c,normalized:h}=l,d=new u.constructor(r*c),p=new l.constructor(d,c,h);p.setUsage(l.usage),t.setAttribute(a,p)}if(e.getIndex()!==null){const a=r>65536?new Uint32Array(i):new Uint16Array(i);t.setIndex(new Cr(a,1))}const o=s>65536?new Uint32Array(r):new Uint16Array(r);t.setAttribute(Og,new Cr(o,1)),this._geometryInitialized=!0}}_validateGeometry(e){if(e.getAttribute(Og))throw new Error(`BatchedMesh: Geometry cannot use attribute "${Og}"`);const t=this.geometry;if(!!e.getIndex()!=!!t.getIndex())throw new Error('BatchedMesh: All geometries must consistently have "index".');for(const r in t.attributes){if(r===Og)continue;if(!e.hasAttribute(r))throw new Error(`BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`);const s=e.getAttribute(r),i=t.getAttribute(r);if(s.itemSize!==i.itemSize||s.normalized!==i.normalized)throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new jo);const e=this._geometryCount,t=this.boundingBox,r=this._active;t.makeEmpty();for(let s=0;s<e;s++)r[s]!==!1&&(this.getMatrixAt(s,od),this.getBoundingBoxAt(s,Vb).applyMatrix4(od),t.union(Vb))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new So);const e=this._geometryCount,t=this.boundingSphere,r=this._active;t.makeEmpty();for(let s=0;s<e;s++)r[s]!==!1&&(this.getMatrixAt(s,od),this.getBoundingSphereAt(s,Jf).applyMatrix4(od),t.union(Jf))}addGeometry(e,t=-1,r=-1){if(this._initializeGeometry(e),this._validateGeometry(e),this._geometryCount>=this._maxGeometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");const s={vertexStart:-1,vertexCount:-1,indexStart:-1,indexCount:-1};let i=null;const o=this._reservedRanges,a=this._drawRanges,l=this._bounds;this._geometryCount!==0&&(i=o[o.length-1]),t===-1?s.vertexCount=e.getAttribute("position").count:s.vertexCount=t,i===null?s.vertexStart=0:s.vertexStart=i.vertexStart+i.vertexCount;const u=e.getIndex(),c=u!==null;if(c&&(r===-1?s.indexCount=u.count:s.indexCount=r,i===null?s.indexStart=0:s.indexStart=i.indexStart+i.indexCount),s.indexStart!==-1&&s.indexStart+s.indexCount>this._maxIndexCount||s.vertexStart+s.vertexCount>this._maxVertexCount)throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");const h=this._visibility,d=this._active,p=this._matricesTexture,g=this._matricesTexture.image.data;h.push(!0),d.push(!0);const w=this._geometryCount;this._geometryCount++,DK.toArray(g,w*16),p.needsUpdate=!0,o.push(s),a.push({start:c?s.indexStart:s.vertexStart,count:-1}),l.push({boxInitialized:!1,box:new jo,sphereInitialized:!1,sphere:new So});const y=this.geometry.getAttribute(Og);for(let x=0;x<s.vertexCount;x++)y.setX(s.vertexStart+x,w);return y.needsUpdate=!0,this.setGeometryAt(w,e),w}setGeometryAt(e,t){if(e>=this._geometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");this._validateGeometry(t);const r=this.geometry,s=r.getIndex()!==null,i=r.getIndex(),o=t.getIndex(),a=this._reservedRanges[e];if(s&&o.count>a.indexCount||t.attributes.position.count>a.vertexCount)throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");const l=a.vertexStart,u=a.vertexCount;for(const p in r.attributes){if(p===Og)continue;const g=t.getAttribute(p),w=r.getAttribute(p);$K(g,w,l);const y=g.itemSize;for(let x=g.count,_=u;x<_;x++){const T=l+x;for(let E=0;E<y;E++)w.setComponent(T,E,0)}w.needsUpdate=!0}if(s){const p=a.indexStart;for(let g=0;g<o.count;g++)i.setX(p+g,l+o.getX(g));for(let g=o.count,w=a.indexCount;g<w;g++)i.setX(p+g,l);i.needsUpdate=!0}const c=this._bounds[e];t.boundingBox!==null?(c.box.copy(t.boundingBox),c.boxInitialized=!0):c.boxInitialized=!1,t.boundingSphere!==null?(c.sphere.copy(t.boundingSphere),c.sphereInitialized=!0):c.sphereInitialized=!1;const h=this._drawRanges[e],d=t.getAttribute("position");return h.count=s?o.count:d.count,this._visibilityChanged=!0,e}deleteGeometry(e){const t=this._active;return e>=t.length||t[e]===!1?this:(t[e]=!1,this._visibilityChanged=!0,this)}getBoundingBoxAt(e,t){if(this._active[e]===!1)return this;const s=this._bounds[e],i=s.box,o=this.geometry;if(s.boxInitialized===!1){i.makeEmpty();const a=o.index,l=o.attributes.position,u=this._drawRanges[e];for(let c=u.start,h=u.start+u.count;c<h;c++){let d=c;a&&(d=a.getX(d)),i.expandByPoint(gv.fromBufferAttribute(l,d))}s.boxInitialized=!0}return t.copy(i),t}getBoundingSphereAt(e,t){if(this._active[e]===!1)return this;const s=this._bounds[e],i=s.sphere,o=this.geometry;if(s.sphereInitialized===!1){i.makeEmpty(),this.getBoundingBoxAt(e,Vb),Vb.getCenter(i.center);const a=o.index,l=o.attributes.position,u=this._drawRanges[e];let c=0;for(let h=u.start,d=u.start+u.count;h<d;h++){let p=h;a&&(p=a.getX(p)),gv.fromBufferAttribute(l,p),c=Math.max(c,i.center.distanceToSquared(gv))}i.radius=Math.sqrt(c),s.sphereInitialized=!0}return t.copy(i),t}setMatrixAt(e,t){const r=this._active,s=this._matricesTexture,i=this._matricesTexture.image.data,o=this._geometryCount;return e>=o||r[e]===!1?this:(t.toArray(i,e*16),s.needsUpdate=!0,this)}getMatrixAt(e,t){const r=this._active,s=this._matricesTexture.image.data,i=this._geometryCount;return e>=i||r[e]===!1?null:t.fromArray(s,e*16)}setVisibleAt(e,t){const r=this._visibility,s=this._active,i=this._geometryCount;return e>=i||s[e]===!1||r[e]===t?this:(r[e]=t,this._visibilityChanged=!0,this)}getVisibleAt(e){const t=this._visibility,r=this._active,s=this._geometryCount;return e>=s||r[e]===!1?!1:t[e]}raycast(e,t){const r=this._visibility,s=this._active,i=this._drawRanges,o=this._geometryCount,a=this.matrixWorld,l=this.geometry;co.material=this.material,co.geometry.index=l.index,co.geometry.attributes=l.attributes,co.geometry.boundingBox===null&&(co.geometry.boundingBox=new jo),co.geometry.boundingSphere===null&&(co.geometry.boundingSphere=new So);for(let u=0;u<o;u++){if(!r[u]||!s[u])continue;const c=i[u];co.geometry.setDrawRange(c.start,c.count),this.getMatrixAt(u,co.matrixWorld).premultiply(a),this.getBoundingBoxAt(u,co.geometry.boundingBox),this.getBoundingSphereAt(u,co.geometry.boundingSphere),co.raycast(e,Wb);for(let h=0,d=Wb.length;h<d;h++){const p=Wb[h];p.object=this,p.batchId=u,t.push(p)}Wb.length=0}co.material=null,co.geometry.index=null,co.geometry.attributes={},co.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=e.boundingBox!==null?e.boundingBox.clone():null,this.boundingSphere=e.boundingSphere!==null?e.boundingSphere.clone():null,this._drawRanges=e._drawRanges.map(t=>({...t})),this._reservedRanges=e._reservedRanges.map(t=>({...t})),this._visibility=e._visibility.slice(),this._active=e._active.slice(),this._bounds=e._bounds.map(t=>({boxInitialized:t.boxInitialized,box:t.box.clone(),sphereInitialized:t.sphereInitialized,sphere:t.sphere.clone()})),this._maxGeometryCount=e._maxGeometryCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._geometryCount=e._geometryCount,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.slice(),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this}onBeforeRender(e,t,r,s,i){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const o=s.getIndex(),a=o===null?1:o.array.BYTES_PER_ELEMENT,l=this._visibility,u=this._multiDrawStarts,c=this._multiDrawCounts,h=this._drawRanges,d=this.perObjectFrustumCulled;d&&(u3.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse).multiply(this.matrixWorld),i2.setFromProjectionMatrix(u3,e.isWebGPURenderer?gy:cu));let p=0;if(this.sortObjects){l3.copy(this.matrixWorld).invert(),gv.setFromMatrixPosition(r.matrixWorld).applyMatrix4(l3);for(let y=0,x=l.length;y<x;y++)if(l[y]){this.getMatrixAt(y,od),this.getBoundingSphereAt(y,Jf).applyMatrix4(od);let _=!1;if(d&&(_=!i2.intersectsSphere(Jf)),!_){const T=gv.distanceTo(Jf.center);o2.push(h[y],T)}}const g=o2.list,w=this.customSort;w===null?g.sort(i.transparent?kK:MK):w.call(this,g,r);for(let y=0,x=g.length;y<x;y++){const _=g[y];u[p]=_.start*a,c[p]=_.count,p++}o2.reset()}else for(let g=0,w=l.length;g<w;g++)if(l[g]){let y=!1;if(d&&(this.getMatrixAt(g,od),this.getBoundingSphereAt(g,Jf).applyMatrix4(od),y=!i2.intersectsSphere(Jf)),!y){const x=h[g];u[p]=x.start*a,c[p]=x.count,p++}}this._multiDrawCount=p,this._visibilityChanged=!1}onBeforeShadow(e,t,r,s,i,o){this.onBeforeRender(e,null,s,i,o)}}class Jo extends Si{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Nt(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const c3=new le,h3=new le,d3=new _n,a2=new Oy,Gb=new So;class kd extends dr{constructor(e=new zn,t=new Jo){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,r=[0];for(let s=1,i=t.count;s<i;s++)c3.fromBufferAttribute(t,s-1),h3.fromBufferAttribute(t,s),r[s]=r[s-1],r[s]+=c3.distanceTo(h3);e.setAttribute("lineDistance",new Jt(r,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const r=this.geometry,s=this.matrixWorld,i=e.params.Line.threshold,o=r.drawRange;if(r.boundingSphere===null&&r.computeBoundingSphere(),Gb.copy(r.boundingSphere),Gb.applyMatrix4(s),Gb.radius+=i,e.ray.intersectsSphere(Gb)===!1)return;d3.copy(s).invert(),a2.copy(e.ray).applyMatrix4(d3);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,u=new le,c=new le,h=new le,d=new le,p=this.isLineSegments?2:1,g=r.index,y=r.attributes.position;if(g!==null){const x=Math.max(0,o.start),_=Math.min(g.count,o.start+o.count);for(let T=x,E=_-1;T<E;T+=p){const N=g.getX(T),M=g.getX(T+1);if(u.fromBufferAttribute(y,N),c.fromBufferAttribute(y,M),a2.distanceSqToSegment(u,c,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const L=e.ray.origin.distanceTo(d);L<e.near||L>e.far||t.push({distance:L,point:h.clone().applyMatrix4(this.matrixWorld),index:T,face:null,faceIndex:null,object:this})}}else{const x=Math.max(0,o.start),_=Math.min(y.count,o.start+o.count);for(let T=x,E=_-1;T<E;T+=p){if(u.fromBufferAttribute(y,T),c.fromBufferAttribute(y,T+1),a2.distanceSqToSegment(u,c,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const M=e.ray.origin.distanceTo(d);M<e.near||M>e.far||t.push({distance:M,point:h.clone().applyMatrix4(this.matrixWorld),index:T,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,r=Object.keys(t);if(r.length>0){const s=t[r[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=s.length;i<o;i++){const a=s[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}}const f3=new le,p3=new le;class ac extends kd{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,r=[];for(let s=0,i=t.count;s<i;s+=2)f3.fromBufferAttribute(t,s),p3.fromBufferAttribute(t,s+1),r[s]=s===0?0:r[s-1],r[s+1]=r[s]+f3.distanceTo(p3);e.setAttribute("lineDistance",new Jt(r,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class uz extends kd{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class WA extends Si{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Nt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const m3=new _n,jI=new Oy,Hb=new So,jb=new le;class cz extends dr{constructor(e=new zn,t=new WA){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const r=this.geometry,s=this.matrixWorld,i=e.params.Points.threshold,o=r.drawRange;if(r.boundingSphere===null&&r.computeBoundingSphere(),Hb.copy(r.boundingSphere),Hb.applyMatrix4(s),Hb.radius+=i,e.ray.intersectsSphere(Hb)===!1)return;m3.copy(s).invert(),jI.copy(e.ray).applyMatrix4(m3);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,u=r.index,h=r.attributes.position;if(u!==null){const d=Math.max(0,o.start),p=Math.min(u.count,o.start+o.count);for(let g=d,w=p;g<w;g++){const y=u.getX(g);jb.fromBufferAttribute(h,y),g3(jb,y,l,s,e,t,this)}}else{const d=Math.max(0,o.start),p=Math.min(h.count,o.start+o.count);for(let g=d,w=p;g<w;g++)jb.fromBufferAttribute(h,g),g3(jb,g,l,s,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,r=Object.keys(t);if(r.length>0){const s=t[r[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=s.length;i<o;i++){const a=s[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}}function g3(n,e,t,r,s,i,o){const a=jI.distanceSqToPoint(n);if(a<t){const l=new le;jI.closestPointToPoint(n,l),l.applyMatrix4(r);const u=s.ray.origin.distanceTo(l);if(u<s.near||u>s.far)return;i.push({distance:u,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}class PK extends fs{constructor(e,t,r,s,i,o,a,l,u){super(e,t,r,s,i,o,a,l,u),this.isVideoTexture=!0,this.minFilter=o!==void 0?o:Lr,this.magFilter=i!==void 0?i:Lr,this.generateMipmaps=!1;const c=this;function h(){c.needsUpdate=!0,e.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(h)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class LK extends fs{constructor(e,t){super({width:e,height:t}),this.isFramebufferTexture=!0,this.magFilter=ss,this.minFilter=ss,this.generateMipmaps=!1,this.needsUpdate=!0}}class Q_ extends fs{constructor(e,t,r,s,i,o,a,l,u,c,h,d){super(null,o,a,l,u,c,s,i,h,d),this.isCompressedTexture=!0,this.image={width:t,height:r},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class OK extends Q_{constructor(e,t,r,s,i,o){super(e,t,r,i,o),this.isCompressedArrayTexture=!0,this.image.depth=s,this.wrapR=mo}}class FK extends Q_{constructor(e,t,r){super(void 0,e[0].width,e[0].height,t,r,tc),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class lx extends fs{constructor(e,t,r,s,i,o,a,l,u){super(e,t,r,s,i,o,a,l,u),this.isCanvasTexture=!0,this.needsUpdate=!0}}class xu{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const r=this.getUtoTmapping(e);return this.getPoint(r,t)}getPoints(e=5){const t=[];for(let r=0;r<=e;r++)t.push(this.getPoint(r/e));return t}getSpacedPoints(e=5){const t=[];for(let r=0;r<=e;r++)t.push(this.getPointAt(r/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let r,s=this.getPoint(0),i=0;t.push(0);for(let o=1;o<=e;o++)r=this.getPoint(o/e),i+=r.distanceTo(s),t.push(i),s=r;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const r=this.getLengths();let s=0;const i=r.length;let o;t?o=t:o=e*r[i-1];let a=0,l=i-1,u;for(;a<=l;)if(s=Math.floor(a+(l-a)/2),u=r[s]-o,u<0)a=s+1;else if(u>0)l=s-1;else{l=s;break}if(s=l,r[s]===o)return s/(i-1);const c=r[s],d=r[s+1]-c,p=(o-c)/d;return(s+p)/(i-1)}getTangent(e,t){let s=e-1e-4,i=e+1e-4;s<0&&(s=0),i>1&&(i=1);const o=this.getPoint(s),a=this.getPoint(i),l=t||(o.isVector2?new rt:new le);return l.copy(a).sub(o).normalize(),l}getTangentAt(e,t){const r=this.getUtoTmapping(e);return this.getTangent(r,t)}computeFrenetFrames(e,t){const r=new le,s=[],i=[],o=[],a=new le,l=new _n;for(let p=0;p<=e;p++){const g=p/e;s[p]=this.getTangentAt(g,new le)}i[0]=new le,o[0]=new le;let u=Number.MAX_VALUE;const c=Math.abs(s[0].x),h=Math.abs(s[0].y),d=Math.abs(s[0].z);c<=u&&(u=c,r.set(1,0,0)),h<=u&&(u=h,r.set(0,1,0)),d<=u&&r.set(0,0,1),a.crossVectors(s[0],r).normalize(),i[0].crossVectors(s[0],a),o[0].crossVectors(s[0],i[0]);for(let p=1;p<=e;p++){if(i[p]=i[p-1].clone(),o[p]=o[p-1].clone(),a.crossVectors(s[p-1],s[p]),a.length()>Number.EPSILON){a.normalize();const g=Math.acos(Es(s[p-1].dot(s[p]),-1,1));i[p].applyMatrix4(l.makeRotationAxis(a,g))}o[p].crossVectors(s[p],i[p])}if(t===!0){let p=Math.acos(Es(i[0].dot(i[e]),-1,1));p/=e,s[0].dot(a.crossVectors(i[0],i[e]))>0&&(p=-p);for(let g=1;g<=e;g++)i[g].applyMatrix4(l.makeRotationAxis(s[g],p*g)),o[g].crossVectors(s[g],i[g])}return{tangents:s,normals:i,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class eT extends xu{constructor(e=0,t=0,r=1,s=1,i=0,o=Math.PI*2,a=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=r,this.yRadius=s,this.aStartAngle=i,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(e,t){const r=t||new rt,s=Math.PI*2;let i=this.aEndAngle-this.aStartAngle;const o=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=s;for(;i>s;)i-=s;i<Number.EPSILON&&(o?i=0:i=s),this.aClockwise===!0&&!o&&(i===s?i=-s:i=i-s);const a=this.aStartAngle+e*i;let l=this.aX+this.xRadius*Math.cos(a),u=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const c=Math.cos(this.aRotation),h=Math.sin(this.aRotation),d=l-this.aX,p=u-this.aY;l=d*c-p*h+this.aX,u=d*h+p*c+this.aY}return r.set(l,u)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class hz extends eT{constructor(e,t,r,s,i,o){super(e,t,r,r,s,i,o),this.isArcCurve=!0,this.type="ArcCurve"}}function GA(){let n=0,e=0,t=0,r=0;function s(i,o,a,l){n=i,e=a,t=-3*i+3*o-2*a-l,r=2*i-2*o+a+l}return{initCatmullRom:function(i,o,a,l,u){s(o,a,u*(a-i),u*(l-o))},initNonuniformCatmullRom:function(i,o,a,l,u,c,h){let d=(o-i)/u-(a-i)/(u+c)+(a-o)/c,p=(a-o)/c-(l-o)/(c+h)+(l-a)/h;d*=c,p*=c,s(o,a,d,p)},calc:function(i){const o=i*i,a=o*i;return n+e*i+t*o+r*a}}}const Xb=new le,l2=new GA,u2=new GA,c2=new GA;class HA extends xu{constructor(e=[],t=!1,r="centripetal",s=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=r,this.tension=s}getPoint(e,t=new le){const r=t,s=this.points,i=s.length,o=(i-(this.closed?0:1))*e;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/i)+1)*i:l===0&&a===i-1&&(a=i-2,l=1);let u,c;this.closed||a>0?u=s[(a-1)%i]:(Xb.subVectors(s[0],s[1]).add(s[0]),u=Xb);const h=s[a%i],d=s[(a+1)%i];if(this.closed||a+2<i?c=s[(a+2)%i]:(Xb.subVectors(s[i-1],s[i-2]).add(s[i-1]),c=Xb),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let g=Math.pow(u.distanceToSquared(h),p),w=Math.pow(h.distanceToSquared(d),p),y=Math.pow(d.distanceToSquared(c),p);w<1e-4&&(w=1),g<1e-4&&(g=w),y<1e-4&&(y=w),l2.initNonuniformCatmullRom(u.x,h.x,d.x,c.x,g,w,y),u2.initNonuniformCatmullRom(u.y,h.y,d.y,c.y,g,w,y),c2.initNonuniformCatmullRom(u.z,h.z,d.z,c.z,g,w,y)}else this.curveType==="catmullrom"&&(l2.initCatmullRom(u.x,h.x,d.x,c.x,this.tension),u2.initCatmullRom(u.y,h.y,d.y,c.y,this.tension),c2.initCatmullRom(u.z,h.z,d.z,c.z,this.tension));return r.set(l2.calc(l),u2.calc(l),c2.calc(l)),r}copy(e){super.copy(e),this.points=[];for(let t=0,r=e.points.length;t<r;t++){const s=e.points[t];this.points.push(s.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,r=this.points.length;t<r;t++){const s=this.points[t];e.points.push(s.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,r=e.points.length;t<r;t++){const s=e.points[t];this.points.push(new le().fromArray(s))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function y3(n,e,t,r,s){const i=(r-e)*.5,o=(s-t)*.5,a=n*n,l=n*a;return(2*t-2*r+i+o)*l+(-3*t+3*r-2*i-o)*a+i*n+t}function zK(n,e){const t=1-n;return t*t*e}function BK(n,e){return 2*(1-n)*n*e}function UK(n,e){return n*n*e}function Gv(n,e,t,r){return zK(n,e)+BK(n,t)+UK(n,r)}function VK(n,e){const t=1-n;return t*t*t*e}function WK(n,e){const t=1-n;return 3*t*t*n*e}function GK(n,e){return 3*(1-n)*n*n*e}function HK(n,e){return n*n*n*e}function Hv(n,e,t,r,s){return VK(n,e)+WK(n,t)+GK(n,r)+HK(n,s)}class jA extends xu{constructor(e=new rt,t=new rt,r=new rt,s=new rt){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=r,this.v3=s}getPoint(e,t=new rt){const r=t,s=this.v0,i=this.v1,o=this.v2,a=this.v3;return r.set(Hv(e,s.x,i.x,o.x,a.x),Hv(e,s.y,i.y,o.y,a.y)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class dz extends xu{constructor(e=new le,t=new le,r=new le,s=new le){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=r,this.v3=s}getPoint(e,t=new le){const r=t,s=this.v0,i=this.v1,o=this.v2,a=this.v3;return r.set(Hv(e,s.x,i.x,o.x,a.x),Hv(e,s.y,i.y,o.y,a.y),Hv(e,s.z,i.z,o.z,a.z)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class XA extends xu{constructor(e=new rt,t=new rt){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new rt){const r=t;return e===1?r.copy(this.v2):(r.copy(this.v2).sub(this.v1),r.multiplyScalar(e).add(this.v1)),r}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new rt){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class fz extends xu{constructor(e=new le,t=new le){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new le){const r=t;return e===1?r.copy(this.v2):(r.copy(this.v2).sub(this.v1),r.multiplyScalar(e).add(this.v1)),r}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new le){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class qA extends xu{constructor(e=new rt,t=new rt,r=new rt){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=r}getPoint(e,t=new rt){const r=t,s=this.v0,i=this.v1,o=this.v2;return r.set(Gv(e,s.x,i.x,o.x),Gv(e,s.y,i.y,o.y)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class KA extends xu{constructor(e=new le,t=new le,r=new le){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=r}getPoint(e,t=new le){const r=t,s=this.v0,i=this.v1,o=this.v2;return r.set(Gv(e,s.x,i.x,o.x),Gv(e,s.y,i.y,o.y),Gv(e,s.z,i.z,o.z)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class YA extends xu{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new rt){const r=t,s=this.points,i=(s.length-1)*e,o=Math.floor(i),a=i-o,l=s[o===0?o:o-1],u=s[o],c=s[o>s.length-2?s.length-1:o+1],h=s[o>s.length-3?s.length-1:o+2];return r.set(y3(a,l.x,u.x,c.x,h.x),y3(a,l.y,u.y,c.y,h.y)),r}copy(e){super.copy(e),this.points=[];for(let t=0,r=e.points.length;t<r;t++){const s=e.points[t];this.points.push(s.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,r=this.points.length;t<r;t++){const s=this.points[t];e.points.push(s.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,r=e.points.length;t<r;t++){const s=e.points[t];this.points.push(new rt().fromArray(s))}return this}}var JS=Object.freeze({__proto__:null,ArcCurve:hz,CatmullRomCurve3:HA,CubicBezierCurve:jA,CubicBezierCurve3:dz,EllipseCurve:eT,LineCurve:XA,LineCurve3:fz,QuadraticBezierCurve:qA,QuadraticBezierCurve3:KA,SplineCurve:YA});class pz extends xu{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(t)){const r=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new JS[r](t,e))}return this}getPoint(e,t){const r=e*this.getLength(),s=this.getCurveLengths();let i=0;for(;i<s.length;){if(s[i]>=r){const o=s[i]-r,a=this.curves[i],l=a.getLength(),u=l===0?0:1-o/l;return a.getPointAt(u,t)}i++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let r=0,s=this.curves.length;r<s;r++)t+=this.curves[r].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let r=0;r<=e;r++)t.push(this.getPoint(r/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let r;for(let s=0,i=this.curves;s<i.length;s++){const o=i[s],a=o.isEllipseCurve?e*2:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?e*o.points.length:e,l=o.getPoints(a);for(let u=0;u<l.length;u++){const c=l[u];r&&r.equals(c)||(t.push(c),r=c)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,r=e.curves.length;t<r;t++){const s=e.curves[t];this.curves.push(s.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,r=this.curves.length;t<r;t++){const s=this.curves[t];e.curves.push(s.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,r=e.curves.length;t<r;t++){const s=e.curves[t];this.curves.push(new JS[s.type]().fromJSON(s))}return this}}class ux extends pz{constructor(e){super(),this.type="Path",this.currentPoint=new rt,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,r=e.length;t<r;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const r=new XA(this.currentPoint.clone(),new rt(e,t));return this.curves.push(r),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,r,s){const i=new qA(this.currentPoint.clone(),new rt(e,t),new rt(r,s));return this.curves.push(i),this.currentPoint.set(r,s),this}bezierCurveTo(e,t,r,s,i,o){const a=new jA(this.currentPoint.clone(),new rt(e,t),new rt(r,s),new rt(i,o));return this.curves.push(a),this.currentPoint.set(i,o),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),r=new YA(t);return this.curves.push(r),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,r,s,i,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+a,t+l,r,s,i,o),this}absarc(e,t,r,s,i,o){return this.absellipse(e,t,r,r,s,i,o),this}ellipse(e,t,r,s,i,o,a,l){const u=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+u,t+c,r,s,i,o,a,l),this}absellipse(e,t,r,s,i,o,a,l){const u=new eT(e,t,r,s,i,o,a,l);if(this.curves.length>0){const h=u.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(u);const c=u.getPoint(1);return this.currentPoint.copy(c),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Kx extends zn{constructor(e=[new rt(0,-.5),new rt(.5,0),new rt(0,.5)],t=12,r=0,s=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:r,phiLength:s},t=Math.floor(t),s=Es(s,0,Math.PI*2);const i=[],o=[],a=[],l=[],u=[],c=1/t,h=new le,d=new rt,p=new le,g=new le,w=new le;let y=0,x=0;for(let _=0;_<=e.length-1;_++)switch(_){case 0:y=e[_+1].x-e[_].x,x=e[_+1].y-e[_].y,p.x=x*1,p.y=-y,p.z=x*0,w.copy(p),p.normalize(),l.push(p.x,p.y,p.z);break;case e.length-1:l.push(w.x,w.y,w.z);break;default:y=e[_+1].x-e[_].x,x=e[_+1].y-e[_].y,p.x=x*1,p.y=-y,p.z=x*0,g.copy(p),p.x+=w.x,p.y+=w.y,p.z+=w.z,p.normalize(),l.push(p.x,p.y,p.z),w.copy(g)}for(let _=0;_<=t;_++){const T=r+_*c*s,E=Math.sin(T),N=Math.cos(T);for(let M=0;M<=e.length-1;M++){h.x=e[M].x*E,h.y=e[M].y,h.z=e[M].x*N,o.push(h.x,h.y,h.z),d.x=_/t,d.y=M/(e.length-1),a.push(d.x,d.y);const $=l[3*M+0]*E,L=l[3*M+1],k=l[3*M+0]*N;u.push($,L,k)}}for(let _=0;_<t;_++)for(let T=0;T<e.length-1;T++){const E=T+_*e.length,N=E,M=E+e.length,$=E+e.length+1,L=E+1;i.push(N,M,L),i.push($,L,M)}this.setIndex(i),this.setAttribute("position",new Jt(o,3)),this.setAttribute("uv",new Jt(a,2)),this.setAttribute("normal",new Jt(u,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Kx(e.points,e.segments,e.phiStart,e.phiLength)}}class tT extends Kx{constructor(e=1,t=1,r=4,s=8){const i=new ux;i.absarc(0,-t/2,e,Math.PI*1.5,0),i.absarc(0,t/2,e,0,Math.PI*.5),super(i.getPoints(r),s),this.type="CapsuleGeometry",this.parameters={radius:e,length:t,capSegments:r,radialSegments:s}}static fromJSON(e){return new tT(e.radius,e.length,e.capSegments,e.radialSegments)}}class nT extends zn{constructor(e=1,t=32,r=0,s=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:r,thetaLength:s},t=Math.max(3,t);const i=[],o=[],a=[],l=[],u=new le,c=new rt;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let h=0,d=3;h<=t;h++,d+=3){const p=r+h/t*s;u.x=e*Math.cos(p),u.y=e*Math.sin(p),o.push(u.x,u.y,u.z),a.push(0,0,1),c.x=(o[d]/e+1)/2,c.y=(o[d+1]/e+1)/2,l.push(c.x,c.y)}for(let h=1;h<=t;h++)i.push(h,h+1,0);this.setIndex(i),this.setAttribute("position",new Jt(o,3)),this.setAttribute("normal",new Jt(a,3)),this.setAttribute("uv",new Jt(l,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new nT(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class Uy extends zn{constructor(e=1,t=1,r=1,s=32,i=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:r,radialSegments:s,heightSegments:i,openEnded:o,thetaStart:a,thetaLength:l};const u=this;s=Math.floor(s),i=Math.floor(i);const c=[],h=[],d=[],p=[];let g=0;const w=[],y=r/2;let x=0;_(),o===!1&&(e>0&&T(!0),t>0&&T(!1)),this.setIndex(c),this.setAttribute("position",new Jt(h,3)),this.setAttribute("normal",new Jt(d,3)),this.setAttribute("uv",new Jt(p,2));function _(){const E=new le,N=new le;let M=0;const $=(t-e)/r;for(let L=0;L<=i;L++){const k=[],R=L/i,P=R*(t-e)+e;for(let B=0;B<=s;B++){const Z=B/s,V=Z*l+a,X=Math.sin(V),q=Math.cos(V);N.x=P*X,N.y=-R*r+y,N.z=P*q,h.push(N.x,N.y,N.z),E.set(X,$,q).normalize(),d.push(E.x,E.y,E.z),p.push(Z,1-R),k.push(g++)}w.push(k)}for(let L=0;L<s;L++)for(let k=0;k<i;k++){const R=w[k][L],P=w[k+1][L],B=w[k+1][L+1],Z=w[k][L+1];c.push(R,P,Z),c.push(P,B,Z),M+=6}u.addGroup(x,M,0),x+=M}function T(E){const N=g,M=new rt,$=new le;let L=0;const k=E===!0?e:t,R=E===!0?1:-1;for(let B=1;B<=s;B++)h.push(0,y*R,0),d.push(0,R,0),p.push(.5,.5),g++;const P=g;for(let B=0;B<=s;B++){const V=B/s*l+a,X=Math.cos(V),q=Math.sin(V);$.x=k*q,$.y=y*R,$.z=k*X,h.push($.x,$.y,$.z),d.push(0,R,0),M.x=X*.5+.5,M.y=q*.5*R+.5,p.push(M.x,M.y),g++}for(let B=0;B<s;B++){const Z=N+B,V=P+B;E===!0?c.push(V,V+1,Z):c.push(V+1,V,Z),L+=3}u.addGroup(x,L,E===!0?1:2),x+=L}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Uy(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class rT extends Uy{constructor(e=1,t=1,r=32,s=1,i=!1,o=0,a=Math.PI*2){super(0,e,t,r,s,i,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:r,heightSegments:s,openEnded:i,thetaStart:o,thetaLength:a}}static fromJSON(e){return new rT(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Xd extends zn{constructor(e=[],t=[],r=1,s=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:r,detail:s};const i=[],o=[];a(s),u(r),c(),this.setAttribute("position",new Jt(i,3)),this.setAttribute("normal",new Jt(i.slice(),3)),this.setAttribute("uv",new Jt(o,2)),s===0?this.computeVertexNormals():this.normalizeNormals();function a(_){const T=new le,E=new le,N=new le;for(let M=0;M<t.length;M+=3)p(t[M+0],T),p(t[M+1],E),p(t[M+2],N),l(T,E,N,_)}function l(_,T,E,N){const M=N+1,$=[];for(let L=0;L<=M;L++){$[L]=[];const k=_.clone().lerp(E,L/M),R=T.clone().lerp(E,L/M),P=M-L;for(let B=0;B<=P;B++)B===0&&L===M?$[L][B]=k:$[L][B]=k.clone().lerp(R,B/P)}for(let L=0;L<M;L++)for(let k=0;k<2*(M-L)-1;k++){const R=Math.floor(k/2);k%2===0?(d($[L][R+1]),d($[L+1][R]),d($[L][R])):(d($[L][R+1]),d($[L+1][R+1]),d($[L+1][R]))}}function u(_){const T=new le;for(let E=0;E<i.length;E+=3)T.x=i[E+0],T.y=i[E+1],T.z=i[E+2],T.normalize().multiplyScalar(_),i[E+0]=T.x,i[E+1]=T.y,i[E+2]=T.z}function c(){const _=new le;for(let T=0;T<i.length;T+=3){_.x=i[T+0],_.y=i[T+1],_.z=i[T+2];const E=y(_)/2/Math.PI+.5,N=x(_)/Math.PI+.5;o.push(E,1-N)}g(),h()}function h(){for(let _=0;_<o.length;_+=6){const T=o[_+0],E=o[_+2],N=o[_+4],M=Math.max(T,E,N),$=Math.min(T,E,N);M>.9&&$<.1&&(T<.2&&(o[_+0]+=1),E<.2&&(o[_+2]+=1),N<.2&&(o[_+4]+=1))}}function d(_){i.push(_.x,_.y,_.z)}function p(_,T){const E=_*3;T.x=e[E+0],T.y=e[E+1],T.z=e[E+2]}function g(){const _=new le,T=new le,E=new le,N=new le,M=new rt,$=new rt,L=new rt;for(let k=0,R=0;k<i.length;k+=9,R+=6){_.set(i[k+0],i[k+1],i[k+2]),T.set(i[k+3],i[k+4],i[k+5]),E.set(i[k+6],i[k+7],i[k+8]),M.set(o[R+0],o[R+1]),$.set(o[R+2],o[R+3]),L.set(o[R+4],o[R+5]),N.copy(_).add(T).add(E).divideScalar(3);const P=y(N);w(M,R+0,_,P),w($,R+2,T,P),w(L,R+4,E,P)}}function w(_,T,E,N){N<0&&_.x===1&&(o[T]=_.x-1),E.x===0&&E.z===0&&(o[T]=N/2/Math.PI+.5)}function y(_){return Math.atan2(_.z,-_.x)}function x(_){return Math.atan2(-_.y,Math.sqrt(_.x*_.x+_.z*_.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Xd(e.vertices,e.indices,e.radius,e.details)}}class sT extends Xd{constructor(e=1,t=0){const r=(1+Math.sqrt(5))/2,s=1/r,i=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-s,-r,0,-s,r,0,s,-r,0,s,r,-s,-r,0,-s,r,0,s,-r,0,s,r,0,-r,0,-s,r,0,-s,-r,0,s,r,0,s],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(i,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new sT(e.radius,e.detail)}}const qb=new le,Kb=new le,h2=new le,Yb=new va;class mz extends zn{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const s=Math.pow(10,4),i=Math.cos(Np*t),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,u=[0,0,0],c=["a","b","c"],h=new Array(3),d={},p=[];for(let g=0;g<l;g+=3){o?(u[0]=o.getX(g),u[1]=o.getX(g+1),u[2]=o.getX(g+2)):(u[0]=g,u[1]=g+1,u[2]=g+2);const{a:w,b:y,c:x}=Yb;if(w.fromBufferAttribute(a,u[0]),y.fromBufferAttribute(a,u[1]),x.fromBufferAttribute(a,u[2]),Yb.getNormal(h2),h[0]=`${Math.round(w.x*s)},${Math.round(w.y*s)},${Math.round(w.z*s)}`,h[1]=`${Math.round(y.x*s)},${Math.round(y.y*s)},${Math.round(y.z*s)}`,h[2]=`${Math.round(x.x*s)},${Math.round(x.y*s)},${Math.round(x.z*s)}`,!(h[0]===h[1]||h[1]===h[2]||h[2]===h[0]))for(let _=0;_<3;_++){const T=(_+1)%3,E=h[_],N=h[T],M=Yb[c[_]],$=Yb[c[T]],L=`${E}_${N}`,k=`${N}_${E}`;k in d&&d[k]?(h2.dot(d[k].normal)<=i&&(p.push(M.x,M.y,M.z),p.push($.x,$.y,$.z)),d[k]=null):L in d||(d[L]={index0:u[_],index1:u[T],normal:h2.clone()})}}for(const g in d)if(d[g]){const{index0:w,index1:y}=d[g];qb.fromBufferAttribute(a,w),Kb.fromBufferAttribute(a,y),p.push(qb.x,qb.y,qb.z),p.push(Kb.x,Kb.y,Kb.z)}this.setAttribute("position",new Jt(p,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class sh extends ux{constructor(e){super(e),this.uuid=Ha(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let r=0,s=this.holes.length;r<s;r++)t[r]=this.holes[r].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,r=e.holes.length;t<r;t++){const s=e.holes[t];this.holes.push(s.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,r=this.holes.length;t<r;t++){const s=this.holes[t];e.holes.push(s.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,r=e.holes.length;t<r;t++){const s=e.holes[t];this.holes.push(new ux().fromJSON(s))}return this}}const jK={triangulate:function(n,e,t=2){const r=e&&e.length,s=r?e[0]*t:n.length;let i=gz(n,0,s,t,!0);const o=[];if(!i||i.next===i.prev)return o;let a,l,u,c,h,d,p;if(r&&(i=ZK(n,e,i,t)),n.length>80*t){a=u=n[0],l=c=n[1];for(let g=t;g<s;g+=t)h=n[g],d=n[g+1],h<a&&(a=h),d<l&&(l=d),h>u&&(u=h),d>c&&(c=d);p=Math.max(u-a,c-l),p=p!==0?32767/p:0}return cx(i,o,t,a,l,p,0),o}};function gz(n,e,t,r,s){let i,o;if(s===lY(n,e,t,r)>0)for(i=e;i<t;i+=r)o=v3(i,n[i],n[i+1],o);else for(i=t-r;i>=e;i-=r)o=v3(i,n[i],n[i+1],o);return o&&iT(o,o.next)&&(dx(o),o=o.next),o}function Fp(n,e){if(!n)return n;e||(e=n);let t=n,r;do if(r=!1,!t.steiner&&(iT(t,t.next)||xs(t.prev,t,t.next)===0)){if(dx(t),t=e=t.prev,t===t.next)break;r=!0}else t=t.next;while(r||t!==e);return e}function cx(n,e,t,r,s,i,o){if(!n)return;!o&&i&&nY(n,r,s,i);let a=n,l,u;for(;n.prev!==n.next;){if(l=n.prev,u=n.next,i?qK(n,r,s,i):XK(n)){e.push(l.i/t|0),e.push(n.i/t|0),e.push(u.i/t|0),dx(n),n=u.next,a=u.next;continue}if(n=u,n===a){o?o===1?(n=KK(Fp(n),e,t),cx(n,e,t,r,s,i,2)):o===2&&YK(n,e,t,r,s,i):cx(Fp(n),e,t,r,s,i,1);break}}}function XK(n){const e=n.prev,t=n,r=n.next;if(xs(e,t,r)>=0)return!1;const s=e.x,i=t.x,o=r.x,a=e.y,l=t.y,u=r.y,c=s<i?s<o?s:o:i<o?i:o,h=a<l?a<u?a:u:l<u?l:u,d=s>i?s>o?s:o:i>o?i:o,p=a>l?a>u?a:u:l>u?l:u;let g=r.next;for(;g!==e;){if(g.x>=c&&g.x<=d&&g.y>=h&&g.y<=p&&sy(s,a,i,l,o,u,g.x,g.y)&&xs(g.prev,g,g.next)>=0)return!1;g=g.next}return!0}function qK(n,e,t,r){const s=n.prev,i=n,o=n.next;if(xs(s,i,o)>=0)return!1;const a=s.x,l=i.x,u=o.x,c=s.y,h=i.y,d=o.y,p=a<l?a<u?a:u:l<u?l:u,g=c<h?c<d?c:d:h<d?h:d,w=a>l?a>u?a:u:l>u?l:u,y=c>h?c>d?c:d:h>d?h:d,x=XI(p,g,e,t,r),_=XI(w,y,e,t,r);let T=n.prevZ,E=n.nextZ;for(;T&&T.z>=x&&E&&E.z<=_;){if(T.x>=p&&T.x<=w&&T.y>=g&&T.y<=y&&T!==s&&T!==o&&sy(a,c,l,h,u,d,T.x,T.y)&&xs(T.prev,T,T.next)>=0||(T=T.prevZ,E.x>=p&&E.x<=w&&E.y>=g&&E.y<=y&&E!==s&&E!==o&&sy(a,c,l,h,u,d,E.x,E.y)&&xs(E.prev,E,E.next)>=0))return!1;E=E.nextZ}for(;T&&T.z>=x;){if(T.x>=p&&T.x<=w&&T.y>=g&&T.y<=y&&T!==s&&T!==o&&sy(a,c,l,h,u,d,T.x,T.y)&&xs(T.prev,T,T.next)>=0)return!1;T=T.prevZ}for(;E&&E.z<=_;){if(E.x>=p&&E.x<=w&&E.y>=g&&E.y<=y&&E!==s&&E!==o&&sy(a,c,l,h,u,d,E.x,E.y)&&xs(E.prev,E,E.next)>=0)return!1;E=E.nextZ}return!0}function KK(n,e,t){let r=n;do{const s=r.prev,i=r.next.next;!iT(s,i)&&yz(s,r,r.next,i)&&hx(s,i)&&hx(i,s)&&(e.push(s.i/t|0),e.push(r.i/t|0),e.push(i.i/t|0),dx(r),dx(r.next),r=n=i),r=r.next}while(r!==n);return Fp(r)}function YK(n,e,t,r,s,i){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&iY(o,a)){let l=vz(o,a);o=Fp(o,o.next),l=Fp(l,l.next),cx(o,e,t,r,s,i,0),cx(l,e,t,r,s,i,0);return}a=a.next}o=o.next}while(o!==n)}function ZK(n,e,t,r){const s=[];let i,o,a,l,u;for(i=0,o=e.length;i<o;i++)a=e[i]*r,l=i<o-1?e[i+1]*r:n.length,u=gz(n,a,l,r,!1),u===u.next&&(u.steiner=!0),s.push(sY(u));for(s.sort(JK),i=0;i<s.length;i++)t=QK(s[i],t);return t}function JK(n,e){return n.x-e.x}function QK(n,e){const t=eY(n,e);if(!t)return e;const r=vz(t,n);return Fp(r,r.next),Fp(t,t.next)}function eY(n,e){let t=e,r=-1/0,s;const i=n.x,o=n.y;do{if(o<=t.y&&o>=t.next.y&&t.next.y!==t.y){const d=t.x+(o-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=i&&d>r&&(r=d,s=t.x<t.next.x?t:t.next,d===i))return s}t=t.next}while(t!==e);if(!s)return null;const a=s,l=s.x,u=s.y;let c=1/0,h;t=s;do i>=t.x&&t.x>=l&&i!==t.x&&sy(o<u?i:r,o,l,u,o<u?r:i,o,t.x,t.y)&&(h=Math.abs(o-t.y)/(i-t.x),hx(t,n)&&(h<c||h===c&&(t.x>s.x||t.x===s.x&&tY(s,t)))&&(s=t,c=h)),t=t.next;while(t!==a);return s}function tY(n,e){return xs(n.prev,n,e.prev)<0&&xs(e.next,n,n.next)<0}function nY(n,e,t,r){let s=n;do s.z===0&&(s.z=XI(s.x,s.y,e,t,r)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==n);s.prevZ.nextZ=null,s.prevZ=null,rY(s)}function rY(n){let e,t,r,s,i,o,a,l,u=1;do{for(t=n,n=null,i=null,o=0;t;){for(o++,r=t,a=0,e=0;e<u&&(a++,r=r.nextZ,!!r);e++);for(l=u;a>0||l>0&&r;)a!==0&&(l===0||!r||t.z<=r.z)?(s=t,t=t.nextZ,a--):(s=r,r=r.nextZ,l--),i?i.nextZ=s:n=s,s.prevZ=i,i=s;t=r}i.nextZ=null,u*=2}while(o>1);return n}function XI(n,e,t,r,s){return n=(n-t)*s|0,e=(e-r)*s|0,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function sY(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function sy(n,e,t,r,s,i,o,a){return(s-o)*(e-a)>=(n-o)*(i-a)&&(n-o)*(r-a)>=(t-o)*(e-a)&&(t-o)*(i-a)>=(s-o)*(r-a)}function iY(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!oY(n,e)&&(hx(n,e)&&hx(e,n)&&aY(n,e)&&(xs(n.prev,n,e.prev)||xs(n,e.prev,e))||iT(n,e)&&xs(n.prev,n,n.next)>0&&xs(e.prev,e,e.next)>0)}function xs(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function iT(n,e){return n.x===e.x&&n.y===e.y}function yz(n,e,t,r){const s=Jb(xs(n,e,t)),i=Jb(xs(n,e,r)),o=Jb(xs(t,r,n)),a=Jb(xs(t,r,e));return!!(s!==i&&o!==a||s===0&&Zb(n,t,e)||i===0&&Zb(n,r,e)||o===0&&Zb(t,n,r)||a===0&&Zb(t,e,r))}function Zb(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function Jb(n){return n>0?1:n<0?-1:0}function oY(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&yz(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function hx(n,e){return xs(n.prev,n,n.next)<0?xs(n,e,n.next)>=0&&xs(n,n.prev,e)>=0:xs(n,e,n.prev)<0||xs(n,n.next,e)<0}function aY(n,e){let t=n,r=!1;const s=(n.x+e.x)/2,i=(n.y+e.y)/2;do t.y>i!=t.next.y>i&&t.next.y!==t.y&&s<(t.next.x-t.x)*(i-t.y)/(t.next.y-t.y)+t.x&&(r=!r),t=t.next;while(t!==n);return r}function vz(n,e){const t=new qI(n.i,n.x,n.y),r=new qI(e.i,e.x,e.y),s=n.next,i=e.prev;return n.next=e,e.prev=n,t.next=s,s.prev=t,r.next=t,t.prev=r,i.next=r,r.prev=i,r}function v3(n,e,t,r){const s=new qI(n,e,t);return r?(s.next=r.next,s.prev=r,r.next.prev=s,r.next=s):(s.prev=s,s.next=s),s}function dx(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function qI(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function lY(n,e,t,r){let s=0;for(let i=e,o=t-r;i<t;i+=r)s+=(n[o]-n[i])*(n[i+1]+n[o+1]),o=i;return s}class ju{static area(e){const t=e.length;let r=0;for(let s=t-1,i=0;i<t;s=i++)r+=e[s].x*e[i].y-e[i].x*e[s].y;return r*.5}static isClockWise(e){return ju.area(e)<0}static triangulateShape(e,t){const r=[],s=[],i=[];x3(e),w3(r,e);let o=e.length;t.forEach(x3);for(let l=0;l<t.length;l++)s.push(o),o+=t[l].length,w3(r,t[l]);const a=jK.triangulate(r,s);for(let l=0;l<a.length;l+=3)i.push(a.slice(l,l+3));return i}}function x3(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function w3(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class Vy extends zn{constructor(e=new sh([new rt(.5,.5),new rt(-.5,.5),new rt(-.5,-.5),new rt(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const r=this,s=[],i=[];for(let a=0,l=e.length;a<l;a++){const u=e[a];o(u)}this.setAttribute("position",new Jt(s,3)),this.setAttribute("uv",new Jt(i,2)),this.computeVertexNormals();function o(a){const l=[],u=t.curveSegments!==void 0?t.curveSegments:12,c=t.steps!==void 0?t.steps:1,h=t.depth!==void 0?t.depth:1;let d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,p=t.bevelThickness!==void 0?t.bevelThickness:.2,g=t.bevelSize!==void 0?t.bevelSize:p-.1,w=t.bevelOffset!==void 0?t.bevelOffset:0,y=t.bevelSegments!==void 0?t.bevelSegments:3;const x=t.extrudePath,_=t.UVGenerator!==void 0?t.UVGenerator:uY;let T,E=!1,N,M,$,L;x&&(T=x.getSpacedPoints(c),E=!0,d=!1,N=x.computeFrenetFrames(c,!1),M=new le,$=new le,L=new le),d||(y=0,p=0,g=0,w=0);const k=a.extractPoints(u);let R=k.shape;const P=k.holes;if(!ju.isClockWise(R)){R=R.reverse();for(let fe=0,nt=P.length;fe<nt;fe++){const Xe=P[fe];ju.isClockWise(Xe)&&(P[fe]=Xe.reverse())}}const Z=ju.triangulateShape(R,P),V=R;for(let fe=0,nt=P.length;fe<nt;fe++){const Xe=P[fe];R=R.concat(Xe)}function X(fe,nt,Xe){return nt||console.error("THREE.ExtrudeGeometry: vec does not exist"),fe.clone().addScaledVector(nt,Xe)}const q=R.length,se=Z.length;function W(fe,nt,Xe){let it,He,_t;const mt=fe.x-nt.x,oe=fe.y-nt.y,ee=Xe.x-fe.x,Le=Xe.y-fe.y,at=mt*mt+oe*oe,ut=mt*Le-oe*ee;if(Math.abs(ut)>Number.EPSILON){const ot=Math.sqrt(at),$t=Math.sqrt(ee*ee+Le*Le),bt=nt.x-oe/ot,It=nt.y+mt/ot,Gt=Xe.x-Le/$t,rn=Xe.y+ee/$t,ht=((Gt-bt)*Le-(rn-It)*ee)/(mt*Le-oe*ee);it=bt+mt*ht-fe.x,He=It+oe*ht-fe.y;const Nn=it*it+He*He;if(Nn<=2)return new rt(it,He);_t=Math.sqrt(Nn/2)}else{let ot=!1;mt>Number.EPSILON?ee>Number.EPSILON&&(ot=!0):mt<-Number.EPSILON?ee<-Number.EPSILON&&(ot=!0):Math.sign(oe)===Math.sign(Le)&&(ot=!0),ot?(it=-oe,He=mt,_t=Math.sqrt(at)):(it=mt,He=oe,_t=Math.sqrt(at/2))}return new rt(it/_t,He/_t)}const J=[];for(let fe=0,nt=V.length,Xe=nt-1,it=fe+1;fe<nt;fe++,Xe++,it++)Xe===nt&&(Xe=0),it===nt&&(it=0),J[fe]=W(V[fe],V[Xe],V[it]);const K=[];let G,Q=J.concat();for(let fe=0,nt=P.length;fe<nt;fe++){const Xe=P[fe];G=[];for(let it=0,He=Xe.length,_t=He-1,mt=it+1;it<He;it++,_t++,mt++)_t===He&&(_t=0),mt===He&&(mt=0),G[it]=W(Xe[it],Xe[_t],Xe[mt]);K.push(G),Q=Q.concat(G)}for(let fe=0;fe<y;fe++){const nt=fe/y,Xe=p*Math.cos(nt*Math.PI/2),it=g*Math.sin(nt*Math.PI/2)+w;for(let He=0,_t=V.length;He<_t;He++){const mt=X(V[He],J[He],it);Re(mt.x,mt.y,-Xe)}for(let He=0,_t=P.length;He<_t;He++){const mt=P[He];G=K[He];for(let oe=0,ee=mt.length;oe<ee;oe++){const Le=X(mt[oe],G[oe],it);Re(Le.x,Le.y,-Xe)}}}const ne=g+w;for(let fe=0;fe<q;fe++){const nt=d?X(R[fe],Q[fe],ne):R[fe];E?($.copy(N.normals[0]).multiplyScalar(nt.x),M.copy(N.binormals[0]).multiplyScalar(nt.y),L.copy(T[0]).add($).add(M),Re(L.x,L.y,L.z)):Re(nt.x,nt.y,0)}for(let fe=1;fe<=c;fe++)for(let nt=0;nt<q;nt++){const Xe=d?X(R[nt],Q[nt],ne):R[nt];E?($.copy(N.normals[fe]).multiplyScalar(Xe.x),M.copy(N.binormals[fe]).multiplyScalar(Xe.y),L.copy(T[fe]).add($).add(M),Re(L.x,L.y,L.z)):Re(Xe.x,Xe.y,h/c*fe)}for(let fe=y-1;fe>=0;fe--){const nt=fe/y,Xe=p*Math.cos(nt*Math.PI/2),it=g*Math.sin(nt*Math.PI/2)+w;for(let He=0,_t=V.length;He<_t;He++){const mt=X(V[He],J[He],it);Re(mt.x,mt.y,h+Xe)}for(let He=0,_t=P.length;He<_t;He++){const mt=P[He];G=K[He];for(let oe=0,ee=mt.length;oe<ee;oe++){const Le=X(mt[oe],G[oe],it);E?Re(Le.x,Le.y+T[c-1].y,T[c-1].x+Xe):Re(Le.x,Le.y,h+Xe)}}}ce(),ye();function ce(){const fe=s.length/3;if(d){let nt=0,Xe=q*nt;for(let it=0;it<se;it++){const He=Z[it];Oe(He[2]+Xe,He[1]+Xe,He[0]+Xe)}nt=c+y*2,Xe=q*nt;for(let it=0;it<se;it++){const He=Z[it];Oe(He[0]+Xe,He[1]+Xe,He[2]+Xe)}}else{for(let nt=0;nt<se;nt++){const Xe=Z[nt];Oe(Xe[2],Xe[1],Xe[0])}for(let nt=0;nt<se;nt++){const Xe=Z[nt];Oe(Xe[0]+q*c,Xe[1]+q*c,Xe[2]+q*c)}}r.addGroup(fe,s.length/3-fe,0)}function ye(){const fe=s.length/3;let nt=0;Se(V,nt),nt+=V.length;for(let Xe=0,it=P.length;Xe<it;Xe++){const He=P[Xe];Se(He,nt),nt+=He.length}r.addGroup(fe,s.length/3-fe,1)}function Se(fe,nt){let Xe=fe.length;for(;--Xe>=0;){const it=Xe;let He=Xe-1;He<0&&(He=fe.length-1);for(let _t=0,mt=c+y*2;_t<mt;_t++){const oe=q*_t,ee=q*(_t+1),Le=nt+it+oe,at=nt+He+oe,ut=nt+He+ee,ot=nt+it+ee;Ke(Le,at,ut,ot)}}}function Re(fe,nt,Xe){l.push(fe),l.push(nt),l.push(Xe)}function Oe(fe,nt,Xe){st(fe),st(nt),st(Xe);const it=s.length/3,He=_.generateTopUV(r,s,it-3,it-2,it-1);ct(He[0]),ct(He[1]),ct(He[2])}function Ke(fe,nt,Xe,it){st(fe),st(nt),st(it),st(nt),st(Xe),st(it);const He=s.length/3,_t=_.generateSideWallUV(r,s,He-6,He-3,He-2,He-1);ct(_t[0]),ct(_t[1]),ct(_t[3]),ct(_t[1]),ct(_t[2]),ct(_t[3])}function st(fe){s.push(l[fe*3+0]),s.push(l[fe*3+1]),s.push(l[fe*3+2])}function ct(fe){i.push(fe.x),i.push(fe.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,r=this.parameters.options;return cY(t,r,e)}static fromJSON(e,t){const r=[];for(let i=0,o=e.shapes.length;i<o;i++){const a=t[e.shapes[i]];r.push(a)}const s=e.options.extrudePath;return s!==void 0&&(e.options.extrudePath=new JS[s.type]().fromJSON(s)),new Vy(r,e.options)}}const uY={generateTopUV:function(n,e,t,r,s){const i=e[t*3],o=e[t*3+1],a=e[r*3],l=e[r*3+1],u=e[s*3],c=e[s*3+1];return[new rt(i,o),new rt(a,l),new rt(u,c)]},generateSideWallUV:function(n,e,t,r,s,i){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],u=e[r*3],c=e[r*3+1],h=e[r*3+2],d=e[s*3],p=e[s*3+1],g=e[s*3+2],w=e[i*3],y=e[i*3+1],x=e[i*3+2];return Math.abs(a-c)<Math.abs(o-u)?[new rt(o,1-l),new rt(u,1-h),new rt(d,1-g),new rt(w,1-x)]:[new rt(a,1-l),new rt(c,1-h),new rt(p,1-g),new rt(y,1-x)]}};function cY(n,e,t){if(t.shapes=[],Array.isArray(n))for(let r=0,s=n.length;r<s;r++){const i=n[r];t.shapes.push(i.uuid)}else t.shapes.push(n.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class Yx extends Xd{constructor(e=1,t=0){const r=(1+Math.sqrt(5))/2,s=[-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1],i=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(s,i,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Yx(e.radius,e.detail)}}class Zx extends Xd{constructor(e=1,t=0){const r=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],s=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(r,s,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Zx(e.radius,e.detail)}}class oT extends zn{constructor(e=.5,t=1,r=32,s=1,i=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:r,phiSegments:s,thetaStart:i,thetaLength:o},r=Math.max(3,r),s=Math.max(1,s);const a=[],l=[],u=[],c=[];let h=e;const d=(t-e)/s,p=new le,g=new rt;for(let w=0;w<=s;w++){for(let y=0;y<=r;y++){const x=i+y/r*o;p.x=h*Math.cos(x),p.y=h*Math.sin(x),l.push(p.x,p.y,p.z),u.push(0,0,1),g.x=(p.x/t+1)/2,g.y=(p.y/t+1)/2,c.push(g.x,g.y)}h+=d}for(let w=0;w<s;w++){const y=w*(r+1);for(let x=0;x<r;x++){const _=x+y,T=_,E=_+r+1,N=_+r+2,M=_+1;a.push(T,E,M),a.push(E,N,M)}}this.setIndex(a),this.setAttribute("position",new Jt(l,3)),this.setAttribute("normal",new Jt(u,3)),this.setAttribute("uv",new Jt(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new oT(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class aT extends zn{constructor(e=new sh([new rt(0,.5),new rt(-.5,-.5),new rt(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const r=[],s=[],i=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)u(e);else for(let c=0;c<e.length;c++)u(e[c]),this.addGroup(a,l,c),a+=l,l=0;this.setIndex(r),this.setAttribute("position",new Jt(s,3)),this.setAttribute("normal",new Jt(i,3)),this.setAttribute("uv",new Jt(o,2));function u(c){const h=s.length/3,d=c.extractPoints(t);let p=d.shape;const g=d.holes;ju.isClockWise(p)===!1&&(p=p.reverse());for(let y=0,x=g.length;y<x;y++){const _=g[y];ju.isClockWise(_)===!0&&(g[y]=_.reverse())}const w=ju.triangulateShape(p,g);for(let y=0,x=g.length;y<x;y++){const _=g[y];p=p.concat(_)}for(let y=0,x=p.length;y<x;y++){const _=p[y];s.push(_.x,_.y,0),i.push(0,0,1),o.push(_.x,_.y)}for(let y=0,x=w.length;y<x;y++){const _=w[y],T=_[0]+h,E=_[1]+h,N=_[2]+h;r.push(T,E,N),l+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return hY(t,e)}static fromJSON(e,t){const r=[];for(let s=0,i=e.shapes.length;s<i;s++){const o=t[e.shapes[s]];r.push(o)}return new aT(r,e.curveSegments)}}function hY(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,r=n.length;t<r;t++){const s=n[t];e.shapes.push(s.uuid)}else e.shapes.push(n.uuid);return e}class Wy extends zn{constructor(e=1,t=32,r=16,s=0,i=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:r,phiStart:s,phiLength:i,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),r=Math.max(2,Math.floor(r));const l=Math.min(o+a,Math.PI);let u=0;const c=[],h=new le,d=new le,p=[],g=[],w=[],y=[];for(let x=0;x<=r;x++){const _=[],T=x/r;let E=0;x===0&&o===0?E=.5/t:x===r&&l===Math.PI&&(E=-.5/t);for(let N=0;N<=t;N++){const M=N/t;h.x=-e*Math.cos(s+M*i)*Math.sin(o+T*a),h.y=e*Math.cos(o+T*a),h.z=e*Math.sin(s+M*i)*Math.sin(o+T*a),g.push(h.x,h.y,h.z),d.copy(h).normalize(),w.push(d.x,d.y,d.z),y.push(M+E,1-T),_.push(u++)}c.push(_)}for(let x=0;x<r;x++)for(let _=0;_<t;_++){const T=c[x][_+1],E=c[x][_],N=c[x+1][_],M=c[x+1][_+1];(x!==0||o>0)&&p.push(T,E,M),(x!==r-1||l<Math.PI)&&p.push(E,N,M)}this.setIndex(p),this.setAttribute("position",new Jt(g,3)),this.setAttribute("normal",new Jt(w,3)),this.setAttribute("uv",new Jt(y,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Wy(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class lT extends Xd{constructor(e=1,t=0){const r=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],s=[2,1,0,0,3,2,1,3,0,2,3,1];super(r,s,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new lT(e.radius,e.detail)}}class uT extends zn{constructor(e=1,t=.4,r=12,s=48,i=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:r,tubularSegments:s,arc:i},r=Math.floor(r),s=Math.floor(s);const o=[],a=[],l=[],u=[],c=new le,h=new le,d=new le;for(let p=0;p<=r;p++)for(let g=0;g<=s;g++){const w=g/s*i,y=p/r*Math.PI*2;h.x=(e+t*Math.cos(y))*Math.cos(w),h.y=(e+t*Math.cos(y))*Math.sin(w),h.z=t*Math.sin(y),a.push(h.x,h.y,h.z),c.x=e*Math.cos(w),c.y=e*Math.sin(w),d.subVectors(h,c).normalize(),l.push(d.x,d.y,d.z),u.push(g/s),u.push(p/r)}for(let p=1;p<=r;p++)for(let g=1;g<=s;g++){const w=(s+1)*p+g-1,y=(s+1)*(p-1)+g-1,x=(s+1)*(p-1)+g,_=(s+1)*p+g;o.push(w,y,_),o.push(y,x,_)}this.setIndex(o),this.setAttribute("position",new Jt(a,3)),this.setAttribute("normal",new Jt(l,3)),this.setAttribute("uv",new Jt(u,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new uT(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class cT extends zn{constructor(e=1,t=.4,r=64,s=8,i=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:r,radialSegments:s,p:i,q:o},r=Math.floor(r),s=Math.floor(s);const a=[],l=[],u=[],c=[],h=new le,d=new le,p=new le,g=new le,w=new le,y=new le,x=new le;for(let T=0;T<=r;++T){const E=T/r*i*Math.PI*2;_(E,i,o,e,p),_(E+.01,i,o,e,g),y.subVectors(g,p),x.addVectors(g,p),w.crossVectors(y,x),x.crossVectors(w,y),w.normalize(),x.normalize();for(let N=0;N<=s;++N){const M=N/s*Math.PI*2,$=-t*Math.cos(M),L=t*Math.sin(M);h.x=p.x+($*x.x+L*w.x),h.y=p.y+($*x.y+L*w.y),h.z=p.z+($*x.z+L*w.z),l.push(h.x,h.y,h.z),d.subVectors(h,p).normalize(),u.push(d.x,d.y,d.z),c.push(T/r),c.push(N/s)}}for(let T=1;T<=r;T++)for(let E=1;E<=s;E++){const N=(s+1)*(T-1)+(E-1),M=(s+1)*T+(E-1),$=(s+1)*T+E,L=(s+1)*(T-1)+E;a.push(N,M,L),a.push(M,$,L)}this.setIndex(a),this.setAttribute("position",new Jt(l,3)),this.setAttribute("normal",new Jt(u,3)),this.setAttribute("uv",new Jt(c,2));function _(T,E,N,M,$){const L=Math.cos(T),k=Math.sin(T),R=N/E*T,P=Math.cos(R);$.x=M*(2+P)*.5*L,$.y=M*(2+P)*k*.5,$.z=M*Math.sin(R)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new cT(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class Jx extends zn{constructor(e=new KA(new le(-1,-1,0),new le(-1,1,0),new le(1,1,0)),t=64,r=1,s=8,i=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:r,radialSegments:s,closed:i};const o=e.computeFrenetFrames(t,i);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new le,l=new le,u=new rt;let c=new le;const h=[],d=[],p=[],g=[];w(),this.setIndex(g),this.setAttribute("position",new Jt(h,3)),this.setAttribute("normal",new Jt(d,3)),this.setAttribute("uv",new Jt(p,2));function w(){for(let T=0;T<t;T++)y(T);y(i===!1?t:0),_(),x()}function y(T){c=e.getPointAt(T/t,c);const E=o.normals[T],N=o.binormals[T];for(let M=0;M<=s;M++){const $=M/s*Math.PI*2,L=Math.sin($),k=-Math.cos($);l.x=k*E.x+L*N.x,l.y=k*E.y+L*N.y,l.z=k*E.z+L*N.z,l.normalize(),d.push(l.x,l.y,l.z),a.x=c.x+r*l.x,a.y=c.y+r*l.y,a.z=c.z+r*l.z,h.push(a.x,a.y,a.z)}}function x(){for(let T=1;T<=t;T++)for(let E=1;E<=s;E++){const N=(s+1)*(T-1)+(E-1),M=(s+1)*T+(E-1),$=(s+1)*T+E,L=(s+1)*(T-1)+E;g.push(N,M,L),g.push(M,$,L)}}function _(){for(let T=0;T<=t;T++)for(let E=0;E<=s;E++)u.x=T/t,u.y=E/s,p.push(u.x,u.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new Jx(new JS[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class xz extends zn{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],r=new Set,s=new le,i=new le;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let u=0,c=l.length;u<c;++u){const h=l[u],d=h.start,p=h.count;for(let g=d,w=d+p;g<w;g+=3)for(let y=0;y<3;y++){const x=a.getX(g+y),_=a.getX(g+(y+1)%3);s.fromBufferAttribute(o,x),i.fromBufferAttribute(o,_),b3(s,i,r)===!0&&(t.push(s.x,s.y,s.z),t.push(i.x,i.y,i.z))}}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let u=0;u<3;u++){const c=3*a+u,h=3*a+(u+1)%3;s.fromBufferAttribute(o,c),i.fromBufferAttribute(o,h),b3(s,i,r)===!0&&(t.push(s.x,s.y,s.z),t.push(i.x,i.y,i.z))}}this.setAttribute("position",new Jt(t,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function b3(n,e,t){const r=`${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,s=`${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;return t.has(r)===!0||t.has(s)===!0?!1:(t.add(r),t.add(s),!0)}var S3=Object.freeze({__proto__:null,BoxGeometry:jd,CapsuleGeometry:tT,CircleGeometry:nT,ConeGeometry:rT,CylinderGeometry:Uy,DodecahedronGeometry:sT,EdgesGeometry:mz,ExtrudeGeometry:Vy,IcosahedronGeometry:Yx,LatheGeometry:Kx,OctahedronGeometry:Zx,PlaneGeometry:qx,PolyhedronGeometry:Xd,RingGeometry:oT,ShapeGeometry:aT,SphereGeometry:Wy,TetrahedronGeometry:lT,TorusGeometry:uT,TorusKnotGeometry:cT,TubeGeometry:Jx,WireframeGeometry:xz});class wz extends Si{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Nt(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class bz extends ni{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class Fu extends Si{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Nt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Gd,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Sz extends Fu{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new rt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Es(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Nt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Nt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Nt(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class _z extends Si{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Nt(16777215),this.specular=new Nt(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Gd,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Wx,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Tz extends Si{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Nt(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Gd,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class ZA extends Si{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Gd,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class Ez extends Si{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Nt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Nt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Gd,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Wx,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Cz extends Si{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Nt(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Gd,this.normalScale=new rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Iz extends Jo{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function wp(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)}function Nz(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function Az(n){function e(s,i){return n[s]-n[i]}const t=n.length,r=new Array(t);for(let s=0;s!==t;++s)r[s]=s;return r.sort(e),r}function KI(n,e,t){const r=n.length,s=new n.constructor(r);for(let i=0,o=0;o!==r;++i){const a=t[i]*e;for(let l=0;l!==e;++l)s[o++]=n[a+l]}return s}function JA(n,e,t,r){let s=1,i=n[0];for(;i!==void 0&&i[r]===void 0;)i=n[s++];if(i===void 0)return;let o=i[r];if(o!==void 0)if(Array.isArray(o))do o=i[r],o!==void 0&&(e.push(i.time),t.push.apply(t,o)),i=n[s++];while(i!==void 0);else if(o.toArray!==void 0)do o=i[r],o!==void 0&&(e.push(i.time),o.toArray(t,t.length)),i=n[s++];while(i!==void 0);else do o=i[r],o!==void 0&&(e.push(i.time),t.push(o)),i=n[s++];while(i!==void 0)}function dY(n,e,t,r,s=30){const i=n.clone();i.name=e;const o=[];for(let l=0;l<i.tracks.length;++l){const u=i.tracks[l],c=u.getValueSize(),h=[],d=[];for(let p=0;p<u.times.length;++p){const g=u.times[p]*s;if(!(g<t||g>=r)){h.push(u.times[p]);for(let w=0;w<c;++w)d.push(u.values[p*c+w])}}h.length!==0&&(u.times=wp(h,u.times.constructor),u.values=wp(d,u.values.constructor),o.push(u))}i.tracks=o;let a=1/0;for(let l=0;l<i.tracks.length;++l)a>i.tracks[l].times[0]&&(a=i.tracks[l].times[0]);for(let l=0;l<i.tracks.length;++l)i.tracks[l].shift(-1*a);return i.resetDuration(),i}function fY(n,e=0,t=n,r=30){r<=0&&(r=30);const s=t.tracks.length,i=e/r;for(let o=0;o<s;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const u=n.tracks.find(function(x){return x.name===a.name&&x.ValueTypeName===l});if(u===void 0)continue;let c=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(c=h/3);let d=0;const p=u.getValueSize();u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=p/3);const g=a.times.length-1;let w;if(i<=a.times[0]){const x=c,_=h-c;w=a.values.slice(x,_)}else if(i>=a.times[g]){const x=g*h+c,_=x+h-c;w=a.values.slice(x,_)}else{const x=a.createInterpolant(),_=c,T=h-c;x.evaluate(i),w=x.resultBuffer.slice(_,T)}l==="quaternion"&&new bo().fromArray(w).normalize().conjugate().toArray(w);const y=u.times.length;for(let x=0;x<y;++x){const _=x*p+d;if(l==="quaternion")bo.multiplyQuaternionsFlat(u.values,_,w,0,u.values,_);else{const T=p-d*2;for(let E=0;E<T;++E)u.values[_+E]-=w[E]}}}return n.blendMode=IA,n}const pY={convertArray:wp,isTypedArray:Nz,getKeyframeOrder:Az,sortedArray:KI,flattenJSON:JA,subclip:dY,makeClipAdditive:fY};class Qx{constructor(e,t,r,s){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=s!==void 0?s:new t.constructor(r),this.sampleValues=t,this.valueSize=r,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let r=this._cachedIndex,s=t[r],i=t[r-1];e:{t:{let o;n:{r:if(!(e<s)){for(let a=r+2;;){if(s===void 0){if(e<i)break r;return r=t.length,this._cachedIndex=r,this.copySampleValue_(r-1)}if(r===a)break;if(i=s,s=t[++r],e<s)break t}o=t.length;break n}if(!(e>=i)){const a=t[1];e<a&&(r=2,i=a);for(let l=r-2;;){if(i===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(r===l)break;if(s=i,i=t[--r-1],e>=i)break t}o=r,r=0;break n}break e}for(;r<o;){const a=r+o>>>1;e<t[a]?o=a:r=a+1}if(s=t[r],i=t[r-1],i===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===void 0)return r=t.length,this._cachedIndex=r,this.copySampleValue_(r-1)}this._cachedIndex=r,this.intervalChanged_(r,i,s)}return this.interpolate_(r,i,e,s)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,r=this.sampleValues,s=this.valueSize,i=e*s;for(let o=0;o!==s;++o)t[o]=r[i+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Mz extends Qx{constructor(e,t,r,s){super(e,t,r,s),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:gp,endingEnd:gp}}intervalChanged_(e,t,r){const s=this.parameterPositions;let i=e-2,o=e+1,a=s[i],l=s[o];if(a===void 0)switch(this.getSettings_().endingStart){case yp:i=e,a=2*t-r;break;case nx:i=s.length-2,a=t+s[i]-s[i+1];break;default:i=e,a=r}if(l===void 0)switch(this.getSettings_().endingEnd){case yp:o=e,l=2*r-t;break;case nx:o=1,l=r+s[1]-s[0];break;default:o=e-1,l=t}const u=(r-t)*.5,c=this.valueSize;this._weightPrev=u/(t-a),this._weightNext=u/(l-r),this._offsetPrev=i*c,this._offsetNext=o*c}interpolate_(e,t,r,s){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,u=l-a,c=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,p=this._weightNext,g=(r-t)/(s-t),w=g*g,y=w*g,x=-d*y+2*d*w-d*g,_=(1+d)*y+(-1.5-2*d)*w+(-.5+d)*g+1,T=(-1-p)*y+(1.5+p)*w+.5*g,E=p*y-p*w;for(let N=0;N!==a;++N)i[N]=x*o[c+N]+_*o[u+N]+T*o[l+N]+E*o[h+N];return i}}class QA extends Qx{constructor(e,t,r,s){super(e,t,r,s)}interpolate_(e,t,r,s){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,u=l-a,c=(r-t)/(s-t),h=1-c;for(let d=0;d!==a;++d)i[d]=o[u+d]*h+o[l+d]*c;return i}}class kz extends Qx{constructor(e,t,r,s){super(e,t,r,s)}interpolate_(e){return this.copySampleValue_(e-1)}}class wu{constructor(e,t,r,s){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=wp(t,this.TimeBufferType),this.values=wp(r,this.ValueBufferType),this.setInterpolation(s||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let r;if(t.toJSON!==this.toJSON)r=t.toJSON(e);else{r={name:e.name,times:wp(e.times,Array),values:wp(e.values,Array)};const s=e.getInterpolation();s!==e.DefaultInterpolation&&(r.interpolation=s)}return r.type=e.ValueTypeName,r}InterpolantFactoryMethodDiscrete(e){return new kz(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new QA(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new Mz(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case ex:t=this.InterpolantFactoryMethodDiscrete;break;case tx:t=this.InterpolantFactoryMethodLinear;break;case AS:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const r="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(r);return console.warn("THREE.KeyframeTrack:",r),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return ex;case this.InterpolantFactoryMethodLinear:return tx;case this.InterpolantFactoryMethodSmooth:return AS}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let r=0,s=t.length;r!==s;++r)t[r]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let r=0,s=t.length;r!==s;++r)t[r]*=e}return this}trim(e,t){const r=this.times,s=r.length;let i=0,o=s-1;for(;i!==s&&r[i]<e;)++i;for(;o!==-1&&r[o]>t;)--o;if(++o,i!==0||o!==s){i>=o&&(o=Math.max(o,1),i=o-1);const a=this.getValueSize();this.times=r.slice(i,o),this.values=this.values.slice(i*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const r=this.times,s=this.values,i=r.length;i===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==i;a++){const l=r[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(s!==void 0&&Nz(s))for(let a=0,l=s.length;a!==l;++a){const u=s[a];if(isNaN(u)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,u),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),r=this.getValueSize(),s=this.getInterpolation()===AS,i=e.length-1;let o=1;for(let a=1;a<i;++a){let l=!1;const u=e[a],c=e[a+1];if(u!==c&&(a!==1||u!==e[0]))if(s)l=!0;else{const h=a*r,d=h-r,p=h+r;for(let g=0;g!==r;++g){const w=t[h+g];if(w!==t[d+g]||w!==t[p+g]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const h=a*r,d=o*r;for(let p=0;p!==r;++p)t[d+p]=t[h+p]}++o}}if(i>0){e[o]=e[i];for(let a=i*r,l=o*r,u=0;u!==r;++u)t[l+u]=t[a+u];++o}return o!==e.length?(this.times=e.slice(0,o),this.values=t.slice(0,o*r)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),r=this.constructor,s=new r(this.name,e,t);return s.createInterpolant=this.createInterpolant,s}}wu.prototype.TimeBufferType=Float32Array;wu.prototype.ValueBufferType=Float32Array;wu.prototype.DefaultInterpolation=tx;class om extends wu{}om.prototype.ValueTypeName="bool";om.prototype.ValueBufferType=Array;om.prototype.DefaultInterpolation=ex;om.prototype.InterpolantFactoryMethodLinear=void 0;om.prototype.InterpolantFactoryMethodSmooth=void 0;class eM extends wu{}eM.prototype.ValueTypeName="color";class fx extends wu{}fx.prototype.ValueTypeName="number";class Rz extends Qx{constructor(e,t,r,s){super(e,t,r,s)}interpolate_(e,t,r,s){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(r-t)/(s-t);let u=e*a;for(let c=u+a;u!==c;u+=4)bo.slerpFlat(i,0,o,u-a,o,u,l);return i}}class Gy extends wu{InterpolantFactoryMethodLinear(e){return new Rz(this.times,this.values,this.getValueSize(),e)}}Gy.prototype.ValueTypeName="quaternion";Gy.prototype.DefaultInterpolation=tx;Gy.prototype.InterpolantFactoryMethodSmooth=void 0;class am extends wu{}am.prototype.ValueTypeName="string";am.prototype.ValueBufferType=Array;am.prototype.DefaultInterpolation=ex;am.prototype.InterpolantFactoryMethodLinear=void 0;am.prototype.InterpolantFactoryMethodSmooth=void 0;class px extends wu{}px.prototype.ValueTypeName="vector";class mx{constructor(e,t=-1,r,s=G_){this.name=e,this.tracks=r,this.duration=t,this.blendMode=s,this.uuid=Ha(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],r=e.tracks,s=1/(e.fps||1);for(let o=0,a=r.length;o!==a;++o)t.push(gY(r[o]).scale(s));const i=new this(e.name,e.duration,t,e.blendMode);return i.uuid=e.uuid,i}static toJSON(e){const t=[],r=e.tracks,s={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let i=0,o=r.length;i!==o;++i)t.push(wu.toJSON(r[i]));return s}static CreateFromMorphTargetSequence(e,t,r,s){const i=t.length,o=[];for(let a=0;a<i;a++){let l=[],u=[];l.push((a+i-1)%i,a,(a+1)%i),u.push(0,1,0);const c=Az(l);l=KI(l,1,c),u=KI(u,1,c),!s&&l[0]===0&&(l.push(i),u.push(u[0])),o.push(new fx(".morphTargetInfluences["+t[a].name+"]",l,u).scale(1/r))}return new this(e,-1,o)}static findByName(e,t){let r=e;if(!Array.isArray(e)){const s=e;r=s.geometry&&s.geometry.animations||s.animations}for(let s=0;s<r.length;s++)if(r[s].name===t)return r[s];return null}static CreateClipsFromMorphTargetSequences(e,t,r){const s={},i=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const u=e[a],c=u.name.match(i);if(c&&c.length>1){const h=c[1];let d=s[h];d||(s[h]=d=[]),d.push(u)}}const o=[];for(const a in s)o.push(this.CreateFromMorphTargetSequence(a,s[a],t,r));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const r=function(h,d,p,g,w){if(p.length!==0){const y=[],x=[];JA(p,y,x,g),y.length!==0&&w.push(new h(d,y,x))}},s=[],i=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const u=e.hierarchy||[];for(let h=0;h<u.length;h++){const d=u[h].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let g;for(g=0;g<d.length;g++)if(d[g].morphTargets)for(let w=0;w<d[g].morphTargets.length;w++)p[d[g].morphTargets[w]]=-1;for(const w in p){const y=[],x=[];for(let _=0;_!==d[g].morphTargets.length;++_){const T=d[g];y.push(T.time),x.push(T.morphTarget===w?1:0)}s.push(new fx(".morphTargetInfluence["+w+"]",y,x))}l=p.length*o}else{const p=".bones["+t[h].name+"]";r(px,p+".position",d,"pos",s),r(Gy,p+".quaternion",d,"rot",s),r(px,p+".scale",d,"scl",s)}}return s.length===0?null:new this(i,l,s,a)}resetDuration(){const e=this.tracks;let t=0;for(let r=0,s=e.length;r!==s;++r){const i=this.tracks[r];t=Math.max(t,i.times[i.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function mY(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return fx;case"vector":case"vector2":case"vector3":case"vector4":return px;case"color":return eM;case"quaternion":return Gy;case"bool":case"boolean":return om;case"string":return am}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function gY(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=mY(n.type);if(n.times===void 0){const t=[],r=[];JA(n.keys,t,r,"value"),n.times=t,n.values=r}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const th={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class tM{constructor(e,t,r){const s=this;let i=!1,o=0,a=0,l;const u=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=r,this.itemStart=function(c){a++,i===!1&&s.onStart!==void 0&&s.onStart(c,o,a),i=!0},this.itemEnd=function(c){o++,s.onProgress!==void 0&&s.onProgress(c,o,a),o===a&&(i=!1,s.onLoad!==void 0&&s.onLoad())},this.itemError=function(c){s.onError!==void 0&&s.onError(c)},this.resolveURL=function(c){return l?l(c):c},this.setURLModifier=function(c){return l=c,this},this.addHandler=function(c,h){return u.push(c,h),this},this.removeHandler=function(c){const h=u.indexOf(c);return h!==-1&&u.splice(h,2),this},this.getHandler=function(c){for(let h=0,d=u.length;h<d;h+=2){const p=u[h],g=u[h+1];if(p.global&&(p.lastIndex=0),p.test(c))return g}return null}}}const Dz=new tM;class Ca{constructor(e){this.manager=e!==void 0?e:Dz,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const r=this;return new Promise(function(s,i){r.load(e,s,t,i)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}Ca.DEFAULT_MATERIAL_NAME="__DEFAULT";const Xc={};class yY extends Error{constructor(e,t){super(e),this.response=t}}class ah extends Ca{constructor(e){super(e)}load(e,t,r,s){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=th.get(e);if(i!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(i),this.manager.itemEnd(e)},0),i;if(Xc[e]!==void 0){Xc[e].push({onLoad:t,onProgress:r,onError:s});return}Xc[e]=[],Xc[e].push({onLoad:t,onProgress:r,onError:s});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,l=this.responseType;fetch(o).then(u=>{if(u.status===200||u.status===0){if(u.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||u.body===void 0||u.body.getReader===void 0)return u;const c=Xc[e],h=u.body.getReader(),d=u.headers.get("Content-Length")||u.headers.get("X-File-Size"),p=d?parseInt(d):0,g=p!==0;let w=0;const y=new ReadableStream({start(x){_();function _(){h.read().then(({done:T,value:E})=>{if(T)x.close();else{w+=E.byteLength;const N=new ProgressEvent("progress",{lengthComputable:g,loaded:w,total:p});for(let M=0,$=c.length;M<$;M++){const L=c[M];L.onProgress&&L.onProgress(N)}x.enqueue(E),_()}})}}});return new Response(y)}else throw new yY(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`,u)}).then(u=>{switch(l){case"arraybuffer":return u.arrayBuffer();case"blob":return u.blob();case"document":return u.text().then(c=>new DOMParser().parseFromString(c,a));case"json":return u.json();default:if(a===void 0)return u.text();{const h=/charset="?([^;"\s]*)"?/i.exec(a),d=h&&h[1]?h[1].toLowerCase():void 0,p=new TextDecoder(d);return u.arrayBuffer().then(g=>p.decode(g))}}}).then(u=>{th.add(e,u);const c=Xc[e];delete Xc[e];for(let h=0,d=c.length;h<d;h++){const p=c[h];p.onLoad&&p.onLoad(u)}}).catch(u=>{const c=Xc[e];if(c===void 0)throw this.manager.itemError(e),u;delete Xc[e];for(let h=0,d=c.length;h<d;h++){const p=c[h];p.onError&&p.onError(u)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class vY extends Ca{constructor(e){super(e)}load(e,t,r,s){const i=this,o=new ah(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{t(i.parse(JSON.parse(a)))}catch(l){s?s(l):console.error(l),i.manager.itemError(e)}},r,s)}parse(e){const t=[];for(let r=0;r<e.length;r++){const s=mx.parse(e[r]);t.push(s)}return t}}class xY extends Ca{constructor(e){super(e)}load(e,t,r,s){const i=this,o=[],a=new Q_,l=new ah(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(i.withCredentials);let u=0;function c(h){l.load(e[h],function(d){const p=i.parse(d,!0);o[h]={width:p.width,height:p.height,format:p.format,mipmaps:p.mipmaps},u+=1,u===6&&(p.mipmapCount===1&&(a.minFilter=Lr),a.image=o,a.format=p.format,a.needsUpdate=!0,t&&t(a))},r,s)}if(Array.isArray(e))for(let h=0,d=e.length;h<d;++h)c(h);else l.load(e,function(h){const d=i.parse(h,!0);if(d.isCubemap){const p=d.mipmaps.length/d.mipmapCount;for(let g=0;g<p;g++){o[g]={mipmaps:[]};for(let w=0;w<d.mipmapCount;w++)o[g].mipmaps.push(d.mipmaps[g*d.mipmapCount+w]),o[g].format=d.format,o[g].width=d.width,o[g].height=d.height}a.image=o}else a.image.width=d.width,a.image.height=d.height,a.mipmaps=d.mipmaps;d.mipmapCount===1&&(a.minFilter=Lr),a.format=d.format,a.needsUpdate=!0,t&&t(a)},r,s);return a}}class gx extends Ca{constructor(e){super(e)}load(e,t,r,s){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,o=th.get(e);if(o!==void 0)return i.manager.itemStart(e),setTimeout(function(){t&&t(o),i.manager.itemEnd(e)},0),o;const a=ax("img");function l(){c(),th.add(e,this),t&&t(this),i.manager.itemEnd(e)}function u(h){c(),s&&s(h),i.manager.itemError(e),i.manager.itemEnd(e)}function c(){a.removeEventListener("load",l,!1),a.removeEventListener("error",u,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",u,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),i.manager.itemStart(e),a.src=e,a}}class $z extends Ca{constructor(e){super(e)}load(e,t,r,s){const i=new jx;i.colorSpace=sr;const o=new gx(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(u){o.load(e[u],function(c){i.images[u]=c,a++,a===6&&(i.needsUpdate=!0,t&&t(i))},void 0,s)}for(let u=0;u<e.length;++u)l(u);return i}}class nM extends Ca{constructor(e){super(e)}load(e,t,r,s){const i=this,o=new Mp,a=new ah(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(i.withCredentials),a.load(e,function(l){let u;try{u=i.parse(l)}catch(c){if(s!==void 0)s(c);else{console.error(c);return}}u.image!==void 0?o.image=u.image:u.data!==void 0&&(o.image.width=u.width,o.image.height=u.height,o.image.data=u.data),o.wrapS=u.wrapS!==void 0?u.wrapS:mo,o.wrapT=u.wrapT!==void 0?u.wrapT:mo,o.magFilter=u.magFilter!==void 0?u.magFilter:Lr,o.minFilter=u.minFilter!==void 0?u.minFilter:Lr,o.anisotropy=u.anisotropy!==void 0?u.anisotropy:1,u.colorSpace!==void 0?o.colorSpace=u.colorSpace:u.encoding!==void 0&&(o.encoding=u.encoding),u.flipY!==void 0&&(o.flipY=u.flipY),u.format!==void 0&&(o.format=u.format),u.type!==void 0&&(o.type=u.type),u.mipmaps!==void 0&&(o.mipmaps=u.mipmaps,o.minFilter=Ad),u.mipmapCount===1&&(o.minFilter=Lr),u.generateMipmaps!==void 0&&(o.generateMipmaps=u.generateMipmaps),o.needsUpdate=!0,t&&t(o,u)},r,s),o}}class Pz extends Ca{constructor(e){super(e)}load(e,t,r,s){const i=new fs,o=new gx(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){i.image=a,i.needsUpdate=!0,t!==void 0&&t(i)},r,s),i}}class qd extends dr{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new Nt(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}class Lz extends qd{constructor(e,t,r){super(e,r),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(dr.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Nt(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const d2=new _n,_3=new le,T3=new le;class rM{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new rt(512,512),this.map=null,this.mapPass=null,this.matrix=new _n,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Xx,this._frameExtents=new rt(1,1),this._viewportCount=1,this._viewports=[new br(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,r=this.matrix;_3.setFromMatrixPosition(e.matrixWorld),t.position.copy(_3),T3.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(T3),t.updateMatrixWorld(),d2.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(d2),r.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),r.multiply(d2)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class wY extends rM{constructor(){super(new fi(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,r=yy*2*e.angle*this.focus,s=this.mapSize.width/this.mapSize.height,i=e.distance||t.far;(r!==t.fov||s!==t.aspect||i!==t.far)&&(t.fov=r,t.aspect=s,t.far=i,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class Oz extends qd{constructor(e,t,r=0,s=Math.PI/3,i=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(dr.DEFAULT_UP),this.updateMatrix(),this.target=new dr,this.distance=r,this.angle=s,this.penumbra=i,this.decay=o,this.map=null,this.shadow=new wY}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const E3=new _n,yv=new le,f2=new le;class bY extends rM{constructor(){super(new fi(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new rt(4,2),this._viewportCount=6,this._viewports=[new br(2,1,1,1),new br(0,1,1,1),new br(3,1,1,1),new br(1,1,1,1),new br(3,0,1,1),new br(1,0,1,1)],this._cubeDirections=[new le(1,0,0),new le(-1,0,0),new le(0,0,1),new le(0,0,-1),new le(0,1,0),new le(0,-1,0)],this._cubeUps=[new le(0,1,0),new le(0,1,0),new le(0,1,0),new le(0,1,0),new le(0,0,1),new le(0,0,-1)]}updateMatrices(e,t=0){const r=this.camera,s=this.matrix,i=e.distance||r.far;i!==r.far&&(r.far=i,r.updateProjectionMatrix()),yv.setFromMatrixPosition(e.matrixWorld),r.position.copy(yv),f2.copy(r.position),f2.add(this._cubeDirections[t]),r.up.copy(this._cubeUps[t]),r.lookAt(f2),r.updateMatrixWorld(),s.makeTranslation(-yv.x,-yv.y,-yv.z),E3.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),this._frustum.setFromProjectionMatrix(E3)}}class Fz extends qd{constructor(e,t,r=0,s=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=r,this.decay=s,this.shadow=new bY}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class SY extends rM{constructor(){super(new zy(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class zz extends qd{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(dr.DEFAULT_UP),this.updateMatrix(),this.target=new dr,this.shadow=new SY}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class Bz extends qd{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class Uz extends qd{constructor(e,t,r=10,s=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=r,this.height=s}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class Vz{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new le)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const r=e.x,s=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*s),t.addScaledVector(o[2],.488603*i),t.addScaledVector(o[3],.488603*r),t.addScaledVector(o[4],1.092548*(r*s)),t.addScaledVector(o[5],1.092548*(s*i)),t.addScaledVector(o[6],.315392*(3*i*i-1)),t.addScaledVector(o[7],1.092548*(r*i)),t.addScaledVector(o[8],.546274*(r*r-s*s)),t}getIrradianceAt(e,t){const r=e.x,s=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*s),t.addScaledVector(o[2],2*.511664*i),t.addScaledVector(o[3],2*.511664*r),t.addScaledVector(o[4],2*.429043*r*s),t.addScaledVector(o[5],2*.429043*s*i),t.addScaledVector(o[6],.743125*i*i-.247708),t.addScaledVector(o[7],2*.429043*r*i),t.addScaledVector(o[8],.429043*(r*r-s*s)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let r=0;r<9;r++)this.coefficients[r].addScaledVector(e.coefficients[r],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let r=0;r<9;r++)this.coefficients[r].lerp(e.coefficients[r],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const r=this.coefficients;for(let s=0;s<9;s++)r[s].fromArray(e,t+s*3);return this}toArray(e=[],t=0){const r=this.coefficients;for(let s=0;s<9;s++)r[s].toArray(e,t+s*3);return e}static getBasisAt(e,t){const r=e.x,s=e.y,i=e.z;t[0]=.282095,t[1]=.488603*s,t[2]=.488603*i,t[3]=.488603*r,t[4]=1.092548*r*s,t[5]=1.092548*s*i,t[6]=.315392*(3*i*i-1),t[7]=1.092548*r*i,t[8]=.546274*(r*r-s*s)}}class Wz extends qd{constructor(e=new Vz,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class hT extends Ca{constructor(e){super(e),this.textures={}}load(e,t,r,s){const i=this,o=new ah(i.manager);o.setPath(i.path),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials),o.load(e,function(a){try{t(i.parse(JSON.parse(a)))}catch(l){s?s(l):console.error(l),i.manager.itemError(e)}},r,s)}parse(e){const t=this.textures;function r(i){return t[i]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",i),t[i]}const s=hT.createMaterialFromType(e.type);if(e.uuid!==void 0&&(s.uuid=e.uuid),e.name!==void 0&&(s.name=e.name),e.color!==void 0&&s.color!==void 0&&s.color.setHex(e.color),e.roughness!==void 0&&(s.roughness=e.roughness),e.metalness!==void 0&&(s.metalness=e.metalness),e.sheen!==void 0&&(s.sheen=e.sheen),e.sheenColor!==void 0&&(s.sheenColor=new Nt().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(s.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&s.emissive!==void 0&&s.emissive.setHex(e.emissive),e.specular!==void 0&&s.specular!==void 0&&s.specular.setHex(e.specular),e.specularIntensity!==void 0&&(s.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&s.specularColor!==void 0&&s.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(s.shininess=e.shininess),e.clearcoat!==void 0&&(s.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=e.clearcoatRoughness),e.iridescence!==void 0&&(s.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(s.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(s.transmission=e.transmission),e.thickness!==void 0&&(s.thickness=e.thickness),e.attenuationDistance!==void 0&&(s.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&s.attenuationColor!==void 0&&s.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(s.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(s.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(s.fog=e.fog),e.flatShading!==void 0&&(s.flatShading=e.flatShading),e.blending!==void 0&&(s.blending=e.blending),e.combine!==void 0&&(s.combine=e.combine),e.side!==void 0&&(s.side=e.side),e.shadowSide!==void 0&&(s.shadowSide=e.shadowSide),e.opacity!==void 0&&(s.opacity=e.opacity),e.transparent!==void 0&&(s.transparent=e.transparent),e.alphaTest!==void 0&&(s.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(s.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(s.depthFunc=e.depthFunc),e.depthTest!==void 0&&(s.depthTest=e.depthTest),e.depthWrite!==void 0&&(s.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(s.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(s.blendSrc=e.blendSrc),e.blendDst!==void 0&&(s.blendDst=e.blendDst),e.blendEquation!==void 0&&(s.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(s.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(s.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(s.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&s.blendColor!==void 0&&s.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(s.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(s.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(s.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(s.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(s.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(s.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(s.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(s.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(s.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(s.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(s.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(s.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(s.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(s.rotation=e.rotation),e.linewidth!==void 0&&(s.linewidth=e.linewidth),e.dashSize!==void 0&&(s.dashSize=e.dashSize),e.gapSize!==void 0&&(s.gapSize=e.gapSize),e.scale!==void 0&&(s.scale=e.scale),e.polygonOffset!==void 0&&(s.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(s.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(s.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(s.dithering=e.dithering),e.alphaToCoverage!==void 0&&(s.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(s.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(s.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(s.visible=e.visible),e.toneMapped!==void 0&&(s.toneMapped=e.toneMapped),e.userData!==void 0&&(s.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?s.vertexColors=e.vertexColors>0:s.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const i in e.uniforms){const o=e.uniforms[i];switch(s.uniforms[i]={},o.type){case"t":s.uniforms[i].value=r(o.value);break;case"c":s.uniforms[i].value=new Nt().setHex(o.value);break;case"v2":s.uniforms[i].value=new rt().fromArray(o.value);break;case"v3":s.uniforms[i].value=new le().fromArray(o.value);break;case"v4":s.uniforms[i].value=new br().fromArray(o.value);break;case"m3":s.uniforms[i].value=new jn().fromArray(o.value);break;case"m4":s.uniforms[i].value=new _n().fromArray(o.value);break;default:s.uniforms[i].value=o.value}}if(e.defines!==void 0&&(s.defines=e.defines),e.vertexShader!==void 0&&(s.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(s.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(s.glslVersion=e.glslVersion),e.extensions!==void 0)for(const i in e.extensions)s.extensions[i]=e.extensions[i];if(e.lights!==void 0&&(s.lights=e.lights),e.clipping!==void 0&&(s.clipping=e.clipping),e.size!==void 0&&(s.size=e.size),e.sizeAttenuation!==void 0&&(s.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(s.map=r(e.map)),e.matcap!==void 0&&(s.matcap=r(e.matcap)),e.alphaMap!==void 0&&(s.alphaMap=r(e.alphaMap)),e.bumpMap!==void 0&&(s.bumpMap=r(e.bumpMap)),e.bumpScale!==void 0&&(s.bumpScale=e.bumpScale),e.normalMap!==void 0&&(s.normalMap=r(e.normalMap)),e.normalMapType!==void 0&&(s.normalMapType=e.normalMapType),e.normalScale!==void 0){let i=e.normalScale;Array.isArray(i)===!1&&(i=[i,i]),s.normalScale=new rt().fromArray(i)}return e.displacementMap!==void 0&&(s.displacementMap=r(e.displacementMap)),e.displacementScale!==void 0&&(s.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(s.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(s.roughnessMap=r(e.roughnessMap)),e.metalnessMap!==void 0&&(s.metalnessMap=r(e.metalnessMap)),e.emissiveMap!==void 0&&(s.emissiveMap=r(e.emissiveMap)),e.emissiveIntensity!==void 0&&(s.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(s.specularMap=r(e.specularMap)),e.specularIntensityMap!==void 0&&(s.specularIntensityMap=r(e.specularIntensityMap)),e.specularColorMap!==void 0&&(s.specularColorMap=r(e.specularColorMap)),e.envMap!==void 0&&(s.envMap=r(e.envMap)),e.envMapIntensity!==void 0&&(s.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(s.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(s.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(s.lightMap=r(e.lightMap)),e.lightMapIntensity!==void 0&&(s.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(s.aoMap=r(e.aoMap)),e.aoMapIntensity!==void 0&&(s.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(s.gradientMap=r(e.gradientMap)),e.clearcoatMap!==void 0&&(s.clearcoatMap=r(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(s.clearcoatRoughnessMap=r(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(s.clearcoatNormalMap=r(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(s.clearcoatNormalScale=new rt().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(s.iridescenceMap=r(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(s.iridescenceThicknessMap=r(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(s.transmissionMap=r(e.transmissionMap)),e.thicknessMap!==void 0&&(s.thicknessMap=r(e.thicknessMap)),e.anisotropyMap!==void 0&&(s.anisotropyMap=r(e.anisotropyMap)),e.sheenColorMap!==void 0&&(s.sheenColorMap=r(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(s.sheenRoughnessMap=r(e.sheenRoughnessMap)),s}setTextures(e){return this.textures=e,this}static createMaterialFromType(e){const t={ShadowMaterial:wz,SpriteMaterial:UA,RawShaderMaterial:bz,ShaderMaterial:ni,PointsMaterial:WA,MeshPhysicalMaterial:Sz,MeshStandardMaterial:Fu,MeshPhongMaterial:_z,MeshToonMaterial:Tz,MeshNormalMaterial:ZA,MeshLambertMaterial:Ez,MeshDepthMaterial:FA,MeshDistanceMaterial:zA,MeshBasicMaterial:Hd,MeshMatcapMaterial:Cz,LineDashedMaterial:Iz,LineBasicMaterial:Jo,Material:Si};return new t[e]}}class YI{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class Gz extends zn{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class Hz extends Ca{constructor(e){super(e)}load(e,t,r,s){const i=this,o=new ah(i.manager);o.setPath(i.path),o.setRequestHeader(i.requestHeader),o.setWithCredentials(i.withCredentials),o.load(e,function(a){try{t(i.parse(JSON.parse(a)))}catch(l){s?s(l):console.error(l),i.manager.itemError(e)}},r,s)}parse(e){const t={},r={};function s(p,g){if(t[g]!==void 0)return t[g];const y=p.interleavedBuffers[g],x=i(p,y.buffer),_=ey(y.type,x),T=new Z_(_,y.stride);return T.uuid=y.uuid,t[g]=T,T}function i(p,g){if(r[g]!==void 0)return r[g];const y=p.arrayBuffers[g],x=new Uint32Array(y).buffer;return r[g]=x,x}const o=e.isInstancedBufferGeometry?new Gz:new zn,a=e.data.index;if(a!==void 0){const p=ey(a.type,a.array);o.setIndex(new Cr(p,1))}const l=e.data.attributes;for(const p in l){const g=l[p];let w;if(g.isInterleavedBufferAttribute){const y=s(e.data,g.data);w=new Op(y,g.itemSize,g.offset,g.normalized)}else{const y=ey(g.type,g.array),x=g.isInstancedBufferAttribute?xy:Cr;w=new x(y,g.itemSize,g.normalized)}g.name!==void 0&&(w.name=g.name),g.usage!==void 0&&w.setUsage(g.usage),o.setAttribute(p,w)}const u=e.data.morphAttributes;if(u)for(const p in u){const g=u[p],w=[];for(let y=0,x=g.length;y<x;y++){const _=g[y];let T;if(_.isInterleavedBufferAttribute){const E=s(e.data,_.data);T=new Op(E,_.itemSize,_.offset,_.normalized)}else{const E=ey(_.type,_.array);T=new Cr(E,_.itemSize,_.normalized)}_.name!==void 0&&(T.name=_.name),w.push(T)}o.morphAttributes[p]=w}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const h=e.data.groups||e.data.drawcalls||e.data.offsets;if(h!==void 0)for(let p=0,g=h.length;p!==g;++p){const w=h[p];o.addGroup(w.start,w.count,w.materialIndex)}const d=e.data.boundingSphere;if(d!==void 0){const p=new le;d.center!==void 0&&p.fromArray(d.center),o.boundingSphere=new So(p,d.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}class _Y extends Ca{constructor(e){super(e)}load(e,t,r,s){const i=this,o=this.path===""?YI.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new ah(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let u=null;try{u=JSON.parse(l)}catch(h){s!==void 0&&s(h),console.error("THREE:ObjectLoader: Can't parse "+e+".",h.message);return}const c=u.metadata;if(c===void 0||c.type===void 0||c.type.toLowerCase()==="geometry"){s!==void 0&&s(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}i.parse(u,t)},r,s)}async loadAsync(e,t){const r=this,s=this.path===""?YI.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||s;const i=new ah(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials);const o=await i.loadAsync(e,t),a=JSON.parse(o),l=a.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await r.parseAsync(a)}parse(e,t){const r=this.parseAnimations(e.animations),s=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,s),o=this.parseImages(e.images,function(){t!==void 0&&t(u)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),u=this.parseObject(e.object,i,l,a,r),c=this.parseSkeletons(e.skeletons,u);if(this.bindSkeletons(u,c),t!==void 0){let h=!1;for(const d in o)if(o[d].data instanceof HTMLImageElement){h=!0;break}h===!1&&t(u)}return u}async parseAsync(e){const t=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),s=this.parseGeometries(e.geometries,r),i=await this.parseImagesAsync(e.images),o=this.parseTextures(e.textures,i),a=this.parseMaterials(e.materials,o),l=this.parseObject(e.object,s,a,o,t),u=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,u),l}parseShapes(e){const t={};if(e!==void 0)for(let r=0,s=e.length;r<s;r++){const i=new sh().fromJSON(e[r]);t[i.uuid]=i}return t}parseSkeletons(e,t){const r={},s={};if(t.traverse(function(i){i.isBone&&(s[i.uuid]=i)}),e!==void 0)for(let i=0,o=e.length;i<o;i++){const a=new J_().fromJSON(e[i],s);r[a.uuid]=a}return r}parseGeometries(e,t){const r={};if(e!==void 0){const s=new Hz;for(let i=0,o=e.length;i<o;i++){let a;const l=e[i];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":a=s.parse(l);break;default:l.type in S3?a=S3[l.type].fromJSON(l,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}a.uuid=l.uuid,l.name!==void 0&&(a.name=l.name),l.userData!==void 0&&(a.userData=l.userData),r[l.uuid]=a}}return r}parseMaterials(e,t){const r={},s={};if(e!==void 0){const i=new hT;i.setTextures(t);for(let o=0,a=e.length;o<a;o++){const l=e[o];r[l.uuid]===void 0&&(r[l.uuid]=i.parse(l)),s[l.uuid]=r[l.uuid]}}return s}parseAnimations(e){const t={};if(e!==void 0)for(let r=0;r<e.length;r++){const s=e[r],i=mx.parse(s);t[i.uuid]=i}return t}parseImages(e,t){const r=this,s={};let i;function o(l){return r.manager.itemStart(l),i.load(l,function(){r.manager.itemEnd(l)},void 0,function(){r.manager.itemError(l),r.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const u=l,c=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(u)?u:r.resourcePath+u;return o(c)}else return l.data?{data:ey(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new tM(t);i=new gx(l),i.setCrossOrigin(this.crossOrigin);for(let u=0,c=e.length;u<c;u++){const h=e[u],d=h.url;if(Array.isArray(d)){const p=[];for(let g=0,w=d.length;g<w;g++){const y=d[g],x=a(y);x!==null&&(x instanceof HTMLImageElement?p.push(x):p.push(new Mp(x.data,x.width,x.height)))}s[h.uuid]=new vp(p)}else{const p=a(h.url);s[h.uuid]=new vp(p)}}}return s}async parseImagesAsync(e){const t=this,r={};let s;async function i(o){if(typeof o=="string"){const a=o,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:t.resourcePath+a;return await s.loadAsync(l)}else return o.data?{data:ey(o.type,o.data),width:o.width,height:o.height}:null}if(e!==void 0&&e.length>0){s=new gx(this.manager),s.setCrossOrigin(this.crossOrigin);for(let o=0,a=e.length;o<a;o++){const l=e[o],u=l.url;if(Array.isArray(u)){const c=[];for(let h=0,d=u.length;h<d;h++){const p=u[h],g=await i(p);g!==null&&(g instanceof HTMLImageElement?c.push(g):c.push(new Mp(g.data,g.width,g.height)))}r[l.uuid]=new vp(c)}else{const c=await i(l.url);r[l.uuid]=new vp(c)}}}return r}parseTextures(e,t){function r(i,o){return typeof i=="number"?i:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",i),o[i])}const s={};if(e!==void 0)for(let i=0,o=e.length;i<o;i++){const a=e[i];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const l=t[a.image],u=l.data;let c;Array.isArray(u)?(c=new jx,u.length===6&&(c.needsUpdate=!0)):(u&&u.data?c=new Mp:c=new fs,u&&(c.needsUpdate=!0)),c.source=l,c.uuid=a.uuid,a.name!==void 0&&(c.name=a.name),a.mapping!==void 0&&(c.mapping=r(a.mapping,TY)),a.channel!==void 0&&(c.channel=a.channel),a.offset!==void 0&&c.offset.fromArray(a.offset),a.repeat!==void 0&&c.repeat.fromArray(a.repeat),a.center!==void 0&&c.center.fromArray(a.center),a.rotation!==void 0&&(c.rotation=a.rotation),a.wrap!==void 0&&(c.wrapS=r(a.wrap[0],C3),c.wrapT=r(a.wrap[1],C3)),a.format!==void 0&&(c.format=a.format),a.internalFormat!==void 0&&(c.internalFormat=a.internalFormat),a.type!==void 0&&(c.type=a.type),a.colorSpace!==void 0&&(c.colorSpace=a.colorSpace),a.encoding!==void 0&&(c.encoding=a.encoding),a.minFilter!==void 0&&(c.minFilter=r(a.minFilter,I3)),a.magFilter!==void 0&&(c.magFilter=r(a.magFilter,I3)),a.anisotropy!==void 0&&(c.anisotropy=a.anisotropy),a.flipY!==void 0&&(c.flipY=a.flipY),a.generateMipmaps!==void 0&&(c.generateMipmaps=a.generateMipmaps),a.premultiplyAlpha!==void 0&&(c.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(c.unpackAlignment=a.unpackAlignment),a.compareFunction!==void 0&&(c.compareFunction=a.compareFunction),a.userData!==void 0&&(c.userData=a.userData),s[a.uuid]=c}return s}parseObject(e,t,r,s,i){let o;function a(d){return t[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",d),t[d]}function l(d){if(d!==void 0){if(Array.isArray(d)){const p=[];for(let g=0,w=d.length;g<w;g++){const y=d[g];r[y]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",y),p.push(r[y])}return p}return r[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",d),r[d]}}function u(d){return s[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",d),s[d]}let c,h;switch(e.type){case"Scene":o=new Lp,e.background!==void 0&&(Number.isInteger(e.background)?o.background=new Nt(e.background):o.background=u(e.background)),e.environment!==void 0&&(o.environment=u(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?o.fog=new Y_(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(o.fog=new K_(e.fog.color,e.fog.density)),e.fog.name!==""&&(o.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(o.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(o.backgroundIntensity=e.backgroundIntensity);break;case"PerspectiveCamera":o=new fi(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(o.focus=e.focus),e.zoom!==void 0&&(o.zoom=e.zoom),e.filmGauge!==void 0&&(o.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(o.filmOffset=e.filmOffset),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new zy(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(o.zoom=e.zoom),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new Bz(e.color,e.intensity);break;case"DirectionalLight":o=new zz(e.color,e.intensity);break;case"PointLight":o=new Fz(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new Uz(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new Oz(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":o=new Lz(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=new Wz().fromJSON(e);break;case"SkinnedMesh":c=a(e.geometry),h=l(e.material),o=new oz(c,h),e.bindMode!==void 0&&(o.bindMode=e.bindMode),e.bindMatrix!==void 0&&o.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(o.skeleton=e.skeleton);break;case"Mesh":c=a(e.geometry),h=l(e.material),o=new zs(c,h);break;case"InstancedMesh":c=a(e.geometry),h=l(e.material);const d=e.count,p=e.instanceMatrix,g=e.instanceColor;o=new az(c,h,d),o.instanceMatrix=new xy(new Float32Array(p.array),16),g!==void 0&&(o.instanceColor=new xy(new Float32Array(g.array),g.itemSize));break;case"BatchedMesh":c=a(e.geometry),h=l(e.material),o=new lz(e.maxGeometryCount,e.maxVertexCount,e.maxIndexCount,h),o.geometry=c,o.perObjectFrustumCulled=e.perObjectFrustumCulled,o.sortObjects=e.sortObjects,o._drawRanges=e.drawRanges,o._reservedRanges=e.reservedRanges,o._visibility=e.visibility,o._active=e.active,o._bounds=e.bounds.map(w=>{const y=new jo;y.min.fromArray(w.boxMin),y.max.fromArray(w.boxMax);const x=new So;return x.radius=w.sphereRadius,x.center.fromArray(w.sphereCenter),{boxInitialized:w.boxInitialized,box:y,sphereInitialized:w.sphereInitialized,sphere:x}}),o._maxGeometryCount=e.maxGeometryCount,o._maxVertexCount=e.maxVertexCount,o._maxIndexCount=e.maxIndexCount,o._geometryInitialized=e.geometryInitialized,o._geometryCount=e.geometryCount,o._matricesTexture=u(e.matricesTexture.uuid);break;case"LOD":o=new iz;break;case"Line":o=new kd(a(e.geometry),l(e.material));break;case"LineLoop":o=new uz(a(e.geometry),l(e.material));break;case"LineSegments":o=new ac(a(e.geometry),l(e.material));break;case"PointCloud":case"Points":o=new cz(a(e.geometry),l(e.material));break;case"Sprite":o=new sz(l(e.material));break;case"Group":o=new ry;break;case"Bone":o=new VA;break;default:o=new dr}if(o.uuid=e.uuid,e.name!==void 0&&(o.name=e.name),e.matrix!==void 0?(o.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(e.position!==void 0&&o.position.fromArray(e.position),e.rotation!==void 0&&o.rotation.fromArray(e.rotation),e.quaternion!==void 0&&o.quaternion.fromArray(e.quaternion),e.scale!==void 0&&o.scale.fromArray(e.scale)),e.up!==void 0&&o.up.fromArray(e.up),e.castShadow!==void 0&&(o.castShadow=e.castShadow),e.receiveShadow!==void 0&&(o.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(o.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(o.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(o.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&o.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(o.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(o.visible=e.visible),e.frustumCulled!==void 0&&(o.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(o.renderOrder=e.renderOrder),e.userData!==void 0&&(o.userData=e.userData),e.layers!==void 0&&(o.layers.mask=e.layers),e.children!==void 0){const d=e.children;for(let p=0;p<d.length;p++)o.add(this.parseObject(d[p],t,r,s,i))}if(e.animations!==void 0){const d=e.animations;for(let p=0;p<d.length;p++){const g=d[p];o.animations.push(i[g])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(o.autoUpdate=e.autoUpdate);const d=e.levels;for(let p=0;p<d.length;p++){const g=d[p],w=o.getObjectByProperty("uuid",g.object);w!==void 0&&o.addLevel(w,g.distance,g.hysteresis)}}return o}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(r){if(r.isSkinnedMesh===!0&&r.skeleton!==void 0){const s=t[r.skeleton];s===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",r.skeleton):r.bind(s,r.bindMatrix)}})}}const TY={UVMapping:V_,CubeReflectionMapping:tc,CubeRefractionMapping:Nd,EquirectangularReflectionMapping:my,EquirectangularRefractionMapping:Jv,CubeUVReflectionMapping:Ly},C3={RepeatWrapping:Pp,ClampToEdgeWrapping:mo,MirroredRepeatWrapping:Qv},I3={NearestFilter:ss,NearestMipmapNearestFilter:KS,NearestMipmapLinearFilter:Uv,LinearFilter:Lr,LinearMipmapNearestFilter:vA,LinearMipmapLinearFilter:Ad};class EY extends Ca{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,r,s){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,o=th.get(e);if(o!==void 0){if(i.manager.itemStart(e),o.then){o.then(u=>{t&&t(u),i.manager.itemEnd(e)}).catch(u=>{s&&s(u)});return}return setTimeout(function(){t&&t(o),i.manager.itemEnd(e)},0),o}const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader;const l=fetch(e,a).then(function(u){return u.blob()}).then(function(u){return createImageBitmap(u,Object.assign(i.options,{colorSpaceConversion:"none"}))}).then(function(u){return th.add(e,u),t&&t(u),i.manager.itemEnd(e),u}).catch(function(u){s&&s(u),th.remove(e),i.manager.itemError(e),i.manager.itemEnd(e)});th.add(e,l),i.manager.itemStart(e)}}let Qb;class sM{static getContext(){return Qb===void 0&&(Qb=new(window.AudioContext||window.webkitAudioContext)),Qb}static setContext(e){Qb=e}}class CY extends Ca{constructor(e){super(e)}load(e,t,r,s){const i=this,o=new ah(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){try{const u=l.slice(0);sM.getContext().decodeAudioData(u,function(h){t(h)}).catch(a)}catch(u){a(u)}},r,s);function a(l){s?s(l):console.error(l),i.manager.itemError(e)}}}const N3=new _n,A3=new _n,Qf=new _n;class IY{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new fi,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new fi,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,Qf.copy(e.projectionMatrix);const s=t.eyeSep/2,i=s*t.near/t.focus,o=t.near*Math.tan(Np*t.fov*.5)/t.zoom;let a,l;A3.elements[12]=-s,N3.elements[12]=s,a=-o*t.aspect+i,l=o*t.aspect+i,Qf.elements[0]=2*t.near/(l-a),Qf.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(Qf),a=-o*t.aspect-i,l=o*t.aspect-i,Qf.elements[0]=2*t.near/(l-a),Qf.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(Qf)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(A3),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(N3)}}class iM{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=M3(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=M3();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function M3(){return(typeof performance>"u"?Date:performance).now()}const ep=new le,k3=new bo,NY=new le,tp=new le;class AY extends dr{constructor(){super(),this.type="AudioListener",this.context=sM.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new iM}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,r=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(ep,k3,NY),tp.set(0,0,-1).applyQuaternion(k3),t.positionX){const s=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(ep.x,s),t.positionY.linearRampToValueAtTime(ep.y,s),t.positionZ.linearRampToValueAtTime(ep.z,s),t.forwardX.linearRampToValueAtTime(tp.x,s),t.forwardY.linearRampToValueAtTime(tp.y,s),t.forwardZ.linearRampToValueAtTime(tp.z,s),t.upX.linearRampToValueAtTime(r.x,s),t.upY.linearRampToValueAtTime(r.y,s),t.upZ.linearRampToValueAtTime(r.z,s)}else t.setPosition(ep.x,ep.y,ep.z),t.setOrientation(tp.x,tp.y,tp.z,r.x,r.y,r.z)}}class jz extends dr{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const np=new le,R3=new bo,MY=new le,rp=new le;class kY extends jz{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,r){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=r,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(np,R3,MY),rp.set(0,0,1).applyQuaternion(R3);const t=this.panner;if(t.positionX){const r=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(np.x,r),t.positionY.linearRampToValueAtTime(np.y,r),t.positionZ.linearRampToValueAtTime(np.z,r),t.orientationX.linearRampToValueAtTime(rp.x,r),t.orientationY.linearRampToValueAtTime(rp.y,r),t.orientationZ.linearRampToValueAtTime(rp.z,r)}else t.setPosition(np.x,np.y,np.z),t.setOrientation(rp.x,rp.y,rp.z)}}class RY{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let r=0;r<t.length;r++)e+=t[r];return e/t.length}}class Xz{constructor(e,t,r){this.binding=e,this.valueSize=r;let s,i,o;switch(t){case"quaternion":s=this._slerp,i=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(r*6),this._workIndex=5;break;case"string":case"bool":s=this._select,i=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(r*5);break;default:s=this._lerp,i=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(r*5)}this._mixBufferRegion=s,this._mixBufferRegionAdditive=i,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const r=this.buffer,s=this.valueSize,i=e*s+s;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==s;++a)r[i+a]=r[a];o=t}else{o+=t;const a=t/o;this._mixBufferRegion(r,i,0,a,s)}this.cumulativeWeight=o}accumulateAdditive(e){const t=this.buffer,r=this.valueSize,s=r*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,s,0,e,r),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,r=this.buffer,s=e*t+t,i=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1){const l=t*this._origIndex;this._mixBufferRegion(r,s,l,1-i,t)}o>0&&this._mixBufferRegionAdditive(r,s,this._addIndex*t,1,t);for(let l=t,u=t+t;l!==u;++l)if(r[l]!==r[l+t]){a.setValue(r,s);break}}saveOriginalState(){const e=this.binding,t=this.buffer,r=this.valueSize,s=r*this._origIndex;e.getValue(t,s);for(let i=r,o=s;i!==o;++i)t[i]=t[s+i%r];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let r=e;r<t;r++)this.buffer[r]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let r=0;r<this.valueSize;r++)this.buffer[t+r]=this.buffer[e+r]}_select(e,t,r,s,i){if(s>=.5)for(let o=0;o!==i;++o)e[t+o]=e[r+o]}_slerp(e,t,r,s){bo.slerpFlat(e,t,e,t,e,r,s)}_slerpAdditive(e,t,r,s,i){const o=this._workIndex*i;bo.multiplyQuaternionsFlat(e,o,e,t,e,r),bo.slerpFlat(e,t,e,t,e,o,s)}_lerp(e,t,r,s,i){const o=1-s;for(let a=0;a!==i;++a){const l=t+a;e[l]=e[l]*o+e[r+a]*s}}_lerpAdditive(e,t,r,s,i){for(let o=0;o!==i;++o){const a=t+o;e[a]=e[a]+e[r+o]*s}}}const oM="\\[\\]\\.:\\/",DY=new RegExp("["+oM+"]","g"),aM="[^"+oM+"]",$Y="[^"+oM.replace("\\.","")+"]",PY=/((?:WC+[\/:])*)/.source.replace("WC",aM),LY=/(WCOD+)?/.source.replace("WCOD",$Y),OY=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",aM),FY=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",aM),zY=new RegExp("^"+PY+LY+OY+FY+"$"),BY=["material","materials","bones","map"];class UY{constructor(e,t,r){const s=r||gr.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,s)}getValue(e,t){this.bind();const r=this._targetGroup.nCachedObjects_,s=this._bindings[r];s!==void 0&&s.getValue(e,t)}setValue(e,t){const r=this._bindings;for(let s=this._targetGroup.nCachedObjects_,i=r.length;s!==i;++s)r[s].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,r=e.length;t!==r;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,r=e.length;t!==r;++t)e[t].unbind()}}class gr{constructor(e,t,r){this.path=t,this.parsedPath=r||gr.parseTrackName(t),this.node=gr.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,r){return e&&e.isAnimationObjectGroup?new gr.Composite(e,t,r):new gr(e,t,r)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(DY,"")}static parseTrackName(e){const t=zY.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const r={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},s=r.nodeName&&r.nodeName.lastIndexOf(".");if(s!==void 0&&s!==-1){const i=r.nodeName.substring(s+1);BY.indexOf(i)!==-1&&(r.nodeName=r.nodeName.substring(0,s),r.objectName=i)}if(r.propertyName===null||r.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return r}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const r=e.skeleton.getBoneByName(t);if(r!==void 0)return r}if(e.children){const r=function(i){for(let o=0;o<i.length;o++){const a=i[o];if(a.name===t||a.uuid===t)return a;const l=r(a.children);if(l)return l}return null},s=r(e.children);if(s)return s}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)e[t++]=r[s]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)r[s]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)r[s]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const r=this.resolvedProperty;for(let s=0,i=r.length;s!==i;++s)r[s]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,r=t.objectName,s=t.propertyName;let i=t.propertyIndex;if(e||(e=gr.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(r){let u=t.objectIndex;switch(r){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let c=0;c<e.length;c++)if(e[c].name===u){u=c;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[r]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[r]}if(u!==void 0){if(e[u]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[u]}}const o=e[s];if(o===void 0){const u=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+u+"."+s+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(i!==void 0){if(s==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[i]!==void 0&&(i=e.morphTargetDictionary[i])}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=i}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=s;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}gr.Composite=UY;gr.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};gr.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};gr.prototype.GetterByBindingType=[gr.prototype._getValue_direct,gr.prototype._getValue_array,gr.prototype._getValue_arrayElement,gr.prototype._getValue_toArray];gr.prototype.SetterByBindingTypeAndVersioning=[[gr.prototype._setValue_direct,gr.prototype._setValue_direct_setNeedsUpdate,gr.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[gr.prototype._setValue_array,gr.prototype._setValue_array_setNeedsUpdate,gr.prototype._setValue_array_setMatrixWorldNeedsUpdate],[gr.prototype._setValue_arrayElement,gr.prototype._setValue_arrayElement_setNeedsUpdate,gr.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[gr.prototype._setValue_fromArray,gr.prototype._setValue_fromArray_setNeedsUpdate,gr.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class VY{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Ha(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let r=0,s=arguments.length;r!==s;++r)e[arguments[r].uuid]=r;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,r=this._paths,s=this._parsedPaths,i=this._bindings,o=i.length;let a,l=e.length,u=this.nCachedObjects_;for(let c=0,h=arguments.length;c!==h;++c){const d=arguments[c],p=d.uuid;let g=t[p];if(g===void 0){g=l++,t[p]=g,e.push(d);for(let w=0,y=o;w!==y;++w)i[w].push(new gr(d,r[w],s[w]))}else if(g<u){a=e[g];const w=--u,y=e[w];t[y.uuid]=g,e[g]=y,t[p]=w,e[w]=d;for(let x=0,_=o;x!==_;++x){const T=i[x],E=T[w];let N=T[g];T[g]=E,N===void 0&&(N=new gr(d,r[x],s[x])),T[w]=N}}else e[g]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=u}remove(){const e=this._objects,t=this._indicesByUUID,r=this._bindings,s=r.length;let i=this.nCachedObjects_;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],u=l.uuid,c=t[u];if(c!==void 0&&c>=i){const h=i++,d=e[h];t[d.uuid]=c,e[c]=d,t[u]=h,e[h]=l;for(let p=0,g=s;p!==g;++p){const w=r[p],y=w[h],x=w[c];w[c]=y,w[h]=x}}}this.nCachedObjects_=i}uncache(){const e=this._objects,t=this._indicesByUUID,r=this._bindings,s=r.length;let i=this.nCachedObjects_,o=e.length;for(let a=0,l=arguments.length;a!==l;++a){const u=arguments[a],c=u.uuid,h=t[c];if(h!==void 0)if(delete t[c],h<i){const d=--i,p=e[d],g=--o,w=e[g];t[p.uuid]=h,e[h]=p,t[w.uuid]=d,e[d]=w,e.pop();for(let y=0,x=s;y!==x;++y){const _=r[y],T=_[d],E=_[g];_[h]=T,_[d]=E,_.pop()}}else{const d=--o,p=e[d];d>0&&(t[p.uuid]=h),e[h]=p,e.pop();for(let g=0,w=s;g!==w;++g){const y=r[g];y[h]=y[d],y.pop()}}}this.nCachedObjects_=i}subscribe_(e,t){const r=this._bindingsIndicesByPath;let s=r[e];const i=this._bindings;if(s!==void 0)return i[s];const o=this._paths,a=this._parsedPaths,l=this._objects,u=l.length,c=this.nCachedObjects_,h=new Array(u);s=i.length,r[e]=s,o.push(e),a.push(t),i.push(h);for(let d=c,p=l.length;d!==p;++d){const g=l[d];h[d]=new gr(g,e,t)}return h}unsubscribe_(e){const t=this._bindingsIndicesByPath,r=t[e];if(r!==void 0){const s=this._paths,i=this._parsedPaths,o=this._bindings,a=o.length-1,l=o[a],u=e[a];t[u]=r,o[r]=l,o.pop(),i[r]=i[a],i.pop(),s[r]=s[a],s.pop()}}}class qz{constructor(e,t,r=null,s=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=r,this.blendMode=s;const i=t.tracks,o=i.length,a=new Array(o),l={endingStart:gp,endingEnd:gp};for(let u=0;u!==o;++u){const c=i[u].createInterpolant(null);a[u]=c,c.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=kF,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,r){if(e.fadeOut(t),this.fadeIn(t),r){const s=this._clip.duration,i=e._clip.duration,o=i/s,a=s/i;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,r){return e.crossFadeFrom(this,t,r)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,r){const s=this._mixer,i=s.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=s._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,u=a.sampleValues;return l[0]=i,l[1]=i+r,u[0]=e/o,u[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,r,s){if(!this.enabled){this._updateWeight(e);return}const i=this._startTime;if(i!==null){const l=(e-i)*r;l<0||r===0?t=0:(this._startTime=null,t=r*l)}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,u=this._propertyBindings;switch(this.blendMode){case IA:for(let c=0,h=l.length;c!==h;++c)l[c].evaluate(o),u[c].accumulateAdditive(a);break;case G_:default:for(let c=0,h=l.length;c!==h;++c)l[c].evaluate(o),u[c].accumulate(s,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const r=this._weightInterpolant;if(r!==null){const s=r.evaluate(e)[0];t*=s,e>r.parameterPositions[1]&&(this.stopFading(),s===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const r=this._timeScaleInterpolant;if(r!==null){const s=r.evaluate(e)[0];t*=s,e>r.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,r=this.loop;let s=this.time+e,i=this._loopCount;const o=r===RF;if(e===0)return i===-1?s:o&&(i&1)===1?t-s:s;if(r===MF){i===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(s>=t)s=t;else if(s<0)s=0;else{this.time=s;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(i===-1&&(e>=0?(i=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),s>=t||s<0){const a=Math.floor(s/t);s-=t*a,i+=Math.abs(a);const l=this.repetitions-i;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,s=e>0?t:0,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const u=e<0;this._setEndings(u,!u,o)}else this._setEndings(!1,!1,o);this._loopCount=i,this.time=s,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=s;if(o&&(i&1)===1)return t-s}return s}_setEndings(e,t,r){const s=this._interpolantSettings;r?(s.endingStart=yp,s.endingEnd=yp):(e?s.endingStart=this.zeroSlopeAtStart?yp:gp:s.endingStart=nx,t?s.endingEnd=this.zeroSlopeAtEnd?yp:gp:s.endingEnd=nx)}_scheduleFading(e,t,r){const s=this._mixer,i=s.time;let o=this._weightInterpolant;o===null&&(o=s._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=i,l[0]=t,a[1]=i+e,l[1]=r,this}}const WY=new Float32Array(1);class GY extends Tl{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const r=e._localRoot||this._root,s=e._clip.tracks,i=s.length,o=e._propertyBindings,a=e._interpolants,l=r.uuid,u=this._bindingsByRootAndName;let c=u[l];c===void 0&&(c={},u[l]=c);for(let h=0;h!==i;++h){const d=s[h],p=d.name;let g=c[p];if(g!==void 0)++g.referenceCount,o[h]=g;else{if(g=o[h],g!==void 0){g._cacheIndex===null&&(++g.referenceCount,this._addInactiveBinding(g,l,p));continue}const w=t&&t._propertyBindings[h].binding.parsedPath;g=new Xz(gr.create(r,p,w),d.ValueTypeName,d.getValueSize()),++g.referenceCount,this._addInactiveBinding(g,l,p),o[h]=g}a[h].resultBuffer=g.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const r=(e._localRoot||this._root).uuid,s=e._clip.uuid,i=this._actionsByClip[s];this._bindAction(e,i&&i.knownActions[0]),this._addInactiveAction(e,s,r)}const t=e._propertyBindings;for(let r=0,s=t.length;r!==s;++r){const i=t[r];i.useCount++===0&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let r=0,s=t.length;r!==s;++r){const i=t[r];--i.useCount===0&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,r){const s=this._actions,i=this._actionsByClip;let o=i[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,i[t]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=s.length,s.push(e),o.actionByRoot[r]=e}_removeInactiveAction(e){const t=this._actions,r=t[t.length-1],s=e._cacheIndex;r._cacheIndex=s,t[s]=r,t.pop(),e._cacheIndex=null;const i=e._clip.uuid,o=this._actionsByClip,a=o[i],l=a.knownActions,u=l[l.length-1],c=e._byClipCacheIndex;u._byClipCacheIndex=c,l[c]=u,l.pop(),e._byClipCacheIndex=null;const h=a.actionByRoot,d=(e._localRoot||this._root).uuid;delete h[d],l.length===0&&delete o[i],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let r=0,s=t.length;r!==s;++r){const i=t[r];--i.referenceCount===0&&this._removeInactiveBinding(i)}}_lendAction(e){const t=this._actions,r=e._cacheIndex,s=this._nActiveActions++,i=t[s];e._cacheIndex=s,t[s]=e,i._cacheIndex=r,t[r]=i}_takeBackAction(e){const t=this._actions,r=e._cacheIndex,s=--this._nActiveActions,i=t[s];e._cacheIndex=s,t[s]=e,i._cacheIndex=r,t[r]=i}_addInactiveBinding(e,t,r){const s=this._bindingsByRootAndName,i=this._bindings;let o=s[t];o===void 0&&(o={},s[t]=o),o[r]=e,e._cacheIndex=i.length,i.push(e)}_removeInactiveBinding(e){const t=this._bindings,r=e.binding,s=r.rootNode.uuid,i=r.path,o=this._bindingsByRootAndName,a=o[s],l=t[t.length-1],u=e._cacheIndex;l._cacheIndex=u,t[u]=l,t.pop(),delete a[i],Object.keys(a).length===0&&delete o[s]}_lendBinding(e){const t=this._bindings,r=e._cacheIndex,s=this._nActiveBindings++,i=t[s];e._cacheIndex=s,t[s]=e,i._cacheIndex=r,t[r]=i}_takeBackBinding(e){const t=this._bindings,r=e._cacheIndex,s=--this._nActiveBindings,i=t[s];e._cacheIndex=s,t[s]=e,i._cacheIndex=r,t[r]=i}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let r=e[t];return r===void 0&&(r=new QA(new Float32Array(2),new Float32Array(2),1,WY),r.__cacheIndex=t,e[t]=r),r}_takeBackControlInterpolant(e){const t=this._controlInterpolants,r=e.__cacheIndex,s=--this._nActiveControlInterpolants,i=t[s];e.__cacheIndex=s,t[s]=e,i.__cacheIndex=r,t[r]=i}clipAction(e,t,r){const s=t||this._root,i=s.uuid;let o=typeof e=="string"?mx.findByName(s,e):e;const a=o!==null?o.uuid:e,l=this._actionsByClip[a];let u=null;if(r===void 0&&(o!==null?r=o.blendMode:r=G_),l!==void 0){const h=l.actionByRoot[i];if(h!==void 0&&h.blendMode===r)return h;u=l.knownActions[0],o===null&&(o=u._clip)}if(o===null)return null;const c=new qz(this,o,t,r);return this._bindAction(c,u),this._addInactiveAction(c,a,i),c}existingAction(e,t){const r=t||this._root,s=r.uuid,i=typeof e=="string"?mx.findByName(r,e):e,o=i?i.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[s]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let r=t-1;r>=0;--r)e[r].stop();return this}update(e){e*=this.timeScale;const t=this._actions,r=this._nActiveActions,s=this.time+=e,i=Math.sign(e),o=this._accuIndex^=1;for(let u=0;u!==r;++u)t[u]._update(s,e,i,o);const a=this._bindings,l=this._nActiveBindings;for(let u=0;u!==l;++u)a[u].apply(o);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,r=e.uuid,s=this._actionsByClip,i=s[r];if(i!==void 0){const o=i.knownActions;for(let a=0,l=o.length;a!==l;++a){const u=o[a];this._deactivateAction(u);const c=u._cacheIndex,h=t[t.length-1];u._cacheIndex=null,u._byClipCacheIndex=null,h._cacheIndex=c,t[c]=h,t.pop(),this._removeInactiveBindingsForAction(u)}delete s[r]}}uncacheRoot(e){const t=e.uuid,r=this._actionsByClip;for(const o in r){const a=r[o].actionByRoot,l=a[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const s=this._bindingsByRootAndName,i=s[t];if(i!==void 0)for(const o in i){const a=i[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){const r=this.existingAction(e,t);r!==null&&(this._deactivateAction(r),this._removeInactiveAction(r))}}class Jn{constructor(e){this.value=e}clone(){return new Jn(this.value.clone===void 0?this.value:this.value.clone())}}let HY=0;class jY extends Tl{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:HY++}),this.name="",this.usage=ox,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let r=0,s=t.length;r<s;r++){const i=Array.isArray(t[r])?t[r]:[t[r]];for(let o=0;o<i.length;o++)this.uniforms.push(i[o].clone())}return this}clone(){return new this.constructor().copy(this)}}class XY extends Z_{constructor(e,t,r=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class qY{constructor(e,t,r,s,i){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=t,this.itemSize=r,this.elementSize=s,this.count=i,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}class lM{constructor(e,t,r=0,s=1/0){this.ray=new Oy(e,t),this.near=r,this.far=s,this.camera=null,this.layers=new Ap,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,r=[]){return ZI(e,this,r,t),r.sort(D3),r}intersectObjects(e,t=!0,r=[]){for(let s=0,i=e.length;s<i;s++)ZI(e[s],this,r,t);return r.sort(D3),r}}function D3(n,e){return n.distance-e.distance}function ZI(n,e,t,r){if(n.layers.test(e.layers)&&n.raycast(e,t),r===!0){const s=n.children;for(let i=0,o=s.length;i<o;i++)ZI(s[i],e,t,!0)}}class KY{constructor(e=1,t=0,r=0){return this.radius=e,this.phi=t,this.theta=r,this}set(e,t,r){return this.radius=e,this.phi=t,this.theta=r,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,r){return this.radius=Math.sqrt(e*e+t*t+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(Es(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class YY{constructor(e=1,t=0,r=0){return this.radius=e,this.theta=t,this.y=r,this}set(e,t,r){return this.radius=e,this.theta=t,this.y=r,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,r){return this.radius=Math.sqrt(e*e+r*r),this.theta=Math.atan2(e,r),this.y=t,this}clone(){return new this.constructor().copy(this)}}const $3=new rt;class ZY{constructor(e=new rt(1/0,1/0),t=new rt(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=$3.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,$3).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const P3=new le,eS=new le;class JY{constructor(e=new le,t=new le){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){P3.subVectors(e,this.start),eS.subVectors(this.end,this.start);const r=eS.dot(eS);let i=eS.dot(P3)/r;return t&&(i=Es(i,0,1)),i}closestPointToPoint(e,t,r){const s=this.closestPointToPointParameter(e,t);return this.delta(r).multiplyScalar(s).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const L3=new le;class QY extends dr{constructor(e,t){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const r=new zn,s=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const u=o/l*Math.PI*2,c=a/l*Math.PI*2;s.push(Math.cos(u),Math.sin(u),1,Math.cos(c),Math.sin(c),1)}r.setAttribute("position",new Jt(s,3));const i=new Jo({fog:!1,toneMapped:!1});this.cone=new ac(r,i),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),L3.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(L3),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const ad=new le,tS=new _n,p2=new _n;class eZ extends ac{constructor(e){const t=Kz(e),r=new zn,s=[],i=[],o=new Nt(0,0,1),a=new Nt(0,1,0);for(let u=0;u<t.length;u++){const c=t[u];c.parent&&c.parent.isBone&&(s.push(0,0,0),s.push(0,0,0),i.push(o.r,o.g,o.b),i.push(a.r,a.g,a.b))}r.setAttribute("position",new Jt(s,3)),r.setAttribute("color",new Jt(i,3));const l=new Jo({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(r,l),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,r=this.geometry,s=r.getAttribute("position");p2.copy(this.root.matrixWorld).invert();for(let i=0,o=0;i<t.length;i++){const a=t[i];a.parent&&a.parent.isBone&&(tS.multiplyMatrices(p2,a.matrixWorld),ad.setFromMatrixPosition(tS),s.setXYZ(o,ad.x,ad.y,ad.z),tS.multiplyMatrices(p2,a.parent.matrixWorld),ad.setFromMatrixPosition(tS),s.setXYZ(o+1,ad.x,ad.y,ad.z),o+=2)}r.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function Kz(n){const e=[];n.isBone===!0&&e.push(n);for(let t=0;t<n.children.length;t++)e.push.apply(e,Kz(n.children[t]));return e}class tZ extends zs{constructor(e,t,r){const s=new Wy(t,4,2),i=new Hd({wireframe:!0,fog:!1,toneMapped:!1});super(s,i),this.light=e,this.color=r,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const nZ=new le,O3=new Nt,F3=new Nt;class rZ extends dr{constructor(e,t,r){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,this.type="HemisphereLightHelper";const s=new Zx(t);s.rotateY(Math.PI*.5),this.material=new Hd({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const i=s.getAttribute("position"),o=new Float32Array(i.count*3);s.setAttribute("color",new Cr(o,3)),this.add(new zs(s,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");O3.copy(this.light.color),F3.copy(this.light.groundColor);for(let r=0,s=t.count;r<s;r++){const i=r<s/2?O3:F3;t.setXYZ(r,i.r,i.g,i.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(nZ.setFromMatrixPosition(this.light.matrixWorld).negate())}}class sZ extends ac{constructor(e=10,t=10,r=4473924,s=8947848){r=new Nt(r),s=new Nt(s);const i=t/2,o=e/t,a=e/2,l=[],u=[];for(let d=0,p=0,g=-a;d<=t;d++,g+=o){l.push(-a,0,g,a,0,g),l.push(g,0,-a,g,0,a);const w=d===i?r:s;w.toArray(u,p),p+=3,w.toArray(u,p),p+=3,w.toArray(u,p),p+=3,w.toArray(u,p),p+=3}const c=new zn;c.setAttribute("position",new Jt(l,3)),c.setAttribute("color",new Jt(u,3));const h=new Jo({vertexColors:!0,toneMapped:!1});super(c,h),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class iZ extends ac{constructor(e=10,t=16,r=8,s=64,i=4473924,o=8947848){i=new Nt(i),o=new Nt(o);const a=[],l=[];if(t>1)for(let h=0;h<t;h++){const d=h/t*(Math.PI*2),p=Math.sin(d)*e,g=Math.cos(d)*e;a.push(0,0,0),a.push(p,0,g);const w=h&1?i:o;l.push(w.r,w.g,w.b),l.push(w.r,w.g,w.b)}for(let h=0;h<r;h++){const d=h&1?i:o,p=e-e/r*h;for(let g=0;g<s;g++){let w=g/s*(Math.PI*2),y=Math.sin(w)*p,x=Math.cos(w)*p;a.push(y,0,x),l.push(d.r,d.g,d.b),w=(g+1)/s*(Math.PI*2),y=Math.sin(w)*p,x=Math.cos(w)*p,a.push(y,0,x),l.push(d.r,d.g,d.b)}}const u=new zn;u.setAttribute("position",new Jt(a,3)),u.setAttribute("color",new Jt(l,3));const c=new Jo({vertexColors:!0,toneMapped:!1});super(u,c),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const z3=new le,nS=new le,B3=new le;class oZ extends dr{constructor(e,t,r){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,this.type="DirectionalLightHelper",t===void 0&&(t=1);let s=new zn;s.setAttribute("position",new Jt([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const i=new Jo({fog:!1,toneMapped:!1});this.lightPlane=new kd(s,i),this.add(this.lightPlane),s=new zn,s.setAttribute("position",new Jt([0,0,0,0,0,1],3)),this.targetLine=new kd(s,i),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),z3.setFromMatrixPosition(this.light.matrixWorld),nS.setFromMatrixPosition(this.light.target.matrixWorld),B3.subVectors(nS,z3),this.lightPlane.lookAt(nS),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(nS),this.targetLine.scale.z=B3.length()}}const rS=new le,Ts=new Hx;class aZ extends ac{constructor(e){const t=new zn,r=new Jo({color:16777215,vertexColors:!0,toneMapped:!1}),s=[],i=[],o={};a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4");function a(g,w){l(g),l(w)}function l(g){s.push(0,0,0),i.push(0,0,0),o[g]===void 0&&(o[g]=[]),o[g].push(s.length/3-1)}t.setAttribute("position",new Jt(s,3)),t.setAttribute("color",new Jt(i,3)),super(t,r),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();const u=new Nt(16755200),c=new Nt(16711680),h=new Nt(43775),d=new Nt(16777215),p=new Nt(3355443);this.setColors(u,c,h,d,p)}setColors(e,t,r,s,i){const a=this.geometry.getAttribute("color");a.setXYZ(0,e.r,e.g,e.b),a.setXYZ(1,e.r,e.g,e.b),a.setXYZ(2,e.r,e.g,e.b),a.setXYZ(3,e.r,e.g,e.b),a.setXYZ(4,e.r,e.g,e.b),a.setXYZ(5,e.r,e.g,e.b),a.setXYZ(6,e.r,e.g,e.b),a.setXYZ(7,e.r,e.g,e.b),a.setXYZ(8,e.r,e.g,e.b),a.setXYZ(9,e.r,e.g,e.b),a.setXYZ(10,e.r,e.g,e.b),a.setXYZ(11,e.r,e.g,e.b),a.setXYZ(12,e.r,e.g,e.b),a.setXYZ(13,e.r,e.g,e.b),a.setXYZ(14,e.r,e.g,e.b),a.setXYZ(15,e.r,e.g,e.b),a.setXYZ(16,e.r,e.g,e.b),a.setXYZ(17,e.r,e.g,e.b),a.setXYZ(18,e.r,e.g,e.b),a.setXYZ(19,e.r,e.g,e.b),a.setXYZ(20,e.r,e.g,e.b),a.setXYZ(21,e.r,e.g,e.b),a.setXYZ(22,e.r,e.g,e.b),a.setXYZ(23,e.r,e.g,e.b),a.setXYZ(24,t.r,t.g,t.b),a.setXYZ(25,t.r,t.g,t.b),a.setXYZ(26,t.r,t.g,t.b),a.setXYZ(27,t.r,t.g,t.b),a.setXYZ(28,t.r,t.g,t.b),a.setXYZ(29,t.r,t.g,t.b),a.setXYZ(30,t.r,t.g,t.b),a.setXYZ(31,t.r,t.g,t.b),a.setXYZ(32,r.r,r.g,r.b),a.setXYZ(33,r.r,r.g,r.b),a.setXYZ(34,r.r,r.g,r.b),a.setXYZ(35,r.r,r.g,r.b),a.setXYZ(36,r.r,r.g,r.b),a.setXYZ(37,r.r,r.g,r.b),a.setXYZ(38,s.r,s.g,s.b),a.setXYZ(39,s.r,s.g,s.b),a.setXYZ(40,i.r,i.g,i.b),a.setXYZ(41,i.r,i.g,i.b),a.setXYZ(42,i.r,i.g,i.b),a.setXYZ(43,i.r,i.g,i.b),a.setXYZ(44,i.r,i.g,i.b),a.setXYZ(45,i.r,i.g,i.b),a.setXYZ(46,i.r,i.g,i.b),a.setXYZ(47,i.r,i.g,i.b),a.setXYZ(48,i.r,i.g,i.b),a.setXYZ(49,i.r,i.g,i.b),a.needsUpdate=!0}update(){const e=this.geometry,t=this.pointMap,r=1,s=1;Ts.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Os("c",t,e,Ts,0,0,-1),Os("t",t,e,Ts,0,0,1),Os("n1",t,e,Ts,-r,-s,-1),Os("n2",t,e,Ts,r,-s,-1),Os("n3",t,e,Ts,-r,s,-1),Os("n4",t,e,Ts,r,s,-1),Os("f1",t,e,Ts,-r,-s,1),Os("f2",t,e,Ts,r,-s,1),Os("f3",t,e,Ts,-r,s,1),Os("f4",t,e,Ts,r,s,1),Os("u1",t,e,Ts,r*.7,s*1.1,-1),Os("u2",t,e,Ts,-r*.7,s*1.1,-1),Os("u3",t,e,Ts,0,s*2,-1),Os("cf1",t,e,Ts,-r,0,1),Os("cf2",t,e,Ts,r,0,1),Os("cf3",t,e,Ts,0,-s,1),Os("cf4",t,e,Ts,0,s,1),Os("cn1",t,e,Ts,-r,0,-1),Os("cn2",t,e,Ts,r,0,-1),Os("cn3",t,e,Ts,0,-s,-1),Os("cn4",t,e,Ts,0,s,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function Os(n,e,t,r,s,i,o){rS.set(s,i,o).unproject(r);const a=e[n];if(a!==void 0){const l=t.getAttribute("position");for(let u=0,c=a.length;u<c;u++)l.setXYZ(a[u],rS.x,rS.y,rS.z)}}const sS=new jo;class lZ extends ac{constructor(e,t=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=new Float32Array(24),i=new zn;i.setIndex(new Cr(r,1)),i.setAttribute("position",new Cr(s,3)),super(i,new Jo({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&sS.setFromObject(this.object),sS.isEmpty())return;const t=sS.min,r=sS.max,s=this.geometry.attributes.position,i=s.array;i[0]=r.x,i[1]=r.y,i[2]=r.z,i[3]=t.x,i[4]=r.y,i[5]=r.z,i[6]=t.x,i[7]=t.y,i[8]=r.z,i[9]=r.x,i[10]=t.y,i[11]=r.z,i[12]=r.x,i[13]=r.y,i[14]=t.z,i[15]=t.x,i[16]=r.y,i[17]=t.z,i[18]=t.x,i[19]=t.y,i[20]=t.z,i[21]=r.x,i[22]=t.y,i[23]=t.z,s.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class uZ extends ac{constructor(e,t=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],i=new zn;i.setIndex(new Cr(r,1)),i.setAttribute("position",new Jt(s,3)),super(i,new Jo({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class cZ extends kd{constructor(e,t=1,r=16776960){const s=r,i=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new zn;o.setAttribute("position",new Jt(i,3)),o.computeBoundingSphere(),super(o,new Jo({color:s,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new zn;l.setAttribute("position",new Jt(a,3)),l.computeBoundingSphere(),this.add(new zs(l,new Hd({color:s,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const U3=new le;let iS,m2;class hZ extends dr{constructor(e=new le(0,0,1),t=new le(0,0,0),r=1,s=16776960,i=r*.2,o=i*.2){super(),this.type="ArrowHelper",iS===void 0&&(iS=new zn,iS.setAttribute("position",new Jt([0,0,0,0,1,0],3)),m2=new Uy(0,.5,1,5,1),m2.translate(0,-.5,0)),this.position.copy(t),this.line=new kd(iS,new Jo({color:s,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new zs(m2,new Hd({color:s,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(r,i,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{U3.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(U3,t)}}setLength(e,t=e*.2,r=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(r,t,r),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class dZ extends ac{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],r=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],s=new zn;s.setAttribute("position",new Jt(t,3)),s.setAttribute("color",new Jt(r,3));const i=new Jo({vertexColors:!0,toneMapped:!1});super(s,i),this.type="AxesHelper"}setColors(e,t,r){const s=new Nt,i=this.geometry.attributes.color.array;return s.set(e),s.toArray(i,0),s.toArray(i,3),s.set(t),s.toArray(i,6),s.toArray(i,9),s.set(r),s.toArray(i,12),s.toArray(i,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class fZ{constructor(){this.type="ShapePath",this.color=new Nt,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new ux,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,r,s){return this.currentPath.quadraticCurveTo(e,t,r,s),this}bezierCurveTo(e,t,r,s,i,o){return this.currentPath.bezierCurveTo(e,t,r,s,i,o),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(x){const _=[];for(let T=0,E=x.length;T<E;T++){const N=x[T],M=new sh;M.curves=N.curves,_.push(M)}return _}function r(x,_){const T=_.length;let E=!1;for(let N=T-1,M=0;M<T;N=M++){let $=_[N],L=_[M],k=L.x-$.x,R=L.y-$.y;if(Math.abs(R)>Number.EPSILON){if(R<0&&($=_[M],k=-k,L=_[N],R=-R),x.y<$.y||x.y>L.y)continue;if(x.y===$.y){if(x.x===$.x)return!0}else{const P=R*(x.x-$.x)-k*(x.y-$.y);if(P===0)return!0;if(P<0)continue;E=!E}}else{if(x.y!==$.y)continue;if(L.x<=x.x&&x.x<=$.x||$.x<=x.x&&x.x<=L.x)return!0}}return E}const s=ju.isClockWise,i=this.subPaths;if(i.length===0)return[];let o,a,l;const u=[];if(i.length===1)return a=i[0],l=new sh,l.curves=a.curves,u.push(l),u;let c=!s(i[0].getPoints());c=e?!c:c;const h=[],d=[];let p=[],g=0,w;d[g]=void 0,p[g]=[];for(let x=0,_=i.length;x<_;x++)a=i[x],w=a.getPoints(),o=s(w),o=e?!o:o,o?(!c&&d[g]&&g++,d[g]={s:new sh,p:w},d[g].s.curves=a.curves,c&&g++,p[g]=[]):p[g].push({h:a,p:w[0]});if(!d[0])return t(i);if(d.length>1){let x=!1,_=0;for(let T=0,E=d.length;T<E;T++)h[T]=[];for(let T=0,E=d.length;T<E;T++){const N=p[T];for(let M=0;M<N.length;M++){const $=N[M];let L=!0;for(let k=0;k<d.length;k++)r($.p,d[k].p)&&(T!==k&&_++,L?(L=!1,h[k].push($)):x=!0);L&&h[T].push($)}}_>0&&x===!1&&(p=h)}let y;for(let x=0,_=d.length;x<_;x++){l=d[x].s,u.push(l),y=p[x];for(let T=0,E=y.length;T<E;T++)l.holes.push(y[T].h)}return u}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Vd}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Vd);const pZ=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:U_,AddEquation:pd,AddOperation:gF,AdditiveAnimationBlendMode:IA,AdditiveBlending:cI,AgXToneMapping:bF,AlphaFormat:EF,AlwaysCompare:UF,AlwaysDepth:yA,AlwaysStencilFunc:UI,AmbientLight:Bz,AnimationAction:qz,AnimationClip:mx,AnimationLoader:vY,AnimationMixer:GY,AnimationObjectGroup:VY,AnimationUtils:pY,ArcCurve:hz,ArrayCamera:tz,ArrowHelper:hZ,AttachedBindMode:mI,Audio:jz,AudioAnalyser:RY,AudioContext:sM,AudioListener:AY,AudioLoader:CY,AxesHelper:dZ,BackSide:yi,BasicDepthPacking:Wd,BasicShadowMap:jO,BatchedMesh:lz,Bone:VA,BooleanKeyframeTrack:om,Box2:ZY,Box3:jo,Box3Helper:uZ,BoxGeometry:jd,BoxHelper:lZ,BufferAttribute:Cr,BufferGeometry:zn,BufferGeometryLoader:Hz,ByteType:_F,Cache:th,Camera:Hx,CameraHelper:aZ,CanvasTexture:lx,CapsuleGeometry:tT,CatmullRomCurve3:HA,CineonToneMapping:xF,CircleGeometry:nT,ClampToEdgeWrapping:mo,Clock:iM,Color:Nt,ColorKeyframeTrack:eM,ColorManagement:$r,CompressedArrayTexture:OK,CompressedCubeTexture:FK,CompressedTexture:Q_,CompressedTextureLoader:xY,ConeGeometry:rT,ConstantAlphaFactor:aF,ConstantColorFactor:iF,CubeCamera:XF,CubeReflectionMapping:tc,CubeRefractionMapping:Nd,CubeTexture:jx,CubeTextureLoader:$z,CubeUVReflectionMapping:Ly,CubicBezierCurve:jA,CubicBezierCurve3:dz,CubicInterpolant:Mz,CullFaceBack:uI,CullFaceFront:HO,CullFaceFrontBack:N8,CullFaceNone:GO,Curve:xu,CurvePath:pz,CustomBlending:XO,CustomToneMapping:wF,CylinderGeometry:Uy,Cylindrical:YY,Data3DTexture:RA,DataArrayTexture:j_,DataTexture:Mp,DataTextureLoader:nM,DataUtils:xp,DecrementStencilOp:B8,DecrementWrapStencilOp:V8,DefaultLoadingManager:Dz,DepthFormat:wd,DepthStencilFormat:Md,DepthTexture:X_,DetachedBindMode:SF,DirectionalLight:zz,DirectionalLightHelper:oZ,DiscreteInterpolant:kz,DisplayP3ColorSpace:H_,DodecahedronGeometry:sT,DoubleSide:Wo,DstAlphaFactor:eF,DstColorFactor:nF,DynamicCopyUsage:rj,DynamicDrawUsage:Z8,DynamicReadUsage:ej,EdgesGeometry:mz,EllipseCurve:eT,EqualCompare:OF,EqualDepth:hF,EqualStencilFunc:j8,EquirectangularReflectionMapping:my,EquirectangularRefractionMapping:Jv,Euler:Fy,EventDispatcher:Tl,ExtrudeGeometry:Vy,FileLoader:ah,Float16BufferAttribute:Vj,Float32BufferAttribute:Jt,Float64BufferAttribute:Wj,FloatType:Di,Fog:Y_,FogExp2:K_,FramebufferTexture:LK,FrontSide:ec,Frustum:Xx,GLBufferAttribute:qY,GLSL1:ij,GLSL3:VI,GreaterCompare:FF,GreaterDepth:fF,GreaterEqualCompare:BF,GreaterEqualDepth:dF,GreaterEqualStencilFunc:Y8,GreaterStencilFunc:q8,GridHelper:sZ,Group:ry,HalfFloatType:vo,HemisphereLight:Lz,HemisphereLightHelper:rZ,IcosahedronGeometry:Yx,ImageBitmapLoader:EY,ImageLoader:gx,ImageUtils:kA,IncrementStencilOp:z8,IncrementWrapStencilOp:U8,InstancedBufferAttribute:xy,InstancedBufferGeometry:Gz,InstancedInterleavedBuffer:XY,InstancedMesh:az,Int16BufferAttribute:Bj,Int32BufferAttribute:Uj,Int8BufferAttribute:Oj,IntType:xA,InterleavedBuffer:Z_,InterleavedBufferAttribute:Op,Interpolant:Qx,InterpolateDiscrete:ex,InterpolateLinear:tx,InterpolateSmooth:AS,InvertStencilOp:W8,KeepStencilOp:ap,KeyframeTrack:wu,LOD:iz,LatheGeometry:Kx,Layers:Ap,LessCompare:LF,LessDepth:cF,LessEqualCompare:AA,LessEqualDepth:Zv,LessEqualStencilFunc:X8,LessStencilFunc:H8,Light:qd,LightProbe:Wz,Line:kd,Line3:JY,LineBasicMaterial:Jo,LineCurve:XA,LineCurve3:fz,LineDashedMaterial:Iz,LineLoop:uz,LineSegments:ac,LinearDisplayP3ColorSpace:Gx,LinearEncoding:NA,LinearFilter:Lr,LinearInterpolant:QA,LinearMipMapLinearFilter:D8,LinearMipMapNearestFilter:R8,LinearMipmapLinearFilter:Ad,LinearMipmapNearestFilter:vA,LinearSRGBColorSpace:xl,LinearToneMapping:yF,LinearTransfer:rx,Loader:Ca,LoaderUtils:YI,LoadingManager:tM,LoopOnce:MF,LoopPingPong:RF,LoopRepeat:kF,LuminanceAlphaFormat:IF,LuminanceFormat:CF,MOUSE:C8,Material:Si,MaterialLoader:hT,MathUtils:Ua,Matrix3:jn,Matrix4:_n,MaxEquation:pI,Mesh:zs,MeshBasicMaterial:Hd,MeshDepthMaterial:FA,MeshDistanceMaterial:zA,MeshLambertMaterial:Ez,MeshMatcapMaterial:Cz,MeshNormalMaterial:ZA,MeshPhongMaterial:_z,MeshPhysicalMaterial:Sz,MeshStandardMaterial:Fu,MeshToonMaterial:Tz,MinEquation:fI,MirroredRepeatWrapping:Qv,MixOperation:mF,MultiplyBlending:dI,MultiplyOperation:Wx,NearestFilter:ss,NearestMipMapLinearFilter:k8,NearestMipMapNearestFilter:M8,NearestMipmapLinearFilter:Uv,NearestMipmapNearestFilter:KS,NeverCompare:PF,NeverDepth:uF,NeverStencilFunc:G8,NoBlending:wo,NoColorSpace:Go,NoToneMapping:Hu,NormalAnimationBlendMode:G_,NormalBlending:Ip,NotEqualCompare:zF,NotEqualDepth:pF,NotEqualStencilFunc:K8,NumberKeyframeTrack:fx,Object3D:dr,ObjectLoader:_Y,ObjectSpaceNormalMap:$F,OctahedronGeometry:Zx,OneFactor:ZO,OneMinusConstantAlphaFactor:lF,OneMinusConstantColorFactor:oF,OneMinusDstAlphaFactor:tF,OneMinusDstColorFactor:rF,OneMinusSrcAlphaFactor:qS,OneMinusSrcColorFactor:QO,OrthographicCamera:zy,P3Primaries:ix,PCFShadowMap:B_,PCFSoftShadowMap:Bv,PMREMGenerator:GI,Path:ux,PerspectiveCamera:fi,Plane:dd,PlaneGeometry:qx,PlaneHelper:cZ,PointLight:Fz,PointLightHelper:tZ,Points:cz,PointsMaterial:WA,PolarGridHelper:iZ,PolyhedronGeometry:Xd,PositionalAudio:kY,PropertyBinding:gr,PropertyMixer:Xz,QuadraticBezierCurve:qA,QuadraticBezierCurve3:KA,Quaternion:bo,QuaternionKeyframeTrack:Gy,QuaternionLinearInterpolant:Rz,RED_GREEN_RGTC2_Format:zI,RED_RGTC1_Format:AF,REVISION:Vd,RGBADepthPacking:DF,RGBAFormat:go,RGBAIntegerFormat:EA,RGBA_ASTC_10x10_Format:DI,RGBA_ASTC_10x5_Format:MI,RGBA_ASTC_10x6_Format:kI,RGBA_ASTC_10x8_Format:RI,RGBA_ASTC_12x10_Format:$I,RGBA_ASTC_12x12_Format:PI,RGBA_ASTC_4x4_Format:SI,RGBA_ASTC_5x4_Format:_I,RGBA_ASTC_5x5_Format:TI,RGBA_ASTC_6x5_Format:EI,RGBA_ASTC_6x6_Format:CI,RGBA_ASTC_8x5_Format:II,RGBA_ASTC_8x6_Format:NI,RGBA_ASTC_8x8_Format:AI,RGBA_BPTC_Format:NS,RGBA_ETC2_EAC_Format:bI,RGBA_PVRTC_2BPPV1_Format:xI,RGBA_PVRTC_4BPPV1_Format:vI,RGBA_S3TC_DXT1_Format:ES,RGBA_S3TC_DXT3_Format:CS,RGBA_S3TC_DXT5_Format:IS,RGB_BPTC_SIGNED_Format:LI,RGB_BPTC_UNSIGNED_Format:OI,RGB_ETC1_Format:CA,RGB_ETC2_Format:wI,RGB_PVRTC_2BPPV1_Format:yI,RGB_PVRTC_4BPPV1_Format:gI,RGB_S3TC_DXT1_Format:TS,RGFormat:NF,RGIntegerFormat:TA,RawShaderMaterial:bz,Ray:Oy,Raycaster:lM,Rec709Primaries:sx,RectAreaLight:Uz,RedFormat:SA,RedIntegerFormat:_A,ReinhardToneMapping:vF,RenderTarget:GF,RepeatWrapping:Pp,ReplaceStencilOp:F8,ReverseSubtractEquation:KO,RingGeometry:oT,SIGNED_RED_GREEN_RGTC2_Format:BI,SIGNED_RED_RGTC1_Format:FI,SRGBColorSpace:sr,SRGBTransfer:Zr,Scene:Lp,ShaderChunk:Un,ShaderLib:ou,ShaderMaterial:ni,ShadowMaterial:wz,Shape:sh,ShapeGeometry:aT,ShapePath:fZ,ShapeUtils:ju,ShortType:TF,Skeleton:J_,SkeletonHelper:eZ,SkinnedMesh:oz,Source:vp,Sphere:So,SphereGeometry:Wy,Spherical:KY,SphericalHarmonics3:Vz,SplineCurve:YA,SpotLight:Oz,SpotLightHelper:QY,Sprite:sz,SpriteMaterial:UA,SrcAlphaFactor:XS,SrcAlphaSaturateFactor:sF,SrcColorFactor:JO,StaticCopyUsage:nj,StaticDrawUsage:ox,StaticReadUsage:Q8,StereoCamera:IY,StreamCopyUsage:sj,StreamDrawUsage:J8,StreamReadUsage:tj,StringKeyframeTrack:am,SubtractEquation:qO,SubtractiveBlending:hI,TOUCH:I8,TangentSpaceNormalMap:Gd,TetrahedronGeometry:lT,Texture:fs,TextureLoader:Pz,TorusGeometry:uT,TorusKnotGeometry:cT,Triangle:va,TriangleFanDrawMode:L8,TriangleStripDrawMode:P8,TrianglesDrawMode:$8,TubeGeometry:Jx,TwoPassDoubleSide:A8,UVMapping:V_,Uint16BufferAttribute:DA,Uint32BufferAttribute:$A,Uint8BufferAttribute:Fj,Uint8ClampedBufferAttribute:zj,Uniform:Jn,UniformsGroup:jY,UniformsLib:Rt,UniformsUtils:PA,UnsignedByteType:Ki,UnsignedInt248Type:rh,UnsignedIntType:Vu,UnsignedShort4444Type:wA,UnsignedShort5551Type:bA,UnsignedShortType:W_,VSMShadowMap:iu,Vector2:rt,Vector3:le,Vector4:br,VectorKeyframeTrack:px,VideoTexture:PK,WebGL1Renderer:nz,WebGL3DRenderTarget:Ej,WebGLArrayRenderTarget:Tj,WebGLCoordinateSystem:cu,WebGLCubeRenderTarget:LA,WebGLMultipleRenderTargets:Cj,WebGLRenderTarget:Us,WebGLRenderer:BA,WebGLUtils:ez,WebGPUCoordinateSystem:gy,WireframeGeometry:xz,WrapAroundEnding:nx,ZeroCurvatureEnding:gp,ZeroFactor:YO,ZeroSlopeEnding:yp,ZeroStencilOp:O8,_SRGBAFormat:YS,createCanvasElement:WF,sRGBEncoding:bd},Symbol.toStringTag,{value:"Module"}));var g2={exports:{}},ld={};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var V3;function mZ(){return V3||(V3=1,ld.ConcurrentRoot=1,ld.ContinuousEventPriority=4,ld.DefaultEventPriority=16,ld.DiscreteEventPriority=1,ld.IdleEventPriority=536870912,ld.LegacyRoot=0),ld}var W3;function gZ(){return W3||(W3=1,g2.exports=mZ()),g2.exports}var iy=gZ();function yZ(n){let e;const t=new Set,r=(u,c)=>{const h=typeof u=="function"?u(e):u;if(h!==e){const d=e;e=c?h:Object.assign({},e,h),t.forEach(p=>p(e,d))}},s=()=>e,i=(u,c=s,h=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let d=c(e);function p(){const g=c(e);if(!h(d,g)){const w=d;u(d=g,w)}}return t.add(p),()=>t.delete(p)},l={setState:r,getState:s,subscribe:(u,c,h)=>c||h?i(u,c,h):(t.add(u),()=>t.delete(u)),destroy:()=>t.clear()};return e=n(r,s,l),l}const vZ=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),G3=vZ?we.useEffect:we.useLayoutEffect;function Yz(n){const e=typeof n=="function"?yZ(n):n,t=(r=e.getState,s=Object.is)=>{const[,i]=we.useReducer(y=>y+1,0),o=e.getState(),a=we.useRef(o),l=we.useRef(r),u=we.useRef(s),c=we.useRef(!1),h=we.useRef();h.current===void 0&&(h.current=r(o));let d,p=!1;(a.current!==o||l.current!==r||u.current!==s||c.current)&&(d=r(o),p=!s(h.current,d)),G3(()=>{p&&(h.current=d),a.current=o,l.current=r,u.current=s,c.current=!1});const g=we.useRef(o);G3(()=>{const y=()=>{try{const _=e.getState(),T=l.current(_);u.current(h.current,T)||(a.current=_,h.current=T,i())}catch{c.current=!0,i()}},x=e.subscribe(y);return e.getState()!==g.current&&y(),x},[]);const w=p?d:h.current;return we.useDebugValue(w),w};return Object.assign(t,e),t[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const r=[t,e];return{next(){const s=r.length<=0;return{value:r.shift(),done:s}}}},t}var y2={exports:{}},v2={exports:{}},x2={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var H3;function xZ(){return H3||(H3=1,(function(n){function e(W,J){var K=W.length;W.push(J);e:for(;0<K;){var G=K-1>>>1,Q=W[G];if(0<s(Q,J))W[G]=J,W[K]=Q,K=G;else break e}}function t(W){return W.length===0?null:W[0]}function r(W){if(W.length===0)return null;var J=W[0],K=W.pop();if(K!==J){W[0]=K;e:for(var G=0,Q=W.length,ne=Q>>>1;G<ne;){var ce=2*(G+1)-1,ye=W[ce],Se=ce+1,Re=W[Se];if(0>s(ye,K))Se<Q&&0>s(Re,ye)?(W[G]=Re,W[Se]=K,G=Se):(W[G]=ye,W[ce]=K,G=ce);else if(Se<Q&&0>s(Re,K))W[G]=Re,W[Se]=K,G=Se;else break e}}return J}function s(W,J){var K=W.sortIndex-J.sortIndex;return K!==0?K:W.id-J.id}if(typeof performance=="object"&&typeof performance.now=="function"){var i=performance;n.unstable_now=function(){return i.now()}}else{var o=Date,a=o.now();n.unstable_now=function(){return o.now()-a}}var l=[],u=[],c=1,h=null,d=3,p=!1,g=!1,w=!1,y=typeof setTimeout=="function"?setTimeout:null,x=typeof clearTimeout=="function"?clearTimeout:null,_=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function T(W){for(var J=t(u);J!==null;){if(J.callback===null)r(u);else if(J.startTime<=W)r(u),J.sortIndex=J.expirationTime,e(l,J);else break;J=t(u)}}function E(W){if(w=!1,T(W),!g)if(t(l)!==null)g=!0,q(N);else{var J=t(u);J!==null&&se(E,J.startTime-W)}}function N(W,J){g=!1,w&&(w=!1,x(L),L=-1),p=!0;var K=d;try{for(T(J),h=t(l);h!==null&&(!(h.expirationTime>J)||W&&!P());){var G=h.callback;if(typeof G=="function"){h.callback=null,d=h.priorityLevel;var Q=G(h.expirationTime<=J);J=n.unstable_now(),typeof Q=="function"?h.callback=Q:h===t(l)&&r(l),T(J)}else r(l);h=t(l)}if(h!==null)var ne=!0;else{var ce=t(u);ce!==null&&se(E,ce.startTime-J),ne=!1}return ne}finally{h=null,d=K,p=!1}}var M=!1,$=null,L=-1,k=5,R=-1;function P(){return!(n.unstable_now()-R<k)}function B(){if($!==null){var W=n.unstable_now();R=W;var J=!0;try{J=$(!0,W)}finally{J?Z():(M=!1,$=null)}}else M=!1}var Z;if(typeof _=="function")Z=function(){_(B)};else if(typeof MessageChannel<"u"){var V=new MessageChannel,X=V.port2;V.port1.onmessage=B,Z=function(){X.postMessage(null)}}else Z=function(){y(B,0)};function q(W){$=W,M||(M=!0,Z())}function se(W,J){L=y(function(){W(n.unstable_now())},J)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(W){W.callback=null},n.unstable_continueExecution=function(){g||p||(g=!0,q(N))},n.unstable_forceFrameRate=function(W){0>W||125<W?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):k=0<W?Math.floor(1e3/W):5},n.unstable_getCurrentPriorityLevel=function(){return d},n.unstable_getFirstCallbackNode=function(){return t(l)},n.unstable_next=function(W){switch(d){case 1:case 2:case 3:var J=3;break;default:J=d}var K=d;d=J;try{return W()}finally{d=K}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(W,J){switch(W){case 1:case 2:case 3:case 4:case 5:break;default:W=3}var K=d;d=W;try{return J()}finally{d=K}},n.unstable_scheduleCallback=function(W,J,K){var G=n.unstable_now();switch(typeof K=="object"&&K!==null?(K=K.delay,K=typeof K=="number"&&0<K?G+K:G):K=G,W){case 1:var Q=-1;break;case 2:Q=250;break;case 5:Q=1073741823;break;case 4:Q=1e4;break;default:Q=5e3}return Q=K+Q,W={id:c++,callback:J,priorityLevel:W,startTime:K,expirationTime:Q,sortIndex:-1},K>G?(W.sortIndex=K,e(u,W),t(l)===null&&W===t(u)&&(w?(x(L),L=-1):w=!0,se(E,K-G))):(W.sortIndex=Q,e(l,W),g||p||(g=!0,q(N))),W},n.unstable_shouldYield=P,n.unstable_wrapCallback=function(W){var J=d;return function(){var K=d;d=J;try{return W.apply(this,arguments)}finally{d=K}}}})(x2)),x2}var j3;function Zz(){return j3||(j3=1,v2.exports=xZ()),v2.exports}/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var w2,X3;function wZ(){return X3||(X3=1,w2=function(e){var t={},r=Vx(),s=Zz(),i=Object.assign;function o(v){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+v,C=1;C<arguments.length;C++)b+="&args[]="+encodeURIComponent(arguments[C]);return"Minified React error #"+v+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var a=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,l=Symbol.for("react.element"),u=Symbol.for("react.portal"),c=Symbol.for("react.fragment"),h=Symbol.for("react.strict_mode"),d=Symbol.for("react.profiler"),p=Symbol.for("react.provider"),g=Symbol.for("react.context"),w=Symbol.for("react.forward_ref"),y=Symbol.for("react.suspense"),x=Symbol.for("react.suspense_list"),_=Symbol.for("react.memo"),T=Symbol.for("react.lazy"),E=Symbol.for("react.offscreen"),N=Symbol.iterator;function M(v){return v===null||typeof v!="object"?null:(v=N&&v[N]||v["@@iterator"],typeof v=="function"?v:null)}function $(v){if(v==null)return null;if(typeof v=="function")return v.displayName||v.name||null;if(typeof v=="string")return v;switch(v){case c:return"Fragment";case u:return"Portal";case d:return"Profiler";case h:return"StrictMode";case y:return"Suspense";case x:return"SuspenseList"}if(typeof v=="object")switch(v.$$typeof){case g:return(v.displayName||"Context")+".Consumer";case p:return(v._context.displayName||"Context")+".Provider";case w:var b=v.render;return v=v.displayName,v||(v=b.displayName||b.name||"",v=v!==""?"ForwardRef("+v+")":"ForwardRef"),v;case _:return b=v.displayName||null,b!==null?b:$(v.type)||"Memo";case T:b=v._payload,v=v._init;try{return $(v(b))}catch{}}return null}function L(v){var b=v.type;switch(v.tag){case 24:return"Cache";case 9:return(b.displayName||"Context")+".Consumer";case 10:return(b._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return v=b.render,v=v.displayName||v.name||"",b.displayName||(v!==""?"ForwardRef("+v+")":"ForwardRef");case 7:return"Fragment";case 5:return b;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return $(b);case 8:return b===h?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof b=="function")return b.displayName||b.name||null;if(typeof b=="string")return b}return null}function k(v){var b=v,C=v;if(v.alternate)for(;b.return;)b=b.return;else{v=b;do b=v,(b.flags&4098)!==0&&(C=b.return),v=b.return;while(v)}return b.tag===3?C:null}function R(v){if(k(v)!==v)throw Error(o(188))}function P(v){var b=v.alternate;if(!b){if(b=k(v),b===null)throw Error(o(188));return b!==v?null:v}for(var C=v,A=b;;){var O=C.return;if(O===null)break;var U=O.alternate;if(U===null){if(A=O.return,A!==null){C=A;continue}break}if(O.child===U.child){for(U=O.child;U;){if(U===C)return R(O),v;if(U===A)return R(O),b;U=U.sibling}throw Error(o(188))}if(C.return!==A.return)C=O,A=U;else{for(var he=!1,ke=O.child;ke;){if(ke===C){he=!0,C=O,A=U;break}if(ke===A){he=!0,A=O,C=U;break}ke=ke.sibling}if(!he){for(ke=U.child;ke;){if(ke===C){he=!0,C=U,A=O;break}if(ke===A){he=!0,A=U,C=O;break}ke=ke.sibling}if(!he)throw Error(o(189))}}if(C.alternate!==A)throw Error(o(190))}if(C.tag!==3)throw Error(o(188));return C.stateNode.current===C?v:b}function B(v){return v=P(v),v!==null?Z(v):null}function Z(v){if(v.tag===5||v.tag===6)return v;for(v=v.child;v!==null;){var b=Z(v);if(b!==null)return b;v=v.sibling}return null}function V(v){if(v.tag===5||v.tag===6)return v;for(v=v.child;v!==null;){if(v.tag!==4){var b=V(v);if(b!==null)return b}v=v.sibling}return null}var X=Array.isArray,q=e.getPublicInstance,se=e.getRootHostContext,W=e.getChildHostContext,J=e.prepareForCommit,K=e.resetAfterCommit,G=e.createInstance,Q=e.appendInitialChild,ne=e.finalizeInitialChildren,ce=e.prepareUpdate,ye=e.shouldSetTextContent,Se=e.createTextInstance,Re=e.scheduleTimeout,Oe=e.cancelTimeout,Ke=e.noTimeout,st=e.isPrimaryRenderer,ct=e.supportsMutation,fe=e.supportsPersistence,nt=e.supportsHydration,Xe=e.getInstanceFromNode,it=e.preparePortalMount,He=e.getCurrentEventPriority,_t=e.detachDeletedInstance,mt=e.supportsMicrotasks,oe=e.scheduleMicrotask,ee=e.supportsTestSelectors,Le=e.findFiberRoot,at=e.getBoundingRect,ut=e.getTextContent,ot=e.isHiddenSubtree,$t=e.matchAccessibilityRole,bt=e.setFocusIfFocusable,It=e.setupIntersectionObserver,Gt=e.appendChild,rn=e.appendChildToContainer,ht=e.commitTextUpdate,Nn=e.commitMount,An=e.commitUpdate,en=e.insertBefore,Ft=e.insertInContainerBefore,Vt=e.removeChild,cn=e.removeChildFromContainer,bn=e.resetTextContent,Mn=e.hideInstance,Tn=e.hideTextInstance,Ge=e.unhideInstance,_e=e.unhideTextInstance,Tt=e.clearContainer,Mt=e.cloneInstance,ln=e.createContainerChildSet,sn=e.appendChildToContainerChildSet,pr=e.finalizeContainerChildren,ur=e.replaceContainerChildren,Vr=e.cloneHiddenInstance,ms=e.cloneHiddenTextInstance,er=e.canHydrateInstance,gs=e.canHydrateTextInstance,Ws=e.canHydrateSuspenseInstance,Qa=e.isSuspenseInstancePending,Na=e.isSuspenseInstanceFallback,zi=e.registerSuspenseInstanceRetry,ii=e.getNextHydratableSibling,En=e.getFirstHydratableChild,uc=e.getFirstHydratableChildWithinContainer,Sh=e.getFirstHydratableChildWithinSuspenseInstance,j=e.hydrateInstance,re=e.hydrateTextInstance,be=e.hydrateSuspenseInstance,H=e.getNextHydratableInstanceAfterSuspenseInstance,ae=e.commitHydratedContainer,ue=e.commitHydratedSuspenseInstance,xe=e.clearSuspenseBoundary,me=e.clearSuspenseBoundaryFromContainer,We=e.shouldDeleteUnhydratedTailInstances,Ye=e.didNotMatchHydratedContainerTextInstance,et=e.didNotMatchHydratedTextInstance,Ue;function Bt(v){if(Ue===void 0)try{throw Error()}catch(C){var b=C.stack.trim().match(/\n( *(at )?)/);Ue=b&&b[1]||""}return`
`+Ue+v}var dt=!1;function gt(v,b){if(!v||dt)return"";dt=!0;var C=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error()},Object.defineProperty(b.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(b,[])}catch(wt){var A=wt}Reflect.construct(v,[],b)}else{try{b.call()}catch(wt){A=wt}v.call(b.prototype)}else{try{throw Error()}catch(wt){A=wt}v()}}catch(wt){if(wt&&A&&typeof wt.stack=="string"){for(var O=wt.stack.split(`
`),U=A.stack.split(`
`),he=O.length-1,ke=U.length-1;1<=he&&0<=ke&&O[he]!==U[ke];)ke--;for(;1<=he&&0<=ke;he--,ke--)if(O[he]!==U[ke]){if(he!==1||ke!==1)do if(he--,ke--,0>ke||O[he]!==U[ke]){var tt=`
`+O[he].replace(" at new "," at ");return v.displayName&&tt.includes("<anonymous>")&&(tt=tt.replace("<anonymous>",v.displayName)),tt}while(1<=he&&0<=ke);break}}}finally{dt=!1,Error.prepareStackTrace=C}return(v=v?v.displayName||v.name:"")?Bt(v):""}var Ut=Object.prototype.hasOwnProperty,tn=[],on=-1;function vn(v){return{current:v}}function kt(v){0>on||(v.current=tn[on],tn[on]=null,on--)}function Ct(v,b){on++,tn[on]=v.current,v.current=b}var mn={},dn=vn(mn),xn=vn(!1),Tr=mn;function Wr(v,b){var C=v.type.contextTypes;if(!C)return mn;var A=v.stateNode;if(A&&A.__reactInternalMemoizedUnmaskedChildContext===b)return A.__reactInternalMemoizedMaskedChildContext;var O={},U;for(U in C)O[U]=b[U];return A&&(v=v.stateNode,v.__reactInternalMemoizedUnmaskedChildContext=b,v.__reactInternalMemoizedMaskedChildContext=O),O}function kr(v){return v=v.childContextTypes,v!=null}function Gn(){kt(xn),kt(dn)}function Pn(v,b,C){if(dn.current!==mn)throw Error(o(168));Ct(dn,b),Ct(xn,C)}function es(v,b,C){var A=v.stateNode;if(b=b.childContextTypes,typeof A.getChildContext!="function")return C;A=A.getChildContext();for(var O in A)if(!(O in b))throw Error(o(108,L(v)||"Unknown",O));return i({},C,A)}function Rn(v){return v=(v=v.stateNode)&&v.__reactInternalMemoizedMergedChildContext||mn,Tr=dn.current,Ct(dn,v),Ct(xn,xn.current),!0}function Hn(v,b,C){var A=v.stateNode;if(!A)throw Error(o(169));C?(v=es(v,b,Tr),A.__reactInternalMemoizedMergedChildContext=v,kt(xn),kt(dn),Ct(dn,v)):kt(xn),Ct(xn,C)}var Rr=Math.clz32?Math.clz32:el,eo=Math.log,Ds=Math.LN2;function el(v){return v>>>=0,v===0?32:31-(eo(v)/Ds|0)|0}var _h=64,cr=4194304;function Th(v){switch(v&-v){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return v&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return v&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return v}}function uf(v,b){var C=v.pendingLanes;if(C===0)return 0;var A=0,O=v.suspendedLanes,U=v.pingedLanes,he=C&268435455;if(he!==0){var ke=he&~O;ke!==0?A=Th(ke):(U&=he,U!==0&&(A=Th(U)))}else he=C&~O,he!==0?A=Th(he):U!==0&&(A=Th(U));if(A===0)return 0;if(b!==0&&b!==A&&(b&O)===0&&(O=A&-A,U=b&-b,O>=U||O===16&&(U&4194240)!==0))return b;if((A&4)!==0&&(A|=C&16),b=v.entangledLanes,b!==0)for(v=v.entanglements,b&=A;0<b;)C=31-Rr(b),O=1<<C,A|=v[C],b&=~O;return A}function d0(v,b){switch(v){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function bw(v,b){for(var C=v.suspendedLanes,A=v.pingedLanes,O=v.expirationTimes,U=v.pendingLanes;0<U;){var he=31-Rr(U),ke=1<<he,tt=O[he];tt===-1?((ke&C)===0||(ke&A)!==0)&&(O[he]=d0(ke,b)):tt<=b&&(v.expiredLanes|=ke),U&=~ke}}function wm(v){return v=v.pendingLanes&-1073741825,v!==0?v:v&1073741824?1073741824:0}function bm(v){for(var b=[],C=0;31>C;C++)b.push(v);return b}function cc(v,b,C){v.pendingLanes|=b,b!==536870912&&(v.suspendedLanes=0,v.pingedLanes=0),v=v.eventTimes,b=31-Rr(b),v[b]=C}function Sm(v,b){var C=v.pendingLanes&~b;v.pendingLanes=b,v.suspendedLanes=0,v.pingedLanes=0,v.expiredLanes&=b,v.mutableReadLanes&=b,v.entangledLanes&=b,b=v.entanglements;var A=v.eventTimes;for(v=v.expirationTimes;0<C;){var O=31-Rr(C),U=1<<O;b[O]=0,A[O]=-1,v[O]=-1,C&=~U}}function tl(v,b){var C=v.entangledLanes|=b;for(v=v.entanglements;C;){var A=31-Rr(C),O=1<<A;O&b|v[A]&b&&(v[A]|=b),C&=~O}}var Bn=0;function Al(v){return v&=-v,1<v?4<v?(v&268435455)!==0?16:536870912:4:1}var hc=s.unstable_scheduleCallback,Eh=s.unstable_cancelCallback,Tu=s.unstable_shouldYield,QE=s.unstable_requestPaint,$s=s.unstable_now,dc=s.unstable_ImmediatePriority,eC=s.unstable_UserBlockingPriority,_m=s.unstable_NormalPriority,Tm=s.unstable_IdlePriority,cf=null,nl=null;function hf(v){if(nl&&typeof nl.onCommitFiberRoot=="function")try{nl.onCommitFiberRoot(cf,v,void 0,(v.current.flags&128)===128)}catch{}}function df(v,b){return v===b&&(v!==0||1/v===1/b)||v!==v&&b!==b}var Bi=typeof Object.is=="function"?Object.is:df,ta=null,Em=!1,f0=!1;function Cm(v){ta===null?ta=[v]:ta.push(v)}function Im(v){Em=!0,Cm(v)}function na(){if(!f0&&ta!==null){f0=!0;var v=0,b=Bn;try{var C=ta;for(Bn=1;v<C.length;v++){var A=C[v];do A=A(!0);while(A!==null)}ta=null,Em=!1}catch(O){throw ta!==null&&(ta=ta.slice(v+1)),hc(dc,na),O}finally{Bn=b,f0=!1}}return null}var Sw=a.ReactCurrentBatchConfig;function Aa(v,b){if(Bi(v,b))return!0;if(typeof v!="object"||v===null||typeof b!="object"||b===null)return!1;var C=Object.keys(v),A=Object.keys(b);if(C.length!==A.length)return!1;for(A=0;A<C.length;A++){var O=C[A];if(!Ut.call(b,O)||!Bi(v[O],b[O]))return!1}return!0}function p0(v){switch(v.tag){case 5:return Bt(v.type);case 16:return Bt("Lazy");case 13:return Bt("Suspense");case 19:return Bt("SuspenseList");case 0:case 2:case 15:return v=gt(v.type,!1),v;case 11:return v=gt(v.type.render,!1),v;case 1:return v=gt(v.type,!0),v;default:return""}}function to(v,b){if(v&&v.defaultProps){b=i({},b),v=v.defaultProps;for(var C in v)b[C]===void 0&&(b[C]=v[C]);return b}return b}var ff=vn(null),fc=null,Ml=null,Nm=null;function Ui(){Nm=Ml=fc=null}function pc(v,b,C){st?(Ct(ff,b._currentValue),b._currentValue=C):(Ct(ff,b._currentValue2),b._currentValue2=C)}function pf(v){var b=ff.current;kt(ff),st?v._currentValue=b:v._currentValue2=b}function mc(v,b,C){for(;v!==null;){var A=v.alternate;if((v.childLanes&b)!==b?(v.childLanes|=b,A!==null&&(A.childLanes|=b)):A!==null&&(A.childLanes&b)!==b&&(A.childLanes|=b),v===C)break;v=v.return}}function Ch(v,b){fc=v,Nm=Ml=null,v=v.dependencies,v!==null&&v.firstContext!==null&&((v.lanes&b)!==0&&(Xs=!0),v.firstContext=null)}function no(v){var b=st?v._currentValue:v._currentValue2;if(Nm!==v)if(v={context:v,memoizedValue:b,next:null},Ml===null){if(fc===null)throw Error(o(308));Ml=v,fc.dependencies={lanes:0,firstContext:v}}else Ml=Ml.next=v;return b}var ra=null,sa=!1;function Ih(v){v.updateQueue={baseState:v.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function m0(v,b){v=v.updateQueue,b.updateQueue===v&&(b.updateQueue={baseState:v.baseState,firstBaseUpdate:v.firstBaseUpdate,lastBaseUpdate:v.lastBaseUpdate,shared:v.shared,effects:v.effects})}function kl(v,b){return{eventTime:v,lane:b,tag:0,payload:null,callback:null,next:null}}function Eu(v,b){var C=v.updateQueue;C!==null&&(C=C.shared,vs!==null&&(v.mode&1)!==0&&(Ln&2)===0?(v=C.interleaved,v===null?(b.next=b,ra===null?ra=[C]:ra.push(C)):(b.next=v.next,v.next=b),C.interleaved=b):(v=C.pending,v===null?b.next=b:(b.next=v.next,v.next=b),C.pending=b))}function Am(v,b,C){if(b=b.updateQueue,b!==null&&(b=b.shared,(C&4194240)!==0)){var A=b.lanes;A&=v.pendingLanes,C|=A,b.lanes=C,tl(v,C)}}function Mm(v,b){var C=v.updateQueue,A=v.alternate;if(A!==null&&(A=A.updateQueue,C===A)){var O=null,U=null;if(C=C.firstBaseUpdate,C!==null){do{var he={eventTime:C.eventTime,lane:C.lane,tag:C.tag,payload:C.payload,callback:C.callback,next:null};U===null?O=U=he:U=U.next=he,C=C.next}while(C!==null);U===null?O=U=b:U=U.next=b}else O=U=b;C={baseState:A.baseState,firstBaseUpdate:O,lastBaseUpdate:U,shared:A.shared,effects:A.effects},v.updateQueue=C;return}v=C.lastBaseUpdate,v===null?C.firstBaseUpdate=b:v.next=b,C.lastBaseUpdate=b}function km(v,b,C,A){var O=v.updateQueue;sa=!1;var U=O.firstBaseUpdate,he=O.lastBaseUpdate,ke=O.shared.pending;if(ke!==null){O.shared.pending=null;var tt=ke,wt=tt.next;tt.next=null,he===null?U=wt:he.next=wt,he=tt;var Ht=v.alternate;Ht!==null&&(Ht=Ht.updateQueue,ke=Ht.lastBaseUpdate,ke!==he&&(ke===null?Ht.firstBaseUpdate=wt:ke.next=wt,Ht.lastBaseUpdate=tt))}if(U!==null){var Cn=O.baseState;he=0,Ht=wt=tt=null,ke=U;do{var un=ke.lane,On=ke.eventTime;if((A&un)===un){Ht!==null&&(Ht=Ht.next={eventTime:On,lane:0,tag:ke.tag,payload:ke.payload,callback:ke.callback,next:null});e:{var zt=v,hi=ke;switch(un=b,On=C,hi.tag){case 1:if(zt=hi.payload,typeof zt=="function"){Cn=zt.call(On,Cn,un);break e}Cn=zt;break e;case 3:zt.flags=zt.flags&-65537|128;case 0:if(zt=hi.payload,un=typeof zt=="function"?zt.call(On,Cn,un):zt,un==null)break e;Cn=i({},Cn,un);break e;case 2:sa=!0}}ke.callback!==null&&ke.lane!==0&&(v.flags|=64,un=O.effects,un===null?O.effects=[ke]:un.push(ke))}else On={eventTime:On,lane:un,tag:ke.tag,payload:ke.payload,callback:ke.callback,next:null},Ht===null?(wt=Ht=On,tt=Cn):Ht=Ht.next=On,he|=un;if(ke=ke.next,ke===null){if(ke=O.shared.pending,ke===null)break;un=ke,ke=un.next,un.next=null,O.lastBaseUpdate=un,O.shared.pending=null}}while(!0);if(Ht===null&&(tt=Cn),O.baseState=tt,O.firstBaseUpdate=wt,O.lastBaseUpdate=Ht,b=O.shared.interleaved,b!==null){O=b;do he|=O.lane,O=O.next;while(O!==b)}else U===null&&(O.shared.lanes=0);ol|=he,v.lanes=he,v.memoizedState=Cn}}function _w(v,b,C){if(v=b.effects,b.effects=null,v!==null)for(b=0;b<v.length;b++){var A=v[b],O=A.callback;if(O!==null){if(A.callback=null,A=C,typeof O!="function")throw Error(o(191,O));O.call(A)}}}var Tw=new r.Component().refs;function g0(v,b,C,A){b=v.memoizedState,C=C(A,b),C=C==null?b:i({},b,C),v.memoizedState=C,v.lanes===0&&(v.updateQueue.baseState=C)}var Rm={isMounted:function(v){return(v=v._reactInternals)?k(v)===v:!1},enqueueSetState:function(v,b,C){v=v._reactInternals;var A=hr(),O=La(v),U=kl(A,O);U.payload=b,C!=null&&(U.callback=C),Eu(v,U),b=Ci(v,O,A),b!==null&&Am(b,v,O)},enqueueReplaceState:function(v,b,C){v=v._reactInternals;var A=hr(),O=La(v),U=kl(A,O);U.tag=1,U.payload=b,C!=null&&(U.callback=C),Eu(v,U),b=Ci(v,O,A),b!==null&&Am(b,v,O)},enqueueForceUpdate:function(v,b){v=v._reactInternals;var C=hr(),A=La(v),O=kl(C,A);O.tag=2,b!=null&&(O.callback=b),Eu(v,O),b=Ci(v,A,C),b!==null&&Am(b,v,A)}};function y0(v,b,C,A,O,U,he){return v=v.stateNode,typeof v.shouldComponentUpdate=="function"?v.shouldComponentUpdate(A,U,he):b.prototype&&b.prototype.isPureReactComponent?!Aa(C,A)||!Aa(O,U):!0}function Ew(v,b,C){var A=!1,O=mn,U=b.contextType;return typeof U=="object"&&U!==null?U=no(U):(O=kr(b)?Tr:dn.current,A=b.contextTypes,U=(A=A!=null)?Wr(v,O):mn),b=new b(C,U),v.memoizedState=b.state!==null&&b.state!==void 0?b.state:null,b.updater=Rm,v.stateNode=b,b._reactInternals=v,A&&(v=v.stateNode,v.__reactInternalMemoizedUnmaskedChildContext=O,v.__reactInternalMemoizedMaskedChildContext=U),b}function Cw(v,b,C,A){v=b.state,typeof b.componentWillReceiveProps=="function"&&b.componentWillReceiveProps(C,A),typeof b.UNSAFE_componentWillReceiveProps=="function"&&b.UNSAFE_componentWillReceiveProps(C,A),b.state!==v&&Rm.enqueueReplaceState(b,b.state,null)}function v0(v,b,C,A){var O=v.stateNode;O.props=C,O.state=v.memoizedState,O.refs=Tw,Ih(v);var U=b.contextType;typeof U=="object"&&U!==null?O.context=no(U):(U=kr(b)?Tr:dn.current,O.context=Wr(v,U)),O.state=v.memoizedState,U=b.getDerivedStateFromProps,typeof U=="function"&&(g0(v,b,U,C),O.state=v.memoizedState),typeof b.getDerivedStateFromProps=="function"||typeof O.getSnapshotBeforeUpdate=="function"||typeof O.UNSAFE_componentWillMount!="function"&&typeof O.componentWillMount!="function"||(b=O.state,typeof O.componentWillMount=="function"&&O.componentWillMount(),typeof O.UNSAFE_componentWillMount=="function"&&O.UNSAFE_componentWillMount(),b!==O.state&&Rm.enqueueReplaceState(O,O.state,null),km(v,C,O,A),O.state=v.memoizedState),typeof O.componentDidMount=="function"&&(v.flags|=4194308)}var Nh=[],Cu=0,Dm=null,$m=0,ia=[],No=0,gc=null,Rl=1,Dl="";function yc(v,b){Nh[Cu++]=$m,Nh[Cu++]=Dm,Dm=v,$m=b}function Iw(v,b,C){ia[No++]=Rl,ia[No++]=Dl,ia[No++]=gc,gc=v;var A=Rl;v=Dl;var O=32-Rr(A)-1;A&=~(1<<O),C+=1;var U=32-Rr(b)+O;if(30<U){var he=O-O%5;U=(A&(1<<he)-1).toString(32),A>>=he,O-=he,Rl=1<<32-Rr(b)+O|C<<O|A,Dl=U+v}else Rl=1<<U|C<<O|A,Dl=v}function x0(v){v.return!==null&&(yc(v,1),Iw(v,1,0))}function w0(v){for(;v===Dm;)Dm=Nh[--Cu],Nh[Cu]=null,$m=Nh[--Cu],Nh[Cu]=null;for(;v===gc;)gc=ia[--No],ia[No]=null,Dl=ia[--No],ia[No]=null,Rl=ia[--No],ia[No]=null}var Vi=null,oi=null,Kr=!1,Ah=!1,oa=null;function b0(v,b){var C=Po(5,null,null,0);C.elementType="DELETED",C.stateNode=b,C.return=v,b=v.deletions,b===null?(v.deletions=[C],v.flags|=16):b.push(C)}function S0(v,b){switch(v.tag){case 5:return b=er(b,v.type,v.pendingProps),b!==null?(v.stateNode=b,Vi=v,oi=En(b),!0):!1;case 6:return b=gs(b,v.pendingProps),b!==null?(v.stateNode=b,Vi=v,oi=null,!0):!1;case 13:if(b=Ws(b),b!==null){var C=gc!==null?{id:Rl,overflow:Dl}:null;return v.memoizedState={dehydrated:b,treeContext:C,retryLane:1073741824},C=Po(18,null,null,0),C.stateNode=b,C.return=v,v.child=C,Vi=v,oi=null,!0}return!1;default:return!1}}function Pm(v){return(v.mode&1)!==0&&(v.flags&128)===0}function Iu(v){if(Kr){var b=oi;if(b){var C=b;if(!S0(v,b)){if(Pm(v))throw Error(o(418));b=ii(C);var A=Vi;b&&S0(v,b)?b0(A,C):(v.flags=v.flags&-4097|2,Kr=!1,Vi=v)}}else{if(Pm(v))throw Error(o(418));v.flags=v.flags&-4097|2,Kr=!1,Vi=v}}}function Nw(v){for(v=v.return;v!==null&&v.tag!==5&&v.tag!==3&&v.tag!==13;)v=v.return;Vi=v}function mf(v){if(!nt||v!==Vi)return!1;if(!Kr)return Nw(v),Kr=!0,!1;if(v.tag!==3&&(v.tag!==5||We(v.type)&&!ye(v.type,v.memoizedProps))){var b=oi;if(b){if(Pm(v)){for(v=oi;v;)v=ii(v);throw Error(o(418))}for(;b;)b0(v,b),b=ii(b)}}if(Nw(v),v.tag===13){if(!nt)throw Error(o(316));if(v=v.memoizedState,v=v!==null?v.dehydrated:null,!v)throw Error(o(317));oi=H(v)}else oi=Vi?ii(v.stateNode):null;return!0}function Mh(){nt&&(oi=Vi=null,Ah=Kr=!1)}function Lm(v){oa===null?oa=[v]:oa.push(v)}function kh(v,b,C){if(v=C.ref,v!==null&&typeof v!="function"&&typeof v!="object"){if(C._owner){if(C=C._owner,C){if(C.tag!==1)throw Error(o(309));var A=C.stateNode}if(!A)throw Error(o(147,v));var O=A,U=""+v;return b!==null&&b.ref!==null&&typeof b.ref=="function"&&b.ref._stringRef===U?b.ref:(b=function(he){var ke=O.refs;ke===Tw&&(ke=O.refs={}),he===null?delete ke[U]:ke[U]=he},b._stringRef=U,b)}if(typeof v!="string")throw Error(o(284));if(!C._owner)throw Error(o(290,v))}return v}function Nu(v,b){throw v=Object.prototype.toString.call(b),Error(o(31,v==="[object Object]"?"object with keys {"+Object.keys(b).join(", ")+"}":v))}function Rh(v){var b=v._init;return b(v._payload)}function Aw(v){function b(Ve,De){if(v){var Ze=Ve.deletions;Ze===null?(Ve.deletions=[De],Ve.flags|=16):Ze.push(De)}}function C(Ve,De){if(!v)return null;for(;De!==null;)b(Ve,De),De=De.sibling;return null}function A(Ve,De){for(Ve=new Map;De!==null;)De.key!==null?Ve.set(De.key,De):Ve.set(De.index,De),De=De.sibling;return Ve}function O(Ve,De){return Ve=Xl(Ve,De),Ve.index=0,Ve.sibling=null,Ve}function U(Ve,De,Ze){return Ve.index=Ze,v?(Ze=Ve.alternate,Ze!==null?(Ze=Ze.index,Ze<De?(Ve.flags|=2,De):Ze):(Ve.flags|=2,De)):(Ve.flags|=1048576,De)}function he(Ve){return v&&Ve.alternate===null&&(Ve.flags|=2),Ve}function ke(Ve,De,Ze,Pt){return De===null||De.tag!==6?(De=ug(Ze,Ve.mode,Pt),De.return=Ve,De):(De=O(De,Ze),De.return=Ve,De)}function tt(Ve,De,Ze,Pt){var Zt=Ze.type;return Zt===c?Ht(Ve,De,Ze.props.children,Pt,Ze.key):De!==null&&(De.elementType===Zt||typeof Zt=="object"&&Zt!==null&&Zt.$$typeof===T&&Rh(Zt)===De.type)?(Pt=O(De,Ze.props),Pt.ref=kh(Ve,De,Ze),Pt.return=Ve,Pt):(Pt=lg(Ze.type,Ze.key,Ze.props,null,Ve.mode,Pt),Pt.ref=kh(Ve,De,Ze),Pt.return=Ve,Pt)}function wt(Ve,De,Ze,Pt){return De===null||De.tag!==4||De.stateNode.containerInfo!==Ze.containerInfo||De.stateNode.implementation!==Ze.implementation?(De=cg(Ze,Ve.mode,Pt),De.return=Ve,De):(De=O(De,Ze.children||[]),De.return=Ve,De)}function Ht(Ve,De,Ze,Pt,Zt){return De===null||De.tag!==7?(De=zc(Ze,Ve.mode,Pt,Zt),De.return=Ve,De):(De=O(De,Ze),De.return=Ve,De)}function Cn(Ve,De,Ze){if(typeof De=="string"&&De!==""||typeof De=="number")return De=ug(""+De,Ve.mode,Ze),De.return=Ve,De;if(typeof De=="object"&&De!==null){switch(De.$$typeof){case l:return Ze=lg(De.type,De.key,De.props,null,Ve.mode,Ze),Ze.ref=kh(Ve,null,De),Ze.return=Ve,Ze;case u:return De=cg(De,Ve.mode,Ze),De.return=Ve,De;case T:var Pt=De._init;return Cn(Ve,Pt(De._payload),Ze)}if(X(De)||M(De))return De=zc(De,Ve.mode,Ze,null),De.return=Ve,De;Nu(Ve,De)}return null}function un(Ve,De,Ze,Pt){var Zt=De!==null?De.key:null;if(typeof Ze=="string"&&Ze!==""||typeof Ze=="number")return Zt!==null?null:ke(Ve,De,""+Ze,Pt);if(typeof Ze=="object"&&Ze!==null){switch(Ze.$$typeof){case l:return Ze.key===Zt?tt(Ve,De,Ze,Pt):null;case u:return Ze.key===Zt?wt(Ve,De,Ze,Pt):null;case T:return Zt=Ze._init,un(Ve,De,Zt(Ze._payload),Pt)}if(X(Ze)||M(Ze))return Zt!==null?null:Ht(Ve,De,Ze,Pt,null);Nu(Ve,Ze)}return null}function On(Ve,De,Ze,Pt,Zt){if(typeof Pt=="string"&&Pt!==""||typeof Pt=="number")return Ve=Ve.get(Ze)||null,ke(De,Ve,""+Pt,Zt);if(typeof Pt=="object"&&Pt!==null){switch(Pt.$$typeof){case l:return Ve=Ve.get(Pt.key===null?Ze:Pt.key)||null,tt(De,Ve,Pt,Zt);case u:return Ve=Ve.get(Pt.key===null?Ze:Pt.key)||null,wt(De,Ve,Pt,Zt);case T:var Dn=Pt._init;return On(Ve,De,Ze,Dn(Pt._payload),Zt)}if(X(Pt)||M(Pt))return Ve=Ve.get(Ze)||null,Ht(De,Ve,Pt,Zt,null);Nu(De,Pt)}return null}function zt(Ve,De,Ze,Pt){for(var Zt=null,Dn=null,In=De,rr=De=0,Ss=null;In!==null&&rr<Ze.length;rr++){In.index>rr?(Ss=In,In=null):Ss=In.sibling;var tr=un(Ve,In,Ze[rr],Pt);if(tr===null){In===null&&(In=Ss);break}v&&In&&tr.alternate===null&&b(Ve,In),De=U(tr,De,rr),Dn===null?Zt=tr:Dn.sibling=tr,Dn=tr,In=Ss}if(rr===Ze.length)return C(Ve,In),Kr&&yc(Ve,rr),Zt;if(In===null){for(;rr<Ze.length;rr++)In=Cn(Ve,Ze[rr],Pt),In!==null&&(De=U(In,De,rr),Dn===null?Zt=In:Dn.sibling=In,Dn=In);return Kr&&yc(Ve,rr),Zt}for(In=A(Ve,In);rr<Ze.length;rr++)Ss=On(In,Ve,rr,Ze[rr],Pt),Ss!==null&&(v&&Ss.alternate!==null&&In.delete(Ss.key===null?rr:Ss.key),De=U(Ss,De,rr),Dn===null?Zt=Ss:Dn.sibling=Ss,Dn=Ss);return v&&In.forEach(function(ql){return b(Ve,ql)}),Kr&&yc(Ve,rr),Zt}function hi(Ve,De,Ze,Pt){var Zt=M(Ze);if(typeof Zt!="function")throw Error(o(150));if(Ze=Zt.call(Ze),Ze==null)throw Error(o(151));for(var Dn=Zt=null,In=De,rr=De=0,Ss=null,tr=Ze.next();In!==null&&!tr.done;rr++,tr=Ze.next()){In.index>rr?(Ss=In,In=null):Ss=In.sibling;var ql=un(Ve,In,tr.value,Pt);if(ql===null){In===null&&(In=Ss);break}v&&In&&ql.alternate===null&&b(Ve,In),De=U(ql,De,rr),Dn===null?Zt=ql:Dn.sibling=ql,Dn=ql,In=Ss}if(tr.done)return C(Ve,In),Kr&&yc(Ve,rr),Zt;if(In===null){for(;!tr.done;rr++,tr=Ze.next())tr=Cn(Ve,tr.value,Pt),tr!==null&&(De=U(tr,De,rr),Dn===null?Zt=tr:Dn.sibling=tr,Dn=tr);return Kr&&yc(Ve,rr),Zt}for(In=A(Ve,In);!tr.done;rr++,tr=Ze.next())tr=On(In,Ve,rr,tr.value,Pt),tr!==null&&(v&&tr.alternate!==null&&In.delete(tr.key===null?rr:tr.key),De=U(tr,De,rr),Dn===null?Zt=tr:Dn.sibling=tr,Dn=tr);return v&&In.forEach(function(Q0){return b(Ve,Q0)}),Kr&&yc(Ve,rr),Zt}function Lo(Ve,De,Ze,Pt){if(typeof Ze=="object"&&Ze!==null&&Ze.type===c&&Ze.key===null&&(Ze=Ze.props.children),typeof Ze=="object"&&Ze!==null){switch(Ze.$$typeof){case l:e:{for(var Zt=Ze.key,Dn=De;Dn!==null;){if(Dn.key===Zt){if(Zt=Ze.type,Zt===c){if(Dn.tag===7){C(Ve,Dn.sibling),De=O(Dn,Ze.props.children),De.return=Ve,Ve=De;break e}}else if(Dn.elementType===Zt||typeof Zt=="object"&&Zt!==null&&Zt.$$typeof===T&&Rh(Zt)===Dn.type){C(Ve,Dn.sibling),De=O(Dn,Ze.props),De.ref=kh(Ve,Dn,Ze),De.return=Ve,Ve=De;break e}C(Ve,Dn);break}else b(Ve,Dn);Dn=Dn.sibling}Ze.type===c?(De=zc(Ze.props.children,Ve.mode,Pt,Ze.key),De.return=Ve,Ve=De):(Pt=lg(Ze.type,Ze.key,Ze.props,null,Ve.mode,Pt),Pt.ref=kh(Ve,De,Ze),Pt.return=Ve,Ve=Pt)}return he(Ve);case u:e:{for(Dn=Ze.key;De!==null;){if(De.key===Dn)if(De.tag===4&&De.stateNode.containerInfo===Ze.containerInfo&&De.stateNode.implementation===Ze.implementation){C(Ve,De.sibling),De=O(De,Ze.children||[]),De.return=Ve,Ve=De;break e}else{C(Ve,De);break}else b(Ve,De);De=De.sibling}De=cg(Ze,Ve.mode,Pt),De.return=Ve,Ve=De}return he(Ve);case T:return Dn=Ze._init,Lo(Ve,De,Dn(Ze._payload),Pt)}if(X(Ze))return zt(Ve,De,Ze,Pt);if(M(Ze))return hi(Ve,De,Ze,Pt);Nu(Ve,Ze)}return typeof Ze=="string"&&Ze!==""||typeof Ze=="number"?(Ze=""+Ze,De!==null&&De.tag===6?(C(Ve,De.sibling),De=O(De,Ze),De.return=Ve,Ve=De):(C(Ve,De),De=ug(Ze,Ve.mode,Pt),De.return=Ve,Ve=De),he(Ve)):C(Ve,De)}return Lo}var $l=Aw(!0),Mw=Aw(!1),Dh={},ro=vn(Dh),vc=vn(Dh),xc=vn(Dh);function Ma(v){if(v===Dh)throw Error(o(174));return v}function Om(v,b){Ct(xc,b),Ct(vc,v),Ct(ro,Dh),v=se(b),kt(ro),Ct(ro,v)}function $h(){kt(ro),kt(vc),kt(xc)}function kw(v){var b=Ma(xc.current),C=Ma(ro.current);b=W(C,v.type,b),C!==b&&(Ct(vc,v),Ct(ro,b))}function _0(v){vc.current===v&&(kt(ro),kt(vc))}var ts=vn(0);function Fm(v){for(var b=v;b!==null;){if(b.tag===13){var C=b.memoizedState;if(C!==null&&(C=C.dehydrated,C===null||Qa(C)||Na(C)))return b}else if(b.tag===19&&b.memoizedProps.revealOrder!==void 0){if((b.flags&128)!==0)return b}else if(b.child!==null){b.child.return=b,b=b.child;continue}if(b===v)break;for(;b.sibling===null;){if(b.return===null||b.return===v)return null;b=b.return}b.sibling.return=b.return,b=b.sibling}return null}var Ao=[];function wc(){for(var v=0;v<Ao.length;v++){var b=Ao[v];st?b._workInProgressVersionPrimary=null:b._workInProgressVersionSecondary=null}Ao.length=0}var gf=a.ReactCurrentDispatcher,Mo=a.ReactCurrentBatchConfig,bc=0,ns=null,Gs=null,Hs=null,zm=!1,rl=!1,Sc=0,yf=0;function js(){throw Error(o(321))}function Bm(v,b){if(b===null)return!1;for(var C=0;C<b.length&&C<v.length;C++)if(!Bi(v[C],b[C]))return!1;return!0}function Ph(v,b,C,A,O,U){if(bc=U,ns=b,b.memoizedState=null,b.updateQueue=null,b.lanes=0,gf.current=v===null||v.memoizedState===null?A0:M0,v=C(A,O),rl){U=0;do{if(rl=!1,Sc=0,25<=U)throw Error(o(301));U+=1,Hs=Gs=null,b.updateQueue=null,gf.current=k0,v=C(A,O)}while(rl)}if(gf.current=zh,b=Gs!==null&&Gs.next!==null,bc=0,Hs=Gs=ns=null,zm=!1,b)throw Error(o(300));return v}function Au(){var v=Sc!==0;return Sc=0,v}function ka(){var v={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Hs===null?ns.memoizedState=Hs=v:Hs=Hs.next=v,Hs}function Ra(){if(Gs===null){var v=ns.alternate;v=v!==null?v.memoizedState:null}else v=Gs.next;var b=Hs===null?ns.memoizedState:Hs.next;if(b!==null)Hs=b,Gs=v;else{if(v===null)throw Error(o(310));Gs=v,v={memoizedState:Gs.memoizedState,baseState:Gs.baseState,baseQueue:Gs.baseQueue,queue:Gs.queue,next:null},Hs===null?ns.memoizedState=Hs=v:Hs=Hs.next=v}return Hs}function sl(v,b){return typeof b=="function"?b(v):b}function vf(v){var b=Ra(),C=b.queue;if(C===null)throw Error(o(311));C.lastRenderedReducer=v;var A=Gs,O=A.baseQueue,U=C.pending;if(U!==null){if(O!==null){var he=O.next;O.next=U.next,U.next=he}A.baseQueue=O=U,C.pending=null}if(O!==null){U=O.next,A=A.baseState;var ke=he=null,tt=null,wt=U;do{var Ht=wt.lane;if((bc&Ht)===Ht)tt!==null&&(tt=tt.next={lane:0,action:wt.action,hasEagerState:wt.hasEagerState,eagerState:wt.eagerState,next:null}),A=wt.hasEagerState?wt.eagerState:v(A,wt.action);else{var Cn={lane:Ht,action:wt.action,hasEagerState:wt.hasEagerState,eagerState:wt.eagerState,next:null};tt===null?(ke=tt=Cn,he=A):tt=tt.next=Cn,ns.lanes|=Ht,ol|=Ht}wt=wt.next}while(wt!==null&&wt!==U);tt===null?he=A:tt.next=ke,Bi(A,b.memoizedState)||(Xs=!0),b.memoizedState=A,b.baseState=he,b.baseQueue=tt,C.lastRenderedState=A}if(v=C.interleaved,v!==null){O=v;do U=O.lane,ns.lanes|=U,ol|=U,O=O.next;while(O!==v)}else O===null&&(C.lanes=0);return[b.memoizedState,C.dispatch]}function xf(v){var b=Ra(),C=b.queue;if(C===null)throw Error(o(311));C.lastRenderedReducer=v;var A=C.dispatch,O=C.pending,U=b.memoizedState;if(O!==null){C.pending=null;var he=O=O.next;do U=v(U,he.action),he=he.next;while(he!==O);Bi(U,b.memoizedState)||(Xs=!0),b.memoizedState=U,b.baseQueue===null&&(b.baseState=U),C.lastRenderedState=U}return[U,A]}function T0(){}function E0(v,b){var C=ns,A=Ra(),O=b(),U=!Bi(A.memoizedState,O);if(U&&(A.memoizedState=O,Xs=!0),A=A.queue,Lh(Pl.bind(null,C,A,v),[v]),A.getSnapshot!==b||U||Hs!==null&&Hs.memoizedState.tag&1){if(C.flags|=2048,bf(9,I0.bind(null,C,A,O,b),void 0,null),vs===null)throw Error(o(349));(bc&30)!==0||C0(C,b,O)}return O}function C0(v,b,C){v.flags|=16384,v={getSnapshot:b,value:C},b=ns.updateQueue,b===null?(b={lastEffect:null,stores:null},ns.updateQueue=b,b.stores=[v]):(C=b.stores,C===null?b.stores=[v]:C.push(v))}function I0(v,b,C,A){b.value=C,b.getSnapshot=A,Um(b)&&Ci(v,1,-1)}function Pl(v,b,C){return C(function(){Um(b)&&Ci(v,1,-1)})}function Um(v){var b=v.getSnapshot;v=v.value;try{var C=b();return!Bi(v,C)}catch{return!0}}function wf(v){var b=ka();return typeof v=="function"&&(v=v()),b.memoizedState=b.baseState=v,v={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:sl,lastRenderedState:v},b.queue=v,v=v.dispatch=tC.bind(null,ns,v),[b.memoizedState,v]}function bf(v,b,C,A){return v={tag:v,create:b,destroy:C,deps:A,next:null},b=ns.updateQueue,b===null?(b={lastEffect:null,stores:null},ns.updateQueue=b,b.lastEffect=v.next=v):(C=b.lastEffect,C===null?b.lastEffect=v.next=v:(A=C.next,C.next=v,v.next=A,b.lastEffect=v)),v}function Rw(){return Ra().memoizedState}function Mu(v,b,C,A){var O=ka();ns.flags|=v,O.memoizedState=bf(1|b,C,void 0,A===void 0?null:A)}function Vm(v,b,C,A){var O=Ra();A=A===void 0?null:A;var U=void 0;if(Gs!==null){var he=Gs.memoizedState;if(U=he.destroy,A!==null&&Bm(A,he.deps)){O.memoizedState=bf(b,C,U,A);return}}ns.flags|=v,O.memoizedState=bf(1|b,C,U,A)}function Wm(v,b){return Mu(8390656,8,v,b)}function Lh(v,b){return Vm(2048,8,v,b)}function Fr(v,b){return Vm(4,2,v,b)}function Gm(v,b){return Vm(4,4,v,b)}function Sf(v,b){if(typeof b=="function")return v=v(),b(v),function(){b(null)};if(b!=null)return v=v(),b.current=v,function(){b.current=null}}function Oh(v,b,C){return C=C!=null?C.concat([v]):null,Vm(4,4,Sf.bind(null,b,v),C)}function Hm(){}function jm(v,b){var C=Ra();b=b===void 0?null:b;var A=C.memoizedState;return A!==null&&b!==null&&Bm(b,A[1])?A[0]:(C.memoizedState=[v,b],v)}function Fh(v,b){var C=Ra();b=b===void 0?null:b;var A=C.memoizedState;return A!==null&&b!==null&&Bm(b,A[1])?A[0]:(v=v(),C.memoizedState=[v,b],v)}function Xm(v,b){var C=Bn;Bn=C!==0&&4>C?C:4,v(!0);var A=Mo.transition;Mo.transition={};try{v(!1),b()}finally{Bn=C,Mo.transition=A}}function _c(){return Ra().memoizedState}function Dw(v,b,C){var A=La(v);C={lane:A,action:C,hasEagerState:!1,eagerState:null,next:null},$w(v)?N0(b,C):(_f(v,b,C),C=hr(),v=Ci(v,A,C),v!==null&&Tf(v,b,A))}function tC(v,b,C){var A=La(v),O={lane:A,action:C,hasEagerState:!1,eagerState:null,next:null};if($w(v))N0(b,O);else{_f(v,b,O);var U=v.alternate;if(v.lanes===0&&(U===null||U.lanes===0)&&(U=b.lastRenderedReducer,U!==null))try{var he=b.lastRenderedState,ke=U(he,C);if(O.hasEagerState=!0,O.eagerState=ke,Bi(ke,he))return}catch{}finally{}C=hr(),v=Ci(v,A,C),v!==null&&Tf(v,b,A)}}function $w(v){var b=v.alternate;return v===ns||b!==null&&b===ns}function N0(v,b){rl=zm=!0;var C=v.pending;C===null?b.next=b:(b.next=C.next,C.next=b),v.pending=b}function _f(v,b,C){vs!==null&&(v.mode&1)!==0&&(Ln&2)===0?(v=b.interleaved,v===null?(C.next=C,ra===null?ra=[b]:ra.push(b)):(C.next=v.next,v.next=C),b.interleaved=C):(v=b.pending,v===null?C.next=C:(C.next=v.next,v.next=C),b.pending=C)}function Tf(v,b,C){if((C&4194240)!==0){var A=b.lanes;A&=v.pendingLanes,C|=A,b.lanes=C,tl(v,C)}}var zh={readContext:no,useCallback:js,useContext:js,useEffect:js,useImperativeHandle:js,useInsertionEffect:js,useLayoutEffect:js,useMemo:js,useReducer:js,useRef:js,useState:js,useDebugValue:js,useDeferredValue:js,useTransition:js,useMutableSource:js,useSyncExternalStore:js,useId:js,unstable_isNewReconciler:!1},A0={readContext:no,useCallback:function(v,b){return ka().memoizedState=[v,b===void 0?null:b],v},useContext:no,useEffect:Wm,useImperativeHandle:function(v,b,C){return C=C!=null?C.concat([v]):null,Mu(4194308,4,Sf.bind(null,b,v),C)},useLayoutEffect:function(v,b){return Mu(4194308,4,v,b)},useInsertionEffect:function(v,b){return Mu(4,2,v,b)},useMemo:function(v,b){var C=ka();return b=b===void 0?null:b,v=v(),C.memoizedState=[v,b],v},useReducer:function(v,b,C){var A=ka();return b=C!==void 0?C(b):b,A.memoizedState=A.baseState=b,v={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:v,lastRenderedState:b},A.queue=v,v=v.dispatch=Dw.bind(null,ns,v),[A.memoizedState,v]},useRef:function(v){var b=ka();return v={current:v},b.memoizedState=v},useState:wf,useDebugValue:Hm,useDeferredValue:function(v){var b=wf(v),C=b[0],A=b[1];return Wm(function(){var O=Mo.transition;Mo.transition={};try{A(v)}finally{Mo.transition=O}},[v]),C},useTransition:function(){var v=wf(!1),b=v[0];return v=Xm.bind(null,v[1]),ka().memoizedState=v,[b,v]},useMutableSource:function(){},useSyncExternalStore:function(v,b,C){var A=ns,O=ka();if(Kr){if(C===void 0)throw Error(o(407));C=C()}else{if(C=b(),vs===null)throw Error(o(349));(bc&30)!==0||C0(A,b,C)}O.memoizedState=C;var U={value:C,getSnapshot:b};return O.queue=U,Wm(Pl.bind(null,A,U,v),[v]),A.flags|=2048,bf(9,I0.bind(null,A,U,C,b),void 0,null),C},useId:function(){var v=ka(),b=vs.identifierPrefix;if(Kr){var C=Dl,A=Rl;C=(A&~(1<<32-Rr(A)-1)).toString(32)+C,b=":"+b+"R"+C,C=Sc++,0<C&&(b+="H"+C.toString(32)),b+=":"}else C=yf++,b=":"+b+"r"+C.toString(32)+":";return v.memoizedState=b},unstable_isNewReconciler:!1},M0={readContext:no,useCallback:jm,useContext:no,useEffect:Lh,useImperativeHandle:Oh,useInsertionEffect:Fr,useLayoutEffect:Gm,useMemo:Fh,useReducer:vf,useRef:Rw,useState:function(){return vf(sl)},useDebugValue:Hm,useDeferredValue:function(v){var b=vf(sl),C=b[0],A=b[1];return Lh(function(){var O=Mo.transition;Mo.transition={};try{A(v)}finally{Mo.transition=O}},[v]),C},useTransition:function(){var v=vf(sl)[0],b=Ra().memoizedState;return[v,b]},useMutableSource:T0,useSyncExternalStore:E0,useId:_c,unstable_isNewReconciler:!1},k0={readContext:no,useCallback:jm,useContext:no,useEffect:Lh,useImperativeHandle:Oh,useInsertionEffect:Fr,useLayoutEffect:Gm,useMemo:Fh,useReducer:xf,useRef:Rw,useState:function(){return xf(sl)},useDebugValue:Hm,useDeferredValue:function(v){var b=xf(sl),C=b[0],A=b[1];return Lh(function(){var O=Mo.transition;Mo.transition={};try{A(v)}finally{Mo.transition=O}},[v]),C},useTransition:function(){var v=xf(sl)[0],b=Ra().memoizedState;return[v,b]},useMutableSource:T0,useSyncExternalStore:E0,useId:_c,unstable_isNewReconciler:!1};function R0(v,b){try{var C="",A=b;do C+=p0(A),A=A.return;while(A);var O=C}catch(U){O=`
Error generating stack: `+U.message+`
`+U.stack}return{value:v,source:b,stack:O}}function qm(v,b){try{console.error(b.value)}catch(C){setTimeout(function(){throw C})}}var nC=typeof WeakMap=="function"?WeakMap:Map;function Pw(v,b,C){C=kl(-1,C),C.tag=3,C.payload={element:null};var A=b.value;return C.callback=function(){Hh||(Hh=!0,Hr=A),qm(v,b)},C}function Km(v,b,C){C=kl(-1,C),C.tag=3;var A=v.type.getDerivedStateFromError;if(typeof A=="function"){var O=b.value;C.payload=function(){return A(O)},C.callback=function(){qm(v,b)}}var U=v.stateNode;return U!==null&&typeof U.componentDidCatch=="function"&&(C.callback=function(){qm(v,b),typeof A!="function"&&(Pa===null?Pa=new Set([this]):Pa.add(this));var he=b.stack;this.componentDidCatch(b.value,{componentStack:he!==null?he:""})}),C}function Ll(v,b,C){var A=v.pingCache;if(A===null){A=v.pingCache=new nC;var O=new Set;A.set(b,O)}else O=A.get(b),O===void 0&&(O=new Set,A.set(b,O));O.has(C)||(O.add(C),v=Y0.bind(null,v,b,C),b.then(v,v))}function D0(v){do{var b;if((b=v.tag===13)&&(b=v.memoizedState,b=b!==null?b.dehydrated!==null:!0),b)return v;v=v.return}while(v!==null);return null}function Tc(v,b,C,A,O){return(v.mode&1)===0?(v===b?v.flags|=65536:(v.flags|=128,C.flags|=131072,C.flags&=-52805,C.tag===1&&(C.alternate===null?C.tag=17:(b=kl(-1,1),b.tag=2,Eu(C,b))),C.lanes|=1),v):(v.flags|=65536,v.lanes=O,v)}function Ps(v){v.flags|=4}function Bh(v,b){if(v!==null&&v.child===b.child)return!0;if((b.flags&16)!==0)return!1;for(v=b.child;v!==null;){if((v.flags&12854)!==0||(v.subtreeFlags&12854)!==0)return!1;v=v.sibling}return!0}var ko,Ec,Ym,Zm;if(ct)ko=function(v,b){for(var C=b.child;C!==null;){if(C.tag===5||C.tag===6)Q(v,C.stateNode);else if(C.tag!==4&&C.child!==null){C.child.return=C,C=C.child;continue}if(C===b)break;for(;C.sibling===null;){if(C.return===null||C.return===b)return;C=C.return}C.sibling.return=C.return,C=C.sibling}},Ec=function(){},Ym=function(v,b,C,A,O){if(v=v.memoizedProps,v!==A){var U=b.stateNode,he=Ma(ro.current);C=ce(U,C,v,A,O,he),(b.updateQueue=C)&&Ps(b)}},Zm=function(v,b,C,A){C!==A&&Ps(b)};else if(fe){ko=function(v,b,C,A){for(var O=b.child;O!==null;){if(O.tag===5){var U=O.stateNode;C&&A&&(U=Vr(U,O.type,O.memoizedProps,O)),Q(v,U)}else if(O.tag===6)U=O.stateNode,C&&A&&(U=ms(U,O.memoizedProps,O)),Q(v,U);else if(O.tag!==4){if(O.tag===22&&O.memoizedState!==null)U=O.child,U!==null&&(U.return=O),ko(v,O,!0,!0);else if(O.child!==null){O.child.return=O,O=O.child;continue}}if(O===b)break;for(;O.sibling===null;){if(O.return===null||O.return===b)return;O=O.return}O.sibling.return=O.return,O=O.sibling}};var ku=function(v,b,C,A){for(var O=b.child;O!==null;){if(O.tag===5){var U=O.stateNode;C&&A&&(U=Vr(U,O.type,O.memoizedProps,O)),sn(v,U)}else if(O.tag===6)U=O.stateNode,C&&A&&(U=ms(U,O.memoizedProps,O)),sn(v,U);else if(O.tag!==4){if(O.tag===22&&O.memoizedState!==null)U=O.child,U!==null&&(U.return=O),ku(v,O,!0,!0);else if(O.child!==null){O.child.return=O,O=O.child;continue}}if(O===b)break;for(;O.sibling===null;){if(O.return===null||O.return===b)return;O=O.return}O.sibling.return=O.return,O=O.sibling}};Ec=function(v,b){var C=b.stateNode;if(!Bh(v,b)){v=C.containerInfo;var A=ln(v);ku(A,b,!1,!1),C.pendingChildren=A,Ps(b),pr(v,A)}},Ym=function(v,b,C,A,O){var U=v.stateNode,he=v.memoizedProps;if((v=Bh(v,b))&&he===A)b.stateNode=U;else{var ke=b.stateNode,tt=Ma(ro.current),wt=null;he!==A&&(wt=ce(ke,C,he,A,O,tt)),v&&wt===null?b.stateNode=U:(U=Mt(U,wt,C,he,A,b,v,ke),ne(U,C,A,O,tt)&&Ps(b),b.stateNode=U,v?Ps(b):ko(U,b,!1,!1))}},Zm=function(v,b,C,A){C!==A?(v=Ma(xc.current),C=Ma(ro.current),b.stateNode=Se(A,v,C,b),Ps(b)):b.stateNode=v.stateNode}}else Ec=function(){},Ym=function(){},Zm=function(){};function Ol(v,b){if(!Kr)switch(v.tailMode){case"hidden":b=v.tail;for(var C=null;b!==null;)b.alternate!==null&&(C=b),b=b.sibling;C===null?v.tail=null:C.sibling=null;break;case"collapsed":C=v.tail;for(var A=null;C!==null;)C.alternate!==null&&(A=C),C=C.sibling;A===null?b||v.tail===null?v.tail=null:v.tail.sibling=null:A.sibling=null}}function ys(v){var b=v.alternate!==null&&v.alternate.child===v.child,C=0,A=0;if(b)for(var O=v.child;O!==null;)C|=O.lanes|O.childLanes,A|=O.subtreeFlags&14680064,A|=O.flags&14680064,O.return=v,O=O.sibling;else for(O=v.child;O!==null;)C|=O.lanes|O.childLanes,A|=O.subtreeFlags,A|=O.flags,O.return=v,O=O.sibling;return v.subtreeFlags|=A,v.childLanes=C,b}function Jm(v,b,C){var A=b.pendingProps;switch(w0(b),b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ys(b),null;case 1:return kr(b.type)&&Gn(),ys(b),null;case 3:return A=b.stateNode,$h(),kt(xn),kt(dn),wc(),A.pendingContext&&(A.context=A.pendingContext,A.pendingContext=null),(v===null||v.child===null)&&(mf(b)?Ps(b):v===null||v.memoizedState.isDehydrated&&(b.flags&256)===0||(b.flags|=1024,oa!==null&&(Of(oa),oa=null))),Ec(v,b),ys(b),null;case 5:_0(b),C=Ma(xc.current);var O=b.type;if(v!==null&&b.stateNode!=null)Ym(v,b,O,A,C),v.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!A){if(b.stateNode===null)throw Error(o(166));return ys(b),null}if(v=Ma(ro.current),mf(b)){if(!nt)throw Error(o(175));v=j(b.stateNode,b.type,b.memoizedProps,C,v,b,!Ah),b.updateQueue=v,v!==null&&Ps(b)}else{var U=G(O,A,C,v,b);ko(U,b,!1,!1),b.stateNode=U,ne(U,O,A,C,v)&&Ps(b)}b.ref!==null&&(b.flags|=512,b.flags|=2097152)}return ys(b),null;case 6:if(v&&b.stateNode!=null)Zm(v,b,v.memoizedProps,A);else{if(typeof A!="string"&&b.stateNode===null)throw Error(o(166));if(v=Ma(xc.current),C=Ma(ro.current),mf(b)){if(!nt)throw Error(o(176));if(v=b.stateNode,A=b.memoizedProps,(C=re(v,A,b,!Ah))&&(O=Vi,O!==null))switch(U=(O.mode&1)!==0,O.tag){case 3:Ye(O.stateNode.containerInfo,v,A,U);break;case 5:et(O.type,O.memoizedProps,O.stateNode,v,A,U)}C&&Ps(b)}else b.stateNode=Se(A,v,C,b)}return ys(b),null;case 13:if(kt(ts),A=b.memoizedState,Kr&&oi!==null&&(b.mode&1)!==0&&(b.flags&128)===0){for(v=oi;v;)v=ii(v);return Mh(),b.flags|=98560,b}if(A!==null&&A.dehydrated!==null){if(A=mf(b),v===null){if(!A)throw Error(o(318));if(!nt)throw Error(o(344));if(v=b.memoizedState,v=v!==null?v.dehydrated:null,!v)throw Error(o(317));be(v,b)}else Mh(),(b.flags&128)===0&&(b.memoizedState=null),b.flags|=4;return ys(b),null}return oa!==null&&(Of(oa),oa=null),(b.flags&128)!==0?(b.lanes=C,b):(A=A!==null,C=!1,v===null?mf(b):C=v.memoizedState!==null,A&&!C&&(b.child.flags|=8192,(b.mode&1)!==0&&(v===null||(ts.current&1)!==0?us===0&&(us=3):ig())),b.updateQueue!==null&&(b.flags|=4),ys(b),null);case 4:return $h(),Ec(v,b),v===null&&it(b.stateNode.containerInfo),ys(b),null;case 10:return pf(b.type._context),ys(b),null;case 17:return kr(b.type)&&Gn(),ys(b),null;case 19:if(kt(ts),O=b.memoizedState,O===null)return ys(b),null;if(A=(b.flags&128)!==0,U=O.rendering,U===null)if(A)Ol(O,!1);else{if(us!==0||v!==null&&(v.flags&128)!==0)for(v=b.child;v!==null;){if(U=Fm(v),U!==null){for(b.flags|=128,Ol(O,!1),v=U.updateQueue,v!==null&&(b.updateQueue=v,b.flags|=4),b.subtreeFlags=0,v=C,A=b.child;A!==null;)C=A,O=v,C.flags&=14680066,U=C.alternate,U===null?(C.childLanes=0,C.lanes=O,C.child=null,C.subtreeFlags=0,C.memoizedProps=null,C.memoizedState=null,C.updateQueue=null,C.dependencies=null,C.stateNode=null):(C.childLanes=U.childLanes,C.lanes=U.lanes,C.child=U.child,C.subtreeFlags=0,C.deletions=null,C.memoizedProps=U.memoizedProps,C.memoizedState=U.memoizedState,C.updateQueue=U.updateQueue,C.type=U.type,O=U.dependencies,C.dependencies=O===null?null:{lanes:O.lanes,firstContext:O.firstContext}),A=A.sibling;return Ct(ts,ts.current&1|2),b.child}v=v.sibling}O.tail!==null&&$s()>$u&&(b.flags|=128,A=!0,Ol(O,!1),b.lanes=4194304)}else{if(!A)if(v=Fm(U),v!==null){if(b.flags|=128,A=!0,v=v.updateQueue,v!==null&&(b.updateQueue=v,b.flags|=4),Ol(O,!0),O.tail===null&&O.tailMode==="hidden"&&!U.alternate&&!Kr)return ys(b),null}else 2*$s()-O.renderingStartTime>$u&&C!==1073741824&&(b.flags|=128,A=!0,Ol(O,!1),b.lanes=4194304);O.isBackwards?(U.sibling=b.child,b.child=U):(v=O.last,v!==null?v.sibling=U:b.child=U,O.last=U)}return O.tail!==null?(b=O.tail,O.rendering=b,O.tail=b.sibling,O.renderingStartTime=$s(),b.sibling=null,v=ts.current,Ct(ts,A?v&1|2:v&1),b):(ys(b),null);case 22:case 23:return Ff(),A=b.memoizedState!==null,v!==null&&v.memoizedState!==null!==A&&(b.flags|=8192),A&&(b.mode&1)!==0?(Ei&1073741824)!==0&&(ys(b),ct&&b.subtreeFlags&6&&(b.flags|=8192)):ys(b),null;case 24:return null;case 25:return null}throw Error(o(156,b.tag))}var $0=a.ReactCurrentOwner,Xs=!1;function ls(v,b,C,A){b.child=v===null?Mw(b,null,C,A):$l(b,v.child,C,A)}function zr(v,b,C,A,O){C=C.render;var U=b.ref;return Ch(b,O),A=Ph(v,b,C,A,U,O),C=Au(),v!==null&&!Xs?(b.updateQueue=v.updateQueue,b.flags&=-2053,v.lanes&=~O,so(v,b,O)):(Kr&&C&&x0(b),b.flags|=1,ls(v,b,A,O),b.child)}function Dr(v,b,C,A,O){if(v===null){var U=C.type;return typeof U=="function"&&!ag(U)&&U.defaultProps===void 0&&C.compare===null&&C.defaultProps===void 0?(b.tag=15,b.type=U,Fl(v,b,U,A,O)):(v=lg(C.type,null,A,b,b.mode,O),v.ref=b.ref,v.return=b,b.child=v)}if(U=v.child,(v.lanes&O)===0){var he=U.memoizedProps;if(C=C.compare,C=C!==null?C:Aa,C(he,A)&&v.ref===b.ref)return so(v,b,O)}return b.flags|=1,v=Xl(U,A),v.ref=b.ref,v.return=b,b.child=v}function Fl(v,b,C,A,O){if(v!==null&&Aa(v.memoizedProps,A)&&v.ref===b.ref)if(Xs=!1,(v.lanes&O)!==0)(v.flags&131072)!==0&&(Xs=!0);else return b.lanes=v.lanes,so(v,b,O);return zl(v,b,C,A,O)}function ai(v,b,C){var A=b.pendingProps,O=A.children,U=v!==null?v.memoizedState:null;if(A.mode==="hidden")if((b.mode&1)===0)b.memoizedState={baseLanes:0,cachePool:null},Ct($c,Ei),Ei|=C;else if((C&1073741824)!==0)b.memoizedState={baseLanes:0,cachePool:null},A=U!==null?U.baseLanes:C,Ct($c,Ei),Ei|=A;else return v=U!==null?U.baseLanes|C:C,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:v,cachePool:null},b.updateQueue=null,Ct($c,Ei),Ei|=v,null;else U!==null?(A=U.baseLanes|C,b.memoizedState=null):A=C,Ct($c,Ei),Ei|=A;return ls(v,b,O,C),b.child}function Wi(v,b){var C=b.ref;(v===null&&C!==null||v!==null&&v.ref!==C)&&(b.flags|=512,b.flags|=2097152)}function zl(v,b,C,A,O){var U=kr(C)?Tr:dn.current;return U=Wr(b,U),Ch(b,O),C=Ph(v,b,C,A,U,O),A=Au(),v!==null&&!Xs?(b.updateQueue=v.updateQueue,b.flags&=-2053,v.lanes&=~O,so(v,b,O)):(Kr&&A&&x0(b),b.flags|=1,ls(v,b,C,O),b.child)}function Cc(v,b,C,A,O){if(kr(C)){var U=!0;Rn(b)}else U=!1;if(Ch(b,O),b.stateNode===null)v!==null&&(v.alternate=null,b.alternate=null,b.flags|=2),Ew(b,C,A),v0(b,C,A,O),A=!0;else if(v===null){var he=b.stateNode,ke=b.memoizedProps;he.props=ke;var tt=he.context,wt=C.contextType;typeof wt=="object"&&wt!==null?wt=no(wt):(wt=kr(C)?Tr:dn.current,wt=Wr(b,wt));var Ht=C.getDerivedStateFromProps,Cn=typeof Ht=="function"||typeof he.getSnapshotBeforeUpdate=="function";Cn||typeof he.UNSAFE_componentWillReceiveProps!="function"&&typeof he.componentWillReceiveProps!="function"||(ke!==A||tt!==wt)&&Cw(b,he,A,wt),sa=!1;var un=b.memoizedState;he.state=un,km(b,A,he,O),tt=b.memoizedState,ke!==A||un!==tt||xn.current||sa?(typeof Ht=="function"&&(g0(b,C,Ht,A),tt=b.memoizedState),(ke=sa||y0(b,C,ke,A,un,tt,wt))?(Cn||typeof he.UNSAFE_componentWillMount!="function"&&typeof he.componentWillMount!="function"||(typeof he.componentWillMount=="function"&&he.componentWillMount(),typeof he.UNSAFE_componentWillMount=="function"&&he.UNSAFE_componentWillMount()),typeof he.componentDidMount=="function"&&(b.flags|=4194308)):(typeof he.componentDidMount=="function"&&(b.flags|=4194308),b.memoizedProps=A,b.memoizedState=tt),he.props=A,he.state=tt,he.context=wt,A=ke):(typeof he.componentDidMount=="function"&&(b.flags|=4194308),A=!1)}else{he=b.stateNode,m0(v,b),ke=b.memoizedProps,wt=b.type===b.elementType?ke:to(b.type,ke),he.props=wt,Cn=b.pendingProps,un=he.context,tt=C.contextType,typeof tt=="object"&&tt!==null?tt=no(tt):(tt=kr(C)?Tr:dn.current,tt=Wr(b,tt));var On=C.getDerivedStateFromProps;(Ht=typeof On=="function"||typeof he.getSnapshotBeforeUpdate=="function")||typeof he.UNSAFE_componentWillReceiveProps!="function"&&typeof he.componentWillReceiveProps!="function"||(ke!==Cn||un!==tt)&&Cw(b,he,A,tt),sa=!1,un=b.memoizedState,he.state=un,km(b,A,he,O);var zt=b.memoizedState;ke!==Cn||un!==zt||xn.current||sa?(typeof On=="function"&&(g0(b,C,On,A),zt=b.memoizedState),(wt=sa||y0(b,C,wt,A,un,zt,tt)||!1)?(Ht||typeof he.UNSAFE_componentWillUpdate!="function"&&typeof he.componentWillUpdate!="function"||(typeof he.componentWillUpdate=="function"&&he.componentWillUpdate(A,zt,tt),typeof he.UNSAFE_componentWillUpdate=="function"&&he.UNSAFE_componentWillUpdate(A,zt,tt)),typeof he.componentDidUpdate=="function"&&(b.flags|=4),typeof he.getSnapshotBeforeUpdate=="function"&&(b.flags|=1024)):(typeof he.componentDidUpdate!="function"||ke===v.memoizedProps&&un===v.memoizedState||(b.flags|=4),typeof he.getSnapshotBeforeUpdate!="function"||ke===v.memoizedProps&&un===v.memoizedState||(b.flags|=1024),b.memoizedProps=A,b.memoizedState=zt),he.props=A,he.state=zt,he.context=tt,A=wt):(typeof he.componentDidUpdate!="function"||ke===v.memoizedProps&&un===v.memoizedState||(b.flags|=4),typeof he.getSnapshotBeforeUpdate!="function"||ke===v.memoizedProps&&un===v.memoizedState||(b.flags|=1024),A=!1)}return Ti(v,b,C,A,U,O)}function Ti(v,b,C,A,O,U){Wi(v,b);var he=(b.flags&128)!==0;if(!A&&!he)return O&&Hn(b,C,!1),so(v,b,U);A=b.stateNode,$0.current=b;var ke=he&&typeof C.getDerivedStateFromError!="function"?null:A.render();return b.flags|=1,v!==null&&he?(b.child=$l(b,v.child,null,U),b.child=$l(b,null,ke,U)):ls(v,b,ke,U),b.memoizedState=A.state,O&&Hn(b,C,!0),b.child}function Ef(v){var b=v.stateNode;b.pendingContext?Pn(v,b.pendingContext,b.pendingContext!==b.context):b.context&&Pn(v,b.context,!1),Om(v,b.containerInfo)}function P0(v,b,C,A,O){return Mh(),Lm(O),b.flags|=256,ls(v,b,C,A),b.child}var Cf={dehydrated:null,treeContext:null,retryLane:0};function Ic(v){return{baseLanes:v,cachePool:null}}function L0(v,b,C){var A=b.pendingProps,O=ts.current,U=!1,he=(b.flags&128)!==0,ke;if((ke=he)||(ke=v!==null&&v.memoizedState===null?!1:(O&2)!==0),ke?(U=!0,b.flags&=-129):(v===null||v.memoizedState!==null)&&(O|=1),Ct(ts,O&1),v===null)return Iu(b),v=b.memoizedState,v!==null&&(v=v.dehydrated,v!==null)?((b.mode&1)===0?b.lanes=1:Na(v)?b.lanes=8:b.lanes=1073741824,null):(O=A.children,v=A.fallback,U?(A=b.mode,U=b.child,O={mode:"hidden",children:O},(A&1)===0&&U!==null?(U.childLanes=0,U.pendingProps=O):U=Uf(O,A,0,null),v=zc(v,A,C,null),U.return=b,v.return=b,U.sibling=v,b.child=U,b.child.memoizedState=Ic(C),b.memoizedState=Cf,v):Da(b,O));if(O=v.memoizedState,O!==null){if(ke=O.dehydrated,ke!==null){if(he)return b.flags&256?(b.flags&=-257,Nf(v,b,C,Error(o(422)))):b.memoizedState!==null?(b.child=v.child,b.flags|=128,null):(U=A.fallback,O=b.mode,A=Uf({mode:"visible",children:A.children},O,0,null),U=zc(U,O,C,null),U.flags|=2,A.return=b,U.return=b,A.sibling=U,b.child=A,(b.mode&1)!==0&&$l(b,v.child,null,C),b.child.memoizedState=Ic(C),b.memoizedState=Cf,U);if((b.mode&1)===0)b=Nf(v,b,C,null);else if(Na(ke))b=Nf(v,b,C,Error(o(419)));else if(A=(C&v.childLanes)!==0,Xs||A){if(A=vs,A!==null){switch(C&-C){case 4:U=2;break;case 16:U=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:U=32;break;case 536870912:U=268435456;break;default:U=0}A=(U&(A.suspendedLanes|C))!==0?0:U,A!==0&&A!==O.retryLane&&(O.retryLane=A,Ci(v,A,-1))}ig(),b=Nf(v,b,C,Error(o(421)))}else Qa(ke)?(b.flags|=128,b.child=v.child,b=Bw.bind(null,v),zi(ke,b),b=null):(C=O.treeContext,nt&&(oi=Sh(ke),Vi=b,Kr=!0,oa=null,Ah=!1,C!==null&&(ia[No++]=Rl,ia[No++]=Dl,ia[No++]=gc,Rl=C.id,Dl=C.overflow,gc=b)),b=Da(b,b.pendingProps.children),b.flags|=4096);return b}return U?(A=Qm(v,b,A.children,A.fallback,C),U=b.child,O=v.child.memoizedState,U.memoizedState=O===null?Ic(C):{baseLanes:O.baseLanes|C,cachePool:null},U.childLanes=v.childLanes&~C,b.memoizedState=Cf,A):(C=If(v,b,A.children,C),b.memoizedState=null,C)}return U?(A=Qm(v,b,A.children,A.fallback,C),U=b.child,O=v.child.memoizedState,U.memoizedState=O===null?Ic(C):{baseLanes:O.baseLanes|C,cachePool:null},U.childLanes=v.childLanes&~C,b.memoizedState=Cf,A):(C=If(v,b,A.children,C),b.memoizedState=null,C)}function Da(v,b){return b=Uf({mode:"visible",children:b},v.mode,0,null),b.return=v,v.child=b}function If(v,b,C,A){var O=v.child;return v=O.sibling,C=Xl(O,{mode:"visible",children:C}),(b.mode&1)===0&&(C.lanes=A),C.return=b,C.sibling=null,v!==null&&(A=b.deletions,A===null?(b.deletions=[v],b.flags|=16):A.push(v)),b.child=C}function Qm(v,b,C,A,O){var U=b.mode;v=v.child;var he=v.sibling,ke={mode:"hidden",children:C};return(U&1)===0&&b.child!==v?(C=b.child,C.childLanes=0,C.pendingProps=ke,b.deletions=null):(C=Xl(v,ke),C.subtreeFlags=v.subtreeFlags&14680064),he!==null?A=Xl(he,A):(A=zc(A,U,O,null),A.flags|=2),A.return=b,C.return=b,C.sibling=A,b.child=C,A}function Nf(v,b,C,A){return A!==null&&Lm(A),$l(b,v.child,null,C),v=Da(b,b.pendingProps.children),v.flags|=2,b.memoizedState=null,v}function Lw(v,b,C){v.lanes|=b;var A=v.alternate;A!==null&&(A.lanes|=b),mc(v.return,b,C)}function il(v,b,C,A,O){var U=v.memoizedState;U===null?v.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:A,tail:C,tailMode:O}:(U.isBackwards=b,U.rendering=null,U.renderingStartTime=0,U.last=A,U.tail=C,U.tailMode=O)}function Nc(v,b,C){var A=b.pendingProps,O=A.revealOrder,U=A.tail;if(ls(v,b,A.children,C),A=ts.current,(A&2)!==0)A=A&1|2,b.flags|=128;else{if(v!==null&&(v.flags&128)!==0)e:for(v=b.child;v!==null;){if(v.tag===13)v.memoizedState!==null&&Lw(v,C,b);else if(v.tag===19)Lw(v,C,b);else if(v.child!==null){v.child.return=v,v=v.child;continue}if(v===b)break e;for(;v.sibling===null;){if(v.return===null||v.return===b)break e;v=v.return}v.sibling.return=v.return,v=v.sibling}A&=1}if(Ct(ts,A),(b.mode&1)===0)b.memoizedState=null;else switch(O){case"forwards":for(C=b.child,O=null;C!==null;)v=C.alternate,v!==null&&Fm(v)===null&&(O=C),C=C.sibling;C=O,C===null?(O=b.child,b.child=null):(O=C.sibling,C.sibling=null),il(b,!1,O,C,U);break;case"backwards":for(C=null,O=b.child,b.child=null;O!==null;){if(v=O.alternate,v!==null&&Fm(v)===null){b.child=O;break}v=O.sibling,O.sibling=C,C=O,O=v}il(b,!0,C,null,U);break;case"together":il(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}function so(v,b,C){if(v!==null&&(b.dependencies=v.dependencies),ol|=b.lanes,(C&b.childLanes)===0)return null;if(v!==null&&b.child!==v.child)throw Error(o(153));if(b.child!==null){for(v=b.child,C=Xl(v,v.pendingProps),b.child=C,C.return=b;v.sibling!==null;)v=v.sibling,C=C.sibling=Xl(v,v.pendingProps),C.return=b;C.sibling=null}return b.child}function eg(v,b,C){switch(b.tag){case 3:Ef(b),Mh();break;case 5:kw(b);break;case 1:kr(b.type)&&Rn(b);break;case 4:Om(b,b.stateNode.containerInfo);break;case 10:pc(b,b.type._context,b.memoizedProps.value);break;case 13:var A=b.memoizedState;if(A!==null)return A.dehydrated!==null?(Ct(ts,ts.current&1),b.flags|=128,null):(C&b.child.childLanes)!==0?L0(v,b,C):(Ct(ts,ts.current&1),v=so(v,b,C),v!==null?v.sibling:null);Ct(ts,ts.current&1);break;case 19:if(A=(C&b.childLanes)!==0,(v.flags&128)!==0){if(A)return Nc(v,b,C);b.flags|=128}var O=b.memoizedState;if(O!==null&&(O.rendering=null,O.tail=null,O.lastEffect=null),Ct(ts,ts.current),A)break;return null;case 22:case 23:return b.lanes=0,ai(v,b,C)}return so(v,b,C)}function tg(v,b){switch(w0(b),b.tag){case 1:return kr(b.type)&&Gn(),v=b.flags,v&65536?(b.flags=v&-65537|128,b):null;case 3:return $h(),kt(xn),kt(dn),wc(),v=b.flags,(v&65536)!==0&&(v&128)===0?(b.flags=v&-65537|128,b):null;case 5:return _0(b),null;case 13:if(kt(ts),v=b.memoizedState,v!==null&&v.dehydrated!==null){if(b.alternate===null)throw Error(o(340));Mh()}return v=b.flags,v&65536?(b.flags=v&-65537|128,b):null;case 19:return kt(ts),null;case 4:return $h(),null;case 10:return pf(b.type._context),null;case 22:case 23:return Ff(),null;case 24:return null;default:return null}}var Gi=!1,qs=!1,Ac=typeof WeakSet=="function"?WeakSet:Set,Et=null;function aa(v,b){var C=v.ref;if(C!==null)if(typeof C=="function")try{C(null)}catch(A){ji(v,b,A)}else C.current=null}function Bl(v,b,C){try{C()}catch(A){ji(v,b,A)}}var O0=!1;function F0(v,b){for(J(v.containerInfo),Et=b;Et!==null;)if(v=Et,b=v.child,(v.subtreeFlags&1028)!==0&&b!==null)b.return=v,Et=b;else for(;Et!==null;){v=Et;try{var C=v.alternate;if((v.flags&1024)!==0)switch(v.tag){case 0:case 11:case 15:break;case 1:if(C!==null){var A=C.memoizedProps,O=C.memoizedState,U=v.stateNode,he=U.getSnapshotBeforeUpdate(v.elementType===v.type?A:to(v.type,A),O);U.__reactInternalSnapshotBeforeUpdate=he}break;case 3:ct&&Tt(v.stateNode.containerInfo);break;case 5:case 6:case 4:case 17:break;default:throw Error(o(163))}}catch(ke){ji(v,v.return,ke)}if(b=v.sibling,b!==null){b.return=v.return,Et=b;break}Et=v.return}return C=O0,O0=!1,C}function Ul(v,b,C){var A=b.updateQueue;if(A=A!==null?A.lastEffect:null,A!==null){var O=A=A.next;do{if((O.tag&v)===v){var U=O.destroy;O.destroy=void 0,U!==void 0&&Bl(b,C,U)}O=O.next}while(O!==A)}}function li(v,b){if(b=b.updateQueue,b=b!==null?b.lastEffect:null,b!==null){var C=b=b.next;do{if((C.tag&v)===v){var A=C.create;C.destroy=A()}C=C.next}while(C!==b)}}function Hi(v){var b=v.ref;if(b!==null){var C=v.stateNode;switch(v.tag){case 5:v=q(C);break;default:v=C}typeof b=="function"?b(v):b.current=v}}function Gr(v,b,C){if(nl&&typeof nl.onCommitFiberUnmount=="function")try{nl.onCommitFiberUnmount(cf,b)}catch{}switch(b.tag){case 0:case 11:case 14:case 15:if(v=b.updateQueue,v!==null&&(v=v.lastEffect,v!==null)){var A=v=v.next;do{var O=A,U=O.destroy;O=O.tag,U!==void 0&&((O&2)!==0||(O&4)!==0)&&Bl(b,C,U),A=A.next}while(A!==v)}break;case 1:if(aa(b,C),v=b.stateNode,typeof v.componentWillUnmount=="function")try{v.props=b.memoizedProps,v.state=b.memoizedState,v.componentWillUnmount()}catch(he){ji(b,C,he)}break;case 5:aa(b,C);break;case 4:ct?U0(v,b,C):fe&&fe&&(b=b.stateNode.containerInfo,C=ln(b),ur(b,C))}}function la(v,b,C){for(var A=b;;)if(Gr(v,A,C),A.child===null||ct&&A.tag===4){if(A===b)break;for(;A.sibling===null;){if(A.return===null||A.return===b)return;A=A.return}A.sibling.return=A.return,A=A.sibling}else A.child.return=A,A=A.child}function z0(v){var b=v.alternate;b!==null&&(v.alternate=null,z0(b)),v.child=null,v.deletions=null,v.sibling=null,v.tag===5&&(b=v.stateNode,b!==null&&_t(b)),v.stateNode=null,v.return=null,v.dependencies=null,v.memoizedProps=null,v.memoizedState=null,v.pendingProps=null,v.stateNode=null,v.updateQueue=null}function B0(v){return v.tag===5||v.tag===3||v.tag===4}function ng(v){e:for(;;){for(;v.sibling===null;){if(v.return===null||B0(v.return))return null;v=v.return}for(v.sibling.return=v.return,v=v.sibling;v.tag!==5&&v.tag!==6&&v.tag!==18;){if(v.flags&2||v.child===null||v.tag===4)continue e;v.child.return=v,v=v.child}if(!(v.flags&2))return v.stateNode}}function rg(v){if(ct){e:{for(var b=v.return;b!==null;){if(B0(b))break e;b=b.return}throw Error(o(160))}var C=b;switch(C.tag){case 5:b=C.stateNode,C.flags&32&&(bn(b),C.flags&=-33),C=ng(v),Uh(v,C,b);break;case 3:case 4:b=C.stateNode.containerInfo,C=ng(v),sg(v,C,b);break;default:throw Error(o(161))}}}function sg(v,b,C){var A=v.tag;if(A===5||A===6)v=v.stateNode,b?Ft(C,v,b):rn(C,v);else if(A!==4&&(v=v.child,v!==null))for(sg(v,b,C),v=v.sibling;v!==null;)sg(v,b,C),v=v.sibling}function Uh(v,b,C){var A=v.tag;if(A===5||A===6)v=v.stateNode,b?en(C,v,b):Gt(C,v);else if(A!==4&&(v=v.child,v!==null))for(Uh(v,b,C),v=v.sibling;v!==null;)Uh(v,b,C),v=v.sibling}function U0(v,b,C){for(var A=b,O=!1,U,he;;){if(!O){O=A.return;e:for(;;){if(O===null)throw Error(o(160));switch(U=O.stateNode,O.tag){case 5:he=!1;break e;case 3:U=U.containerInfo,he=!0;break e;case 4:U=U.containerInfo,he=!0;break e}O=O.return}O=!0}if(A.tag===5||A.tag===6)la(v,A,C),he?cn(U,A.stateNode):Vt(U,A.stateNode);else if(A.tag===18)he?me(U,A.stateNode):xe(U,A.stateNode);else if(A.tag===4){if(A.child!==null){U=A.stateNode.containerInfo,he=!0,A.child.return=A,A=A.child;continue}}else if(Gr(v,A,C),A.child!==null){A.child.return=A,A=A.child;continue}if(A===b)break;for(;A.sibling===null;){if(A.return===null||A.return===b)return;A=A.return,A.tag===4&&(O=!1)}A.sibling.return=A.return,A=A.sibling}}function Ru(v,b){if(ct){switch(b.tag){case 0:case 11:case 14:case 15:Ul(3,b,b.return),li(3,b),Ul(5,b,b.return);return;case 1:return;case 5:var C=b.stateNode;if(C!=null){var A=b.memoizedProps;v=v!==null?v.memoizedProps:A;var O=b.type,U=b.updateQueue;b.updateQueue=null,U!==null&&An(C,U,O,v,A,b)}return;case 6:if(b.stateNode===null)throw Error(o(162));C=b.memoizedProps,ht(b.stateNode,v!==null?v.memoizedProps:C,C);return;case 3:nt&&v!==null&&v.memoizedState.isDehydrated&&ae(b.stateNode.containerInfo);return;case 12:return;case 13:Vh(b);return;case 19:Vh(b);return;case 17:return}throw Error(o(163))}switch(b.tag){case 0:case 11:case 14:case 15:Ul(3,b,b.return),li(3,b),Ul(5,b,b.return);return;case 12:return;case 13:Vh(b);return;case 19:Vh(b);return;case 3:nt&&v!==null&&v.memoizedState.isDehydrated&&ae(b.stateNode.containerInfo);break;case 22:case 23:return}e:if(fe){switch(b.tag){case 1:case 5:case 6:break e;case 3:case 4:b=b.stateNode,ur(b.containerInfo,b.pendingChildren);break e}throw Error(o(163))}}function Vh(v){var b=v.updateQueue;if(b!==null){v.updateQueue=null;var C=v.stateNode;C===null&&(C=v.stateNode=new Ac),b.forEach(function(A){var O=Uw.bind(null,v,A);C.has(A)||(C.add(A),A.then(O,O))})}}function rC(v,b){for(Et=b;Et!==null;){b=Et;var C=b.deletions;if(C!==null)for(var A=0;A<C.length;A++){var O=C[A];try{var U=v;ct?U0(U,O,b):la(U,O,b);var he=O.alternate;he!==null&&(he.return=null),O.return=null}catch(Zt){ji(O,b,Zt)}}if(C=b.child,(b.subtreeFlags&12854)!==0&&C!==null)C.return=b,Et=C;else for(;Et!==null;){b=Et;try{var ke=b.flags;if(ke&32&&ct&&bn(b.stateNode),ke&512){var tt=b.alternate;if(tt!==null){var wt=tt.ref;wt!==null&&(typeof wt=="function"?wt(null):wt.current=null)}}if(ke&8192)switch(b.tag){case 13:if(b.memoizedState!==null){var Ht=b.alternate;(Ht===null||Ht.memoizedState===null)&&(Pf=$s())}break;case 22:var Cn=b.memoizedState!==null,un=b.alternate,On=un!==null&&un.memoizedState!==null;if(C=b,ct){e:if(A=C,O=Cn,U=null,ct)for(var zt=A;;){if(zt.tag===5){if(U===null){U=zt;var hi=zt.stateNode;O?Mn(hi):Ge(zt.stateNode,zt.memoizedProps)}}else if(zt.tag===6){if(U===null){var Lo=zt.stateNode;O?Tn(Lo):_e(Lo,zt.memoizedProps)}}else if((zt.tag!==22&&zt.tag!==23||zt.memoizedState===null||zt===A)&&zt.child!==null){zt.child.return=zt,zt=zt.child;continue}if(zt===A)break;for(;zt.sibling===null;){if(zt.return===null||zt.return===A)break e;U===zt&&(U=null),zt=zt.return}U===zt&&(U=null),zt.sibling.return=zt.return,zt=zt.sibling}}if(Cn&&!On&&(C.mode&1)!==0){Et=C;for(var Ve=C.child;Ve!==null;){for(C=Et=Ve;Et!==null;){A=Et;var De=A.child;switch(A.tag){case 0:case 11:case 14:case 15:Ul(4,A,A.return);break;case 1:aa(A,A.return);var Ze=A.stateNode;if(typeof Ze.componentWillUnmount=="function"){var Pt=A.return;try{Ze.props=A.memoizedProps,Ze.state=A.memoizedState,Ze.componentWillUnmount()}catch(Zt){ji(A,Pt,Zt)}}break;case 5:aa(A,A.return);break;case 22:if(A.memoizedState!==null){W0(C);continue}}De!==null?(De.return=A,Et=De):W0(C)}Ve=Ve.sibling}}}switch(ke&4102){case 2:rg(b),b.flags&=-3;break;case 6:rg(b),b.flags&=-3,Ru(b.alternate,b);break;case 4096:b.flags&=-4097;break;case 4100:b.flags&=-4097,Ru(b.alternate,b);break;case 4:Ru(b.alternate,b)}}catch(Zt){ji(b,b.return,Zt)}if(C=b.sibling,C!==null){C.return=b.return,Et=C;break}Et=b.return}}}function Af(v,b,C){Et=v,Mf(v)}function Mf(v,b,C){for(var A=(v.mode&1)!==0;Et!==null;){var O=Et,U=O.child;if(O.tag===22&&A){var he=O.memoizedState!==null||Gi;if(!he){var ke=O.alternate,tt=ke!==null&&ke.memoizedState!==null||qs;ke=Gi;var wt=qs;if(Gi=he,(qs=tt)&&!wt)for(Et=O;Et!==null;)he=Et,tt=he.child,he.tag===22&&he.memoizedState!==null?Mc(O):tt!==null?(tt.return=he,Et=tt):Mc(O);for(;U!==null;)Et=U,Mf(U),U=U.sibling;Et=O,Gi=ke,qs=wt}V0(v)}else(O.subtreeFlags&8772)!==0&&U!==null?(U.return=O,Et=U):V0(v)}}function V0(v){for(;Et!==null;){var b=Et;if((b.flags&8772)!==0){var C=b.alternate;try{if((b.flags&8772)!==0)switch(b.tag){case 0:case 11:case 15:qs||li(5,b);break;case 1:var A=b.stateNode;if(b.flags&4&&!qs)if(C===null)A.componentDidMount();else{var O=b.elementType===b.type?C.memoizedProps:to(b.type,C.memoizedProps);A.componentDidUpdate(O,C.memoizedState,A.__reactInternalSnapshotBeforeUpdate)}var U=b.updateQueue;U!==null&&_w(b,U,A);break;case 3:var he=b.updateQueue;if(he!==null){if(C=null,b.child!==null)switch(b.child.tag){case 5:C=q(b.child.stateNode);break;case 1:C=b.child.stateNode}_w(b,he,C)}break;case 5:var ke=b.stateNode;C===null&&b.flags&4&&Nn(ke,b.type,b.memoizedProps,b);break;case 6:break;case 4:break;case 12:break;case 13:if(nt&&b.memoizedState===null){var tt=b.alternate;if(tt!==null){var wt=tt.memoizedState;if(wt!==null){var Ht=wt.dehydrated;Ht!==null&&ue(Ht)}}}break;case 19:case 17:case 21:case 22:case 23:break;default:throw Error(o(163))}qs||b.flags&512&&Hi(b)}catch(Cn){ji(b,b.return,Cn)}}if(b===v){Et=null;break}if(C=b.sibling,C!==null){C.return=b.return,Et=C;break}Et=b.return}}function W0(v){for(;Et!==null;){var b=Et;if(b===v){Et=null;break}var C=b.sibling;if(C!==null){C.return=b.return,Et=C;break}Et=b.return}}function Mc(v){for(;Et!==null;){var b=Et;try{switch(b.tag){case 0:case 11:case 15:var C=b.return;try{li(4,b)}catch(tt){ji(b,C,tt)}break;case 1:var A=b.stateNode;if(typeof A.componentDidMount=="function"){var O=b.return;try{A.componentDidMount()}catch(tt){ji(b,O,tt)}}var U=b.return;try{Hi(b)}catch(tt){ji(b,U,tt)}break;case 5:var he=b.return;try{Hi(b)}catch(tt){ji(b,he,tt)}}}catch(tt){ji(b,b.return,tt)}if(b===v){Et=null;break}var ke=b.sibling;if(ke!==null){ke.return=b.return,Et=ke;break}Et=b.return}}var kf=0,kc=1,Rc=2,Vl=3,Wh=4;if(typeof Symbol=="function"&&Symbol.for){var Dc=Symbol.for;kf=Dc("selector.component"),kc=Dc("selector.has_pseudo_class"),Rc=Dc("selector.role"),Vl=Dc("selector.test_id"),Wh=Dc("selector.text")}function Rf(v){var b=Xe(v);if(b!=null){if(typeof b.memoizedProps["data-testname"]!="string")throw Error(o(364));return b}if(v=Le(v),v===null)throw Error(o(362));return v.stateNode.current}function Df(v,b){switch(b.$$typeof){case kf:if(v.type===b.value)return!0;break;case kc:e:{b=b.value,v=[v,0];for(var C=0;C<v.length;){var A=v[C++],O=v[C++],U=b[O];if(A.tag!==5||!ot(A)){for(;U!=null&&Df(A,U);)O++,U=b[O];if(O===b.length){b=!0;break e}else for(A=A.child;A!==null;)v.push(A,O),A=A.sibling}}b=!1}return b;case Rc:if(v.tag===5&&$t(v.stateNode,b.value))return!0;break;case Wh:if((v.tag===5||v.tag===6)&&(v=ut(v),v!==null&&0<=v.indexOf(b.value)))return!0;break;case Vl:if(v.tag===5&&(v=v.memoizedProps["data-testname"],typeof v=="string"&&v.toLowerCase()===b.value.toLowerCase()))return!0;break;default:throw Error(o(365))}return!1}function Du(v){switch(v.$$typeof){case kf:return"<"+($(v.value)||"Unknown")+">";case kc:return":has("+(Du(v)||"")+")";case Rc:return'[role="'+v.value+'"]';case Wh:return'"'+v.value+'"';case Vl:return'[data-testname="'+v.value+'"]';default:throw Error(o(365))}}function Ro(v,b){var C=[];v=[v,0];for(var A=0;A<v.length;){var O=v[A++],U=v[A++],he=b[U];if(O.tag!==5||!ot(O)){for(;he!=null&&Df(O,he);)U++,he=b[U];if(U===b.length)C.push(O);else for(O=O.child;O!==null;)v.push(O,U),O=O.sibling}}return C}function Wl(v,b){if(!ee)throw Error(o(363));v=Rf(v),v=Ro(v,b),b=[],v=Array.from(v);for(var C=0;C<v.length;){var A=v[C++];if(A.tag===5)ot(A)||b.push(A.stateNode);else for(A=A.child;A!==null;)v.push(A),A=A.sibling}return b}var G0=Math.ceil,$f=a.ReactCurrentDispatcher,$a=a.ReactCurrentOwner,Ir=a.ReactCurrentBatchConfig,Ln=0,vs=null,Nr=null,Yr=0,Ei=0,$c=vn(0),us=0,Gh=null,ol=0,Do=0,Pc=0,Gl=null,bs=null,Pf=0,$u=1/0;function Lc(){$u=$s()+500}var Hh=!1,Hr=null,Pa=null,jh=!1,al=null,Oc=0,Fc=0,Hl=null,Br=-1,cs=0;function hr(){return(Ln&6)!==0?$s():Br!==-1?Br:Br=$s()}function La(v){return(v.mode&1)===0?1:(Ln&2)!==0&&Yr!==0?Yr&-Yr:Sw.transition!==null?(cs===0&&(v=_h,_h<<=1,(_h&4194240)===0&&(_h=64),cs=v),cs):(v=Bn,v!==0?v:He())}function Ci(v,b,C){if(50<Fc)throw Fc=0,Hl=null,Error(o(185));var A=Pu(v,b);return A===null?null:(cc(A,b,C),((Ln&2)===0||A!==vs)&&(A===vs&&((Ln&2)===0&&(Do|=b),us===4&&ci(A,Yr)),io(A,C),b===1&&Ln===0&&(v.mode&1)===0&&(Lc(),Em&&na())),A)}function Pu(v,b){v.lanes|=b;var C=v.alternate;for(C!==null&&(C.lanes|=b),C=v,v=v.return;v!==null;)v.childLanes|=b,C=v.alternate,C!==null&&(C.childLanes|=b),C=v,v=v.return;return C.tag===3?C.stateNode:null}function io(v,b){var C=v.callbackNode;bw(v,b);var A=uf(v,v===vs?Yr:0);if(A===0)C!==null&&Eh(C),v.callbackNode=null,v.callbackPriority=0;else if(b=A&-A,v.callbackPriority!==b){if(C!=null&&Eh(C),b===1)v.tag===0?Im($o.bind(null,v)):Cm($o.bind(null,v)),mt?oe(function(){Ln===0&&na()}):hc(dc,na),C=null;else{switch(Al(A)){case 1:C=dc;break;case 4:C=eC;break;case 16:C=_m;break;case 536870912:C=Tm;break;default:C=_m}C=og(C,ui.bind(null,v))}v.callbackPriority=b,v.callbackNode=C}}function ui(v,b){if(Br=-1,cs=0,(Ln&6)!==0)throw Error(o(327));var C=v.callbackNode;if(ll()&&v.callbackNode!==C)return null;var A=uf(v,v===vs?Yr:0);if(A===0)return null;if((A&30)!==0||(A&v.expiredLanes)!==0||b)b=zf(v,A);else{b=A;var O=Ln;Ln|=2;var U=X0();(vs!==v||Yr!==b)&&(Lc(),jl(v,b));do try{Fw();break}catch(ke){j0(v,ke)}while(!0);Ui(),$f.current=U,Ln=O,Nr!==null?b=0:(vs=null,Yr=0,b=us)}if(b!==0){if(b===2&&(O=wm(v),O!==0&&(A=O,b=Lf(v,O))),b===1)throw C=Gh,jl(v,0),ci(v,A),io(v,$s()),C;if(b===6)ci(v,A);else{if(O=v.current.alternate,(A&30)===0&&!H0(O)&&(b=zf(v,A),b===2&&(U=wm(v),U!==0&&(A=U,b=Lf(v,U))),b===1))throw C=Gh,jl(v,0),ci(v,A),io(v,$s()),C;switch(v.finishedWork=O,v.finishedLanes=A,b){case 0:case 1:throw Error(o(345));case 2:Oa(v,bs);break;case 3:if(ci(v,A),(A&130023424)===A&&(b=Pf+500-$s(),10<b)){if(uf(v,0)!==0)break;if(O=v.suspendedLanes,(O&A)!==A){hr(),v.pingedLanes|=v.suspendedLanes&O;break}v.timeoutHandle=Re(Oa.bind(null,v,bs),b);break}Oa(v,bs);break;case 4:if(ci(v,A),(A&4194240)===A)break;for(b=v.eventTimes,O=-1;0<A;){var he=31-Rr(A);U=1<<he,he=b[he],he>O&&(O=he),A&=~U}if(A=O,A=$s()-A,A=(120>A?120:480>A?480:1080>A?1080:1920>A?1920:3e3>A?3e3:4320>A?4320:1960*G0(A/1960))-A,10<A){v.timeoutHandle=Re(Oa.bind(null,v,bs),A);break}Oa(v,bs);break;case 5:Oa(v,bs);break;default:throw Error(o(329))}}}return io(v,$s()),v.callbackNode===C?ui.bind(null,v):null}function Lf(v,b){var C=Gl;return v.current.memoizedState.isDehydrated&&(jl(v,b).flags|=256),v=zf(v,b),v!==2&&(b=bs,bs=C,b!==null&&Of(b)),v}function Of(v){bs===null?bs=v:bs.push.apply(bs,v)}function H0(v){for(var b=v;;){if(b.flags&16384){var C=b.updateQueue;if(C!==null&&(C=C.stores,C!==null))for(var A=0;A<C.length;A++){var O=C[A],U=O.getSnapshot;O=O.value;try{if(!Bi(U(),O))return!1}catch{return!1}}}if(C=b.child,b.subtreeFlags&16384&&C!==null)C.return=b,b=C;else{if(b===v)break;for(;b.sibling===null;){if(b.return===null||b.return===v)return!0;b=b.return}b.sibling.return=b.return,b=b.sibling}}return!0}function ci(v,b){for(b&=~Pc,b&=~Do,v.suspendedLanes|=b,v.pingedLanes&=~b,v=v.expirationTimes;0<b;){var C=31-Rr(b),A=1<<C;v[C]=-1,b&=~A}}function $o(v){if((Ln&6)!==0)throw Error(o(327));ll();var b=uf(v,0);if((b&1)===0)return io(v,$s()),null;var C=zf(v,b);if(v.tag!==0&&C===2){var A=wm(v);A!==0&&(b=A,C=Lf(v,A))}if(C===1)throw C=Gh,jl(v,0),ci(v,b),io(v,$s()),C;if(C===6)throw Error(o(345));return v.finishedWork=v.current.alternate,v.finishedLanes=b,Oa(v,bs),io(v,$s()),null}function Xh(v){al!==null&&al.tag===0&&(Ln&6)===0&&ll();var b=Ln;Ln|=1;var C=Ir.transition,A=Bn;try{if(Ir.transition=null,Bn=1,v)return v()}finally{Bn=A,Ir.transition=C,Ln=b,(Ln&6)===0&&na()}}function Ff(){Ei=$c.current,kt($c)}function jl(v,b){v.finishedWork=null,v.finishedLanes=0;var C=v.timeoutHandle;if(C!==Ke&&(v.timeoutHandle=Ke,Oe(C)),Nr!==null)for(C=Nr.return;C!==null;){var A=C;switch(w0(A),A.tag){case 1:A=A.type.childContextTypes,A!=null&&Gn();break;case 3:$h(),kt(xn),kt(dn),wc();break;case 5:_0(A);break;case 4:$h();break;case 13:kt(ts);break;case 19:kt(ts);break;case 10:pf(A.type._context);break;case 22:case 23:Ff()}C=C.return}if(vs=v,Nr=v=Xl(v.current,null),Yr=Ei=b,us=0,Gh=null,Pc=Do=ol=0,bs=Gl=null,ra!==null){for(b=0;b<ra.length;b++)if(C=ra[b],A=C.interleaved,A!==null){C.interleaved=null;var O=A.next,U=C.pending;if(U!==null){var he=U.next;U.next=O,A.next=he}C.pending=A}ra=null}return v}function j0(v,b){do{var C=Nr;try{if(Ui(),gf.current=zh,zm){for(var A=ns.memoizedState;A!==null;){var O=A.queue;O!==null&&(O.pending=null),A=A.next}zm=!1}if(bc=0,Hs=Gs=ns=null,rl=!1,Sc=0,$a.current=null,C===null||C.return===null){us=1,Gh=b,Nr=null;break}e:{var U=v,he=C.return,ke=C,tt=b;if(b=Yr,ke.flags|=32768,tt!==null&&typeof tt=="object"&&typeof tt.then=="function"){var wt=tt,Ht=ke,Cn=Ht.tag;if((Ht.mode&1)===0&&(Cn===0||Cn===11||Cn===15)){var un=Ht.alternate;un?(Ht.updateQueue=un.updateQueue,Ht.memoizedState=un.memoizedState,Ht.lanes=un.lanes):(Ht.updateQueue=null,Ht.memoizedState=null)}var On=D0(he);if(On!==null){On.flags&=-257,Tc(On,he,ke,U,b),On.mode&1&&Ll(U,wt,b),b=On,tt=wt;var zt=b.updateQueue;if(zt===null){var hi=new Set;hi.add(tt),b.updateQueue=hi}else zt.add(tt);break e}else{if((b&1)===0){Ll(U,wt,b),ig();break e}tt=Error(o(426))}}else if(Kr&&ke.mode&1){var Lo=D0(he);if(Lo!==null){(Lo.flags&65536)===0&&(Lo.flags|=256),Tc(Lo,he,ke,U,b),Lm(tt);break e}}U=tt,us!==4&&(us=2),Gl===null?Gl=[U]:Gl.push(U),tt=R0(tt,ke),ke=he;do{switch(ke.tag){case 3:ke.flags|=65536,b&=-b,ke.lanes|=b;var Ve=Pw(ke,tt,b);Mm(ke,Ve);break e;case 1:U=tt;var De=ke.type,Ze=ke.stateNode;if((ke.flags&128)===0&&(typeof De.getDerivedStateFromError=="function"||Ze!==null&&typeof Ze.componentDidCatch=="function"&&(Pa===null||!Pa.has(Ze)))){ke.flags|=65536,b&=-b,ke.lanes|=b;var Pt=Km(ke,U,b);Mm(ke,Pt);break e}}ke=ke.return}while(ke!==null)}K0(C)}catch(Zt){b=Zt,Nr===C&&C!==null&&(Nr=C=C.return);continue}break}while(!0)}function X0(){var v=$f.current;return $f.current=zh,v===null?zh:v}function ig(){(us===0||us===3||us===2)&&(us=4),vs===null||(ol&268435455)===0&&(Do&268435455)===0||ci(vs,Yr)}function zf(v,b){var C=Ln;Ln|=2;var A=X0();vs===v&&Yr===b||jl(v,b);do try{Ow();break}catch(O){j0(v,O)}while(!0);if(Ui(),Ln=C,$f.current=A,Nr!==null)throw Error(o(261));return vs=null,Yr=0,us}function Ow(){for(;Nr!==null;)q0(Nr)}function Fw(){for(;Nr!==null&&!Tu();)q0(Nr)}function q0(v){var b=J0(v.alternate,v,Ei);v.memoizedProps=v.pendingProps,b===null?K0(v):Nr=b,$a.current=null}function K0(v){var b=v;do{var C=b.alternate;if(v=b.return,(b.flags&32768)===0){if(C=Jm(C,b,Ei),C!==null){Nr=C;return}}else{if(C=tg(C,b),C!==null){C.flags&=32767,Nr=C;return}if(v!==null)v.flags|=32768,v.subtreeFlags=0,v.deletions=null;else{us=6,Nr=null;return}}if(b=b.sibling,b!==null){Nr=b;return}Nr=b=v}while(b!==null);us===0&&(us=5)}function Oa(v,b){var C=Bn,A=Ir.transition;try{Ir.transition=null,Bn=1,zw(v,b,C)}finally{Ir.transition=A,Bn=C}return null}function zw(v,b,C){do ll();while(al!==null);if((Ln&6)!==0)throw Error(o(327));var A=v.finishedWork,O=v.finishedLanes;if(A===null)return null;if(v.finishedWork=null,v.finishedLanes=0,A===v.current)throw Error(o(177));v.callbackNode=null,v.callbackPriority=0;var U=A.lanes|A.childLanes;if(Sm(v,U),v===vs&&(Nr=vs=null,Yr=0),(A.subtreeFlags&2064)===0&&(A.flags&2064)===0||jh||(jh=!0,og(_m,function(){return ll(),null})),U=(A.flags&15990)!==0,(A.subtreeFlags&15990)!==0||U){U=Ir.transition,Ir.transition=null;var he=Bn;Bn=1;var ke=Ln;Ln|=4,$a.current=null,F0(v,A),rC(v,A),K(v.containerInfo),v.current=A,Af(A),QE(),Ln=ke,Bn=he,Ir.transition=U}else v.current=A;if(jh&&(jh=!1,al=v,Oc=O),U=v.pendingLanes,U===0&&(Pa=null),hf(A.stateNode),io(v,$s()),b!==null)for(C=v.onRecoverableError,A=0;A<b.length;A++)C(b[A]);if(Hh)throw Hh=!1,v=Hr,Hr=null,v;return(Oc&1)!==0&&v.tag!==0&&ll(),U=v.pendingLanes,(U&1)!==0?v===Hl?Fc++:(Fc=0,Hl=v):Fc=0,na(),null}function ll(){if(al!==null){var v=Al(Oc),b=Ir.transition,C=Bn;try{if(Ir.transition=null,Bn=16>v?16:v,al===null)var A=!1;else{if(v=al,al=null,Oc=0,(Ln&6)!==0)throw Error(o(331));var O=Ln;for(Ln|=4,Et=v.current;Et!==null;){var U=Et,he=U.child;if((Et.flags&16)!==0){var ke=U.deletions;if(ke!==null){for(var tt=0;tt<ke.length;tt++){var wt=ke[tt];for(Et=wt;Et!==null;){var Ht=Et;switch(Ht.tag){case 0:case 11:case 15:Ul(8,Ht,U)}var Cn=Ht.child;if(Cn!==null)Cn.return=Ht,Et=Cn;else for(;Et!==null;){Ht=Et;var un=Ht.sibling,On=Ht.return;if(z0(Ht),Ht===wt){Et=null;break}if(un!==null){un.return=On,Et=un;break}Et=On}}}var zt=U.alternate;if(zt!==null){var hi=zt.child;if(hi!==null){zt.child=null;do{var Lo=hi.sibling;hi.sibling=null,hi=Lo}while(hi!==null)}}Et=U}}if((U.subtreeFlags&2064)!==0&&he!==null)he.return=U,Et=he;else e:for(;Et!==null;){if(U=Et,(U.flags&2048)!==0)switch(U.tag){case 0:case 11:case 15:Ul(9,U,U.return)}var Ve=U.sibling;if(Ve!==null){Ve.return=U.return,Et=Ve;break e}Et=U.return}}var De=v.current;for(Et=De;Et!==null;){he=Et;var Ze=he.child;if((he.subtreeFlags&2064)!==0&&Ze!==null)Ze.return=he,Et=Ze;else e:for(he=De;Et!==null;){if(ke=Et,(ke.flags&2048)!==0)try{switch(ke.tag){case 0:case 11:case 15:li(9,ke)}}catch(Zt){ji(ke,ke.return,Zt)}if(ke===he){Et=null;break e}var Pt=ke.sibling;if(Pt!==null){Pt.return=ke.return,Et=Pt;break e}Et=ke.return}}if(Ln=O,na(),nl&&typeof nl.onPostCommitFiberRoot=="function")try{nl.onPostCommitFiberRoot(cf,v)}catch{}A=!0}return A}finally{Bn=C,Ir.transition=b}}return!1}function Bf(v,b,C){b=R0(C,b),b=Pw(v,b,1),Eu(v,b),b=hr(),v=Pu(v,1),v!==null&&(cc(v,1,b),io(v,b))}function ji(v,b,C){if(v.tag===3)Bf(v,v,C);else for(;b!==null;){if(b.tag===3){Bf(b,v,C);break}else if(b.tag===1){var A=b.stateNode;if(typeof b.type.getDerivedStateFromError=="function"||typeof A.componentDidCatch=="function"&&(Pa===null||!Pa.has(A))){v=R0(C,v),v=Km(b,v,1),Eu(b,v),v=hr(),b=Pu(b,1),b!==null&&(cc(b,1,v),io(b,v));break}}b=b.return}}function Y0(v,b,C){var A=v.pingCache;A!==null&&A.delete(b),b=hr(),v.pingedLanes|=v.suspendedLanes&C,vs===v&&(Yr&C)===C&&(us===4||us===3&&(Yr&130023424)===Yr&&500>$s()-Pf?jl(v,0):Pc|=C),io(v,b)}function Z0(v,b){b===0&&((v.mode&1)===0?b=1:(b=cr,cr<<=1,(cr&130023424)===0&&(cr=4194304)));var C=hr();v=Pu(v,b),v!==null&&(cc(v,b,C),io(v,C))}function Bw(v){var b=v.memoizedState,C=0;b!==null&&(C=b.retryLane),Z0(v,C)}function Uw(v,b){var C=0;switch(v.tag){case 13:var A=v.stateNode,O=v.memoizedState;O!==null&&(C=O.retryLane);break;case 19:A=v.stateNode;break;default:throw Error(o(314))}A!==null&&A.delete(b),Z0(v,C)}var J0;J0=function(v,b,C){if(v!==null)if(v.memoizedProps!==b.pendingProps||xn.current)Xs=!0;else{if((v.lanes&C)===0&&(b.flags&128)===0)return Xs=!1,eg(v,b,C);Xs=(v.flags&131072)!==0}else Xs=!1,Kr&&(b.flags&1048576)!==0&&Iw(b,$m,b.index);switch(b.lanes=0,b.tag){case 2:var A=b.type;v!==null&&(v.alternate=null,b.alternate=null,b.flags|=2),v=b.pendingProps;var O=Wr(b,dn.current);Ch(b,C),O=Ph(null,b,A,v,O,C);var U=Au();return b.flags|=1,typeof O=="object"&&O!==null&&typeof O.render=="function"&&O.$$typeof===void 0?(b.tag=1,b.memoizedState=null,b.updateQueue=null,kr(A)?(U=!0,Rn(b)):U=!1,b.memoizedState=O.state!==null&&O.state!==void 0?O.state:null,Ih(b),O.updater=Rm,b.stateNode=O,O._reactInternals=b,v0(b,A,v,C),b=Ti(null,b,A,!0,U,C)):(b.tag=0,Kr&&U&&x0(b),ls(null,b,O,C),b=b.child),b;case 16:A=b.elementType;e:{switch(v!==null&&(v.alternate=null,b.alternate=null,b.flags|=2),v=b.pendingProps,O=A._init,A=O(A._payload),b.type=A,O=b.tag=sC(A),v=to(A,v),O){case 0:b=zl(null,b,A,v,C);break e;case 1:b=Cc(null,b,A,v,C);break e;case 11:b=zr(null,b,A,v,C);break e;case 14:b=Dr(null,b,A,to(A.type,v),C);break e}throw Error(o(306,A,""))}return b;case 0:return A=b.type,O=b.pendingProps,O=b.elementType===A?O:to(A,O),zl(v,b,A,O,C);case 1:return A=b.type,O=b.pendingProps,O=b.elementType===A?O:to(A,O),Cc(v,b,A,O,C);case 3:e:{if(Ef(b),v===null)throw Error(o(387));A=b.pendingProps,U=b.memoizedState,O=U.element,m0(v,b),km(b,A,null,C);var he=b.memoizedState;if(A=he.element,nt&&U.isDehydrated)if(U={element:A,isDehydrated:!1,cache:he.cache,transitions:he.transitions},b.updateQueue.baseState=U,b.memoizedState=U,b.flags&256){O=Error(o(423)),b=P0(v,b,A,C,O);break e}else if(A!==O){O=Error(o(424)),b=P0(v,b,A,C,O);break e}else for(nt&&(oi=uc(b.stateNode.containerInfo),Vi=b,Kr=!0,oa=null,Ah=!1),C=Mw(b,null,A,C),b.child=C;C;)C.flags=C.flags&-3|4096,C=C.sibling;else{if(Mh(),A===O){b=so(v,b,C);break e}ls(v,b,A,C)}b=b.child}return b;case 5:return kw(b),v===null&&Iu(b),A=b.type,O=b.pendingProps,U=v!==null?v.memoizedProps:null,he=O.children,ye(A,O)?he=null:U!==null&&ye(A,U)&&(b.flags|=32),Wi(v,b),ls(v,b,he,C),b.child;case 6:return v===null&&Iu(b),null;case 13:return L0(v,b,C);case 4:return Om(b,b.stateNode.containerInfo),A=b.pendingProps,v===null?b.child=$l(b,null,A,C):ls(v,b,A,C),b.child;case 11:return A=b.type,O=b.pendingProps,O=b.elementType===A?O:to(A,O),zr(v,b,A,O,C);case 7:return ls(v,b,b.pendingProps,C),b.child;case 8:return ls(v,b,b.pendingProps.children,C),b.child;case 12:return ls(v,b,b.pendingProps.children,C),b.child;case 10:e:{if(A=b.type._context,O=b.pendingProps,U=b.memoizedProps,he=O.value,pc(b,A,he),U!==null)if(Bi(U.value,he)){if(U.children===O.children&&!xn.current){b=so(v,b,C);break e}}else for(U=b.child,U!==null&&(U.return=b);U!==null;){var ke=U.dependencies;if(ke!==null){he=U.child;for(var tt=ke.firstContext;tt!==null;){if(tt.context===A){if(U.tag===1){tt=kl(-1,C&-C),tt.tag=2;var wt=U.updateQueue;if(wt!==null){wt=wt.shared;var Ht=wt.pending;Ht===null?tt.next=tt:(tt.next=Ht.next,Ht.next=tt),wt.pending=tt}}U.lanes|=C,tt=U.alternate,tt!==null&&(tt.lanes|=C),mc(U.return,C,b),ke.lanes|=C;break}tt=tt.next}}else if(U.tag===10)he=U.type===b.type?null:U.child;else if(U.tag===18){if(he=U.return,he===null)throw Error(o(341));he.lanes|=C,ke=he.alternate,ke!==null&&(ke.lanes|=C),mc(he,C,b),he=U.sibling}else he=U.child;if(he!==null)he.return=U;else for(he=U;he!==null;){if(he===b){he=null;break}if(U=he.sibling,U!==null){U.return=he.return,he=U;break}he=he.return}U=he}ls(v,b,O.children,C),b=b.child}return b;case 9:return O=b.type,A=b.pendingProps.children,Ch(b,C),O=no(O),A=A(O),b.flags|=1,ls(v,b,A,C),b.child;case 14:return A=b.type,O=to(A,b.pendingProps),O=to(A.type,O),Dr(v,b,A,O,C);case 15:return Fl(v,b,b.type,b.pendingProps,C);case 17:return A=b.type,O=b.pendingProps,O=b.elementType===A?O:to(A,O),v!==null&&(v.alternate=null,b.alternate=null,b.flags|=2),b.tag=1,kr(A)?(v=!0,Rn(b)):v=!1,Ch(b,C),Ew(b,A,O),v0(b,A,O,C),Ti(null,b,A,!0,v,C);case 19:return Nc(v,b,C);case 22:return ai(v,b,C)}throw Error(o(156,b.tag))};function og(v,b){return hc(v,b)}function Vw(v,b,C,A){this.tag=v,this.key=C,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=b,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=A,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Po(v,b,C,A){return new Vw(v,b,C,A)}function ag(v){return v=v.prototype,!(!v||!v.isReactComponent)}function sC(v){if(typeof v=="function")return ag(v)?1:0;if(v!=null){if(v=v.$$typeof,v===w)return 11;if(v===_)return 14}return 2}function Xl(v,b){var C=v.alternate;return C===null?(C=Po(v.tag,b,v.key,v.mode),C.elementType=v.elementType,C.type=v.type,C.stateNode=v.stateNode,C.alternate=v,v.alternate=C):(C.pendingProps=b,C.type=v.type,C.flags=0,C.subtreeFlags=0,C.deletions=null),C.flags=v.flags&14680064,C.childLanes=v.childLanes,C.lanes=v.lanes,C.child=v.child,C.memoizedProps=v.memoizedProps,C.memoizedState=v.memoizedState,C.updateQueue=v.updateQueue,b=v.dependencies,C.dependencies=b===null?null:{lanes:b.lanes,firstContext:b.firstContext},C.sibling=v.sibling,C.index=v.index,C.ref=v.ref,C}function lg(v,b,C,A,O,U){var he=2;if(A=v,typeof v=="function")ag(v)&&(he=1);else if(typeof v=="string")he=5;else e:switch(v){case c:return zc(C.children,O,U,b);case h:he=8,O|=8;break;case d:return v=Po(12,C,b,O|2),v.elementType=d,v.lanes=U,v;case y:return v=Po(13,C,b,O),v.elementType=y,v.lanes=U,v;case x:return v=Po(19,C,b,O),v.elementType=x,v.lanes=U,v;case E:return Uf(C,O,U,b);default:if(typeof v=="object"&&v!==null)switch(v.$$typeof){case p:he=10;break e;case g:he=9;break e;case w:he=11;break e;case _:he=14;break e;case T:he=16,A=null;break e}throw Error(o(130,v==null?v:typeof v,""))}return b=Po(he,C,b,O),b.elementType=v,b.type=A,b.lanes=U,b}function zc(v,b,C,A){return v=Po(7,v,A,b),v.lanes=C,v}function Uf(v,b,C,A){return v=Po(22,v,A,b),v.elementType=E,v.lanes=C,v.stateNode={},v}function ug(v,b,C){return v=Po(6,v,null,b),v.lanes=C,v}function cg(v,b,C){return b=Po(4,v.children!==null?v.children:[],v.key,b),b.lanes=C,b.stateNode={containerInfo:v.containerInfo,pendingChildren:null,implementation:v.implementation},b}function hg(v,b,C,A,O){this.tag=b,this.containerInfo=v,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=Ke,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=bm(0),this.expirationTimes=bm(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=bm(0),this.identifierPrefix=A,this.onRecoverableError=O,nt&&(this.mutableSourceEagerHydrationData=null)}function Ww(v,b,C,A,O,U,he,ke,tt){return v=new hg(v,b,C,ke,tt),b===1?(b=1,U===!0&&(b|=8)):b=0,U=Po(3,null,null,b),v.current=U,U.stateNode=v,U.memoizedState={element:A,isDehydrated:C,cache:null,transitions:null},Ih(U),v}function Gw(v){if(!v)return mn;v=v._reactInternals;e:{if(k(v)!==v||v.tag!==1)throw Error(o(170));var b=v;do{switch(b.tag){case 3:b=b.stateNode.context;break e;case 1:if(kr(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break e}}b=b.return}while(b!==null);throw Error(o(171))}if(v.tag===1){var C=v.type;if(kr(C))return es(v,C,b)}return b}function Hw(v){var b=v._reactInternals;if(b===void 0)throw typeof v.render=="function"?Error(o(188)):(v=Object.keys(v).join(","),Error(o(268,v)));return v=B(b),v===null?null:v.stateNode}function ua(v,b){if(v=v.memoizedState,v!==null&&v.dehydrated!==null){var C=v.retryLane;v.retryLane=C!==0&&C<b?C:b}}function Vf(v,b){ua(v,b),(v=v.alternate)&&ua(v,b)}function dg(v){return v=B(v),v===null?null:v.stateNode}function jw(){return null}return t.attemptContinuousHydration=function(v){if(v.tag===13){var b=hr();Ci(v,134217728,b),Vf(v,134217728)}},t.attemptHydrationAtCurrentPriority=function(v){if(v.tag===13){var b=hr(),C=La(v);Ci(v,C,b),Vf(v,C)}},t.attemptSynchronousHydration=function(v){switch(v.tag){case 3:var b=v.stateNode;if(b.current.memoizedState.isDehydrated){var C=Th(b.pendingLanes);C!==0&&(tl(b,C|1),io(b,$s()),(Ln&6)===0&&(Lc(),na()))}break;case 13:var A=hr();Xh(function(){return Ci(v,1,A)}),Vf(v,1)}},t.batchedUpdates=function(v,b){var C=Ln;Ln|=1;try{return v(b)}finally{Ln=C,Ln===0&&(Lc(),Em&&na())}},t.createComponentSelector=function(v){return{$$typeof:kf,value:v}},t.createContainer=function(v,b,C,A,O,U,he){return Ww(v,b,!1,null,C,A,O,U,he)},t.createHasPseudoClassSelector=function(v){return{$$typeof:kc,value:v}},t.createHydrationContainer=function(v,b,C,A,O,U,he,ke,tt){return v=Ww(C,A,!0,v,O,U,he,ke,tt),v.context=Gw(null),C=v.current,A=hr(),O=La(C),U=kl(A,O),U.callback=b??null,Eu(C,U),v.current.lanes=O,cc(v,O,A),io(v,A),v},t.createPortal=function(v,b,C){var A=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:u,key:A==null?null:""+A,children:v,containerInfo:b,implementation:C}},t.createRoleSelector=function(v){return{$$typeof:Rc,value:v}},t.createTestNameSelector=function(v){return{$$typeof:Vl,value:v}},t.createTextSelector=function(v){return{$$typeof:Wh,value:v}},t.deferredUpdates=function(v){var b=Bn,C=Ir.transition;try{return Ir.transition=null,Bn=16,v()}finally{Bn=b,Ir.transition=C}},t.discreteUpdates=function(v,b,C,A,O){var U=Bn,he=Ir.transition;try{return Ir.transition=null,Bn=1,v(b,C,A,O)}finally{Bn=U,Ir.transition=he,Ln===0&&Lc()}},t.findAllNodes=Wl,t.findBoundingRects=function(v,b){if(!ee)throw Error(o(363));b=Wl(v,b),v=[];for(var C=0;C<b.length;C++)v.push(at(b[C]));for(b=v.length-1;0<b;b--){C=v[b];for(var A=C.x,O=A+C.width,U=C.y,he=U+C.height,ke=b-1;0<=ke;ke--)if(b!==ke){var tt=v[ke],wt=tt.x,Ht=wt+tt.width,Cn=tt.y,un=Cn+tt.height;if(A>=wt&&U>=Cn&&O<=Ht&&he<=un){v.splice(b,1);break}else if(A!==wt||C.width!==tt.width||un<U||Cn>he){if(!(U!==Cn||C.height!==tt.height||Ht<A||wt>O)){wt>A&&(tt.width+=wt-A,tt.x=A),Ht<O&&(tt.width=O-wt),v.splice(b,1);break}}else{Cn>U&&(tt.height+=Cn-U,tt.y=U),un<he&&(tt.height=he-Cn),v.splice(b,1);break}}}return v},t.findHostInstance=Hw,t.findHostInstanceWithNoPortals=function(v){return v=P(v),v=v!==null?V(v):null,v===null?null:v.stateNode},t.findHostInstanceWithWarning=function(v){return Hw(v)},t.flushControlled=function(v){var b=Ln;Ln|=1;var C=Ir.transition,A=Bn;try{Ir.transition=null,Bn=1,v()}finally{Bn=A,Ir.transition=C,Ln=b,Ln===0&&(Lc(),na())}},t.flushPassiveEffects=ll,t.flushSync=Xh,t.focusWithin=function(v,b){if(!ee)throw Error(o(363));for(v=Rf(v),b=Ro(v,b),b=Array.from(b),v=0;v<b.length;){var C=b[v++];if(!ot(C)){if(C.tag===5&&bt(C.stateNode))return!0;for(C=C.child;C!==null;)b.push(C),C=C.sibling}}return!1},t.getCurrentUpdatePriority=function(){return Bn},t.getFindAllNodesFailureDescription=function(v,b){if(!ee)throw Error(o(363));var C=0,A=[];v=[Rf(v),0];for(var O=0;O<v.length;){var U=v[O++],he=v[O++],ke=b[he];if((U.tag!==5||!ot(U))&&(Df(U,ke)&&(A.push(Du(ke)),he++,he>C&&(C=he)),he<b.length))for(U=U.child;U!==null;)v.push(U,he),U=U.sibling}if(C<b.length){for(v=[];C<b.length;C++)v.push(Du(b[C]));return`findAllNodes was able to match part of the selector:
  `+(A.join(" > ")+`

No matching component was found for:
  `)+v.join(" > ")}return null},t.getPublicRootInstance=function(v){if(v=v.current,!v.child)return null;switch(v.child.tag){case 5:return q(v.child.stateNode);default:return v.child.stateNode}},t.injectIntoDevTools=function(v){if(v={bundleType:v.bundleType,version:v.version,rendererPackageName:v.rendererPackageName,rendererConfig:v.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:a.ReactCurrentDispatcher,findHostInstanceByFiber:dg,findFiberByHostInstance:v.findFiberByHostInstance||jw,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")v=!1;else{var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)v=!0;else{try{cf=b.inject(v),nl=b}catch{}v=!!b.checkDCE}}return v},t.isAlreadyRendering=function(){return!1},t.observeVisibleRects=function(v,b,C,A){if(!ee)throw Error(o(363));v=Wl(v,b);var O=It(v,C,A).disconnect;return{disconnect:function(){O()}}},t.registerMutableSourceForHydration=function(v,b){var C=b._getVersion;C=C(b._source),v.mutableSourceEagerHydrationData==null?v.mutableSourceEagerHydrationData=[b,C]:v.mutableSourceEagerHydrationData.push(b,C)},t.runWithPriority=function(v,b){var C=Bn;try{return Bn=v,b()}finally{Bn=C}},t.shouldError=function(){return null},t.shouldSuspend=function(){return!1},t.updateContainer=function(v,b,C,A){var O=b.current,U=hr(),he=La(O);return C=Gw(C),b.context===null?b.context=C:b.pendingContext=C,b=kl(U,he),b.payload={element:v},A=A===void 0?null:A,A!==null&&(b.callback=A),Eu(O,b),v=Ci(O,he,U),v!==null&&Am(v,O,he),he},t}),w2}var q3;function bZ(){return q3||(q3=1,y2.exports=wZ()),y2.exports}var SZ=bZ();const _Z=Ux(SZ);var K3=Zz();const TZ=n=>typeof n=="object"&&typeof n.then=="function",bp=[];function Jz(n,e,t=(r,s)=>r===s){if(n===e)return!0;if(!n||!e)return!1;const r=n.length;if(e.length!==r)return!1;for(let s=0;s<r;s++)if(!t(n[s],e[s]))return!1;return!0}function Qz(n,e=null,t=!1,r={}){e===null&&(e=[n]);for(const i of bp)if(Jz(e,i.keys,i.equal)){if(t)return;if(Object.prototype.hasOwnProperty.call(i,"error"))throw i.error;if(Object.prototype.hasOwnProperty.call(i,"response"))return r.lifespan&&r.lifespan>0&&(i.timeout&&clearTimeout(i.timeout),i.timeout=setTimeout(i.remove,r.lifespan)),i.response;if(!t)throw i.promise}const s={keys:e,equal:r.equal,remove:()=>{const i=bp.indexOf(s);i!==-1&&bp.splice(i,1)},promise:(TZ(n)?n:n(...e)).then(i=>{s.response=i,r.lifespan&&r.lifespan>0&&(s.timeout=setTimeout(s.remove,r.lifespan))}).catch(i=>s.error=i)};if(bp.push(s),!t)throw s.promise}const EZ=(n,e,t)=>Qz(n,e,!1,t),CZ=(n,e,t)=>void Qz(n,e,!0,t),IZ=n=>{if(n===void 0||n.length===0)bp.splice(0,bp.length);else{const e=bp.find(t=>Jz(n,t.keys,t.equal));e&&e.remove()}},uM={},dT=n=>void Object.assign(uM,n);function NZ(n,e){function t(c,{args:h=[],attach:d,...p},g){let w=`${c[0].toUpperCase()}${c.slice(1)}`,y;if(c==="primitive"){if(p.object===void 0)throw new Error("R3F: Primitives without 'object' are invalid!");const x=p.object;y=Hg(x,{type:c,root:g,attach:d,primitive:!0})}else{const x=uM[w];if(!x)throw new Error(`R3F: ${w} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(!Array.isArray(h))throw new Error("R3F: The args prop must be an array!");y=Hg(new x(...h),{type:c,root:g,attach:d,memoizedProps:{args:h}})}return y.__r3f.attach===void 0&&(y instanceof zn?y.__r3f.attach="geometry":y instanceof Si&&(y.__r3f.attach="material")),w!=="inject"&&_2(y,p),y}function r(c,h){let d=!1;if(h){var p,g;(p=h.__r3f)!=null&&p.attach?S2(c,h,h.__r3f.attach):h.isObject3D&&c.isObject3D&&(c.add(h),d=!0),d||(g=c.__r3f)==null||g.objects.push(h),h.__r3f||Hg(h,{}),h.__r3f.parent=c,QI(h),jg(h)}}function s(c,h,d){let p=!1;if(h){var g,w;if((g=h.__r3f)!=null&&g.attach)S2(c,h,h.__r3f.attach);else if(h.isObject3D&&c.isObject3D){h.parent=c,h.dispatchEvent({type:"added"});const y=c.children.filter(_=>_!==h),x=y.indexOf(d);c.children=[...y.slice(0,x),h,...y.slice(x)],p=!0}p||(w=c.__r3f)==null||w.objects.push(h),h.__r3f||Hg(h,{}),h.__r3f.parent=c,QI(h),jg(h)}}function i(c,h,d=!1){c&&[...c].forEach(p=>o(h,p,d))}function o(c,h,d){if(h){var p,g,w;if(h.__r3f&&(h.__r3f.parent=null),(p=c.__r3f)!=null&&p.objects&&(c.__r3f.objects=c.__r3f.objects.filter(E=>E!==h)),(g=h.__r3f)!=null&&g.attach)eP(c,h,h.__r3f.attach);else if(h.isObject3D&&c.isObject3D){var y;c.remove(h),(y=h.__r3f)!=null&&y.root&&PZ(kS(h),h)}const _=(w=h.__r3f)==null?void 0:w.primitive,T=!_&&(d===void 0?h.dispose!==null:d);if(!_){var x;i((x=h.__r3f)==null?void 0:x.objects,h,T),i(h.children,h,T)}if(delete h.__r3f,T&&h.dispose&&h.type!=="Scene"){const E=()=>{try{h.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT>"u"?K3.unstable_scheduleCallback(K3.unstable_IdlePriority,E):E()}jg(c)}}function a(c,h,d,p){var g;const w=(g=c.__r3f)==null?void 0:g.parent;if(!w)return;const y=t(h,d,c.__r3f.root);if(c.children){for(const x of c.children)x.__r3f&&r(y,x);c.children=c.children.filter(x=>!x.__r3f)}c.__r3f.objects.forEach(x=>r(y,x)),c.__r3f.objects=[],c.__r3f.autoRemovedBeforeAppend||o(w,c),y.parent&&(y.__r3f.autoRemovedBeforeAppend=!0),r(w,y),y.raycast&&y.__r3f.eventCount&&kS(y).getState().internal.interaction.push(y),[p,p.alternate].forEach(x=>{x!==null&&(x.stateNode=y,x.ref&&(typeof x.ref=="function"?x.ref(y):x.ref.current=y))})}const l=()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");return{reconciler:_Z({createInstance:t,removeChild:o,appendChild:r,appendInitialChild:r,insertBefore:s,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:(c,h)=>{if(!h)return;const d=c.getState().scene;d.__r3f&&(d.__r3f.root=c,r(d,h))},removeChildFromContainer:(c,h)=>{h&&o(c.getState().scene,h)},insertInContainerBefore:(c,h,d)=>{if(!h||!d)return;const p=c.getState().scene;p.__r3f&&s(p,h,d)},getRootHostContext:()=>null,getChildHostContext:c=>c,finalizeInitialChildren(c){var h;return!!((h=c==null?void 0:c.__r3f)!=null?h:{}).handlers},prepareUpdate(c,h,d,p){var g;if(((g=c==null?void 0:c.__r3f)!=null?g:{}).primitive&&p.object&&p.object!==c)return[!0];{const{args:y=[],children:x,..._}=p,{args:T=[],children:E,...N}=d;if(!Array.isArray(y))throw new Error("R3F: the args prop must be an array!");if(y.some(($,L)=>$!==T[L]))return[!0];const M=oB(c,_,N,!0);return M.changes.length?[!1,M]:null}},commitUpdate(c,[h,d],p,g,w,y){h?a(c,p,w,y):_2(c,d)},commitMount(c,h,d,p){var g;const w=(g=c.__r3f)!=null?g:{};c.raycast&&w.handlers&&w.eventCount&&kS(c).getState().internal.interaction.push(c)},getPublicInstance:c=>c,prepareForCommit:()=>null,preparePortalMount:c=>Hg(c.getState().scene),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance(c){var h;const{attach:d,parent:p}=(h=c.__r3f)!=null?h:{};d&&p&&eP(p,c,d),c.isObject3D&&(c.visible=!1),jg(c)},unhideInstance(c,h){var d;const{attach:p,parent:g}=(d=c.__r3f)!=null?d:{};p&&g&&S2(g,c,p),(c.isObject3D&&h.visible==null||h.visible)&&(c.visible=!0),jg(c)},createTextInstance:l,hideTextInstance:l,unhideTextInstance:l,getCurrentEventPriority:()=>e?e():iy.DefaultEventPriority,beforeActiveInstanceBlur:()=>{},afterActiveInstanceBlur:()=>{},detachDeletedInstance:()=>{},now:typeof performance<"u"&&rs.fun(performance.now)?performance.now:rs.fun(Date.now)?Date.now:()=>0,scheduleTimeout:rs.fun(setTimeout)?setTimeout:void 0,cancelTimeout:rs.fun(clearTimeout)?clearTimeout:void 0}),applyProps:_2}}var Y3,Z3;const b2=n=>"colorSpace"in n||"outputColorSpace"in n,eB=()=>{var n;return(n=uM.ColorManagement)!=null?n:null},tB=n=>n&&n.isOrthographicCamera,AZ=n=>n&&n.hasOwnProperty("current"),Hy=typeof window<"u"&&((Y3=window.document)!=null&&Y3.createElement||((Z3=window.navigator)==null?void 0:Z3.product)==="ReactNative")?we.useLayoutEffect:we.useEffect;function nB(n){const e=we.useRef(n);return Hy(()=>void(e.current=n),[n]),e}function MZ({set:n}){return Hy(()=>(n(new Promise(()=>null)),()=>n(!1)),[n]),null}class rB extends we.Component{constructor(...e){super(...e),this.state={error:!1}}componentDidCatch(e){this.props.set(e)}render(){return this.state.error?null:this.props.children}}rB.getDerivedStateFromError=()=>({error:!0});const sB="__default",J3=new Map,kZ=n=>n&&!!n.memoized&&!!n.changes;function iB(n){var e;const t=typeof window<"u"?(e=window.devicePixelRatio)!=null?e:2:1;return Array.isArray(n)?Math.min(Math.max(n[0],t),n[1]):n}const vv=n=>{var e;return(e=n.__r3f)==null?void 0:e.root.getState()};function kS(n){let e=n.__r3f.root;for(;e.getState().previousRoot;)e=e.getState().previousRoot;return e}const rs={obj:n=>n===Object(n)&&!rs.arr(n)&&typeof n!="function",fun:n=>typeof n=="function",str:n=>typeof n=="string",num:n=>typeof n=="number",boo:n=>typeof n=="boolean",und:n=>n===void 0,arr:n=>Array.isArray(n),equ(n,e,{arrays:t="shallow",objects:r="reference",strict:s=!0}={}){if(typeof n!=typeof e||!!n!=!!e)return!1;if(rs.str(n)||rs.num(n))return n===e;const i=rs.obj(n);if(i&&r==="reference")return n===e;const o=rs.arr(n);if(o&&t==="reference")return n===e;if((o||i)&&n===e)return!0;let a;for(a in n)if(!(a in e))return!1;if(i&&t==="shallow"&&r==="shallow"){for(a in s?e:n)if(!rs.equ(n[a],e[a],{strict:s,objects:"reference"}))return!1}else for(a in s?e:n)if(n[a]!==e[a])return!1;if(rs.und(a)){if(o&&n.length===0&&e.length===0||i&&Object.keys(n).length===0&&Object.keys(e).length===0)return!0;if(n!==e)return!1}return!0}};function RZ(n){const e={nodes:{},materials:{}};return n&&n.traverse(t=>{t.name&&(e.nodes[t.name]=t),t.material&&!e.materials[t.material.name]&&(e.materials[t.material.name]=t.material)}),e}function DZ(n){n.dispose&&n.type!=="Scene"&&n.dispose();for(const e in n)e.dispose==null||e.dispose(),delete n[e]}function Hg(n,e){const t=n;return t.__r3f={type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null,...e},n}function JI(n,e){let t=n;if(e.includes("-")){const r=e.split("-"),s=r.pop();return t=r.reduce((i,o)=>i[o],n),{target:t,key:s}}else return{target:t,key:e}}const Q3=/-\d+$/;function S2(n,e,t){if(rs.str(t)){if(Q3.test(t)){const i=t.replace(Q3,""),{target:o,key:a}=JI(n,i);Array.isArray(o[a])||(o[a]=[])}const{target:r,key:s}=JI(n,t);e.__r3f.previousAttach=r[s],r[s]=e}else e.__r3f.previousAttach=t(n,e)}function eP(n,e,t){var r,s;if(rs.str(t)){const{target:i,key:o}=JI(n,t),a=e.__r3f.previousAttach;a===void 0?delete i[o]:i[o]=a}else(r=e.__r3f)==null||r.previousAttach==null||r.previousAttach(n,e);(s=e.__r3f)==null||delete s.previousAttach}function oB(n,{children:e,key:t,ref:r,...s},{children:i,key:o,ref:a,...l}={},u=!1){var c;const h=(c=n==null?void 0:n.__r3f)!=null?c:{},d=Object.entries(s),p=[];if(u){const w=Object.keys(l);for(let y=0;y<w.length;y++)s.hasOwnProperty(w[y])||d.unshift([w[y],sB+"remove"])}d.forEach(([w,y])=>{var x;if((x=n.__r3f)!=null&&x.primitive&&w==="object"||rs.equ(y,l[w]))return;if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(w))return p.push([w,y,!0,[]]);let _=[];w.includes("-")&&(_=w.split("-")),p.push([w,y,!1,_]);for(const T in s){const E=s[T];T.startsWith(`${w}-`)&&p.push([T,E,!1,T.split("-")])}});const g={...s};return h.memoizedProps&&h.memoizedProps.args&&(g.args=h.memoizedProps.args),h.memoizedProps&&h.memoizedProps.attach&&(g.attach=h.memoizedProps.attach),{memoized:g,changes:p}}function _2(n,e){var t,r,s;const i=(t=n.__r3f)!=null?t:{},o=i.root,a=(r=o==null||o.getState==null?void 0:o.getState())!=null?r:{},{memoized:l,changes:u}=kZ(e)?e:oB(n,e),c=i.eventCount;n.__r3f&&(n.__r3f.memoizedProps=l);for(let d=0;d<u.length;d++){let[p,g,w,y]=u[d];if(b2(n)){const E="srgb",N="srgb-linear";p==="encoding"?(p="colorSpace",g=g===3001?E:N):p==="outputEncoding"&&(p="outputColorSpace",g=g===3001?E:N)}let x=n,_=x[p];if(y.length&&(_=y.reduce((T,E)=>T[E],n),!(_&&_.set))){const[T,...E]=y.reverse();x=E.reverse().reduce((N,M)=>N[M],n),p=T}if(g===sB+"remove")if(x.constructor){let T=J3.get(x.constructor);T||(T=new x.constructor,J3.set(x.constructor,T)),g=T[p]}else g=0;if(w)g?i.handlers[p]=g:delete i.handlers[p],i.eventCount=Object.keys(i.handlers).length;else if(_&&_.set&&(_.copy||_ instanceof Ap)){if(Array.isArray(g))_.fromArray?_.fromArray(g):_.set(...g);else if(_.copy&&g&&g.constructor&&_.constructor===g.constructor)_.copy(g);else if(g!==void 0){const T=_ instanceof Nt;!T&&_.setScalar?_.setScalar(g):_ instanceof Ap&&g instanceof Ap?_.mask=g.mask:_.set(g),!eB()&&!a.linear&&T&&_.convertSRGBToLinear()}}else if(x[p]=g,x[p]instanceof fs&&x[p].format===go&&x[p].type===Ki){const T=x[p];b2(T)&&b2(a.gl)?T.colorSpace=a.gl.outputColorSpace:T.encoding=a.gl.outputEncoding}jg(n)}if(i.parent&&n.raycast&&c!==i.eventCount){const d=kS(n).getState().internal,p=d.interaction.indexOf(n);p>-1&&d.interaction.splice(p,1),i.eventCount&&d.interaction.push(n)}return!(u.length===1&&u[0][0]==="onUpdate")&&u.length&&(s=n.__r3f)!=null&&s.parent&&QI(n),n}function jg(n){var e,t;const r=(e=n.__r3f)==null||(t=e.root)==null||t.getState==null?void 0:t.getState();r&&r.internal.frames===0&&r.invalidate()}function QI(n){n.onUpdate==null||n.onUpdate(n)}function aB(n,e){n.manual||(tB(n)?(n.left=e.width/-2,n.right=e.width/2,n.top=e.height/2,n.bottom=e.height/-2):n.aspect=e.width/e.height,n.updateProjectionMatrix(),n.updateMatrixWorld())}function oS(n){return(n.eventObject||n.object).uuid+"/"+n.index+n.instanceId}function $Z(){var n;const e=typeof self<"u"&&self||typeof window<"u"&&window;if(!e)return iy.DefaultEventPriority;switch((n=e.event)==null?void 0:n.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return iy.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return iy.ContinuousEventPriority;default:return iy.DefaultEventPriority}}function lB(n,e,t,r){const s=t.get(e);s&&(t.delete(e),t.size===0&&(n.delete(r),s.target.releasePointerCapture(r)))}function PZ(n,e){const{internal:t}=n.getState();t.interaction=t.interaction.filter(r=>r!==e),t.initialHits=t.initialHits.filter(r=>r!==e),t.hovered.forEach((r,s)=>{(r.eventObject===e||r.object===e)&&t.hovered.delete(s)}),t.capturedMap.forEach((r,s)=>{lB(t.capturedMap,e,r,s)})}function LZ(n){function e(l){const{internal:u}=n.getState(),c=l.offsetX-u.initialClick[0],h=l.offsetY-u.initialClick[1];return Math.round(Math.sqrt(c*c+h*h))}function t(l){return l.filter(u=>["Move","Over","Enter","Out","Leave"].some(c=>{var h;return(h=u.__r3f)==null?void 0:h.handlers["onPointer"+c]}))}function r(l,u){const c=n.getState(),h=new Set,d=[],p=u?u(c.internal.interaction):c.internal.interaction;for(let x=0;x<p.length;x++){const _=vv(p[x]);_&&(_.raycaster.camera=void 0)}c.previousRoot||c.events.compute==null||c.events.compute(l,c);function g(x){const _=vv(x);if(!_||!_.events.enabled||_.raycaster.camera===null)return[];if(_.raycaster.camera===void 0){var T;_.events.compute==null||_.events.compute(l,_,(T=_.previousRoot)==null?void 0:T.getState()),_.raycaster.camera===void 0&&(_.raycaster.camera=null)}return _.raycaster.camera?_.raycaster.intersectObject(x,!0):[]}let w=p.flatMap(g).sort((x,_)=>{const T=vv(x.object),E=vv(_.object);return!T||!E?x.distance-_.distance:E.events.priority-T.events.priority||x.distance-_.distance}).filter(x=>{const _=oS(x);return h.has(_)?!1:(h.add(_),!0)});c.events.filter&&(w=c.events.filter(w,c));for(const x of w){let _=x.object;for(;_;){var y;(y=_.__r3f)!=null&&y.eventCount&&d.push({...x,eventObject:_}),_=_.parent}}if("pointerId"in l&&c.internal.capturedMap.has(l.pointerId))for(let x of c.internal.capturedMap.get(l.pointerId).values())h.has(oS(x.intersection))||d.push(x.intersection);return d}function s(l,u,c,h){const d=n.getState();if(l.length){const p={stopped:!1};for(const g of l){const w=vv(g.object)||d,{raycaster:y,pointer:x,camera:_,internal:T}=w,E=new le(x.x,x.y,0).unproject(_),N=R=>{var P,B;return(P=(B=T.capturedMap.get(R))==null?void 0:B.has(g.eventObject))!=null?P:!1},M=R=>{const P={intersection:g,target:u.target};T.capturedMap.has(R)?T.capturedMap.get(R).set(g.eventObject,P):T.capturedMap.set(R,new Map([[g.eventObject,P]])),u.target.setPointerCapture(R)},$=R=>{const P=T.capturedMap.get(R);P&&lB(T.capturedMap,g.eventObject,P,R)};let L={};for(let R in u){let P=u[R];typeof P!="function"&&(L[R]=P)}let k={...g,...L,pointer:x,intersections:l,stopped:p.stopped,delta:c,unprojectedPoint:E,ray:y.ray,camera:_,stopPropagation(){const R="pointerId"in u&&T.capturedMap.get(u.pointerId);if((!R||R.has(g.eventObject))&&(k.stopped=p.stopped=!0,T.hovered.size&&Array.from(T.hovered.values()).find(P=>P.eventObject===g.eventObject))){const P=l.slice(0,l.indexOf(g));i([...P,g])}},target:{hasPointerCapture:N,setPointerCapture:M,releasePointerCapture:$},currentTarget:{hasPointerCapture:N,setPointerCapture:M,releasePointerCapture:$},nativeEvent:u};if(h(k),p.stopped===!0)break}}return l}function i(l){const{internal:u}=n.getState();for(const c of u.hovered.values())if(!l.length||!l.find(h=>h.object===c.object&&h.index===c.index&&h.instanceId===c.instanceId)){const d=c.eventObject.__r3f,p=d==null?void 0:d.handlers;if(u.hovered.delete(oS(c)),d!=null&&d.eventCount){const g={...c,intersections:l};p.onPointerOut==null||p.onPointerOut(g),p.onPointerLeave==null||p.onPointerLeave(g)}}}function o(l,u){for(let c=0;c<u.length;c++){const h=u[c].__r3f;h==null||h.handlers.onPointerMissed==null||h.handlers.onPointerMissed(l)}}function a(l){switch(l){case"onPointerLeave":case"onPointerCancel":return()=>i([]);case"onLostPointerCapture":return u=>{const{internal:c}=n.getState();"pointerId"in u&&c.capturedMap.has(u.pointerId)&&requestAnimationFrame(()=>{c.capturedMap.has(u.pointerId)&&(c.capturedMap.delete(u.pointerId),i([]))})}}return function(c){const{onPointerMissed:h,internal:d}=n.getState();d.lastEvent.current=c;const p=l==="onPointerMove",g=l==="onClick"||l==="onContextMenu"||l==="onDoubleClick",y=r(c,p?t:void 0),x=g?e(c):0;l==="onPointerDown"&&(d.initialClick=[c.offsetX,c.offsetY],d.initialHits=y.map(T=>T.eventObject)),g&&!y.length&&x<=2&&(o(c,d.interaction),h&&h(c)),p&&i(y);function _(T){const E=T.eventObject,N=E.__r3f,M=N==null?void 0:N.handlers;if(N!=null&&N.eventCount)if(p){if(M.onPointerOver||M.onPointerEnter||M.onPointerOut||M.onPointerLeave){const $=oS(T),L=d.hovered.get($);L?L.stopped&&T.stopPropagation():(d.hovered.set($,T),M.onPointerOver==null||M.onPointerOver(T),M.onPointerEnter==null||M.onPointerEnter(T))}M.onPointerMove==null||M.onPointerMove(T)}else{const $=M[l];$?(!g||d.initialHits.includes(E))&&(o(c,d.interaction.filter(L=>!d.initialHits.includes(L))),$(T)):g&&d.initialHits.includes(E)&&o(c,d.interaction.filter(L=>!d.initialHits.includes(L)))}}s(y,c,x,_)}}return{handlePointer:a}}const OZ=["set","get","setSize","setFrameloop","setDpr","events","invalidate","advance","size","viewport"],uB=n=>!!(n!=null&&n.render),cM=we.createContext(null),FZ=(n,e)=>{const t=Yz((a,l)=>{const u=new le,c=new le,h=new le;function d(x=l().camera,_=c,T=l().size){const{width:E,height:N,top:M,left:$}=T,L=E/N;_ instanceof le?h.copy(_):h.set(..._);const k=x.getWorldPosition(u).distanceTo(h);if(tB(x))return{width:E/x.zoom,height:N/x.zoom,top:M,left:$,factor:1,distance:k,aspect:L};{const R=x.fov*Math.PI/180,P=2*Math.tan(R/2)*k,B=P*(E/N);return{width:B,height:P,top:M,left:$,factor:E/B,distance:k,aspect:L}}}let p;const g=x=>a(_=>({performance:{..._.performance,current:x}})),w=new rt;return{set:a,get:l,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,scene:null,invalidate:(x=1)=>n(l(),x),advance:(x,_)=>e(x,_,l()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new iM,pointer:w,mouse:w,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const x=l();p&&clearTimeout(p),x.performance.current!==x.performance.min&&g(x.performance.min),p=setTimeout(()=>g(l().performance.max),x.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:d},setEvents:x=>a(_=>({..._,events:{..._.events,...x}})),setSize:(x,_,T,E,N)=>{const M=l().camera,$={width:x,height:_,top:E||0,left:N||0,updateStyle:T};a(L=>({size:$,viewport:{...L.viewport,...d(M,c,$)}}))},setDpr:x=>a(_=>{const T=iB(x);return{viewport:{..._.viewport,dpr:T,initialDpr:_.viewport.initialDpr||T}}}),setFrameloop:(x="always")=>{const _=l().clock;_.stop(),_.elapsedTime=0,x!=="never"&&(_.start(),_.elapsedTime=0),a(()=>({frameloop:x}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:we.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(x,_,T)=>{const E=l().internal;return E.priority=E.priority+(_>0?1:0),E.subscribers.push({ref:x,priority:_,store:T}),E.subscribers=E.subscribers.sort((N,M)=>N.priority-M.priority),()=>{const N=l().internal;N!=null&&N.subscribers&&(N.priority=N.priority-(_>0?1:0),N.subscribers=N.subscribers.filter(M=>M.ref!==x))}}}}}),r=t.getState();let s=r.size,i=r.viewport.dpr,o=r.camera;return t.subscribe(()=>{const{camera:a,size:l,viewport:u,gl:c,set:h}=t.getState();if(l.width!==s.width||l.height!==s.height||u.dpr!==i){var d;s=l,i=u.dpr,aB(a,l),c.setPixelRatio(u.dpr);const p=(d=l.updateStyle)!=null?d:typeof HTMLCanvasElement<"u"&&c.domElement instanceof HTMLCanvasElement;c.setSize(l.width,l.height,p)}a!==o&&(o=a,h(p=>({viewport:{...p.viewport,...p.viewport.getCurrentViewport(a)}})))}),t.subscribe(a=>n(a)),t};let aS,zZ=new Set,BZ=new Set,UZ=new Set;function T2(n,e){if(n.size)for(const{callback:t}of n.values())t(e)}function xv(n,e){switch(n){case"before":return T2(zZ,e);case"after":return T2(BZ,e);case"tail":return T2(UZ,e)}}let E2,C2;function I2(n,e,t){let r=e.clock.getDelta();for(e.frameloop==="never"&&typeof n=="number"&&(r=n-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=n),E2=e.internal.subscribers,aS=0;aS<E2.length;aS++)C2=E2[aS],C2.ref.current(C2.store.getState(),r,t);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),e.frameloop==="always"?1:e.internal.frames}function VZ(n){let e=!1,t,r,s;function i(l){r=requestAnimationFrame(i),e=!0,t=0,xv("before",l);for(const c of n.values()){var u;s=c.store.getState(),s.internal.active&&(s.frameloop==="always"||s.internal.frames>0)&&!((u=s.gl.xr)!=null&&u.isPresenting)&&(t+=I2(l,s))}if(xv("after",l),t===0)return xv("tail",l),e=!1,cancelAnimationFrame(r)}function o(l,u=1){var c;if(!l)return n.forEach(h=>o(h.store.getState()),u);(c=l.gl.xr)!=null&&c.isPresenting||!l.internal.active||l.frameloop==="never"||(l.internal.frames=Math.min(60,l.internal.frames+u),e||(e=!0,requestAnimationFrame(i)))}function a(l,u=!0,c,h){if(u&&xv("before",l),c)I2(l,c,h);else for(const d of n.values())I2(l,d.store.getState());u&&xv("after",l)}return{loop:i,invalidate:o,advance:a}}function WZ(n){const e=we.useRef(null);return Hy(()=>void(e.current=n.current.__r3f),[n]),e}function hM(){const n=we.useContext(cM);if(!n)throw new Error("R3F: Hooks can only be used within the Canvas component!");return n}function wl(n=t=>t,e){return hM()(n,e)}function Ka(n,e=0){const t=hM(),r=t.getState().internal.subscribe,s=nB(n);return Hy(()=>r(s,e,t),[e,r,t]),null}const tP=new WeakMap;function cB(n,e){return function(t,...r){let s=tP.get(t);return s||(s=new t,tP.set(t,s)),n&&n(s),Promise.all(r.map(i=>new Promise((o,a)=>s.load(i,l=>{l.scene&&Object.assign(l,RZ(l.scene)),o(l)},e,l=>a(new Error(`Could not load ${i}: ${l==null?void 0:l.message}`)))))).finally(()=>s.dispose==null?void 0:s.dispose())}}function fT(n,e,t,r){const s=Array.isArray(e)?e:[e],i=EZ(cB(t,r),[n,...s],{equal:rs.equ});return Array.isArray(e)?i:i[0]}fT.preload=function(n,e,t){const r=Array.isArray(e)?e:[e];return CZ(cB(t),[n,...r])};fT.clear=function(n,e){const t=Array.isArray(e)?e:[e];return IZ([n,...t])};const wy=new Map,{invalidate:nP,advance:rP}=VZ(wy),{reconciler:yx,applyProps:Fg}=NZ(wy,$Z),zg={objects:"shallow",strict:!1},GZ=(n,e)=>{const t=typeof n=="function"?n(e):n;return uB(t)?t:new BA({powerPreference:"high-performance",canvas:e,antialias:!0,alpha:!0,...n})};function HZ(n,e){const t=typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement;if(e){const{width:r,height:s,top:i,left:o,updateStyle:a=t}=e;return{width:r,height:s,top:i,left:o,updateStyle:a}}else if(typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement&&n.parentElement){const{width:r,height:s,top:i,left:o}=n.parentElement.getBoundingClientRect();return{width:r,height:s,top:i,left:o,updateStyle:t}}else if(typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas)return{width:n.width,height:n.height,top:0,left:0,updateStyle:t};return{width:0,height:0,top:0,left:0}}function jZ(n){const e=wy.get(n),t=e==null?void 0:e.fiber,r=e==null?void 0:e.store;e&&console.warn("R3F.createRoot should only be called once!");const s=typeof reportError=="function"?reportError:console.error,i=r||FZ(nP,rP),o=t||yx.createContainer(i,iy.ConcurrentRoot,null,!1,null,"",s,null);e||wy.set(n,{fiber:o,store:i});let a,l=!1,u;return{configure(c={}){let{gl:h,size:d,scene:p,events:g,onCreated:w,shadows:y=!1,linear:x=!1,flat:_=!1,legacy:T=!1,orthographic:E=!1,frameloop:N="always",dpr:M=[1,2],performance:$,raycaster:L,camera:k,onPointerMissed:R}=c,P=i.getState(),B=P.gl;P.gl||P.set({gl:B=GZ(h,n)});let Z=P.raycaster;Z||P.set({raycaster:Z=new lM});const{params:V,...X}=L||{};if(rs.equ(X,Z,zg)||Fg(Z,{...X}),rs.equ(V,Z.params,zg)||Fg(Z,{params:{...Z.params,...V}}),!P.camera||P.camera===u&&!rs.equ(u,k,zg)){u=k;const Q=k instanceof Hx,ne=Q?k:E?new zy(0,0,0,0,.1,1e3):new fi(75,0,.1,1e3);Q||(ne.position.z=5,k&&Fg(ne,k),!P.camera&&!(k!=null&&k.rotation)&&ne.lookAt(0,0,0)),P.set({camera:ne}),Z.camera=ne}if(!P.scene){let Q;p instanceof Lp?Q=p:(Q=new Lp,p&&Fg(Q,p)),P.set({scene:Hg(Q)})}if(!P.xr){var q;const Q=(ye,Se)=>{const Re=i.getState();Re.frameloop!=="never"&&rP(ye,!0,Re,Se)},ne=()=>{const ye=i.getState();ye.gl.xr.enabled=ye.gl.xr.isPresenting,ye.gl.xr.setAnimationLoop(ye.gl.xr.isPresenting?Q:null),ye.gl.xr.isPresenting||nP(ye)},ce={connect(){const ye=i.getState().gl;ye.xr.addEventListener("sessionstart",ne),ye.xr.addEventListener("sessionend",ne)},disconnect(){const ye=i.getState().gl;ye.xr.removeEventListener("sessionstart",ne),ye.xr.removeEventListener("sessionend",ne)}};typeof((q=B.xr)==null?void 0:q.addEventListener)=="function"&&ce.connect(),P.set({xr:ce})}if(B.shadowMap){const Q=B.shadowMap.enabled,ne=B.shadowMap.type;if(B.shadowMap.enabled=!!y,rs.boo(y))B.shadowMap.type=Bv;else if(rs.str(y)){var se;const ce={basic:jO,percentage:B_,soft:Bv,variance:iu};B.shadowMap.type=(se=ce[y])!=null?se:Bv}else rs.obj(y)&&Object.assign(B.shadowMap,y);(Q!==B.shadowMap.enabled||ne!==B.shadowMap.type)&&(B.shadowMap.needsUpdate=!0)}const W=eB();W&&("enabled"in W?W.enabled=!T:"legacyMode"in W&&(W.legacyMode=T)),Fg(B,{outputEncoding:x?3e3:3001,toneMapping:_?Hu:U_}),P.legacy!==T&&P.set(()=>({legacy:T})),P.linear!==x&&P.set(()=>({linear:x})),P.flat!==_&&P.set(()=>({flat:_})),h&&!rs.fun(h)&&!uB(h)&&!rs.equ(h,B,zg)&&Fg(B,h),g&&!P.events.handlers&&P.set({events:g(i)});const G=HZ(n,d);return rs.equ(G,P.size,zg)||P.setSize(G.width,G.height,G.updateStyle,G.top,G.left),M&&P.viewport.dpr!==iB(M)&&P.setDpr(M),P.frameloop!==N&&P.setFrameloop(N),P.onPointerMissed||P.set({onPointerMissed:R}),$&&!rs.equ($,P.performance,zg)&&P.set(Q=>({performance:{...Q.performance,...$}})),a=w,l=!0,this},render(c){return l||this.configure(),yx.updateContainer(we.createElement(XZ,{store:i,children:c,onCreated:a,rootElement:n}),o,null,()=>{}),i},unmount(){hB(n)}}}function XZ({store:n,children:e,onCreated:t,rootElement:r}){return Hy(()=>{const s=n.getState();s.set(i=>({internal:{...i.internal,active:!0}})),t&&t(s),n.getState().events.connected||s.events.connect==null||s.events.connect(r)},[]),we.createElement(cM.Provider,{value:n},e)}function hB(n,e){const t=wy.get(n),r=t==null?void 0:t.fiber;if(r){const s=t==null?void 0:t.store.getState();s&&(s.internal.active=!1),yx.updateContainer(null,r,null,()=>{s&&setTimeout(()=>{try{var i,o,a,l;s.events.disconnect==null||s.events.disconnect(),(i=s.gl)==null||(o=i.renderLists)==null||o.dispose==null||o.dispose(),(a=s.gl)==null||a.forceContextLoss==null||a.forceContextLoss(),(l=s.gl)!=null&&l.xr&&s.xr.disconnect(),DZ(s),wy.delete(n)}catch{}},500)})}}function qZ(n,e,t){return we.createElement(KZ,{key:e.uuid,children:n,container:e,state:t})}function KZ({state:n={},children:e,container:t}){const{events:r,size:s,...i}=n,o=hM(),[a]=we.useState(()=>new lM),[l]=we.useState(()=>new rt),u=we.useCallback((h,d)=>{const p={...h};Object.keys(h).forEach(w=>{(OZ.includes(w)||h[w]!==d[w]&&d[w])&&delete p[w]});let g;if(d&&s){const w=d.camera;g=h.viewport.getCurrentViewport(w,new le,s),w!==h.camera&&aB(w,s)}return{...p,scene:t,raycaster:a,pointer:l,mouse:l,previousRoot:o,events:{...h.events,...d==null?void 0:d.events,...r},size:{...h.size,...s},viewport:{...h.viewport,...g},...i}},[n]),[c]=we.useState(()=>{const h=o.getState();return Yz((p,g)=>({...h,scene:t,raycaster:a,pointer:l,mouse:l,previousRoot:o,events:{...h.events,...r},size:{...h.size,...s},...i,set:p,get:g,setEvents:w=>p(y=>({...y,events:{...y.events,...w}}))}))});return we.useEffect(()=>{const h=o.subscribe(d=>c.setState(p=>u(d,p)));return()=>{h(),c.destroy()}},[]),we.useEffect(()=>{c.setState(h=>u(o.getState(),h))},[u]),we.createElement(we.Fragment,null,yx.createPortal(we.createElement(cM.Provider,{value:c},e),c,null))}yx.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:we.version});function by(){return by=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},by.apply(null,arguments)}function sP(n,e){let t;return(...r)=>{window.clearTimeout(t),t=window.setTimeout(()=>n(...r),e)}}function YZ({debounce:n,scroll:e,polyfill:t,offsetSize:r}={debounce:0,scroll:!1,offsetSize:!1}){const s=t||(typeof window>"u"?class{}:window.ResizeObserver);if(!s)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[i,o]=we.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),a=we.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:i,orientationHandler:null}),l=n?typeof n=="number"?n:n.scroll:null,u=n?typeof n=="number"?n:n.resize:null,c=we.useRef(!1);we.useEffect(()=>(c.current=!0,()=>void(c.current=!1)));const[h,d,p]=we.useMemo(()=>{const x=()=>{if(!a.current.element)return;const{left:_,top:T,width:E,height:N,bottom:M,right:$,x:L,y:k}=a.current.element.getBoundingClientRect(),R={left:_,top:T,width:E,height:N,bottom:M,right:$,x:L,y:k};a.current.element instanceof HTMLElement&&r&&(R.height=a.current.element.offsetHeight,R.width=a.current.element.offsetWidth),Object.freeze(R),c.current&&!eJ(a.current.lastBounds,R)&&o(a.current.lastBounds=R)};return[x,u?sP(x,u):x,l?sP(x,l):x]},[o,r,l,u]);function g(){a.current.scrollContainers&&(a.current.scrollContainers.forEach(x=>x.removeEventListener("scroll",p,!0)),a.current.scrollContainers=null),a.current.resizeObserver&&(a.current.resizeObserver.disconnect(),a.current.resizeObserver=null),a.current.orientationHandler&&("orientation"in screen&&"removeEventListener"in screen.orientation?screen.orientation.removeEventListener("change",a.current.orientationHandler):"onorientationchange"in window&&window.removeEventListener("orientationchange",a.current.orientationHandler))}function w(){a.current.element&&(a.current.resizeObserver=new s(p),a.current.resizeObserver.observe(a.current.element),e&&a.current.scrollContainers&&a.current.scrollContainers.forEach(x=>x.addEventListener("scroll",p,{capture:!0,passive:!0})),a.current.orientationHandler=()=>{p()},"orientation"in screen&&"addEventListener"in screen.orientation?screen.orientation.addEventListener("change",a.current.orientationHandler):"onorientationchange"in window&&window.addEventListener("orientationchange",a.current.orientationHandler))}const y=x=>{!x||x===a.current.element||(g(),a.current.element=x,a.current.scrollContainers=dB(x),w())};return JZ(p,!!e),ZZ(d),we.useEffect(()=>{g(),w()},[e,p,d]),we.useEffect(()=>g,[]),[y,i,h]}function ZZ(n){we.useEffect(()=>{const e=n;return window.addEventListener("resize",e),()=>void window.removeEventListener("resize",e)},[n])}function JZ(n,e){we.useEffect(()=>{if(e){const t=n;return window.addEventListener("scroll",t,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",t,!0)}},[n,e])}function dB(n){const e=[];if(!n||n===document.body)return e;const{overflow:t,overflowX:r,overflowY:s}=window.getComputedStyle(n);return[t,r,s].some(i=>i==="auto"||i==="scroll")&&e.push(n),[...e,...dB(n.parentElement)]}const QZ=["x","y","top","bottom","left","right","width","height"],eJ=(n,e)=>QZ.every(t=>n[t]===e[t]);var tJ=Object.defineProperty,nJ=Object.defineProperties,rJ=Object.getOwnPropertyDescriptors,iP=Object.getOwnPropertySymbols,sJ=Object.prototype.hasOwnProperty,iJ=Object.prototype.propertyIsEnumerable,oP=(n,e,t)=>e in n?tJ(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,aP=(n,e)=>{for(var t in e||(e={}))sJ.call(e,t)&&oP(n,t,e[t]);if(iP)for(var t of iP(e))iJ.call(e,t)&&oP(n,t,e[t]);return n},oJ=(n,e)=>nJ(n,rJ(e)),lP,uP;typeof window<"u"&&((lP=window.document)!=null&&lP.createElement||((uP=window.navigator)==null?void 0:uP.product)==="ReactNative")?we.useLayoutEffect:we.useEffect;function fB(n,e,t){if(!n)return;if(t(n)===!0)return n;let r=n.child;for(;r;){const s=fB(r,e,t);if(s)return s;r=r.sibling}}function pB(n){try{return Object.defineProperties(n,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return n}}const cP=console.error;console.error=function(){const n=[...arguments].join("");if(n!=null&&n.startsWith("Warning:")&&n.includes("useContext")){console.error=cP;return}return cP.apply(this,arguments)};const dM=pB(we.createContext(null));class mB extends we.Component{render(){return we.createElement(dM.Provider,{value:this._reactInternals},this.props.children)}}function aJ(){const n=we.useContext(dM);if(n===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const e=we.useId();return we.useMemo(()=>{for(const r of[n,n==null?void 0:n.alternate]){if(!r)continue;const s=fB(r,!1,i=>{let o=i.memoizedState;for(;o;){if(o.memoizedState===e)return!0;o=o.next}});if(s)return s}},[n,e])}function lJ(){const n=aJ(),[e]=we.useState(()=>new Map);e.clear();let t=n;for(;t;){if(t.type&&typeof t.type=="object"){const s=t.type._context===void 0&&t.type.Provider===t.type?t.type:t.type._context;s&&s!==dM&&!e.has(s)&&e.set(s,we.useContext(pB(s)))}t=t.return}return e}function uJ(){const n=lJ();return we.useMemo(()=>Array.from(n.keys()).reduce((e,t)=>r=>we.createElement(e,null,we.createElement(t.Provider,oJ(aP({},r),{value:n.get(t)}))),e=>we.createElement(mB,aP({},e))),[n])}const N2={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function cJ(n){const{handlePointer:e}=LZ(n);return{priority:1,enabled:!0,compute(t,r,s){r.pointer.set(t.offsetX/r.size.width*2-1,-(t.offsetY/r.size.height)*2+1),r.raycaster.setFromCamera(r.pointer,r.camera)},connected:void 0,handlers:Object.keys(N2).reduce((t,r)=>({...t,[r]:e(r)}),{}),update:()=>{var t;const{events:r,internal:s}=n.getState();(t=s.lastEvent)!=null&&t.current&&r.handlers&&r.handlers.onPointerMove(s.lastEvent.current)},connect:t=>{var r;const{set:s,events:i}=n.getState();i.disconnect==null||i.disconnect(),s(o=>({events:{...o.events,connected:t}})),Object.entries((r=i.handlers)!=null?r:[]).forEach(([o,a])=>{const[l,u]=N2[o];t.addEventListener(l,a,{passive:u})})},disconnect:()=>{const{set:t,events:r}=n.getState();if(r.connected){var s;Object.entries((s=r.handlers)!=null?s:[]).forEach(([i,o])=>{if(r&&r.connected instanceof HTMLElement){const[a]=N2[i];r.connected.removeEventListener(a,o)}}),t(i=>({events:{...i.events,connected:void 0}}))}}}}const hJ=we.forwardRef(function({children:e,fallback:t,resize:r,style:s,gl:i,events:o=cJ,eventSource:a,eventPrefix:l,shadows:u,linear:c,flat:h,legacy:d,orthographic:p,frameloop:g,dpr:w,performance:y,raycaster:x,camera:_,scene:T,onPointerMissed:E,onCreated:N,...M},$){we.useMemo(()=>dT(pZ),[]);const L=uJ(),[k,R]=YZ({scroll:!0,debounce:{scroll:50,resize:0},...r}),P=we.useRef(null),B=we.useRef(null);we.useImperativeHandle($,()=>P.current);const Z=nB(E),[V,X]=we.useState(!1),[q,se]=we.useState(!1);if(V)throw V;if(q)throw q;const W=we.useRef(null);Hy(()=>{const K=P.current;R.width>0&&R.height>0&&K&&(W.current||(W.current=jZ(K)),W.current.configure({gl:i,events:o,shadows:u,linear:c,flat:h,legacy:d,orthographic:p,frameloop:g,dpr:w,performance:y,raycaster:x,camera:_,scene:T,size:R,onPointerMissed:(...G)=>Z.current==null?void 0:Z.current(...G),onCreated:G=>{G.events.connect==null||G.events.connect(a?AZ(a)?a.current:a:B.current),l&&G.setEvents({compute:(Q,ne)=>{const ce=Q[l+"X"],ye=Q[l+"Y"];ne.pointer.set(ce/ne.size.width*2-1,-(ye/ne.size.height)*2+1),ne.raycaster.setFromCamera(ne.pointer,ne.camera)}}),N==null||N(G)}}),W.current.render(we.createElement(L,null,we.createElement(rB,{set:se},we.createElement(we.Suspense,{fallback:we.createElement(MZ,{set:X})},e)))))}),we.useEffect(()=>{const K=P.current;if(K)return()=>hB(K)},[]);const J=a?"none":"auto";return we.createElement("div",by({ref:B,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:J,...s}},M),we.createElement("div",{ref:k,style:{width:"100%",height:"100%"}},we.createElement("canvas",{ref:P,style:{display:"block"}},t)))}),dJ=we.forwardRef(function(e,t){return we.createElement(mB,null,we.createElement(hJ,by({},e,{ref:t})))});let wv;function fJ(){var n;if(wv!==void 0)return wv;try{let e;const t=document.createElement("canvas");return wv=!!(window.WebGL2RenderingContext&&(e=t.getContext("webgl2"))),e&&((n=e.getExtension("WEBGL_lose_context"))==null||n.loseContext()),wv}catch{return wv=!1}}const gB=parseInt(Vd.replace(/\D+/g,""));var gl=Uint8Array,md=Uint16Array,eN=Uint32Array,yB=new gl([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),vB=new gl([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),pJ=new gl([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),xB=function(n,e){for(var t=new md(31),r=0;r<31;++r)t[r]=e+=1<<n[r-1];for(var s=new eN(t[30]),r=1;r<30;++r)for(var i=t[r];i<t[r+1];++i)s[i]=i-t[r]<<5|r;return[t,s]},wB=xB(yB,2),bB=wB[0],mJ=wB[1];bB[28]=258,mJ[258]=28;var gJ=xB(vB,0),yJ=gJ[0],tN=new md(32768);for(var is=0;is<32768;++is){var ud=(is&43690)>>>1|(is&21845)<<1;ud=(ud&52428)>>>2|(ud&13107)<<2,ud=(ud&61680)>>>4|(ud&3855)<<4,tN[is]=((ud&65280)>>>8|(ud&255)<<8)>>>1}var jv=(function(n,e,t){for(var r=n.length,s=0,i=new md(e);s<r;++s)++i[n[s]-1];var o=new md(e);for(s=0;s<e;++s)o[s]=o[s-1]+i[s-1]<<1;var a;if(t){a=new md(1<<e);var l=15-e;for(s=0;s<r;++s)if(n[s])for(var u=s<<4|n[s],c=e-n[s],h=o[n[s]-1]++<<c,d=h|(1<<c)-1;h<=d;++h)a[tN[h]>>>l]=u}else for(a=new md(r),s=0;s<r;++s)n[s]&&(a[s]=tN[o[n[s]-1]++]>>>15-n[s]);return a}),e1=new gl(288);for(var is=0;is<144;++is)e1[is]=8;for(var is=144;is<256;++is)e1[is]=9;for(var is=256;is<280;++is)e1[is]=7;for(var is=280;is<288;++is)e1[is]=8;var SB=new gl(32);for(var is=0;is<32;++is)SB[is]=5;var vJ=jv(e1,9,1),xJ=jv(SB,5,1),A2=function(n){for(var e=n[0],t=1;t<n.length;++t)n[t]>e&&(e=n[t]);return e},tu=function(n,e,t){var r=e/8|0;return(n[r]|n[r+1]<<8)>>(e&7)&t},M2=function(n,e){var t=e/8|0;return(n[t]|n[t+1]<<8|n[t+2]<<16)>>(e&7)},wJ=function(n){return(n/8|0)+(n&7&&1)},bJ=function(n,e,t){(t==null||t>n.length)&&(t=n.length);var r=new(n instanceof md?md:n instanceof eN?eN:gl)(t-e);return r.set(n.subarray(e,t)),r},SJ=function(n,e,t){var r=n.length;if(!r||t&&!t.l&&r<5)return e||new gl(0);var s=!e||t,i=!t||t.i;t||(t={}),e||(e=new gl(r*3));var o=function(Se){var Re=e.length;if(Se>Re){var Oe=new gl(Math.max(Re*2,Se));Oe.set(e),e=Oe}},a=t.f||0,l=t.p||0,u=t.b||0,c=t.l,h=t.d,d=t.m,p=t.n,g=r*8;do{if(!c){t.f=a=tu(n,l,1);var w=tu(n,l+1,3);if(l+=3,w)if(w==1)c=vJ,h=xJ,d=9,p=5;else if(w==2){var T=tu(n,l,31)+257,E=tu(n,l+10,15)+4,N=T+tu(n,l+5,31)+1;l+=14;for(var M=new gl(N),$=new gl(19),L=0;L<E;++L)$[pJ[L]]=tu(n,l+L*3,7);l+=E*3;for(var k=A2($),R=(1<<k)-1,P=jv($,k,1),L=0;L<N;){var B=P[tu(n,l,R)];l+=B&15;var y=B>>>4;if(y<16)M[L++]=y;else{var Z=0,V=0;for(y==16?(V=3+tu(n,l,3),l+=2,Z=M[L-1]):y==17?(V=3+tu(n,l,7),l+=3):y==18&&(V=11+tu(n,l,127),l+=7);V--;)M[L++]=Z}}var X=M.subarray(0,T),q=M.subarray(T);d=A2(X),p=A2(q),c=jv(X,d,1),h=jv(q,p,1)}else throw"invalid block type";else{var y=wJ(l)+4,x=n[y-4]|n[y-3]<<8,_=y+x;if(_>r){if(i)throw"unexpected EOF";break}s&&o(u+x),e.set(n.subarray(y,_),u),t.b=u+=x,t.p=l=_*8;continue}if(l>g){if(i)throw"unexpected EOF";break}}s&&o(u+131072);for(var se=(1<<d)-1,W=(1<<p)-1,J=l;;J=l){var Z=c[M2(n,l)&se],K=Z>>>4;if(l+=Z&15,l>g){if(i)throw"unexpected EOF";break}if(!Z)throw"invalid length/literal";if(K<256)e[u++]=K;else if(K==256){J=l,c=null;break}else{var G=K-254;if(K>264){var L=K-257,Q=yB[L];G=tu(n,l,(1<<Q)-1)+bB[L],l+=Q}var ne=h[M2(n,l)&W],ce=ne>>>4;if(!ne)throw"invalid distance";l+=ne&15;var q=yJ[ce];if(ce>3){var Q=vB[ce];q+=M2(n,l)&(1<<Q)-1,l+=Q}if(l>g){if(i)throw"unexpected EOF";break}s&&o(u+131072);for(var ye=u+G;u<ye;u+=4)e[u]=e[u-q],e[u+1]=e[u+1-q],e[u+2]=e[u+2-q],e[u+3]=e[u+3-q];u=ye}}t.l=c,t.p=J,t.b=u,c&&(a=1,t.m=d,t.d=h,t.n=p)}while(!a);return u==e.length?e:bJ(e,0,u)},_J=new gl(0),TJ=function(n){if((n[0]&15)!=8||n[0]>>>4>7||(n[0]<<8|n[1])%31)throw"invalid zlib data";if(n[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function lS(n,e){return SJ((TJ(n),n.subarray(2,-4)),e)}var EJ=typeof TextDecoder<"u"&&new TextDecoder,CJ=0;try{EJ.decode(_J,{stream:!0}),CJ=1}catch{}const IJ=n=>n&&n.isCubeTexture;class NJ extends zs{constructor(e,t){var r,s;const i=IJ(e),a=((s=i?(r=e.image[0])==null?void 0:r.width:e.image.width)!=null?s:1024)/4,l=Math.floor(Math.log2(a)),u=Math.pow(2,l),c=3*Math.max(u,112),h=4*u,d=[i?"#define ENVMAP_TYPE_CUBE":"",`#define CUBEUV_TEXEL_WIDTH ${1/c}`,`#define CUBEUV_TEXEL_HEIGHT ${1/h}`,`#define CUBEUV_MAX_MIP ${l}.0`],p=`
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,g=d.join(`
`)+`
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${gB>=154?"colorspace_fragment":"encodings_fragment"}>
        }
        `,w={map:{value:e},height:{value:(t==null?void 0:t.height)||15},radius:{value:(t==null?void 0:t.radius)||100}},y=new Yx(1,16),x=new ni({uniforms:w,fragmentShader:g,vertexShader:p,side:Wo});super(y,x)}set radius(e){this.material.uniforms.radius.value=e}get radius(){return this.material.uniforms.radius.value}set height(e){this.material.uniforms.height.value=e}get height(){return this.material.uniforms.height.value}}class AJ extends nM{constructor(e){super(e),this.type=vo}parse(e){const o=function(L,k){switch(L){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(k||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(k||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(k||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(k||""))}},h=function(L,k,R){k=k||1024;let B=L.pos,Z=-1,V=0,X="",q=String.fromCharCode.apply(null,new Uint16Array(L.subarray(B,B+128)));for(;0>(Z=q.indexOf(`
`))&&V<k&&B<L.byteLength;)X+=q,V+=q.length,B+=128,q+=String.fromCharCode.apply(null,new Uint16Array(L.subarray(B,B+128)));return-1<Z?(L.pos+=V+Z+1,X+q.slice(0,Z)):!1},d=function(L){const k=/^#\?(\S+)/,R=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,P=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,B=/^\s*FORMAT=(\S+)\s*$/,Z=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,V={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let X,q;for((L.pos>=L.byteLength||!(X=h(L)))&&o(1,"no header found"),(q=X.match(k))||o(3,"bad initial token"),V.valid|=1,V.programtype=q[1],V.string+=X+`
`;X=h(L),X!==!1;){if(V.string+=X+`
`,X.charAt(0)==="#"){V.comments+=X+`
`;continue}if((q=X.match(R))&&(V.gamma=parseFloat(q[1])),(q=X.match(P))&&(V.exposure=parseFloat(q[1])),(q=X.match(B))&&(V.valid|=2,V.format=q[1]),(q=X.match(Z))&&(V.valid|=4,V.height=parseInt(q[1],10),V.width=parseInt(q[2],10)),V.valid&2&&V.valid&4)break}return V.valid&2||o(3,"missing format specifier"),V.valid&4||o(3,"missing image size specifier"),V},p=function(L,k,R){const P=k;if(P<8||P>32767||L[0]!==2||L[1]!==2||L[2]&128)return new Uint8Array(L);P!==(L[2]<<8|L[3])&&o(3,"wrong scanline width");const B=new Uint8Array(4*k*R);B.length||o(4,"unable to allocate buffer space");let Z=0,V=0;const X=4*P,q=new Uint8Array(4),se=new Uint8Array(X);let W=R;for(;W>0&&V<L.byteLength;){V+4>L.byteLength&&o(1),q[0]=L[V++],q[1]=L[V++],q[2]=L[V++],q[3]=L[V++],(q[0]!=2||q[1]!=2||(q[2]<<8|q[3])!=P)&&o(3,"bad rgbe scanline format");let J=0,K;for(;J<X&&V<L.byteLength;){K=L[V++];const Q=K>128;if(Q&&(K-=128),(K===0||J+K>X)&&o(3,"bad scanline data"),Q){const ne=L[V++];for(let ce=0;ce<K;ce++)se[J++]=ne}else se.set(L.subarray(V,V+K),J),J+=K,V+=K}const G=P;for(let Q=0;Q<G;Q++){let ne=0;B[Z]=se[Q+ne],ne+=P,B[Z+1]=se[Q+ne],ne+=P,B[Z+2]=se[Q+ne],ne+=P,B[Z+3]=se[Q+ne],Z+=4}W--}return B},g=function(L,k,R,P){const B=L[k+3],Z=Math.pow(2,B-128)/255;R[P+0]=L[k+0]*Z,R[P+1]=L[k+1]*Z,R[P+2]=L[k+2]*Z,R[P+3]=1},w=function(L,k,R,P){const B=L[k+3],Z=Math.pow(2,B-128)/255;R[P+0]=xp.toHalfFloat(Math.min(L[k+0]*Z,65504)),R[P+1]=xp.toHalfFloat(Math.min(L[k+1]*Z,65504)),R[P+2]=xp.toHalfFloat(Math.min(L[k+2]*Z,65504)),R[P+3]=xp.toHalfFloat(1)},y=new Uint8Array(e);y.pos=0;const x=d(y),_=x.width,T=x.height,E=p(y.subarray(y.pos),_,T);let N,M,$;switch(this.type){case Di:$=E.length/4;const L=new Float32Array($*4);for(let R=0;R<$;R++)g(E,R*4,L,R*4);N=L,M=Di;break;case vo:$=E.length/4;const k=new Uint16Array($*4);for(let R=0;R<$;R++)w(E,R*4,k,R*4);N=k,M=vo;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:_,height:T,data:N,header:x.string,gamma:x.gamma,exposure:x.exposure,type:M}}setDataType(e){return this.type=e,this}load(e,t,r,s){function i(o,a){switch(o.type){case Di:case vo:"colorSpace"in o?o.colorSpace="srgb-linear":o.encoding=3e3,o.minFilter=Lr,o.magFilter=Lr,o.generateMipmaps=!1,o.flipY=!0;break}t&&t(o,a)}return super.load(e,i,r,s)}}const bv=gB>=152;class MJ extends nM{constructor(e){super(e),this.type=vo}parse(e){const k=Math.pow(2.7182818,2.2);function R(j,re){for(var be=0,H=0;H<65536;++H)(H==0||j[H>>3]&1<<(H&7))&&(re[be++]=H);for(var ae=be-1;be<65536;)re[be++]=0;return ae}function P(j){for(var re=0;re<16384;re++)j[re]={},j[re].len=0,j[re].lit=0,j[re].p=null}const B={l:0,c:0,lc:0};function Z(j,re,be,H,ae){for(;be<j;)re=re<<8|Vt(H,ae),be+=8;be-=j,B.l=re>>be&(1<<j)-1,B.c=re,B.lc=be}const V=new Array(59);function X(j){for(var re=0;re<=58;++re)V[re]=0;for(var re=0;re<65537;++re)V[j[re]]+=1;for(var be=0,re=58;re>0;--re){var H=be+V[re]>>1;V[re]=be,be=H}for(var re=0;re<65537;++re){var ae=j[re];ae>0&&(j[re]=ae|V[ae]++<<6)}}function q(j,re,be,H,ae,ue,xe){for(var me=be,We=0,Ye=0;ae<=ue;ae++){if(me.value-be.value>H)return!1;Z(6,We,Ye,j,me);var et=B.l;if(We=B.c,Ye=B.lc,xe[ae]=et,et==63){if(me.value-be.value>H)throw"Something wrong with hufUnpackEncTable";Z(8,We,Ye,j,me);var Ue=B.l+6;if(We=B.c,Ye=B.lc,ae+Ue>ue+1)throw"Something wrong with hufUnpackEncTable";for(;Ue--;)xe[ae++]=0;ae--}else if(et>=59){var Ue=et-59+2;if(ae+Ue>ue+1)throw"Something wrong with hufUnpackEncTable";for(;Ue--;)xe[ae++]=0;ae--}}X(xe)}function se(j){return j&63}function W(j){return j>>6}function J(j,re,be,H){for(;re<=be;re++){var ae=W(j[re]),ue=se(j[re]);if(ae>>ue)throw"Invalid table entry";if(ue>14){var xe=H[ae>>ue-14];if(xe.len)throw"Invalid table entry";if(xe.lit++,xe.p){var me=xe.p;xe.p=new Array(xe.lit);for(var We=0;We<xe.lit-1;++We)xe.p[We]=me[We]}else xe.p=new Array(1);xe.p[xe.lit-1]=re}else if(ue)for(var Ye=0,We=1<<14-ue;We>0;We--){var xe=H[(ae<<14-ue)+Ye];if(xe.len||xe.p)throw"Invalid table entry";xe.len=ue,xe.lit=re,Ye++}}return!0}const K={c:0,lc:0};function G(j,re,be,H){j=j<<8|Vt(be,H),re+=8,K.c=j,K.lc=re}const Q={c:0,lc:0};function ne(j,re,be,H,ae,ue,xe,me,We,Ye){if(j==re){H<8&&(G(be,H,ae,xe),be=K.c,H=K.lc),H-=8;var et=be>>H,et=new Uint8Array([et])[0];if(We.value+et>Ye)return!1;for(var Ue=me[We.value-1];et-- >0;)me[We.value++]=Ue}else if(We.value<Ye)me[We.value++]=j;else return!1;Q.c=be,Q.lc=H}function ce(j){return j&65535}function ye(j){var re=ce(j);return re>32767?re-65536:re}const Se={a:0,b:0};function Re(j,re){var be=ye(j),H=ye(re),ae=H,ue=be+(ae&1)+(ae>>1),xe=ue,me=ue-ae;Se.a=xe,Se.b=me}function Oe(j,re){var be=ce(j),H=ce(re),ae=be-(H>>1)&65535,ue=H+ae-32768&65535;Se.a=ue,Se.b=ae}function Ke(j,re,be,H,ae,ue,xe){for(var me=xe<16384,We=be>ae?ae:be,Ye=1,et;Ye<=We;)Ye<<=1;for(Ye>>=1,et=Ye,Ye>>=1;Ye>=1;){for(var Ue=0,Bt=Ue+ue*(ae-et),dt=ue*Ye,gt=ue*et,Ut=H*Ye,tn=H*et,on,vn,kt,Ct;Ue<=Bt;Ue+=gt){for(var mn=Ue,dn=Ue+H*(be-et);mn<=dn;mn+=tn){var xn=mn+Ut,Tr=mn+dt,Wr=Tr+Ut;me?(Re(j[mn+re],j[Tr+re]),on=Se.a,kt=Se.b,Re(j[xn+re],j[Wr+re]),vn=Se.a,Ct=Se.b,Re(on,vn),j[mn+re]=Se.a,j[xn+re]=Se.b,Re(kt,Ct),j[Tr+re]=Se.a,j[Wr+re]=Se.b):(Oe(j[mn+re],j[Tr+re]),on=Se.a,kt=Se.b,Oe(j[xn+re],j[Wr+re]),vn=Se.a,Ct=Se.b,Oe(on,vn),j[mn+re]=Se.a,j[xn+re]=Se.b,Oe(kt,Ct),j[Tr+re]=Se.a,j[Wr+re]=Se.b)}if(be&Ye){var Tr=mn+dt;me?Re(j[mn+re],j[Tr+re]):Oe(j[mn+re],j[Tr+re]),on=Se.a,j[Tr+re]=Se.b,j[mn+re]=on}}if(ae&Ye)for(var mn=Ue,dn=Ue+H*(be-et);mn<=dn;mn+=tn){var xn=mn+Ut;me?Re(j[mn+re],j[xn+re]):Oe(j[mn+re],j[xn+re]),on=Se.a,j[xn+re]=Se.b,j[mn+re]=on}et=Ye,Ye>>=1}return Ue}function st(j,re,be,H,ae,ue,xe,me,We,Ye){for(var et=0,Ue=0,Bt=me,dt=Math.trunc(ae.value+(ue+7)/8);ae.value<dt;)for(G(et,Ue,be,ae),et=K.c,Ue=K.lc;Ue>=14;){var gt=et>>Ue-14&16383,Ut=re[gt];if(Ut.len)Ue-=Ut.len,ne(Ut.lit,xe,et,Ue,be,H,ae,We,Ye,Bt),et=Q.c,Ue=Q.lc;else{if(!Ut.p)throw"hufDecode issues";var tn;for(tn=0;tn<Ut.lit;tn++){for(var on=se(j[Ut.p[tn]]);Ue<on&&ae.value<dt;)G(et,Ue,be,ae),et=K.c,Ue=K.lc;if(Ue>=on&&W(j[Ut.p[tn]])==(et>>Ue-on&(1<<on)-1)){Ue-=on,ne(Ut.p[tn],xe,et,Ue,be,H,ae,We,Ye,Bt),et=Q.c,Ue=Q.lc;break}}if(tn==Ut.lit)throw"hufDecode issues"}}var vn=8-ue&7;for(et>>=vn,Ue-=vn;Ue>0;){var Ut=re[et<<14-Ue&16383];if(Ut.len)Ue-=Ut.len,ne(Ut.lit,xe,et,Ue,be,H,ae,We,Ye,Bt),et=Q.c,Ue=Q.lc;else throw"hufDecode issues"}return!0}function ct(j,re,be,H,ae,ue){var xe={value:0},me=be.value,We=Ft(re,be),Ye=Ft(re,be);be.value+=4;var et=Ft(re,be);if(be.value+=4,We<0||We>=65537||Ye<0||Ye>=65537)throw"Something wrong with HUF_ENCSIZE";var Ue=new Array(65537),Bt=new Array(16384);P(Bt);var dt=H-(be.value-me);if(q(j,re,be,dt,We,Ye,Ue),et>8*(H-(be.value-me)))throw"Something wrong with hufUncompress";J(Ue,We,Ye,Bt),st(Ue,Bt,j,re,be,et,Ye,ue,ae,xe)}function fe(j,re,be){for(var H=0;H<be;++H)re[H]=j[re[H]]}function nt(j){for(var re=1;re<j.length;re++){var be=j[re-1]+j[re]-128;j[re]=be}}function Xe(j,re){for(var be=0,H=Math.floor((j.length+1)/2),ae=0,ue=j.length-1;!(ae>ue||(re[ae++]=j[be++],ae>ue));)re[ae++]=j[H++]}function it(j){for(var re=j.byteLength,be=new Array,H=0,ae=new DataView(j);re>0;){var ue=ae.getInt8(H++);if(ue<0){var xe=-ue;re-=xe+1;for(var me=0;me<xe;me++)be.push(ae.getUint8(H++))}else{var xe=ue;re-=2;for(var We=ae.getUint8(H++),me=0;me<xe+1;me++)be.push(We)}}return be}function He(j,re,be,H,ae,ue){var xn=new DataView(ue.buffer),xe=be[j.idx[0]].width,me=be[j.idx[0]].height,We=3,Ye=Math.floor(xe/8),et=Math.ceil(xe/8),Ue=Math.ceil(me/8),Bt=xe-(et-1)*8,dt=me-(Ue-1)*8,gt={value:0},Ut=new Array(We),tn=new Array(We),on=new Array(We),vn=new Array(We),kt=new Array(We);for(let Pn=0;Pn<We;++Pn)kt[Pn]=re[j.idx[Pn]],Ut[Pn]=Pn<1?0:Ut[Pn-1]+et*Ue,tn[Pn]=new Float32Array(64),on[Pn]=new Uint16Array(64),vn[Pn]=new Uint16Array(et*64);for(let Pn=0;Pn<Ue;++Pn){var Ct=8;Pn==Ue-1&&(Ct=dt);var mn=8;for(let Rn=0;Rn<et;++Rn){Rn==et-1&&(mn=Bt);for(let Hn=0;Hn<We;++Hn)on[Hn].fill(0),on[Hn][0]=ae[Ut[Hn]++],_t(gt,H,on[Hn]),mt(on[Hn],tn[Hn]),oe(tn[Hn]);ee(tn);for(let Hn=0;Hn<We;++Hn)Le(tn[Hn],vn[Hn],Rn*64)}let es=0;for(let Rn=0;Rn<We;++Rn){const Hn=be[j.idx[Rn]].type;for(let Rr=8*Pn;Rr<8*Pn+Ct;++Rr){es=kt[Rn][Rr];for(let eo=0;eo<Ye;++eo){const Ds=eo*64+(Rr&7)*8;xn.setUint16(es+0*Hn,vn[Rn][Ds+0],!0),xn.setUint16(es+2*Hn,vn[Rn][Ds+1],!0),xn.setUint16(es+4*Hn,vn[Rn][Ds+2],!0),xn.setUint16(es+6*Hn,vn[Rn][Ds+3],!0),xn.setUint16(es+8*Hn,vn[Rn][Ds+4],!0),xn.setUint16(es+10*Hn,vn[Rn][Ds+5],!0),xn.setUint16(es+12*Hn,vn[Rn][Ds+6],!0),xn.setUint16(es+14*Hn,vn[Rn][Ds+7],!0),es+=16*Hn}}if(Ye!=et)for(let Rr=8*Pn;Rr<8*Pn+Ct;++Rr){const eo=kt[Rn][Rr]+8*Ye*2*Hn,Ds=Ye*64+(Rr&7)*8;for(let el=0;el<mn;++el)xn.setUint16(eo+el*2*Hn,vn[Rn][Ds+el],!0)}}}for(var dn=new Uint16Array(xe),xn=new DataView(ue.buffer),Tr=0;Tr<We;++Tr){be[j.idx[Tr]].decoded=!0;var Wr=be[j.idx[Tr]].type;if(be[Tr].type==2)for(var kr=0;kr<me;++kr){const Pn=kt[Tr][kr];for(var Gn=0;Gn<xe;++Gn)dn[Gn]=xn.getUint16(Pn+Gn*2*Wr,!0);for(var Gn=0;Gn<xe;++Gn)xn.setFloat32(Pn+Gn*2*Wr,Ge(dn[Gn]),!0)}}}function _t(j,re,be){for(var H,ae=1;ae<64;)H=re[j.value],H==65280?ae=64:H>>8==255?ae+=H&255:(be[ae]=H,ae++),j.value++}function mt(j,re){re[0]=Ge(j[0]),re[1]=Ge(j[1]),re[2]=Ge(j[5]),re[3]=Ge(j[6]),re[4]=Ge(j[14]),re[5]=Ge(j[15]),re[6]=Ge(j[27]),re[7]=Ge(j[28]),re[8]=Ge(j[2]),re[9]=Ge(j[4]),re[10]=Ge(j[7]),re[11]=Ge(j[13]),re[12]=Ge(j[16]),re[13]=Ge(j[26]),re[14]=Ge(j[29]),re[15]=Ge(j[42]),re[16]=Ge(j[3]),re[17]=Ge(j[8]),re[18]=Ge(j[12]),re[19]=Ge(j[17]),re[20]=Ge(j[25]),re[21]=Ge(j[30]),re[22]=Ge(j[41]),re[23]=Ge(j[43]),re[24]=Ge(j[9]),re[25]=Ge(j[11]),re[26]=Ge(j[18]),re[27]=Ge(j[24]),re[28]=Ge(j[31]),re[29]=Ge(j[40]),re[30]=Ge(j[44]),re[31]=Ge(j[53]),re[32]=Ge(j[10]),re[33]=Ge(j[19]),re[34]=Ge(j[23]),re[35]=Ge(j[32]),re[36]=Ge(j[39]),re[37]=Ge(j[45]),re[38]=Ge(j[52]),re[39]=Ge(j[54]),re[40]=Ge(j[20]),re[41]=Ge(j[22]),re[42]=Ge(j[33]),re[43]=Ge(j[38]),re[44]=Ge(j[46]),re[45]=Ge(j[51]),re[46]=Ge(j[55]),re[47]=Ge(j[60]),re[48]=Ge(j[21]),re[49]=Ge(j[34]),re[50]=Ge(j[37]),re[51]=Ge(j[47]),re[52]=Ge(j[50]),re[53]=Ge(j[56]),re[54]=Ge(j[59]),re[55]=Ge(j[61]),re[56]=Ge(j[35]),re[57]=Ge(j[36]),re[58]=Ge(j[48]),re[59]=Ge(j[49]),re[60]=Ge(j[57]),re[61]=Ge(j[58]),re[62]=Ge(j[62]),re[63]=Ge(j[63])}function oe(j){const re=.5*Math.cos(.7853975),be=.5*Math.cos(3.14159/16),H=.5*Math.cos(3.14159/8),ae=.5*Math.cos(3*3.14159/16),ue=.5*Math.cos(5*3.14159/16),xe=.5*Math.cos(3*3.14159/8),me=.5*Math.cos(7*3.14159/16);for(var We=new Array(4),Ye=new Array(4),et=new Array(4),Ue=new Array(4),Bt=0;Bt<8;++Bt){var dt=Bt*8;We[0]=H*j[dt+2],We[1]=xe*j[dt+2],We[2]=H*j[dt+6],We[3]=xe*j[dt+6],Ye[0]=be*j[dt+1]+ae*j[dt+3]+ue*j[dt+5]+me*j[dt+7],Ye[1]=ae*j[dt+1]-me*j[dt+3]-be*j[dt+5]-ue*j[dt+7],Ye[2]=ue*j[dt+1]-be*j[dt+3]+me*j[dt+5]+ae*j[dt+7],Ye[3]=me*j[dt+1]-ue*j[dt+3]+ae*j[dt+5]-be*j[dt+7],et[0]=re*(j[dt+0]+j[dt+4]),et[3]=re*(j[dt+0]-j[dt+4]),et[1]=We[0]+We[3],et[2]=We[1]-We[2],Ue[0]=et[0]+et[1],Ue[1]=et[3]+et[2],Ue[2]=et[3]-et[2],Ue[3]=et[0]-et[1],j[dt+0]=Ue[0]+Ye[0],j[dt+1]=Ue[1]+Ye[1],j[dt+2]=Ue[2]+Ye[2],j[dt+3]=Ue[3]+Ye[3],j[dt+4]=Ue[3]-Ye[3],j[dt+5]=Ue[2]-Ye[2],j[dt+6]=Ue[1]-Ye[1],j[dt+7]=Ue[0]-Ye[0]}for(var gt=0;gt<8;++gt)We[0]=H*j[16+gt],We[1]=xe*j[16+gt],We[2]=H*j[48+gt],We[3]=xe*j[48+gt],Ye[0]=be*j[8+gt]+ae*j[24+gt]+ue*j[40+gt]+me*j[56+gt],Ye[1]=ae*j[8+gt]-me*j[24+gt]-be*j[40+gt]-ue*j[56+gt],Ye[2]=ue*j[8+gt]-be*j[24+gt]+me*j[40+gt]+ae*j[56+gt],Ye[3]=me*j[8+gt]-ue*j[24+gt]+ae*j[40+gt]-be*j[56+gt],et[0]=re*(j[gt]+j[32+gt]),et[3]=re*(j[gt]-j[32+gt]),et[1]=We[0]+We[3],et[2]=We[1]-We[2],Ue[0]=et[0]+et[1],Ue[1]=et[3]+et[2],Ue[2]=et[3]-et[2],Ue[3]=et[0]-et[1],j[0+gt]=Ue[0]+Ye[0],j[8+gt]=Ue[1]+Ye[1],j[16+gt]=Ue[2]+Ye[2],j[24+gt]=Ue[3]+Ye[3],j[32+gt]=Ue[3]-Ye[3],j[40+gt]=Ue[2]-Ye[2],j[48+gt]=Ue[1]-Ye[1],j[56+gt]=Ue[0]-Ye[0]}function ee(j){for(var re=0;re<64;++re){var be=j[0][re],H=j[1][re],ae=j[2][re];j[0][re]=be+1.5747*ae,j[1][re]=be-.1873*H-.4682*ae,j[2][re]=be+1.8556*H}}function Le(j,re,be){for(var H=0;H<64;++H)re[be+H]=xp.toHalfFloat(at(j[H]))}function at(j){return j<=1?Math.sign(j)*Math.pow(Math.abs(j),2.2):Math.sign(j)*Math.pow(k,Math.abs(j)-1)}function ut(j){return new DataView(j.array.buffer,j.offset.value,j.size)}function ot(j){var re=j.viewer.buffer.slice(j.offset.value,j.offset.value+j.size),be=new Uint8Array(it(re)),H=new Uint8Array(be.length);return nt(be),Xe(be,H),new DataView(H.buffer)}function $t(j){var re=j.array.slice(j.offset.value,j.offset.value+j.size),be=lS(re),H=new Uint8Array(be.length);return nt(be),Xe(be,H),new DataView(H.buffer)}function bt(j){for(var re=j.viewer,be={value:j.offset.value},H=new Uint16Array(j.width*j.scanlineBlockSize*(j.channels*j.type)),ae=new Uint8Array(8192),ue=0,xe=new Array(j.channels),me=0;me<j.channels;me++)xe[me]={},xe[me].start=ue,xe[me].end=xe[me].start,xe[me].nx=j.width,xe[me].ny=j.lines,xe[me].size=j.type,ue+=xe[me].nx*xe[me].ny*xe[me].size;var We=_e(re,be),Ye=_e(re,be);if(Ye>=8192)throw"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";if(We<=Ye)for(var me=0;me<Ye-We+1;me++)ae[me+We]=cn(re,be);var et=new Uint16Array(65536),Ue=R(ae,et),Bt=Ft(re,be);ct(j.array,re,be,Bt,H,ue);for(var me=0;me<j.channels;++me)for(var dt=xe[me],gt=0;gt<xe[me].size;++gt)Ke(H,dt.start+gt,dt.nx,dt.size,dt.ny,dt.nx*dt.size,Ue);fe(et,H,ue);for(var Ut=0,tn=new Uint8Array(H.buffer.byteLength),on=0;on<j.lines;on++)for(var vn=0;vn<j.channels;vn++){var dt=xe[vn],kt=dt.nx*dt.size,Ct=new Uint8Array(H.buffer,dt.end*2,kt*2);tn.set(Ct,Ut),Ut+=kt*2,dt.end+=kt}return new DataView(tn.buffer)}function It(j){var re=j.array.slice(j.offset.value,j.offset.value+j.size),be=lS(re);const H=j.lines*j.channels*j.width,ae=j.type==1?new Uint16Array(H):new Uint32Array(H);let ue=0,xe=0;const me=new Array(4);for(let We=0;We<j.lines;We++)for(let Ye=0;Ye<j.channels;Ye++){let et=0;switch(j.type){case 1:me[0]=ue,me[1]=me[0]+j.width,ue=me[1]+j.width;for(let Ue=0;Ue<j.width;++Ue){const Bt=be[me[0]++]<<8|be[me[1]++];et+=Bt,ae[xe]=et,xe++}break;case 2:me[0]=ue,me[1]=me[0]+j.width,me[2]=me[1]+j.width,ue=me[2]+j.width;for(let Ue=0;Ue<j.width;++Ue){const Bt=be[me[0]++]<<24|be[me[1]++]<<16|be[me[2]++]<<8;et+=Bt,ae[xe]=et,xe++}break}}return new DataView(ae.buffer)}function Gt(j){var re=j.viewer,be={value:j.offset.value},H=new Uint8Array(j.width*j.lines*(j.channels*j.type*2)),ae={version:bn(re,be),unknownUncompressedSize:bn(re,be),unknownCompressedSize:bn(re,be),acCompressedSize:bn(re,be),dcCompressedSize:bn(re,be),rleCompressedSize:bn(re,be),rleUncompressedSize:bn(re,be),rleRawSize:bn(re,be),totalAcUncompressedCount:bn(re,be),totalDcUncompressedCount:bn(re,be),acCompression:bn(re,be)};if(ae.version<2)throw"EXRLoader.parse: "+ii.compression+" version "+ae.version+" is unsupported";for(var ue=new Array,xe=_e(re,be)-2;xe>0;){var me=rn(re.buffer,be),We=cn(re,be),Ye=We>>2&3,et=(We>>4)-1,Ue=new Int8Array([et])[0],Bt=cn(re,be);ue.push({name:me,index:Ue,type:Bt,compression:Ye}),xe-=me.length+3}for(var dt=ii.channels,gt=new Array(j.channels),Ut=0;Ut<j.channels;++Ut){var tn=gt[Ut]={},on=dt[Ut];tn.name=on.name,tn.compression=0,tn.decoded=!1,tn.type=on.pixelType,tn.pLinear=on.pLinear,tn.width=j.width,tn.height=j.lines}for(var vn={idx:new Array(3)},kt=0;kt<j.channels;++kt)for(var tn=gt[kt],Ut=0;Ut<ue.length;++Ut){var Ct=ue[Ut];tn.name==Ct.name&&(tn.compression=Ct.compression,Ct.index>=0&&(vn.idx[Ct.index]=kt),tn.offset=kt)}if(ae.acCompressedSize>0)switch(ae.acCompression){case 0:var xn=new Uint16Array(ae.totalAcUncompressedCount);ct(j.array,re,be,ae.acCompressedSize,xn,ae.totalAcUncompressedCount);break;case 1:var mn=j.array.slice(be.value,be.value+ae.totalAcUncompressedCount),dn=lS(mn),xn=new Uint16Array(dn.buffer);be.value+=ae.totalAcUncompressedCount;break}if(ae.dcCompressedSize>0){var Tr={array:j.array,offset:be,size:ae.dcCompressedSize},Wr=new Uint16Array($t(Tr).buffer);be.value+=ae.dcCompressedSize}if(ae.rleRawSize>0){var mn=j.array.slice(be.value,be.value+ae.rleCompressedSize),dn=lS(mn),kr=it(dn.buffer);be.value+=ae.rleCompressedSize}for(var Gn=0,Pn=new Array(gt.length),Ut=0;Ut<Pn.length;++Ut)Pn[Ut]=new Array;for(var es=0;es<j.lines;++es)for(var Rn=0;Rn<gt.length;++Rn)Pn[Rn].push(Gn),Gn+=gt[Rn].width*j.type*2;He(vn,Pn,gt,xn,Wr,H);for(var Ut=0;Ut<gt.length;++Ut){var tn=gt[Ut];if(!tn.decoded)switch(tn.compression){case 2:for(var Hn=0,Rr=0,es=0;es<j.lines;++es){for(var eo=Pn[Ut][Hn],Ds=0;Ds<tn.width;++Ds){for(var el=0;el<2*tn.type;++el)H[eo++]=kr[Rr+el*tn.width*tn.height];Rr++}Hn++}break;case 1:default:throw"EXRLoader.parse: unsupported channel compression"}}return new DataView(H.buffer)}function rn(j,re){for(var be=new Uint8Array(j),H=0;be[re.value+H]!=0;)H+=1;var ae=new TextDecoder().decode(be.slice(re.value,re.value+H));return re.value=re.value+H+1,ae}function ht(j,re,be){var H=new TextDecoder().decode(new Uint8Array(j).slice(re.value,re.value+be));return re.value=re.value+be,H}function Nn(j,re){var be=en(j,re),H=Ft(j,re);return[be,H]}function An(j,re){var be=Ft(j,re),H=Ft(j,re);return[be,H]}function en(j,re){var be=j.getInt32(re.value,!0);return re.value=re.value+4,be}function Ft(j,re){var be=j.getUint32(re.value,!0);return re.value=re.value+4,be}function Vt(j,re){var be=j[re.value];return re.value=re.value+1,be}function cn(j,re){var be=j.getUint8(re.value);return re.value=re.value+1,be}const bn=function(j,re){let be;return"getBigInt64"in DataView.prototype?be=Number(j.getBigInt64(re.value,!0)):be=j.getUint32(re.value+4,!0)+Number(j.getUint32(re.value,!0)<<32),re.value+=8,be};function Mn(j,re){var be=j.getFloat32(re.value,!0);return re.value+=4,be}function Tn(j,re){return xp.toHalfFloat(Mn(j,re))}function Ge(j){var re=(j&31744)>>10,be=j&1023;return(j>>15?-1:1)*(re?re===31?be?NaN:1/0:Math.pow(2,re-15)*(1+be/1024):6103515625e-14*(be/1024))}function _e(j,re){var be=j.getUint16(re.value,!0);return re.value+=2,be}function Tt(j,re){return Ge(_e(j,re))}function Mt(j,re,be,H){for(var ae=be.value,ue=[];be.value<ae+H-1;){var xe=rn(re,be),me=en(j,be),We=cn(j,be);be.value+=3;var Ye=en(j,be),et=en(j,be);ue.push({name:xe,pixelType:me,pLinear:We,xSampling:Ye,ySampling:et})}return be.value+=1,ue}function ln(j,re){var be=Mn(j,re),H=Mn(j,re),ae=Mn(j,re),ue=Mn(j,re),xe=Mn(j,re),me=Mn(j,re),We=Mn(j,re),Ye=Mn(j,re);return{redX:be,redY:H,greenX:ae,greenY:ue,blueX:xe,blueY:me,whiteX:We,whiteY:Ye}}function sn(j,re){var be=["NO_COMPRESSION","RLE_COMPRESSION","ZIPS_COMPRESSION","ZIP_COMPRESSION","PIZ_COMPRESSION","PXR24_COMPRESSION","B44_COMPRESSION","B44A_COMPRESSION","DWAA_COMPRESSION","DWAB_COMPRESSION"],H=cn(j,re);return be[H]}function pr(j,re){var be=Ft(j,re),H=Ft(j,re),ae=Ft(j,re),ue=Ft(j,re);return{xMin:be,yMin:H,xMax:ae,yMax:ue}}function ur(j,re){var be=["INCREASING_Y"],H=cn(j,re);return be[H]}function Vr(j,re){var be=Mn(j,re),H=Mn(j,re);return[be,H]}function ms(j,re){var be=Mn(j,re),H=Mn(j,re),ae=Mn(j,re);return[be,H,ae]}function er(j,re,be,H,ae){if(H==="string"||H==="stringvector"||H==="iccProfile")return ht(re,be,ae);if(H==="chlist")return Mt(j,re,be,ae);if(H==="chromaticities")return ln(j,be);if(H==="compression")return sn(j,be);if(H==="box2i")return pr(j,be);if(H==="lineOrder")return ur(j,be);if(H==="float")return Mn(j,be);if(H==="v2f")return Vr(j,be);if(H==="v3f")return ms(j,be);if(H==="int")return en(j,be);if(H==="rational")return Nn(j,be);if(H==="timecode")return An(j,be);if(H==="preview")return be.value+=ae,"skipped";be.value+=ae}function gs(j,re,be){const H={};if(j.getUint32(0,!0)!=20000630)throw"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";H.version=j.getUint8(4);const ae=j.getUint8(5);H.spec={singleTile:!!(ae&2),longName:!!(ae&4),deepFormat:!!(ae&8),multiPart:!!(ae&16)},be.value=8;for(var ue=!0;ue;){var xe=rn(re,be);if(xe==0)ue=!1;else{var me=rn(re,be),We=Ft(j,be),Ye=er(j,re,be,me,We);Ye===void 0?console.warn(`EXRLoader.parse: skipped unknown header attribute type '${me}'.`):H[xe]=Ye}}if((ae&-5)!=0)throw console.error("EXRHeader:",H),"THREE.EXRLoader: provided file is currently unsupported.";return H}function Ws(j,re,be,H,ae){const ue={size:0,viewer:re,array:be,offset:H,width:j.dataWindow.xMax-j.dataWindow.xMin+1,height:j.dataWindow.yMax-j.dataWindow.yMin+1,channels:j.channels.length,bytesPerLine:null,lines:null,inputSize:null,type:j.channels[0].pixelType,uncompress:null,getter:null,format:null,[bv?"colorSpace":"encoding"]:null};switch(j.compression){case"NO_COMPRESSION":ue.lines=1,ue.uncompress=ut;break;case"RLE_COMPRESSION":ue.lines=1,ue.uncompress=ot;break;case"ZIPS_COMPRESSION":ue.lines=1,ue.uncompress=$t;break;case"ZIP_COMPRESSION":ue.lines=16,ue.uncompress=$t;break;case"PIZ_COMPRESSION":ue.lines=32,ue.uncompress=bt;break;case"PXR24_COMPRESSION":ue.lines=16,ue.uncompress=It;break;case"DWAA_COMPRESSION":ue.lines=32,ue.uncompress=Gt;break;case"DWAB_COMPRESSION":ue.lines=256,ue.uncompress=Gt;break;default:throw"EXRLoader.parse: "+j.compression+" is unsupported"}if(ue.scanlineBlockSize=ue.lines,ue.type==1)switch(ae){case Di:ue.getter=Tt,ue.inputSize=2;break;case vo:ue.getter=_e,ue.inputSize=2;break}else if(ue.type==2)switch(ae){case Di:ue.getter=Mn,ue.inputSize=4;break;case vo:ue.getter=Tn,ue.inputSize=4}else throw"EXRLoader.parse: unsupported pixelType "+ue.type+" for "+j.compression+".";ue.blockCount=(j.dataWindow.yMax+1)/ue.scanlineBlockSize;for(var xe=0;xe<ue.blockCount;xe++)bn(re,H);ue.outputChannels=ue.channels==3?4:ue.channels;const me=ue.width*ue.height*ue.outputChannels;switch(ae){case Di:ue.byteArray=new Float32Array(me),ue.channels<ue.outputChannels&&ue.byteArray.fill(1,0,me);break;case vo:ue.byteArray=new Uint16Array(me),ue.channels<ue.outputChannels&&ue.byteArray.fill(15360,0,me);break;default:console.error("THREE.EXRLoader: unsupported type: ",ae);break}return ue.bytesPerLine=ue.width*ue.inputSize*ue.channels,ue.outputChannels==4?ue.format=go:ue.format=SA,bv?ue.colorSpace="srgb-linear":ue.encoding=3e3,ue}const Qa=new DataView(e),Na=new Uint8Array(e),zi={value:0},ii=gs(Qa,e,zi),En=Ws(ii,Qa,Na,zi,this.type),uc={value:0},Sh={R:0,G:1,B:2,A:3,Y:0};for(let j=0;j<En.height/En.scanlineBlockSize;j++){const re=Ft(Qa,zi);En.size=Ft(Qa,zi),En.lines=re+En.scanlineBlockSize>En.height?En.height-re:En.scanlineBlockSize;const H=En.size<En.lines*En.bytesPerLine?En.uncompress(En):ut(En);zi.value+=En.size;for(let ae=0;ae<En.scanlineBlockSize;ae++){const ue=ae+j*En.scanlineBlockSize;if(ue>=En.height)break;for(let xe=0;xe<En.channels;xe++){const me=Sh[ii.channels[xe].name];for(let We=0;We<En.width;We++){uc.value=(ae*(En.channels*En.width)+xe*En.width+We)*En.inputSize;const Ye=(En.height-1-ue)*(En.width*En.outputChannels)+We*En.outputChannels+me;En.byteArray[Ye]=En.getter(H,uc)}}}}return{header:ii,width:En.width,height:En.height,data:En.byteArray,format:En.format,[bv?"colorSpace":"encoding"]:En[bv?"colorSpace":"encoding"],type:this.type}}setDataType(e){return this.type=e,this}load(e,t,r,s){function i(o,a){bv?o.colorSpace=a.colorSpace:o.encoding=a.encoding,o.minFilter=Lr,o.magFilter=Lr,o.generateMipmaps=!1,o.flipY=!1,t&&t(o,a)}return super.load(e,i,r,s)}}function kJ(n,e,t,r){const s=class extends ni{constructor(o={}){const a=Object.entries(n);super({uniforms:a.reduce((l,[u,c])=>{const h=PA.clone({[u]:{value:c}});return{...l,...h}},{}),vertexShader:e,fragmentShader:t}),this.key="",a.forEach(([l])=>Object.defineProperty(this,l,{get:()=>this.uniforms[l].value,set:u=>this.uniforms[l].value=u})),Object.assign(this,o)}};return s.key=Ua.generateUUID(),s}const RJ=()=>parseInt(Vd.replace(/\D+/g,"")),DJ=RJ(),k2={apartment:"lebombo_1k.hdr",city:"potsdamer_platz_1k.hdr",dawn:"kiara_1_dawn_1k.hdr",forest:"forest_slope_1k.hdr",lobby:"st_fagans_interior_1k.hdr",night:"dikhololo_night_1k.hdr",park:"rooitou_park_1k.hdr",studio:"studio_small_03_1k.hdr",sunset:"venice_sunset_1k.hdr",warehouse:"empty_warehouse_01_1k.hdr"},$J="https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",hP=n=>Array.isArray(n);function _B({files:n=["/px.png","/nx.png","/py.png","/ny.png","/pz.png","/nz.png"],path:e="",preset:t=void 0,encoding:r=void 0,extensions:s}={}){var i;let o=null,a=!1,l;if(t){if(!(t in k2))throw new Error("Preset must be one of: "+Object.keys(k2).join(", "));n=k2[t],e=$J}if(a=hP(n),l=hP(n)?"cube":n.startsWith("data:application/exr")?"exr":n.startsWith("data:application/hdr")?"hdr":(i=n.split(".").pop())==null||(i=i.split("?"))==null||(i=i.shift())==null?void 0:i.toLowerCase(),o=a?$z:l==="hdr"?AJ:l==="exr"?MJ:null,!o)throw new Error("useEnvironment: Unrecognized file extension: "+n);const u=fT(o,a?[n]:n,p=>{p.setPath==null||p.setPath(e),s&&s(p)}),c=a?u[0]:u;c.mapping=a?tc:my;const h=3001,d=3e3;return"colorSpace"in c?c.colorSpace=r??a?"srgb":"srgb-linear":c.encoding=r??a?h:d,c}const PJ=n=>n.current&&n.current.isScene,LJ=n=>PJ(n)?n.current:n;function fM(n,e,t,r,s=0){const i=LJ(e||t),o=i.background,a=i.environment,l=i.backgroundBlurriness||0;return n!=="only"&&(i.environment=r),n&&(i.background=r),n&&i.backgroundBlurriness!==void 0&&(i.backgroundBlurriness=s),()=>{n!=="only"&&(i.environment=a),n&&(i.background=o),n&&i.backgroundBlurriness!==void 0&&(i.backgroundBlurriness=l)}}function pM({scene:n,background:e=!1,blur:t,map:r}){const s=wl(i=>i.scene);return we.useLayoutEffect(()=>{if(r)return fM(e,n,s,r,t)},[s,n,r,e,t]),null}function TB({background:n=!1,scene:e,blur:t,...r}){const s=_B(r),i=wl(o=>o.scene);return we.useLayoutEffect(()=>fM(n,e,i,s,t),[s,n,e,i,t]),null}function OJ({children:n,near:e=1,far:t=1e3,resolution:r=256,frames:s=1,map:i,background:o=!1,blur:a,scene:l,files:u,path:c,preset:h=void 0,extensions:d}){const p=wl(T=>T.gl),g=wl(T=>T.scene),w=we.useRef(null),[y]=we.useState(()=>new Lp),x=we.useMemo(()=>{const T=new LA(r);return T.texture.type=vo,T},[r]);we.useLayoutEffect(()=>(s===1&&w.current.update(p,y),fM(o,l,g,x.texture,a)),[n,y,x.texture,l,g,o,s,p]);let _=1;return Ka(()=>{(s===1/0||_<s)&&(w.current.update(p,y),_++)}),we.createElement(we.Fragment,null,qZ(we.createElement(we.Fragment,null,n,we.createElement("cubeCamera",{ref:w,args:[e,t,x]}),u||h?we.createElement(TB,{background:!0,files:u,preset:h,path:c,extensions:d}):i?we.createElement(pM,{background:!0,map:i,extensions:d}):null),y))}function FJ(n){var e,t,r,s;const i=_B(n),o=n.map||i;we.useMemo(()=>dT({GroundProjectedEnvImpl:NJ}),[]);const a=we.useMemo(()=>[o],[o]),l=(e=n.ground)==null?void 0:e.height,u=(t=n.ground)==null?void 0:t.radius,c=(r=(s=n.ground)==null?void 0:s.scale)!==null&&r!==void 0?r:1e3;return we.createElement(we.Fragment,null,we.createElement(pM,by({},n,{map:o})),we.createElement("groundProjectedEnvImpl",{args:a,scale:c,height:l,radius:u}))}function zJ(n){return n.ground?we.createElement(FJ,n):n.map?we.createElement(pM,n):n.children?we.createElement(OJ,n):we.createElement(TB,n)}const BJ=kJ({time:0,pixelRatio:1},` uniform float pixelRatio;
    uniform float time;
    attribute float size;  
    attribute float speed;  
    attribute float opacity;
    attribute vec3 noise;
    attribute vec3 color;
    varying vec3 vColor;
    varying float vOpacity;
    void main() {
      vec4 modelPosition = modelMatrix * vec4(position, 1.0);
      modelPosition.y += sin(time * speed + modelPosition.x * noise.x * 100.0) * 0.2;
      modelPosition.z += cos(time * speed + modelPosition.x * noise.y * 100.0) * 0.2;
      modelPosition.x += cos(time * speed + modelPosition.x * noise.z * 100.0) * 0.2;
      vec4 viewPosition = viewMatrix * modelPosition;
      vec4 projectionPostion = projectionMatrix * viewPosition;
      gl_Position = projectionPostion;
      gl_PointSize = size * 25. * pixelRatio;
      gl_PointSize *= (1.0 / - viewPosition.z);
      vColor = color;
      vOpacity = opacity;
    }`,` varying vec3 vColor;
    varying float vOpacity;
    void main() {
      float distanceToCenter = distance(gl_PointCoord, vec2(0.5));
      float strength = 0.05 / distanceToCenter - 0.1;
      gl_FragColor = vec4(vColor, strength * vOpacity);
      #include <tonemapping_fragment>
      #include <${DJ>=154?"colorspace_fragment":"encodings_fragment"}>
    }`),EB=n=>n&&n.constructor===Float32Array,UJ=n=>[n.r,n.g,n.b],CB=n=>n instanceof rt||n instanceof le||n instanceof br,IB=n=>Array.isArray(n)?n:CB(n)?n.toArray():[n,n,n];function Sv(n,e,t){return we.useMemo(()=>{if(e!==void 0){if(EB(e))return e;if(e instanceof Nt){const r=Array.from({length:n*3},()=>UJ(e)).flat();return Float32Array.from(r)}else if(CB(e)||Array.isArray(e)){const r=Array.from({length:n*3},()=>IB(e)).flat();return Float32Array.from(r)}return Float32Array.from({length:n},()=>e)}return Float32Array.from({length:n},t)},[e])}const VJ=we.forwardRef(({noise:n=1,count:e=100,speed:t=1,opacity:r=1,scale:s=1,size:i,color:o,children:a,...l},u)=>{we.useMemo(()=>dT({SparklesImplMaterial:BJ}),[]);const c=we.useRef(null),h=wl(T=>T.viewport.dpr),d=IB(s),p=we.useMemo(()=>Float32Array.from(Array.from({length:e},()=>d.map(Ua.randFloatSpread)).flat()),[e,...d]),g=Sv(e,i,Math.random),w=Sv(e,r),y=Sv(e,t),x=Sv(e*3,n),_=Sv(o===void 0?e*3:e,EB(o)?o:new Nt(o),()=>1);return Ka(T=>{c.current&&c.current.material&&(c.current.material.time=T.clock.elapsedTime)}),we.useImperativeHandle(u,()=>c.current,[]),we.createElement("points",by({key:`particle-${e}-${JSON.stringify(s)}`},l,{ref:c}),we.createElement("bufferGeometry",null,we.createElement("bufferAttribute",{attach:"attributes-position",args:[p,3]}),we.createElement("bufferAttribute",{attach:"attributes-size",args:[g,1]}),we.createElement("bufferAttribute",{attach:"attributes-opacity",args:[w,1]}),we.createElement("bufferAttribute",{attach:"attributes-speed",args:[y,1]}),we.createElement("bufferAttribute",{attach:"attributes-color",args:[_,3]}),we.createElement("bufferAttribute",{attach:"attributes-noise",args:[x,3]})),a||we.createElement("sparklesImplMaterial",{transparent:!0,pixelRatio:h,depthWrite:!1}))});/**
 * postprocessing v6.38.0 build Sat Nov 08 2025
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2025 Raoul van Rschen
 * @license Zlib
 */var R2=1/1e3,WJ=1e3,GJ=class{constructor(){this.startTime=performance.now(),this.previousTime=0,this.currentTime=0,this._delta=0,this._elapsed=0,this._fixedDelta=1e3/60,this.timescale=1,this.useFixedDelta=!1,this._autoReset=!1}get autoReset(){return this._autoReset}set autoReset(n){typeof document<"u"&&document.hidden!==void 0&&(n?document.addEventListener("visibilitychange",this):document.removeEventListener("visibilitychange",this),this._autoReset=n)}get delta(){return this._delta*R2}get fixedDelta(){return this._fixedDelta*R2}set fixedDelta(n){this._fixedDelta=n*WJ}get elapsed(){return this._elapsed*R2}update(n){this.useFixedDelta?this._delta=this.fixedDelta:(this.previousTime=this.currentTime,this.currentTime=(n!==void 0?n:performance.now())-this.startTime,this._delta=this.currentTime-this.previousTime),this._delta*=this.timescale,this._elapsed+=this._delta}reset(){this._delta=0,this._elapsed=0,this.currentTime=performance.now()-this.startTime}getDelta(){return this.delta}getElapsed(){return this.elapsed}handleEvent(n){document.hidden||(this.currentTime=performance.now()-this.startTime)}dispose(){this.autoReset=!1}},HJ=(()=>{const n=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),e=new Float32Array([0,0,2,0,0,2]),t=new zn;return t.setAttribute("position",new Cr(n,3)),t.setAttribute("uv",new Cr(e,2)),t})(),Ia=class nN{static get fullscreenGeometry(){return HJ}constructor(e="Pass",t=new Lp,r=new zy){this.name=e,this.renderer=null,this.scene=t,this.camera=r,this.screen=null,this.rtt=!0,this.needsSwap=!0,this.needsDepthTexture=!1,this.enabled=!0}get renderToScreen(){return!this.rtt}set renderToScreen(e){if(this.rtt===e){const t=this.fullscreenMaterial;t!==null&&(t.needsUpdate=!0),this.rtt=!e}}set mainScene(e){}set mainCamera(e){}setRenderer(e){this.renderer=e}isEnabled(){return this.enabled}setEnabled(e){this.enabled=e}get fullscreenMaterial(){return this.screen!==null?this.screen.material:null}set fullscreenMaterial(e){let t=this.screen;t!==null?t.material=e:(t=new zs(nN.fullscreenGeometry,e),t.frustumCulled=!1,this.scene===null&&(this.scene=new Lp),this.scene.add(t),this.screen=t)}getFullscreenMaterial(){return this.fullscreenMaterial}setFullscreenMaterial(e){this.fullscreenMaterial=e}getDepthTexture(){return null}setDepthTexture(e,t=Wd){}render(e,t,r,s,i){throw new Error("Render method not implemented!")}setSize(e,t){}initialize(e,t,r){}dispose(){for(const e of Object.keys(this)){const t=this[e];(t instanceof Us||t instanceof Si||t instanceof fs||t instanceof nN)&&this[e].dispose()}this.fullscreenMaterial!==null&&this.fullscreenMaterial.dispose()}},jJ=class extends Ia{constructor(){super("ClearMaskPass",null,null),this.needsSwap=!1}render(n,e,t,r,s){const i=n.state.buffers.stencil;i.setLocked(!1),i.setTest(!1)}},XJ=`#ifdef COLOR_WRITE
#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#endif
#ifdef DEPTH_WRITE
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}
#endif
#ifdef USE_WEIGHTS
uniform vec4 channelWeights;
#endif
uniform float opacity;varying vec2 vUv;void main(){
#ifdef COLOR_WRITE
vec4 texel=texture2D(inputBuffer,vUv);
#ifdef USE_WEIGHTS
texel*=channelWeights;
#endif
gl_FragColor=opacity*texel;
#ifdef COLOR_SPACE_CONVERSION
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
#else
gl_FragColor=vec4(0.0);
#endif
#ifdef DEPTH_WRITE
gl_FragDepth=readDepth(vUv);
#endif
}`,NB="varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",AB=class extends ni{constructor(){super({name:"CopyMaterial",defines:{DEPTH_PACKING:"0",COLOR_WRITE:"1"},uniforms:{inputBuffer:new Jn(null),depthBuffer:new Jn(null),channelWeights:new Jn(null),opacity:new Jn(1)},blending:wo,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:XJ,vertexShader:NB}),this.depthFunc=yA}get inputBuffer(){return this.uniforms.inputBuffer.value}set inputBuffer(n){const e=n!==null;this.colorWrite!==e&&(e?this.defines.COLOR_WRITE=!0:delete this.defines.COLOR_WRITE,this.colorWrite=e,this.needsUpdate=!0),this.uniforms.inputBuffer.value=n}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(n){const e=n!==null;this.depthWrite!==e&&(e?this.defines.DEPTH_WRITE=!0:delete this.defines.DEPTH_WRITE,this.depthTest=e,this.depthWrite=e,this.needsUpdate=!0),this.uniforms.depthBuffer.value=n}set depthPacking(n){this.defines.DEPTH_PACKING=n.toFixed(0),this.needsUpdate=!0}get channelWeights(){return this.uniforms.channelWeights.value}set channelWeights(n){n!==null?(this.defines.USE_WEIGHTS="1",this.uniforms.channelWeights.value=n):delete this.defines.USE_WEIGHTS,this.needsUpdate=!0}setInputBuffer(n){this.uniforms.inputBuffer.value=n}getOpacity(n){return this.uniforms.opacity.value}setOpacity(n){this.uniforms.opacity.value=n}},qJ=class extends Ia{constructor(n,e=!0){super("CopyPass"),this.fullscreenMaterial=new AB,this.needsSwap=!1,this.renderTarget=n,n===void 0&&(this.renderTarget=new Us(1,1,{minFilter:Lr,magFilter:Lr,stencilBuffer:!1,depthBuffer:!1}),this.renderTarget.texture.name="CopyPass.Target"),this.autoResize=e}get resize(){return this.autoResize}set resize(n){this.autoResize=n}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}setAutoResizeEnabled(n){this.autoResize=n}render(n,e,t,r,s){this.fullscreenMaterial.inputBuffer=e.texture,n.setRenderTarget(this.renderToScreen?null:this.renderTarget),n.render(this.scene,this.camera)}setSize(n,e){this.autoResize&&this.renderTarget.setSize(n,e)}initialize(n,e,t){t!==void 0&&(this.renderTarget.texture.type=t,t!==Ki?this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1":n!==null&&n.outputColorSpace===sr&&(this.renderTarget.texture.colorSpace=sr))}},dP=new Nt,MB=class extends Ia{constructor(n=!0,e=!0,t=!1){super("ClearPass",null,null),this.needsSwap=!1,this.color=n,this.depth=e,this.stencil=t,this.overrideClearColor=null,this.overrideClearAlpha=-1}setClearFlags(n,e,t){this.color=n,this.depth=e,this.stencil=t}getOverrideClearColor(){return this.overrideClearColor}setOverrideClearColor(n){this.overrideClearColor=n}getOverrideClearAlpha(){return this.overrideClearAlpha}setOverrideClearAlpha(n){this.overrideClearAlpha=n}render(n,e,t,r,s){const i=this.overrideClearColor,o=this.overrideClearAlpha,a=n.getClearAlpha(),l=i!==null,u=o>=0;l?(n.getClearColor(dP),n.setClearColor(i,u?o:a)):u&&n.setClearAlpha(o),n.setRenderTarget(this.renderToScreen?null:e),n.clear(this.color,this.depth,this.stencil),l?n.setClearColor(dP,a):u&&n.setClearAlpha(a)}},KJ=class extends Ia{constructor(n,e){super("MaskPass",n,e),this.needsSwap=!1,this.clearPass=new MB(!1,!1,!0),this.inverse=!1}set mainScene(n){this.scene=n}set mainCamera(n){this.camera=n}get inverted(){return this.inverse}set inverted(n){this.inverse=n}get clear(){return this.clearPass.enabled}set clear(n){this.clearPass.enabled=n}getClearPass(){return this.clearPass}isInverted(){return this.inverted}setInverted(n){this.inverted=n}render(n,e,t,r,s){const i=n.getContext(),o=n.state.buffers,a=this.scene,l=this.camera,u=this.clearPass,c=this.inverted?0:1,h=1-c;o.color.setMask(!1),o.depth.setMask(!1),o.color.setLocked(!0),o.depth.setLocked(!0),o.stencil.setTest(!0),o.stencil.setOp(i.REPLACE,i.REPLACE,i.REPLACE),o.stencil.setFunc(i.ALWAYS,c,4294967295),o.stencil.setClear(h),o.stencil.setLocked(!0),this.clearPass.enabled&&(this.renderToScreen?u.render(n,null):(u.render(n,e),u.render(n,t))),this.renderToScreen?(n.setRenderTarget(null),n.render(a,l)):(n.setRenderTarget(e),n.render(a,l),n.setRenderTarget(t),n.render(a,l)),o.color.setLocked(!1),o.depth.setLocked(!1),o.stencil.setLocked(!1),o.stencil.setFunc(i.EQUAL,1,4294967295),o.stencil.setOp(i.KEEP,i.KEEP,i.KEEP),o.stencil.setLocked(!0)}},YJ=class{constructor(e=null,{depthBuffer:t=!0,stencilBuffer:r=!1,multisampling:s=0,frameBufferType:i}={}){this.renderer=null,this.inputBuffer=this.createBuffer(t,r,i,s),this.outputBuffer=this.inputBuffer.clone(),this.copyPass=new qJ,this.depthTexture=null,this.passes=[],this.timer=new GJ,this.autoRenderToScreen=!0,this.setRenderer(e)}get multisampling(){return this.inputBuffer.samples||0}set multisampling(e){const t=this.inputBuffer,r=this.multisampling;r>0&&e>0?(this.inputBuffer.samples=e,this.outputBuffer.samples=e,this.inputBuffer.dispose(),this.outputBuffer.dispose()):r!==e&&(this.inputBuffer.dispose(),this.outputBuffer.dispose(),this.inputBuffer=this.createBuffer(t.depthBuffer,t.stencilBuffer,t.texture.type,e),this.inputBuffer.depthTexture=this.depthTexture,this.outputBuffer=this.inputBuffer.clone())}getTimer(){return this.timer}getRenderer(){return this.renderer}setRenderer(e){if(this.renderer=e,e!==null){const t=e.getSize(new rt),r=e.getContext().getContextAttributes().alpha,s=this.inputBuffer.texture.type;s===Ki&&e.outputColorSpace===sr&&(this.inputBuffer.texture.colorSpace=sr,this.outputBuffer.texture.colorSpace=sr,this.inputBuffer.dispose(),this.outputBuffer.dispose()),e.autoClear=!1,this.setSize(t.width,t.height);for(const i of this.passes)i.initialize(e,r,s)}}replaceRenderer(e,t=!0){const r=this.renderer,s=r.domElement.parentNode;return this.setRenderer(e),t&&s!==null&&(s.removeChild(r.domElement),s.appendChild(e.domElement)),r}createDepthTexture(){const e=this.depthTexture=new X_;return this.inputBuffer.depthTexture=e,this.inputBuffer.dispose(),this.inputBuffer.stencilBuffer?(e.format=Md,e.type=rh):e.type=Vu,e}deleteDepthTexture(){if(this.depthTexture!==null){this.depthTexture.dispose(),this.depthTexture=null,this.inputBuffer.depthTexture=null,this.inputBuffer.dispose();for(const e of this.passes)e.setDepthTexture(null)}}createBuffer(e,t,r,s){const i=this.renderer,o=i===null?new rt:i.getDrawingBufferSize(new rt),a={minFilter:Lr,magFilter:Lr,stencilBuffer:t,depthBuffer:e,type:r},l=new Us(o.width,o.height,a);return s>0&&(l.samples=s),r===Ki&&i!==null&&i.outputColorSpace===sr&&(l.texture.colorSpace=sr),l.texture.name="EffectComposer.Buffer",l.texture.generateMipmaps=!1,l}setMainScene(e){for(const t of this.passes)t.mainScene=e}setMainCamera(e){for(const t of this.passes)t.mainCamera=e}addPass(e,t){const r=this.passes,s=this.renderer,i=s.getDrawingBufferSize(new rt),o=s.getContext().getContextAttributes().alpha,a=this.inputBuffer.texture.type;if(e.setRenderer(s),e.setSize(i.width,i.height),e.initialize(s,o,a),this.autoRenderToScreen&&(r.length>0&&(r[r.length-1].renderToScreen=!1),e.renderToScreen&&(this.autoRenderToScreen=!1)),t!==void 0?r.splice(t,0,e):r.push(e),this.autoRenderToScreen&&(r[r.length-1].renderToScreen=!0),e.needsDepthTexture||this.depthTexture!==null)if(this.depthTexture===null){const l=this.createDepthTexture();for(e of r)e.setDepthTexture(l)}else e.setDepthTexture(this.depthTexture)}removePass(e){const t=this.passes,r=t.indexOf(e);if(r!==-1&&t.splice(r,1).length>0){if(this.depthTexture!==null){const o=(l,u)=>l||u.needsDepthTexture;t.reduce(o,!1)||(e.getDepthTexture()===this.depthTexture&&e.setDepthTexture(null),this.deleteDepthTexture())}this.autoRenderToScreen&&r===t.length&&(e.renderToScreen=!1,t.length>0&&(t[t.length-1].renderToScreen=!0))}}removeAllPasses(){const e=this.passes;this.deleteDepthTexture(),e.length>0&&(this.autoRenderToScreen&&(e[e.length-1].renderToScreen=!1),this.passes=[])}render(e){const t=this.renderer,r=this.copyPass;let s=this.inputBuffer,i=this.outputBuffer,o=!1,a,l,u;e===void 0&&(this.timer.update(),e=this.timer.getDelta());for(const c of this.passes)c.enabled&&(c.render(t,s,i,e,o),c.needsSwap&&(o&&(r.renderToScreen=c.renderToScreen,a=t.getContext(),l=t.state.buffers.stencil,l.setFunc(a.NOTEQUAL,1,4294967295),r.render(t,s,i,e,o),l.setFunc(a.EQUAL,1,4294967295)),u=s,s=i,i=u),c instanceof KJ?o=!0:c instanceof jJ&&(o=!1))}setSize(e,t,r){const s=this.renderer,i=s.getSize(new rt);(e===void 0||t===void 0)&&(e=i.width,t=i.height),(i.width!==e||i.height!==t)&&s.setSize(e,t,r);const o=s.getDrawingBufferSize(new rt);this.inputBuffer.setSize(o.width,o.height),this.outputBuffer.setSize(o.width,o.height);for(const a of this.passes)a.setSize(o.width,o.height)}reset(){this.dispose(),this.autoRenderToScreen=!0}dispose(){for(const e of this.passes)e.dispose();this.passes=[],this.inputBuffer!==null&&this.inputBuffer.dispose(),this.outputBuffer!==null&&this.outputBuffer.dispose(),this.deleteDepthTexture(),this.copyPass.dispose(),this.timer.dispose(),Ia.fullscreenGeometry.dispose()}},ih={NONE:0,DEPTH:1,CONVOLUTION:2},xr={FRAGMENT_HEAD:"FRAGMENT_HEAD",FRAGMENT_MAIN_UV:"FRAGMENT_MAIN_UV",FRAGMENT_MAIN_IMAGE:"FRAGMENT_MAIN_IMAGE",VERTEX_HEAD:"VERTEX_HEAD",VERTEX_MAIN_SUPPORT:"VERTEX_MAIN_SUPPORT"},ZJ=class{constructor(){this.shaderParts=new Map([[xr.FRAGMENT_HEAD,null],[xr.FRAGMENT_MAIN_UV,null],[xr.FRAGMENT_MAIN_IMAGE,null],[xr.VERTEX_HEAD,null],[xr.VERTEX_MAIN_SUPPORT,null]]),this.defines=new Map,this.uniforms=new Map,this.blendModes=new Map,this.extensions=new Set,this.attributes=ih.NONE,this.varyings=new Set,this.uvTransformation=!1,this.readDepth=!1,this.colorSpace=xl}},D2=!1,fP=class{constructor(n=null){this.originalMaterials=new Map,this.material=null,this.materials=null,this.materialsBackSide=null,this.materialsDoubleSide=null,this.materialsFlatShaded=null,this.materialsFlatShadedBackSide=null,this.materialsFlatShadedDoubleSide=null,this.setMaterial(n),this.meshCount=0,this.replaceMaterial=e=>{if(e.isMesh){let t;if(e.material.flatShading)switch(e.material.side){case Wo:t=this.materialsFlatShadedDoubleSide;break;case yi:t=this.materialsFlatShadedBackSide;break;default:t=this.materialsFlatShaded;break}else switch(e.material.side){case Wo:t=this.materialsDoubleSide;break;case yi:t=this.materialsBackSide;break;default:t=this.materials;break}this.originalMaterials.set(e,e.material),e.isSkinnedMesh?e.material=t[2]:e.isInstancedMesh?e.material=t[1]:e.material=t[0],++this.meshCount}}}cloneMaterial(n){if(!(n instanceof ni))return n.clone();const e=n.uniforms,t=new Map;for(const s in e){const i=e[s].value;i.isRenderTargetTexture&&(e[s].value=null,t.set(s,i))}const r=n.clone();for(const s of t)e[s[0]].value=s[1],r.uniforms[s[0]].value=s[1];return r}setMaterial(n){if(this.disposeMaterials(),this.material=n,n!==null){const e=this.materials=[this.cloneMaterial(n),this.cloneMaterial(n),this.cloneMaterial(n)];for(const t of e)t.uniforms=Object.assign({},n.uniforms),t.side=ec;e[2].skinning=!0,this.materialsBackSide=e.map(t=>{const r=this.cloneMaterial(t);return r.uniforms=Object.assign({},n.uniforms),r.side=yi,r}),this.materialsDoubleSide=e.map(t=>{const r=this.cloneMaterial(t);return r.uniforms=Object.assign({},n.uniforms),r.side=Wo,r}),this.materialsFlatShaded=e.map(t=>{const r=this.cloneMaterial(t);return r.uniforms=Object.assign({},n.uniforms),r.flatShading=!0,r}),this.materialsFlatShadedBackSide=e.map(t=>{const r=this.cloneMaterial(t);return r.uniforms=Object.assign({},n.uniforms),r.flatShading=!0,r.side=yi,r}),this.materialsFlatShadedDoubleSide=e.map(t=>{const r=this.cloneMaterial(t);return r.uniforms=Object.assign({},n.uniforms),r.flatShading=!0,r.side=Wo,r})}}render(n,e,t){const r=n.shadowMap.enabled;if(n.shadowMap.enabled=!1,D2){const s=this.originalMaterials;this.meshCount=0,e.traverse(this.replaceMaterial),n.render(e,t);for(const i of s)i[0].material=i[1];this.meshCount!==s.size&&s.clear()}else{const s=e.overrideMaterial;e.overrideMaterial=this.material,n.render(e,t),e.overrideMaterial=s}n.shadowMap.enabled=r}disposeMaterials(){if(this.material!==null){const n=this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);for(const e of n)e.dispose()}}dispose(){this.originalMaterials.clear(),this.disposeMaterials()}static get workaroundEnabled(){return D2}static set workaroundEnabled(n){D2=n}},cd=-1,xo=class extends Tl{constructor(n,e=cd,t=cd,r=1){super(),this.resizable=n,this.baseSize=new rt(1,1),this.preferredSize=new rt(e,t),this.target=this.preferredSize,this.s=r,this.effectiveSize=new rt,this.addEventListener("change",()=>this.updateEffectiveSize()),this.updateEffectiveSize()}updateEffectiveSize(){const n=this.baseSize,e=this.preferredSize,t=this.effectiveSize,r=this.scale;e.width!==cd?t.width=e.width:e.height!==cd?t.width=Math.round(e.height*(n.width/Math.max(n.height,1))):t.width=Math.round(n.width*r),e.height!==cd?t.height=e.height:e.width!==cd?t.height=Math.round(e.width/Math.max(n.width/Math.max(n.height,1),1)):t.height=Math.round(n.height*r)}get width(){return this.effectiveSize.width}set width(n){this.preferredWidth=n}get height(){return this.effectiveSize.height}set height(n){this.preferredHeight=n}getWidth(){return this.width}getHeight(){return this.height}get scale(){return this.s}set scale(n){this.s!==n&&(this.s=n,this.preferredSize.setScalar(cd),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getScale(){return this.scale}setScale(n){this.scale=n}get baseWidth(){return this.baseSize.width}set baseWidth(n){this.baseSize.width!==n&&(this.baseSize.width=n,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseWidth(){return this.baseWidth}setBaseWidth(n){this.baseWidth=n}get baseHeight(){return this.baseSize.height}set baseHeight(n){this.baseSize.height!==n&&(this.baseSize.height=n,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getBaseHeight(){return this.baseHeight}setBaseHeight(n){this.baseHeight=n}setBaseSize(n,e){(this.baseSize.width!==n||this.baseSize.height!==e)&&(this.baseSize.set(n,e),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}get preferredWidth(){return this.preferredSize.width}set preferredWidth(n){this.preferredSize.width!==n&&(this.preferredSize.width=n,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredWidth(){return this.preferredWidth}setPreferredWidth(n){this.preferredWidth=n}get preferredHeight(){return this.preferredSize.height}set preferredHeight(n){this.preferredSize.height!==n&&(this.preferredSize.height=n,this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}getPreferredHeight(){return this.preferredHeight}setPreferredHeight(n){this.preferredHeight=n}setPreferredSize(n,e){(this.preferredSize.width!==n||this.preferredSize.height!==e)&&(this.preferredSize.set(n,e),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height))}copy(n){this.s=n.scale,this.baseSize.set(n.baseWidth,n.baseHeight),this.preferredSize.set(n.preferredWidth,n.preferredHeight),this.dispatchEvent({type:"change"}),this.resizable.setSize(this.baseSize.width,this.baseSize.height)}static get AUTO_SIZE(){return cd}},nr={ADD:0,AVERAGE:2,COLOR:3,COLOR_BURN:4,COLOR_DODGE:5,DARKEN:6,DIFFERENCE:7,DIVIDE:8,DST:9,EXCLUSION:10,HARD_LIGHT:11,HARD_MIX:12,HUE:13,INVERT:14,INVERT_RGB:15,LIGHTEN:16,LINEAR_BURN:17,LINEAR_DODGE:18,LINEAR_LIGHT:19,LUMINOSITY:20,MULTIPLY:21,NEGATION:22,NORMAL:23,OVERLAY:24,PIN_LIGHT:25,REFLECT:26,SATURATION:27,SCREEN:28,SOFT_LIGHT:29,SRC:30,SUBTRACT:31,VIVID_LIGHT:32},JJ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),y.a*opacity);}",QJ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb)*0.5,y.a),y.a*opacity);}",eQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.xy,xHSL.z));return mix(x,vec4(z,y.a),y.a*opacity);}",tQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/b)),vec3(1.0),step(1.0,a));return mix(x,vec4(z,y.a),y.a*opacity);}",nQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(x,vec4(z,y.a),y.a*opacity);}",rQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb,y.rgb),y.a),y.a*opacity);}",sQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(abs(x.rgb-y.rgb),y.a),y.a*opacity);}",iQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb/max(y.rgb,1e-12),y.a),y.a*opacity);}",oQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb-2.0*x.rgb*y.rgb),y.a),y.a*opacity);}",aQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=min(x.rgb,1.0);vec3 b=min(y.rgb,1.0);vec3 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(x,vec4(z,y.a),y.a*opacity);}",lQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(step(1.0,x.rgb+y.rgb),y.a),y.a*opacity);}",uQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.x,xHSL.yz));return mix(x,vec4(z,y.a),y.a*opacity);}",cQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-y.rgb,y.a),y.a*opacity);}",hQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(y.rgb*(1.0-x.rgb),y.a),y.a*opacity);}",dQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb,y.rgb),y.a),y.a*opacity);}",fQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(y.rgb+x.rgb-1.0,0.0,1.0),y.a),y.a*opacity);}",pQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb+y.rgb,1.0),y.a),y.a*opacity);}",mQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(2.0*y.rgb+x.rgb-1.0,0.0,1.0),y.a),y.a*opacity);}",gQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.xy,yHSL.z));return mix(x,vec4(z,y.a),y.a*opacity);}",yQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb*y.rgb,y.a),y.a*opacity);}",vQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-abs(1.0-x.rgb-y.rgb),y.a),y.a*opacity);}",xQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,y.a*opacity);}",wQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(2.0*y.rgb*x.rgb,1.0-2.0*(1.0-y.rgb)*(1.0-x.rgb),step(0.5,x.rgb));return mix(x,vec4(z,y.a),y.a*opacity);}",bQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 y2=2.0*y.rgb;vec3 z=mix(mix(y2,x.rgb,step(0.5*x.rgb,y.rgb)),max(y2-1.0,vec3(0.0)),step(x.rgb,y2-1.0));return mix(x,vec4(z,y.a),y.a*opacity);}",SQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(min(x.rgb*x.rgb/max(1.0-y.rgb,1e-12),1.0),y.rgb,step(1.0,y.rgb));return mix(x,vec4(z,y.a),y.a*opacity);}",_Q="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.x,yHSL.y,xHSL.z));return mix(x,vec4(z,y.a),y.a*opacity);}",TQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb-min(x.rgb*y.rgb,1.0),y.a),y.a*opacity);}",EQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb;vec3 b=y.rgb;vec3 y2=2.0*b;vec3 w=step(0.5,b);vec3 c=a-(1.0-y2)*a*(1.0-a);vec3 d=mix(a+(y2-1.0)*(sqrt(a)-a),a+(y2-1.0)*a*((16.0*a-12.0)*a+3.0),w*(1.0-step(0.25,a)));vec3 z=mix(c,d,w);return mix(x,vec4(z,y.a),y.a*opacity);}",CQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",IQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb+y.rgb-1.0,0.0),y.a),y.a*opacity);}",NQ="vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(max(1.0-min((1.0-x.rgb)/(2.0*y.rgb),1.0),0.0),min(x.rgb/(2.0*(1.0-y.rgb)),1.0),step(0.5,y.rgb));return mix(x,vec4(z,y.a),y.a*opacity);}",AQ=new Map([[nr.ADD,JJ],[nr.AVERAGE,QJ],[nr.COLOR,eQ],[nr.COLOR_BURN,tQ],[nr.COLOR_DODGE,nQ],[nr.DARKEN,rQ],[nr.DIFFERENCE,sQ],[nr.DIVIDE,iQ],[nr.DST,null],[nr.EXCLUSION,oQ],[nr.HARD_LIGHT,aQ],[nr.HARD_MIX,lQ],[nr.HUE,uQ],[nr.INVERT,cQ],[nr.INVERT_RGB,hQ],[nr.LIGHTEN,dQ],[nr.LINEAR_BURN,fQ],[nr.LINEAR_DODGE,pQ],[nr.LINEAR_LIGHT,mQ],[nr.LUMINOSITY,gQ],[nr.MULTIPLY,yQ],[nr.NEGATION,vQ],[nr.NORMAL,xQ],[nr.OVERLAY,wQ],[nr.PIN_LIGHT,bQ],[nr.REFLECT,SQ],[nr.SATURATION,_Q],[nr.SCREEN,TQ],[nr.SOFT_LIGHT,EQ],[nr.SRC,CQ],[nr.SUBTRACT,IQ],[nr.VIVID_LIGHT,NQ]]),MQ=class extends Tl{constructor(n,e=1){super(),this._blendFunction=n,this.opacity=new Jn(e)}getOpacity(){return this.opacity.value}setOpacity(n){this.opacity.value=n}get blendFunction(){return this._blendFunction}set blendFunction(n){this._blendFunction=n,this.dispatchEvent({type:"change"})}getBlendFunction(){return this.blendFunction}setBlendFunction(n){this.blendFunction=n}getShaderCode(){return AQ.get(this.blendFunction)}},QS=class extends Tl{constructor(n,e,{attributes:t=ih.NONE,blendFunction:r=nr.NORMAL,defines:s=new Map,uniforms:i=new Map,extensions:o=null,vertexShader:a=null}={}){super(),this.name=n,this.renderer=null,this.attributes=t,this.fragmentShader=e,this.vertexShader=a,this.defines=s,this.uniforms=i,this.extensions=o,this.blendMode=new MQ(r),this.blendMode.addEventListener("change",l=>this.setChanged()),this._inputColorSpace=xl,this._outputColorSpace=Go}get inputColorSpace(){return this._inputColorSpace}set inputColorSpace(n){this._inputColorSpace=n,this.setChanged()}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(n){this._outputColorSpace=n,this.setChanged()}set mainScene(n){}set mainCamera(n){}getName(){return this.name}setRenderer(n){this.renderer=n}getDefines(){return this.defines}getUniforms(){return this.uniforms}getExtensions(){return this.extensions}getBlendMode(){return this.blendMode}getAttributes(){return this.attributes}setAttributes(n){this.attributes=n,this.setChanged()}getFragmentShader(){return this.fragmentShader}setFragmentShader(n){this.fragmentShader=n,this.setChanged()}getVertexShader(){return this.vertexShader}setVertexShader(n){this.vertexShader=n,this.setChanged()}setChanged(){this.dispatchEvent({type:"change"})}setDepthTexture(n,e=Wd){}update(n,e,t){}setSize(n,e){}initialize(n,e,t){}dispose(){for(const n of Object.keys(this)){const e=this[n];(e instanceof Us||e instanceof Si||e instanceof fs||e instanceof Ia)&&this[n].dispose()}}},mM={MEDIUM:2,LARGE:3},kQ=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`,RQ="uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",DQ=[new Float32Array([0,0]),new Float32Array([0,1,1]),new Float32Array([0,1,1,2]),new Float32Array([0,1,2,2,3]),new Float32Array([0,1,2,3,4,4,5]),new Float32Array([0,1,2,3,4,5,7,8,9,10])],$Q=class extends ni{constructor(n=new br){super({name:"KawaseBlurMaterial",uniforms:{inputBuffer:new Jn(null),texelSize:new Jn(new br),scale:new Jn(1),kernel:new Jn(0)},blending:wo,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:kQ,vertexShader:RQ}),this.setTexelSize(n.x,n.y),this.kernelSize=mM.MEDIUM}set inputBuffer(n){this.uniforms.inputBuffer.value=n}setInputBuffer(n){this.inputBuffer=n}get kernelSequence(){return DQ[this.kernelSize]}get scale(){return this.uniforms.scale.value}set scale(n){this.uniforms.scale.value=n}getScale(){return this.uniforms.scale.value}setScale(n){this.uniforms.scale.value=n}getKernel(){return null}get kernel(){return this.uniforms.kernel.value}set kernel(n){this.uniforms.kernel.value=n}setKernel(n){this.kernel=n}setTexelSize(n,e){this.uniforms.texelSize.value.set(n,e,n*.5,e*.5)}setSize(n,e){const t=1/n,r=1/e;this.uniforms.texelSize.value.set(t,r,t*.5,r*.5)}},PQ=class extends Ia{constructor({kernelSize:n=mM.MEDIUM,resolutionScale:e=.5,width:t=xo.AUTO_SIZE,height:r=xo.AUTO_SIZE,resolutionX:s=t,resolutionY:i=r}={}){super("KawaseBlurPass"),this.renderTargetA=new Us(1,1,{depthBuffer:!1}),this.renderTargetA.texture.name="Blur.Target.A",this.renderTargetB=this.renderTargetA.clone(),this.renderTargetB.texture.name="Blur.Target.B";const o=this.resolution=new xo(this,s,i,e);o.addEventListener("change",a=>this.setSize(o.baseWidth,o.baseHeight)),this._blurMaterial=new $Q,this._blurMaterial.kernelSize=n,this.copyMaterial=new AB}getResolution(){return this.resolution}get blurMaterial(){return this._blurMaterial}set blurMaterial(n){this._blurMaterial=n}get dithering(){return this.copyMaterial.dithering}set dithering(n){this.copyMaterial.dithering=n}get kernelSize(){return this.blurMaterial.kernelSize}set kernelSize(n){this.blurMaterial.kernelSize=n}get width(){return this.resolution.width}set width(n){this.resolution.preferredWidth=n}get height(){return this.resolution.height}set height(n){this.resolution.preferredHeight=n}get scale(){return this.blurMaterial.scale}set scale(n){this.blurMaterial.scale=n}getScale(){return this.blurMaterial.scale}setScale(n){this.blurMaterial.scale=n}getKernelSize(){return this.kernelSize}setKernelSize(n){this.kernelSize=n}getResolutionScale(){return this.resolution.scale}setResolutionScale(n){this.resolution.scale=n}render(n,e,t,r,s){const i=this.scene,o=this.camera,a=this.renderTargetA,l=this.renderTargetB,u=this.blurMaterial,c=u.kernelSequence;let h=e;this.fullscreenMaterial=u;for(let d=0,p=c.length;d<p;++d){const g=(d&1)===0?a:l;u.kernel=c[d],u.inputBuffer=h.texture,n.setRenderTarget(g),n.render(i,o),h=g}this.fullscreenMaterial=this.copyMaterial,this.copyMaterial.inputBuffer=h.texture,n.setRenderTarget(this.renderToScreen?null:t),n.render(i,o)}setSize(n,e){const t=this.resolution;t.setBaseSize(n,e);const r=t.width,s=t.height;this.renderTargetA.setSize(r,s),this.renderTargetB.setSize(r,s),this.blurMaterial.setSize(n,e)}initialize(n,e,t){t!==void 0&&(this.renderTargetA.texture.type=t,this.renderTargetB.texture.type=t,t!==Ki?(this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1"):n!==null&&n.outputColorSpace===sr&&(this.renderTargetA.texture.colorSpace=sr,this.renderTargetB.texture.colorSpace=sr))}static get AUTO_SIZE(){return xo.AUTO_SIZE}},LQ=`#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);float mask=1.0;
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);mask=low*high;
#elif defined(THRESHOLD)
mask=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=texel*mask;
#else
gl_FragColor=vec4(l*mask);
#endif
}`,OQ=class extends ni{constructor(n=!1,e=null){super({name:"LuminanceMaterial",defines:{THREE_REVISION:Vd.replace(/\D+/g,"")},uniforms:{inputBuffer:new Jn(null),threshold:new Jn(0),smoothing:new Jn(1),range:new Jn(null)},blending:wo,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:LQ,vertexShader:NB}),this.colorOutput=n,this.luminanceRange=e}set inputBuffer(n){this.uniforms.inputBuffer.value=n}setInputBuffer(n){this.uniforms.inputBuffer.value=n}get threshold(){return this.uniforms.threshold.value}set threshold(n){this.smoothing>0||n>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.threshold.value=n}getThreshold(){return this.threshold}setThreshold(n){this.threshold=n}get smoothing(){return this.uniforms.smoothing.value}set smoothing(n){this.threshold>0||n>0?this.defines.THRESHOLD="1":delete this.defines.THRESHOLD,this.uniforms.smoothing.value=n}getSmoothingFactor(){return this.smoothing}setSmoothingFactor(n){this.smoothing=n}get useThreshold(){return this.threshold>0||this.smoothing>0}set useThreshold(n){}get colorOutput(){return this.defines.COLOR!==void 0}set colorOutput(n){n?this.defines.COLOR="1":delete this.defines.COLOR,this.needsUpdate=!0}isColorOutputEnabled(n){return this.colorOutput}setColorOutputEnabled(n){this.colorOutput=n}get useRange(){return this.luminanceRange!==null}set useRange(n){this.luminanceRange=null}get luminanceRange(){return this.uniforms.range.value}set luminanceRange(n){n!==null?this.defines.RANGE="1":delete this.defines.RANGE,this.uniforms.range.value=n,this.needsUpdate=!0}getLuminanceRange(){return this.luminanceRange}setLuminanceRange(n){this.luminanceRange=n}},FQ=class extends Ia{constructor({renderTarget:n,luminanceRange:e,colorOutput:t,resolutionScale:r=1,width:s=xo.AUTO_SIZE,height:i=xo.AUTO_SIZE,resolutionX:o=s,resolutionY:a=i}={}){super("LuminancePass"),this.fullscreenMaterial=new OQ(t,e),this.needsSwap=!1,this.renderTarget=n,this.renderTarget===void 0&&(this.renderTarget=new Us(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="LuminancePass.Target");const l=this.resolution=new xo(this,o,a,r);l.addEventListener("change",u=>this.setSize(l.baseWidth,l.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}render(n,e,t,r,s){const i=this.fullscreenMaterial;i.inputBuffer=e.texture,n.setRenderTarget(this.renderToScreen?null:this.renderTarget),n.render(this.scene,this.camera)}setSize(n,e){const t=this.resolution;t.setBaseSize(n,e),this.renderTarget.setSize(t.width,t.height)}initialize(n,e,t){t!==void 0&&t!==Ki&&(this.renderTarget.texture.type=t,this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}},zQ=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <colorspace_fragment>
}`,BQ="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}",UQ=class extends ni{constructor(){super({name:"DownsamplingMaterial",uniforms:{inputBuffer:new Jn(null),texelSize:new Jn(new rt)},blending:wo,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:zQ,vertexShader:BQ})}set inputBuffer(n){this.uniforms.inputBuffer.value=n}setSize(n,e){this.uniforms.texelSize.value.set(1/n,1/e)}},VQ=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <colorspace_fragment>
}`,WQ="uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}",GQ=class extends ni{constructor(){super({name:"UpsamplingMaterial",uniforms:{inputBuffer:new Jn(null),supportBuffer:new Jn(null),texelSize:new Jn(new rt),radius:new Jn(.85)},blending:wo,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:VQ,vertexShader:WQ})}set inputBuffer(n){this.uniforms.inputBuffer.value=n}set supportBuffer(n){this.uniforms.supportBuffer.value=n}get radius(){return this.uniforms.radius.value}set radius(n){this.uniforms.radius.value=n}setSize(n,e){this.uniforms.texelSize.value.set(1/n,1/e)}},HQ=class extends Ia{constructor(){super("MipmapBlurPass"),this.needsSwap=!1,this.renderTarget=new Us(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Upsampling.Mipmap0",this.downsamplingMipmaps=[],this.upsamplingMipmaps=[],this.downsamplingMaterial=new UQ,this.upsamplingMaterial=new GQ,this.resolution=new rt}get texture(){return this.renderTarget.texture}get levels(){return this.downsamplingMipmaps.length}set levels(n){if(this.levels!==n){const e=this.renderTarget;this.dispose(),this.downsamplingMipmaps=[],this.upsamplingMipmaps=[];for(let t=0;t<n;++t){const r=e.clone();r.texture.name="Downsampling.Mipmap"+t,this.downsamplingMipmaps.push(r)}this.upsamplingMipmaps.push(e);for(let t=1,r=n-1;t<r;++t){const s=e.clone();s.texture.name="Upsampling.Mipmap"+t,this.upsamplingMipmaps.push(s)}this.setSize(this.resolution.x,this.resolution.y)}}get radius(){return this.upsamplingMaterial.radius}set radius(n){this.upsamplingMaterial.radius=n}render(n,e,t,r,s){const{scene:i,camera:o}=this,{downsamplingMaterial:a,upsamplingMaterial:l}=this,{downsamplingMipmaps:u,upsamplingMipmaps:c}=this;let h=e;this.fullscreenMaterial=a;for(let d=0,p=u.length;d<p;++d){const g=u[d];a.setSize(h.width,h.height),a.inputBuffer=h.texture,n.setRenderTarget(g),n.render(i,o),h=g}this.fullscreenMaterial=l;for(let d=c.length-1;d>=0;--d){const p=c[d];l.setSize(h.width,h.height),l.inputBuffer=h.texture,l.supportBuffer=u[d].texture,n.setRenderTarget(p),n.render(i,o),h=p}}setSize(n,e){const t=this.resolution;t.set(n,e);let r=t.width,s=t.height;for(let i=0,o=this.downsamplingMipmaps.length;i<o;++i)r=Math.round(r*.5),s=Math.round(s*.5),this.downsamplingMipmaps[i].setSize(r,s),i<this.upsamplingMipmaps.length&&this.upsamplingMipmaps[i].setSize(r,s)}initialize(n,e,t){if(t!==void 0){const r=this.downsamplingMipmaps.concat(this.upsamplingMipmaps);for(const s of r)s.texture.type=t;if(t!==Ki)this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1",this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1";else if(n!==null&&n.outputColorSpace===sr)for(const s of r)s.texture.colorSpace=sr}}dispose(){super.dispose();for(const n of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))n.dispose()}},jQ=`#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,max(inputColor.a,texel.a));}`,XQ=class extends QS{constructor({blendFunction:n=nr.SCREEN,luminanceThreshold:e=1,luminanceSmoothing:t=.03,mipmapBlur:r=!0,intensity:s=1,radius:i=.85,levels:o=8,kernelSize:a=mM.LARGE,resolutionScale:l=.5,width:u=xo.AUTO_SIZE,height:c=xo.AUTO_SIZE,resolutionX:h=u,resolutionY:d=c}={}){super("BloomEffect",jQ,{blendFunction:n,uniforms:new Map([["map",new Jn(null)],["intensity",new Jn(s)]])}),this.renderTarget=new Us(1,1,{depthBuffer:!1}),this.renderTarget.texture.name="Bloom.Target",this.blurPass=new PQ({kernelSize:a}),this.luminancePass=new FQ({colorOutput:!0}),this.luminanceMaterial.threshold=e,this.luminanceMaterial.smoothing=t,this.mipmapBlurPass=new HQ,this.mipmapBlurPass.enabled=r,this.mipmapBlurPass.radius=i,this.mipmapBlurPass.levels=o,this.uniforms.get("map").value=r?this.mipmapBlurPass.texture:this.renderTarget.texture;const p=this.resolution=new xo(this,h,d,l);p.addEventListener("change",g=>this.setSize(p.baseWidth,p.baseHeight))}get texture(){return this.mipmapBlurPass.enabled?this.mipmapBlurPass.texture:this.renderTarget.texture}getTexture(){return this.texture}getResolution(){return this.resolution}getBlurPass(){return this.blurPass}getLuminancePass(){return this.luminancePass}get luminanceMaterial(){return this.luminancePass.fullscreenMaterial}getLuminanceMaterial(){return this.luminancePass.fullscreenMaterial}get width(){return this.resolution.width}set width(n){this.resolution.preferredWidth=n}get height(){return this.resolution.height}set height(n){this.resolution.preferredHeight=n}get dithering(){return this.blurPass.dithering}set dithering(n){this.blurPass.dithering=n}get kernelSize(){return this.blurPass.kernelSize}set kernelSize(n){this.blurPass.kernelSize=n}get distinction(){return console.warn(this.name,"distinction was removed"),1}set distinction(n){console.warn(this.name,"distinction was removed")}get intensity(){return this.uniforms.get("intensity").value}set intensity(n){this.uniforms.get("intensity").value=n}getIntensity(){return this.intensity}setIntensity(n){this.intensity=n}getResolutionScale(){return this.resolution.scale}setResolutionScale(n){this.resolution.scale=n}update(n,e,t){const r=this.renderTarget,s=this.luminancePass;s.enabled?(s.render(n,e),this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(n,s.renderTarget):this.blurPass.render(n,s.renderTarget,r)):this.mipmapBlurPass.enabled?this.mipmapBlurPass.render(n,e):this.blurPass.render(n,e,r)}setSize(n,e){const t=this.resolution;t.setBaseSize(n,e),this.renderTarget.setSize(t.width,t.height),this.blurPass.resolution.copy(t),this.luminancePass.setSize(n,e),this.mipmapBlurPass.setSize(n,e)}initialize(n,e,t){this.blurPass.initialize(n,e,t),this.luminancePass.initialize(n,e,t),this.mipmapBlurPass.initialize(n,e,t),t!==void 0&&(this.renderTarget.texture.type=t,n!==null&&n.outputColorSpace===sr&&(this.renderTarget.texture.colorSpace=sr))}},kB=class extends Ia{constructor(n,e,t=null){super("RenderPass",n,e),this.needsSwap=!1,this.clearPass=new MB,this.overrideMaterialManager=t===null?null:new fP(t),this.ignoreBackground=!1,this.skipShadowMapUpdate=!1,this.selection=null}set mainScene(n){this.scene=n}set mainCamera(n){this.camera=n}get renderToScreen(){return super.renderToScreen}set renderToScreen(n){super.renderToScreen=n,this.clearPass.renderToScreen=n}get overrideMaterial(){const n=this.overrideMaterialManager;return n!==null?n.material:null}set overrideMaterial(n){const e=this.overrideMaterialManager;n!==null?e!==null?e.setMaterial(n):this.overrideMaterialManager=new fP(n):e!==null&&(e.dispose(),this.overrideMaterialManager=null)}getOverrideMaterial(){return this.overrideMaterial}setOverrideMaterial(n){this.overrideMaterial=n}get clear(){return this.clearPass.enabled}set clear(n){this.clearPass.enabled=n}getSelection(){return this.selection}setSelection(n){this.selection=n}isBackgroundDisabled(){return this.ignoreBackground}setBackgroundDisabled(n){this.ignoreBackground=n}isShadowMapDisabled(){return this.skipShadowMapUpdate}setShadowMapDisabled(n){this.skipShadowMapUpdate=n}getClearPass(){return this.clearPass}render(n,e,t,r,s){const i=this.scene,o=this.camera,a=this.selection,l=o.layers.mask,u=i.background,c=n.shadowMap.autoUpdate,h=this.renderToScreen?null:e;a!==null&&o.layers.set(a.getLayer()),this.skipShadowMapUpdate&&(n.shadowMap.autoUpdate=!1),(this.ignoreBackground||this.clearPass.overrideClearColor!==null)&&(i.background=null),this.clearPass.enabled&&this.clearPass.render(n,e),n.setRenderTarget(h),this.overrideMaterialManager!==null?this.overrideMaterialManager.render(n,i,o):n.render(i,o),o.layers.mask=l,i.background=u,n.shadowMap.autoUpdate=c}},_v={DEFAULT:0,ESKIL:1},qQ=`#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`,KQ="uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",YQ=class extends ni{constructor(){super({name:"DepthDownsamplingMaterial",defines:{DEPTH_PACKING:"0"},uniforms:{depthBuffer:new Jn(null),normalBuffer:new Jn(null),texelSize:new Jn(new rt)},blending:wo,toneMapped:!1,depthWrite:!1,depthTest:!1,fragmentShader:qQ,vertexShader:KQ})}set depthBuffer(n){this.uniforms.depthBuffer.value=n}set depthPacking(n){this.defines.DEPTH_PACKING=n.toFixed(0),this.needsUpdate=!0}setDepthBuffer(n,e=Wd){this.depthBuffer=n,this.depthPacking=e}set normalBuffer(n){this.uniforms.normalBuffer.value=n,n!==null?this.defines.DOWNSAMPLE_NORMALS="1":delete this.defines.DOWNSAMPLE_NORMALS,this.needsUpdate=!0}setNormalBuffer(n){this.normalBuffer=n}setTexelSize(n,e){this.uniforms.texelSize.value.set(n,e)}setSize(n,e){this.uniforms.texelSize.value.set(1/n,1/e)}},ZQ=class extends Ia{constructor({normalBuffer:n=null,resolutionScale:e=.5,width:t=xo.AUTO_SIZE,height:r=xo.AUTO_SIZE,resolutionX:s=t,resolutionY:i=r}={}){super("DepthDownsamplingPass");const o=new YQ;o.normalBuffer=n,this.fullscreenMaterial=o,this.needsDepthTexture=!0,this.needsSwap=!1,this.renderTarget=new Us(1,1,{minFilter:ss,magFilter:ss,depthBuffer:!1,type:Di}),this.renderTarget.texture.name="DepthDownsamplingPass.Target",this.renderTarget.texture.generateMipmaps=!1;const a=this.resolution=new xo(this,s,i,e);a.addEventListener("change",l=>this.setSize(a.baseWidth,a.baseHeight))}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}setDepthTexture(n,e=Wd){this.fullscreenMaterial.depthBuffer=n,this.fullscreenMaterial.depthPacking=e}render(n,e,t,r,s){n.setRenderTarget(this.renderToScreen?null:this.renderTarget),n.render(this.scene,this.camera)}setSize(n,e){const t=this.resolution;t.setBaseSize(n,e),this.renderTarget.setSize(t.width,t.height),this.fullscreenMaterial.setSize(n,e)}initialize(n,e,t){const r=n.getContext();if(!(r.getExtension("EXT_color_buffer_float")||r.getExtension("EXT_color_buffer_half_float")))throw new Error("Rendering to float texture is not supported.")}},JQ=`uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`,QQ=class extends QS{constructor({blendFunction:n,eskil:e=!1,technique:t=e?_v.ESKIL:_v.DEFAULT,offset:r=.5,darkness:s=.5}={}){super("VignetteEffect",JQ,{blendFunction:n,defines:new Map([["VIGNETTE_TECHNIQUE",t.toFixed(0)]]),uniforms:new Map([["offset",new Jn(r)],["darkness",new Jn(s)]])})}get technique(){return Number(this.defines.get("VIGNETTE_TECHNIQUE"))}set technique(n){this.technique!==n&&(this.defines.set("VIGNETTE_TECHNIQUE",n.toFixed(0)),this.setChanged())}get eskil(){return this.technique===_v.ESKIL}set eskil(n){this.technique=n?_v.ESKIL:_v.DEFAULT}getTechnique(){return this.technique}setTechnique(n){this.technique=n}get offset(){return this.uniforms.get("offset").value}set offset(n){this.uniforms.get("offset").value=n}getOffset(){return this.offset}setOffset(n){this.offset=n}get darkness(){return this.uniforms.get("darkness").value}set darkness(n){this.uniforms.get("darkness").value=n}getDarkness(){return this.darkness}setDarkness(n){this.darkness=n}},eee=`#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
float depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
float depth=texture2D(depthBuffer,uv).r;
#endif
#if defined(USE_LOGARITHMIC_DEPTH_BUFFER) || defined(LOG_DEPTH)
float d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;
#elif defined(USE_REVERSED_DEPTH_BUFFER)
depth=1.0-depth;
#endif
return depth;}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,tee="uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",nee=class extends ni{constructor(n,e,t,r,s=!1){super({name:"EffectMaterial",defines:{THREE_REVISION:Vd.replace(/\D+/g,""),DEPTH_PACKING:"0",ENCODE_OUTPUT:"1"},uniforms:{inputBuffer:new Jn(null),depthBuffer:new Jn(null),resolution:new Jn(new rt),texelSize:new Jn(new rt),cameraNear:new Jn(.3),cameraFar:new Jn(1e3),aspect:new Jn(1),time:new Jn(0)},blending:wo,toneMapped:!1,depthWrite:!1,depthTest:!1,dithering:s}),n&&this.setShaderParts(n),e&&this.setDefines(e),t&&this.setUniforms(t),this.copyCameraSettings(r)}set inputBuffer(n){this.uniforms.inputBuffer.value=n}setInputBuffer(n){this.uniforms.inputBuffer.value=n}get depthBuffer(){return this.uniforms.depthBuffer.value}set depthBuffer(n){this.uniforms.depthBuffer.value=n}get depthPacking(){return Number(this.defines.DEPTH_PACKING)}set depthPacking(n){this.defines.DEPTH_PACKING=n.toFixed(0),this.needsUpdate=!0}setDepthBuffer(n,e=Wd){this.depthBuffer=n,this.depthPacking=e}setShaderData(n){this.setShaderParts(n.shaderParts),this.setDefines(n.defines),this.setUniforms(n.uniforms),this.setExtensions(n.extensions)}setShaderParts(n){return this.fragmentShader=eee.replace(xr.FRAGMENT_HEAD,n.get(xr.FRAGMENT_HEAD)||"").replace(xr.FRAGMENT_MAIN_UV,n.get(xr.FRAGMENT_MAIN_UV)||"").replace(xr.FRAGMENT_MAIN_IMAGE,n.get(xr.FRAGMENT_MAIN_IMAGE)||""),this.vertexShader=tee.replace(xr.VERTEX_HEAD,n.get(xr.VERTEX_HEAD)||"").replace(xr.VERTEX_MAIN_SUPPORT,n.get(xr.VERTEX_MAIN_SUPPORT)||""),this.needsUpdate=!0,this}setDefines(n){for(const e of n.entries())this.defines[e[0]]=e[1];return this.needsUpdate=!0,this}setUniforms(n){for(const e of n.entries())this.uniforms[e[0]]=e[1];return this}setExtensions(n){this.extensions={};for(const e of n)this.extensions[e]=!0;return this}get encodeOutput(){return this.defines.ENCODE_OUTPUT!==void 0}set encodeOutput(n){this.encodeOutput!==n&&(n?this.defines.ENCODE_OUTPUT="1":delete this.defines.ENCODE_OUTPUT,this.needsUpdate=!0)}isOutputEncodingEnabled(n){return this.encodeOutput}setOutputEncodingEnabled(n){this.encodeOutput=n}get time(){return this.uniforms.time.value}set time(n){this.uniforms.time.value=n}setDeltaTime(n){this.uniforms.time.value+=n}adoptCameraSettings(n){this.copyCameraSettings(n)}copyCameraSettings(n){n&&(this.uniforms.cameraNear.value=n.near,this.uniforms.cameraFar.value=n.far,n instanceof fi?this.defines.PERSPECTIVE_CAMERA="1":delete this.defines.PERSPECTIVE_CAMERA,this.needsUpdate=!0)}setSize(n,e){const t=this.uniforms;t.resolution.value.set(n,e),t.texelSize.value.set(1/n,1/e),t.aspect.value=n/e}static get Section(){return xr}};function pP(n,e,t){for(const r of e){const s="$1"+n+r.charAt(0).toUpperCase()+r.slice(1),i=new RegExp("([^\\.])(\\b"+r+"\\b)","g");for(const o of t.entries())o[1]!==null&&t.set(o[0],o[1].replace(i,s))}}function ree(n,e,t){let r=e.getFragmentShader(),s=e.getVertexShader();const i=r!==void 0&&/mainImage/.test(r),o=r!==void 0&&/mainUv/.test(r);if(t.attributes|=e.getAttributes(),r===void 0)throw new Error(`Missing fragment shader (${e.name})`);if(o&&(t.attributes&ih.CONVOLUTION)!==0)throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`);if(!i&&!o)throw new Error(`Could not find mainImage or mainUv function (${e.name})`);{const a=/\w+\s+(\w+)\([\w\s,]*\)\s*{/g,l=t.shaderParts;let u=l.get(xr.FRAGMENT_HEAD)||"",c=l.get(xr.FRAGMENT_MAIN_UV)||"",h=l.get(xr.FRAGMENT_MAIN_IMAGE)||"",d=l.get(xr.VERTEX_HEAD)||"",p=l.get(xr.VERTEX_MAIN_SUPPORT)||"";const g=new Set,w=new Set;if(o&&(c+=`	${n}MainUv(UV);
`,t.uvTransformation=!0),s!==null&&/mainSupport/.test(s)){const _=/mainSupport *\([\w\s]*?uv\s*?\)/.test(s);p+=`	${n}MainSupport(`,p+=_?`vUv);
`:`);
`;for(const T of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))for(const E of T[1].split(/\s*,\s*/))t.varyings.add(E),g.add(E),w.add(E);for(const T of s.matchAll(a))w.add(T[1])}for(const _ of r.matchAll(a))w.add(_[1]);for(const _ of e.defines.keys())w.add(_.replace(/\([\w\s,]*\)/g,""));for(const _ of e.uniforms.keys())w.add(_);w.delete("while"),w.delete("for"),w.delete("if"),e.uniforms.forEach((_,T)=>t.uniforms.set(n+T.charAt(0).toUpperCase()+T.slice(1),_)),e.defines.forEach((_,T)=>t.defines.set(n+T.charAt(0).toUpperCase()+T.slice(1),_));const y=new Map([["fragment",r],["vertex",s]]);pP(n,w,t.defines),pP(n,w,y),r=y.get("fragment"),s=y.get("vertex");const x=e.blendMode;if(t.blendModes.set(x.blendFunction,x),i){e.inputColorSpace!==null&&e.inputColorSpace!==t.colorSpace&&(h+=e.inputColorSpace===sr?`color0 = sRGBTransferOETF(color0);
	`:`color0 = sRGBToLinear(color0);
	`),e.outputColorSpace!==Go?t.colorSpace=e.outputColorSpace:e.inputColorSpace!==null&&(t.colorSpace=e.inputColorSpace);const _=/MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;h+=`${n}MainImage(color0, UV, `,(t.attributes&ih.DEPTH)!==0&&_.test(r)&&(h+="depth, ",t.readDepth=!0),h+=`color1);
	`;const T=n+"BlendOpacity";t.uniforms.set(T,x.opacity),h+=`color0 = blend${x.blendFunction}(color0, color1, ${T});

	`,u+=`uniform float ${T};

`}if(u+=r+`
`,s!==null&&(d+=s+`
`),l.set(xr.FRAGMENT_HEAD,u),l.set(xr.FRAGMENT_MAIN_UV,c),l.set(xr.FRAGMENT_MAIN_IMAGE,h),l.set(xr.VERTEX_HEAD,d),l.set(xr.VERTEX_MAIN_SUPPORT,p),e.extensions!==null)for(const _ of e.extensions)t.extensions.add(_)}}var see=class extends Ia{constructor(n,...e){super("EffectPass"),this.fullscreenMaterial=new nee(null,null,null,n),this.listener=t=>this.handleEvent(t),this.effects=[],this.setEffects(e),this.skipRendering=!1,this.minTime=1,this.maxTime=Number.POSITIVE_INFINITY,this.timeScale=1}set mainScene(n){for(const e of this.effects)e.mainScene=n}set mainCamera(n){this.fullscreenMaterial.copyCameraSettings(n);for(const e of this.effects)e.mainCamera=n}get encodeOutput(){return this.fullscreenMaterial.encodeOutput}set encodeOutput(n){this.fullscreenMaterial.encodeOutput=n}get dithering(){return this.fullscreenMaterial.dithering}set dithering(n){const e=this.fullscreenMaterial;e.dithering=n,e.needsUpdate=!0}setEffects(n){for(const e of this.effects)e.removeEventListener("change",this.listener);this.effects=n.sort((e,t)=>t.attributes-e.attributes);for(const e of this.effects)e.addEventListener("change",this.listener)}updateMaterial(){const n=new ZJ;let e=0;for(const o of this.effects)if(o.blendMode.blendFunction===nr.DST)n.attributes|=o.getAttributes()&ih.DEPTH;else{if((n.attributes&o.getAttributes()&ih.CONVOLUTION)!==0)throw new Error(`Convolution effects cannot be merged (${o.name})`);ree("e"+e++,o,n)}let t=n.shaderParts.get(xr.FRAGMENT_HEAD),r=n.shaderParts.get(xr.FRAGMENT_MAIN_IMAGE),s=n.shaderParts.get(xr.FRAGMENT_MAIN_UV);const i=/\bblend\b/g;for(const o of n.blendModes.values())t+=o.getShaderCode().replace(i,`blend${o.blendFunction}`)+`
`;(n.attributes&ih.DEPTH)!==0?(n.readDepth&&(r=`float depth = readDepth(UV);

	`+r),this.needsDepthTexture=this.getDepthTexture()===null):this.needsDepthTexture=!1,n.colorSpace===sr&&(r+=`color0 = sRGBToLinear(color0);
	`),n.uvTransformation?(s=`vec2 transformedUv = vUv;
`+s,n.defines.set("UV","transformedUv")):n.defines.set("UV","vUv"),n.shaderParts.set(xr.FRAGMENT_HEAD,t),n.shaderParts.set(xr.FRAGMENT_MAIN_IMAGE,r),n.shaderParts.set(xr.FRAGMENT_MAIN_UV,s);for(const[o,a]of n.shaderParts)a!==null&&n.shaderParts.set(o,a.trim().replace(/^#/,`
#`));this.skipRendering=e===0,this.needsSwap=!this.skipRendering,this.fullscreenMaterial.setShaderData(n)}recompile(){this.updateMaterial()}getDepthTexture(){return this.fullscreenMaterial.depthBuffer}setDepthTexture(n,e=Wd){this.fullscreenMaterial.depthBuffer=n,this.fullscreenMaterial.depthPacking=e;for(const t of this.effects)t.setDepthTexture(n,e)}render(n,e,t,r,s){for(const i of this.effects)i.update(n,e,r);if(!this.skipRendering||this.renderToScreen){const i=this.fullscreenMaterial;i.inputBuffer=e.texture,i.time+=r*this.timeScale,n.setRenderTarget(this.renderToScreen?null:t),n.render(this.scene,this.camera)}}setSize(n,e){this.fullscreenMaterial.setSize(n,e);for(const t of this.effects)t.setSize(n,e)}initialize(n,e,t){this.renderer=n;for(const r of this.effects)r.initialize(n,e,t);this.updateMaterial(),t!==void 0&&t!==Ki&&(this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH="1")}dispose(){super.dispose();for(const n of this.effects)n.removeEventListener("change",this.listener),n.dispose()}handleEvent(n){switch(n.type){case"change":this.recompile();break}}},iee=class extends Ia{constructor(n,e,{renderTarget:t,resolutionScale:r=1,width:s=xo.AUTO_SIZE,height:i=xo.AUTO_SIZE,resolutionX:o=s,resolutionY:a=i}={}){super("NormalPass"),this.needsSwap=!1,this.renderPass=new kB(n,e,new ZA);const l=this.renderPass;l.ignoreBackground=!0,l.skipShadowMapUpdate=!0;const u=l.getClearPass();u.overrideClearColor=new Nt(7829503),u.overrideClearAlpha=1,this.renderTarget=t,this.renderTarget===void 0&&(this.renderTarget=new Us(1,1,{minFilter:ss,magFilter:ss}),this.renderTarget.texture.name="NormalPass.Target");const c=this.resolution=new xo(this,o,a,r);c.addEventListener("change",h=>this.setSize(c.baseWidth,c.baseHeight))}set mainScene(n){this.renderPass.mainScene=n}set mainCamera(n){this.renderPass.mainCamera=n}get texture(){return this.renderTarget.texture}getTexture(){return this.renderTarget.texture}getResolution(){return this.resolution}getResolutionScale(){return this.resolution.scale}setResolutionScale(n){this.resolution.scale=n}render(n,e,t,r,s){const i=this.renderToScreen?null:this.renderTarget;this.renderPass.render(n,i,i)}setSize(n,e){const t=this.resolution;t.setBaseSize(n,e),this.renderTarget.setSize(t.width,t.height)}};const oee=we.createContext(null),mP=n=>(n.getAttributes()&ih.CONVOLUTION)===ih.CONVOLUTION,aee=Yv.memo(we.forwardRef(({children:n,camera:e,scene:t,resolutionScale:r,enabled:s=!0,renderPriority:i=1,autoClear:o=!0,depthBuffer:a,disableNormalPass:l,stencilBuffer:u,multisampling:c=8,frameBufferType:h=vo},d)=>{const{gl:p,scene:g,camera:w,size:y}=wl(),x=t||g,_=e||w,[T,E,N]=we.useMemo(()=>{const k=fJ(),R=new YJ(p,{depthBuffer:a,stencilBuffer:u,multisampling:c>0&&k?c:0,frameBufferType:h});R.addPass(new kB(x,_));let P=null,B=null;return l||(B=new iee(x,_),B.enabled=!1,R.addPass(B),r!==void 0&&k&&(P=new ZQ({normalBuffer:B.texture,resolutionScale:r}),P.enabled=!1,R.addPass(P))),[R,B,P]},[_,p,a,u,c,h,x,l,r]);we.useEffect(()=>T==null?void 0:T.setSize(y.width,y.height),[T,y]),Ka((k,R)=>{if(s){const P=p.autoClear;p.autoClear=o,u&&!o&&p.clearStencil(),T.render(R),p.autoClear=P}},s?i:0);const M=we.useRef(null),$=WZ(M);we.useLayoutEffect(()=>{const k=[];if(M.current&&$.current&&T){const R=$.current.objects;for(let P=0;P<R.length;P++){const B=R[P];if(B instanceof QS){const Z=[B];if(!mP(B)){let X=null;for(;(X=R[P+1])instanceof QS&&!mP(X);)Z.push(X),P++}const V=new see(_,...Z);k.push(V)}else B instanceof Ia&&k.push(B)}for(const P of k)T==null||T.addPass(P);E&&(E.enabled=!0),N&&(N.enabled=!0)}return()=>{for(const R of k)T==null||T.removePass(R);E&&(E.enabled=!1),N&&(N.enabled=!1)}},[T,n,_,E,N,$]);const L=we.useMemo(()=>({composer:T,normalPass:E,downSamplingPass:N,resolutionScale:r,camera:_,scene:x}),[T,E,N,r,_,x]);return we.useImperativeHandle(d,()=>T,[T]),Ie.jsx(oee.Provider,{value:L,children:Ie.jsx("group",{ref:M,children:n})})}));let lee=0;const gP=new WeakMap,RB=(n,e)=>Yv.forwardRef(function({blendFunction:r=e==null?void 0:e.blendFunction,opacity:s=e==null?void 0:e.opacity,...i},o){let a=gP.get(n);if(!a){const c=`@react-three/postprocessing/${n.name}-${lee++}`;dT({[c]:n}),gP.set(n,a=c)}const l=wl(c=>c.camera),u=Yv.useMemo(()=>{var c,h;return[...(c=e==null?void 0:e.args)!=null?c:[],...(h=i.args)!=null?h:[{...e,...i}]]},[JSON.stringify(i)]);return Ie.jsx(a,{camera:l,"blendMode-blendFunction":r,"blendMode-opacity-value":s,...i,ref:o,args:u})}),uee=RB(XQ,{blendFunction:nr.ADD}),cee=RB(QQ),gM=n=>{const e=Math.random()*Math.PI*2,t=Math.acos(2*Math.random()-1),r=n*Math.sin(t)*Math.cos(e),s=n*Math.sin(t)*Math.sin(e),i=n*Math.cos(t);return new le(r,s,i)},hee=(n,e,t)=>{const r=(t-.5)*n,s=(1-t)*e,i=Math.random()*Math.PI*2,o=s*Math.cos(i),a=s*Math.sin(i);return new le(o,r,a)},dee=(n,e,t)=>{const r=new Float32Array(n*3),s=new Float32Array(n*3),i=new Float32Array(n);for(let o=0;o<n;o++){const a=1-Math.sqrt(Math.random()),l=hee(e,t,a);l.x+=(Math.random()-.5)*1,l.z+=(Math.random()-.5)*1,l.y+=(Math.random()-.5)*1,r[o*3]=l.x,r[o*3+1]=l.y,r[o*3+2]=l.z;const u=gM(e*1.5);s[o*3]=u.x,s[o*3+1]=u.y,s[o*3+2]=u.z,i[o]=Math.random()}return{target:r,chaos:s,randoms:i}},fee=(n,e,t,r)=>{const s=new Float32Array(n*3),i=new Float32Array(n*3);for(let o=0;o<n;o++){const a=o/n,l=(a-.5)*e,u=(1-a)*t+.5,c=a*Math.PI*2*r;s[o*3]=u*Math.cos(c),s[o*3+1]=l,s[o*3+2]=u*Math.sin(c);const h=gM(e*1.2);i[o*3]=h.x,i[o*3+1]=h.y,i[o*3+2]=h.z}return{target:s,chaos:i}},mi=(n,e,t)=>n*(1-t)+e*t,pee=`
  precision highp float;
  uniform float uTime;
  uniform float uMix;
  uniform float uSize;
  
  attribute vec3 aTargetPos;
  attribute vec3 aChaosPos;
  attribute float aRandom;
  
  varying vec3 vPos;
  varying float vRandom;
  varying float vIsSnow;

  void main() {
    vRandom = aRandom;
    vIsSnow = step(0.85, aRandom); // Top 15% random values become snow

    // Interpolate position
    vec3 pos = mix(aChaosPos, aTargetPos, uMix);
    
    // Breathing effect
    float breath = sin(uTime + pos.y * 0.5) * 0.05 * uMix;
    pos.x += pos.x * breath;
    pos.z += pos.z * breath;

    vPos = pos;

    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;
    
    // Size attenuation
    gl_PointSize = uSize * (20.0 / -mvPosition.z) * (0.6 + 0.8 * aRandom);
  }
`,mee=`
  precision highp float;
  uniform vec3 uColorBottom;
  uniform vec3 uColorTop;
  
  varying vec3 vPos;
  varying float vRandom;
  varying float vIsSnow;

  void main() {
    // Exact height normalization for tree (-9 to 9)
    float h = (vPos.y + 9.0) / 18.0;
    h = clamp(h, 0.0, 1.0);
    
    // Mix gradient
    vec3 color = mix(uColorBottom, uColorTop, h);
    
    // Depth Variation
    color *= 0.6 + 0.6 * vRandom;

    // Apply Snow
    // If vIsSnow is 1.0, mix with white
    vec3 snowColor = vec3(0.95, 0.98, 1.0);
    color = mix(color, snowColor, vIsSnow * 0.9); // 90% white blend

    // Circular particle
    float dist = length(gl_PointCoord - vec2(0.5));
    if (dist > 0.5) discard;
    
    // Soft edge
    float alpha = 1.0 - smoothstep(0.3, 0.5, dist);

    gl_FragColor = vec4(color, alpha);
  }
`,gee=({mixFactor:n,colors:e})=>{const r=we.useRef(null),s=we.useRef(1),{target:i,chaos:o,randoms:a}=we.useMemo(()=>dee(75e3,18,7.5),[75e3]),l=we.useMemo(()=>({uTime:{value:0},uMix:{value:1},uSize:{value:4},uColorBottom:{value:new Nt(e.bottom)},uColorTop:{value:new Nt(e.top)}}),[]);return Ka((u,c)=>{if(r.current){const h=2*c;s.current=mi(s.current,n,h),r.current.uniforms.uTime.value=u.clock.elapsedTime,r.current.uniforms.uMix.value=s.current,r.current.uniforms.uColorBottom.value.set(e.bottom),r.current.uniforms.uColorTop.value.set(e.top)}}),Ie.jsxs("points",{children:[Ie.jsxs("bufferGeometry",{children:[Ie.jsx("bufferAttribute",{attach:"attributes-position",count:75e3,array:i,itemSize:3}),Ie.jsx("bufferAttribute",{attach:"attributes-aTargetPos",count:75e3,array:i,itemSize:3}),Ie.jsx("bufferAttribute",{attach:"attributes-aChaosPos",count:75e3,array:o,itemSize:3}),Ie.jsx("bufferAttribute",{attach:"attributes-aRandom",count:75e3,array:a,itemSize:1})]}),Ie.jsx("shaderMaterial",{ref:r,vertexShader:pee,fragmentShader:mee,uniforms:l,transparent:!0,depthWrite:!1})]})},yee=()=>{const n=new HA([new le(0,-1,0),new le(0,.5,0),new le(.1,.8,0),new le(.4,.9,0),new le(.6,.6,0)]),e=new Jx(n,32,.12,8,!1);return e.center(),e},yP=(n,e,t,r)=>{const s=new sh,i=Math.PI*2/(n*2);s.moveTo(0,e);for(let a=0;a<n*2;a++){const l=a%2===0?e:t,u=a*i;s.lineTo(Math.sin(u)*l,Math.cos(u)*l)}s.closePath();const o=new Vy(s,{depth:r,bevelEnabled:!0,bevelThickness:.05,bevelSize:.05,bevelSegments:2});return o.center(),o},vee=()=>{const n=document.createElement("canvas");n.width=128,n.height=128;const e=n.getContext("2d");if(!e)return null;e.fillStyle="#ffffff",e.fillRect(0,0,128,128),e.fillStyle="#cc0000";for(let r=-128;r<256;r+=42)e.beginPath(),e.moveTo(r,0),e.lineTo(r+20,0),e.lineTo(r+20+128,128),e.lineTo(r+128,128),e.closePath(),e.fill();const t=new lx(n);return t.wrapS=Pp,t.wrapT=Pp,t.repeat.set(4,1),t},xee=n=>{const e=document.createElement("canvas");e.width=512,e.height=128;const t=e.getContext("2d");if(!t)return null;if(t.clearRect(0,0,e.width,e.height),!n)return new lx(e);t.fillStyle="#111111",t.textAlign="center",t.textBaseline="middle",t.font="bold 60px 'Monsieur La Doulaise', cursive",t.fillText(n,e.width/2,e.height/2);const r=new lx(e);return r.needsUpdate=!0,r},DB=({item:n,index:e,mixFactor:t,texture:r,signatureTexture:s,interactionRef:i})=>{const o=we.useRef(null),a=we.useRef(null),l=we.useRef(null),u=we.useRef(null),c=we.useRef(null),h=we.useRef(null),d=we.useRef(null),p=we.useRef(1),g=we.useRef(0),w=we.useMemo(()=>new le,[]),y=we.useMemo(()=>new le,[]),x=we.useMemo(()=>new bo,[]),_=we.useMemo(()=>new bo,[]),{camera:T}=wl(),{frameArgs:E,photoArgs:N,photoPos:M,textPos:$,textArgs:L}=we.useMemo(()=>{const B=r.image,Z=(B==null?void 0:B.width)||1,V=(B==null?void 0:B.height)||1,X=Z/V,q=.85;let se,W;X>=1?(se=q,W=q/X):(W=q,se=q*X);const J=.08,K=.08,G=.2,Q=se+J*2,ne=W+K+G,ce=ne/2-K-W/2,ye=-(ne/2)+G/2;return{frameArgs:[Q,ne,.05],photoArgs:[se,W],photoPos:[0,ce,.03],textPos:[0,ye,.03],textArgs:[Q,G]}},[r]);Ka((B,Z)=>{if(!o.current||!a.current)return;const V=2*Z,X=i.current.zoomedIndex===e,q=i.current.hoveredIndex===e,se=X?1:0;g.current=Ua.lerp(g.current,se,Z*12);const W=g.current;p.current=mi(p.current,t,V);const J=p.current,K=J<.3;w.lerpVectors(n.chaosPos,n.targetPos,J),y.lerpVectors(n.chaosScale,n.targetScale,J);const{width:G,height:Q}=B.viewport,ne=G<22;if(y.multiplyScalar(ne?.6:1),W>.001){const Re=new le(0,0,-1).applyQuaternion(T.quaternion),Oe=T.position.clone().add(Re.multiplyScalar(2));o.current.parent&&o.current.parent.worldToLocal(Oe),w.lerp(Oe,W),o.current.parent?(o.current.parent.getWorldQuaternion(_),x.copy(_).invert().multiply(T.quaternion)):x.copy(T.quaternion),o.current.quaternion.slerp(x,W);const ct=4*Math.tan(T.fov*Math.PI/360)*.75/E[1],fe=new le(ct,ct,ct);y.lerp(fe,W),a.current.rotation.z=mi(a.current.rotation.z,0,Z*15)}else if(J>.8?(o.current.position.copy(w),o.current.lookAt(0,o.current.position.y,0),o.current.rotateY(Math.PI),a.current.rotation.z=mi(a.current.rotation.z,0,V)):(o.current.position.copy(w),o.current.lookAt(B.camera.position),a.current.rotation.z=mi(a.current.rotation.z,n.chaosTilt,V)),K&&q&&i.current.zoomedIndex===-1){y.multiplyScalar(mi(1,1.35,.2));const Re=T.position.clone().sub(w).normalize();w.add(Re.multiplyScalar(.5))}o.current.position.copy(w),o.current.scale.copy(y);const ye=W>.1?9999:0;if(l.current&&(l.current.renderOrder=ye),u.current&&(u.current.renderOrder=ye),c.current&&(c.current.renderOrder=ye),h.current&&d.current){const Se=W*.8;h.current.emissiveIntensity=.25+Se;const Re=W>.2;h.current.depthTest=!Re,h.current.depthWrite=!Re,d.current.depthTest=!Re,d.current.depthWrite=!Re,X?(d.current.color.setHex(16777215),d.current.emissiveIntensity=.8):K&&q?(d.current.color.setHex(65535),d.current.emissive.setHex(65535),d.current.emissiveIntensity=.5):(d.current.color.setHex(16777215),d.current.emissive.setHex(16777215),d.current.emissiveIntensity=.3)}});const k=B=>{p.current<.3&&(B.stopPropagation(),document.body.style.cursor="pointer",i.current.zoomedIndex===-1&&(i.current.hoveredIndex=e))},R=B=>{document.body.style.cursor="auto",i.current.hoveredIndex===e&&(i.current.hoveredIndex=-1)},P=B=>{p.current<.3&&(B.stopPropagation(),i.current.zoomedIndex===e?i.current.zoomedIndex=-1:i.current.zoomedIndex=e)};return Ie.jsx("group",{ref:o,children:Ie.jsxs("group",{ref:a,onClick:P,onPointerOver:k,onPointerOut:R,children:[Ie.jsxs("mesh",{ref:l,children:[Ie.jsx("boxGeometry",{args:E}),Ie.jsx("meshStandardMaterial",{ref:d,color:"#ffffff",roughness:.8,metalness:.1,emissive:"#ffffff",emissiveIntensity:.3,toneMapped:!1})]}),Ie.jsxs("mesh",{ref:u,position:M,children:[Ie.jsx("planeGeometry",{args:N}),Ie.jsx("meshStandardMaterial",{ref:h,map:r,emissiveMap:r,roughness:.4,metalness:0,color:"white",emissive:"white",emissiveIntensity:.25,toneMapped:!1})]}),s&&Ie.jsxs("mesh",{ref:c,position:$,children:[Ie.jsx("planeGeometry",{args:L}),Ie.jsx("meshBasicMaterial",{map:s,transparent:!0,opacity:.85,depthWrite:!1,depthTest:!0})]})]})})},wee=({item:n,mixFactor:e})=>{const t=we.useRef(null),r=we.useRef(1),s=we.useMemo(()=>new le,[]),i=we.useMemo(()=>new le,[]),{ribbonColor:o,ribbonMaterial:a}=we.useMemo(()=>{const l=n.color,u=.299*l.r+.587*l.g+.114*l.b;let c="#FFD700";return l.b>l.r+.2&&l.b>l.g+.2?c="#E0E0E0":u>.6&&(c="#AA0000"),{ribbonColor:new Nt(c),ribbonMaterial:new Fu({color:c,roughness:.2,metalness:.8,emissive:c,emissiveIntensity:.2})}},[n.color]);return Ka((l,u)=>{if(!t.current)return;const c=2*u;r.current=mi(r.current,e,c);const h=r.current;s.lerpVectors(n.chaosPos,n.targetPos,h),t.current.position.copy(s),i.lerpVectors(n.chaosScale,n.targetScale,h),t.current.scale.copy(i),t.current.rotation.copy(n.rotation),h<.5&&(t.current.rotation.x+=u*.5,t.current.rotation.y+=u*.5)}),Ie.jsxs("group",{ref:t,children:[Ie.jsxs("mesh",{castShadow:!0,receiveShadow:!0,children:[Ie.jsx("boxGeometry",{args:[1,1,1]}),Ie.jsx("meshStandardMaterial",{color:n.color,roughness:.4,metalness:.1})]}),Ie.jsx("mesh",{scale:[.2,1.01,1.01],material:a,children:Ie.jsx("boxGeometry",{args:[1,1,1]})}),Ie.jsx("mesh",{scale:[1.01,1.01,.2],material:a,children:Ie.jsx("boxGeometry",{args:[1,1,1]})}),Ie.jsx("mesh",{position:[0,.5,0],rotation:[0,Math.PI/4,0],material:a,scale:[.35,.35,.35],children:Ie.jsx("torusKnotGeometry",{args:[.6,.15,64,8,2,3]})})]})},$2=()=>{const n=document.createElement("canvas");n.width=256,n.height=320;const e=n.getContext("2d");return e&&(e.fillStyle="#000000",e.fillRect(0,0,256,320),e.strokeStyle="#d4af37",e.lineWidth=4,e.strokeRect(10,10,236,300),e.fillStyle="#d4af37",e.font="30px serif",e.textAlign="center",e.fillText("Merry",128,140),e.fillText("Christmas",128,180)),new lx(n)},bee=({item:n,index:e,mixFactor:t,url:r,signatureTexture:s,interactionRef:i})=>{const o=fT(Pz,r);return Ie.jsx(DB,{item:n,index:e,mixFactor:t,texture:o,signatureTexture:s,interactionRef:i})},See=n=>Ie.jsx(Yv.Suspense,{fallback:Ie.jsx("group",{position:n.item.targetPos,children:Ie.jsxs("mesh",{scale:n.item.targetScale,children:[Ie.jsx("boxGeometry",{args:[1,1.2,.05]}),Ie.jsx("meshStandardMaterial",{color:"#222"})]})}),children:Ie.jsx(bee,{...n})}),_ee=n=>{switch(n){case"BALL":return 0;case"BOX":return 1;case"STAR":return 2;case"CANDY":return 3;case"CRYSTAL":return 4;case"PHOTO":return 5;default:return 0}},Bg=({mixFactor:n,type:e,count:t,colors:r,scale:s=1,userImages:i=[],signatureText:o,inputRef:a,ringStateRef:l})=>{const u=we.useRef(null),c=we.useMemo(()=>new dr,[]),h=we.useRef(1),d=we.useRef(null),{camera:p}=wl(),g=we.useRef({hoveredIndex:-1,zoomedIndex:-1}),w=we.useMemo(()=>new le,[]),y=we.useMemo(()=>e==="CANDY"?vee():null,[e]),x=we.useMemo(()=>e==="PHOTO"&&o?xee(o):null,[e,o]),_=we.useMemo(()=>{switch(e){case"CANDY":return yee();case"CRYSTAL":return yP(6,1,.3,.1);case"STAR":return yP(5,1,.5,.2);case"BALL":return new Wy(1,16,16);case"BOX":default:return new jd(1,1,1)}},[e]),T=we.useMemo(()=>{const N=[],M=Math.PI*(3-Math.sqrt(5)),$=18,L=7.5,k=9,P=_ee(e)*(Math.PI*2/6);for(let B=0;B<t;B++){const Z=Math.sqrt((B+1)/t)*.9,V=Z*L,X=k-Z*$,q=B*M+P,se=V*Math.cos(q),W=V*Math.sin(q),J=new le(se,X,W),K=e==="STAR"||e==="PHOTO"?1.15:1.08;J.multiplyScalar(K);let G,Q=0;if(e==="PHOTO"){const st=(B/t-.5)*14,ct=B*M;G=new le(22*Math.cos(ct),st,22*Math.sin(ct)),Q=(B%5-2)*.15}else G=gM(25);const ne=r?r[Math.floor(Math.random()*r.length)]:"#ffffff",ce=new le(1,1,1),ye=Math.random()*.4+.8;e==="CANDY"?ce.setScalar(.7):e==="CRYSTAL"?ce.setScalar(.6):e==="STAR"?ce.setScalar(.7):e==="BOX"&&ce.set(1+Math.random()*.3,.7+Math.random()*.4,1+Math.random()*.3);const Se=ce.clone().multiplyScalar(s*ye);let Re=Se.clone();if(e==="PHOTO"){const Oe=3.5+Math.random()*1.5;Re.multiplyScalar(Oe)}N.push({chaosPos:G,targetPos:J,rotation:new Fy(Math.random()*Math.PI,Math.random()*Math.PI,0),color:new Nt(ne),targetScale:Se,chaosScale:Re,chaosTilt:Q})}return N},[t,e,r,s]),E=we.useMemo(()=>e!=="PHOTO"?[]:[$2(),$2(),$2()],[e]);return we.useLayoutEffect(()=>{!u.current||e==="PHOTO"||e==="BOX"||(T.forEach((N,M)=>{const $=e==="CANDY"?new Nt("#ffffff"):N.color;u.current.setColorAt(M,$),c.position.copy(N.targetPos),c.scale.copy(N.targetScale),c.rotation.copy(N.rotation),c.updateMatrix(),u.current.setMatrixAt(M,c.matrix)}),u.current.instanceColor&&(u.current.instanceColor.needsUpdate=!0),u.current.instanceMatrix.needsUpdate=!0)},[T,e,c]),Ka((N,M)=>{const $=2*M;h.current=mi(h.current,n,$);const L=h.current;if(L>.3&&g.current.zoomedIndex!==-1&&(g.current.zoomedIndex=-1),e==="PHOTO"&&a&&d.current){const{x:P,y:B,gesture:Z,isDetected:V}=a.current,X=L<.3;let q=!1,se=-1;if(X&&V)if(Z==="PINCH")if(g.current.zoomedIndex!==-1)se=g.current.zoomedIndex;else{const J=d.current.matrixWorld;let K=1/0,G=-1;T.forEach((Q,ne)=>{w.lerpVectors(Q.chaosPos,Q.targetPos,L),w.applyMatrix4(J),w.project(p);const ce=Math.hypot(w.x-P,w.y-B);ce<.25&&ce<K&&(K=ce,G=ne)}),G!==-1&&(g.current.zoomedIndex=G,se=G)}else{g.current.zoomedIndex=-1;const J=d.current.matrixWorld;let K=1/0,G=-1;T.forEach((Q,ne)=>{w.lerpVectors(Q.chaosPos,Q.targetPos,L),w.applyMatrix4(J),w.project(p);const ce=Math.hypot(w.x-P,w.y-B);ce<.25&&ce<K&&(K=ce,G=ne)}),se=G}else g.current.zoomedIndex=-1;se!==-1?(q=!0,g.current.hoveredIndex=se):g.current.hoveredIndex=-1,l&&(l.current.isHovering=q)}if(!u.current||e==="PHOTO"||e==="BOX")return;const k=new le,R=new le;T.forEach((P,B)=>{k.lerpVectors(P.chaosPos,P.targetPos,L),c.position.copy(k),e==="STAR"&&L>.8?(c.lookAt(0,k.y,0),c.rotateZ(Math.PI/2)):e==="CRYSTAL"&&L>.8?c.lookAt(0,k.y,0):(c.rotation.copy(P.rotation),L<.5&&(c.rotation.x+=M*.5,c.rotation.y+=M*.5)),R.lerpVectors(P.chaosScale,P.targetScale,L),c.scale.copy(R),c.updateMatrix(),u.current.setMatrixAt(B,c.matrix)}),u.current.instanceMatrix.needsUpdate=!0}),e==="PHOTO"?Ie.jsx("group",{ref:d,children:T.map((N,M)=>{let $;i&&i.length>0&&M<i.length&&($=i[M]);const L=E[M%E.length];return $?Ie.jsx(See,{index:M,item:N,mixFactor:n,url:$,signatureTexture:x,interactionRef:g},M):Ie.jsx(DB,{index:M,item:N,mixFactor:n,texture:L,signatureTexture:x,interactionRef:g},M)})}):e==="BOX"?Ie.jsx("group",{children:T.map((N,M)=>Ie.jsx(wee,{item:N,mixFactor:n},M))}):Ie.jsx("instancedMesh",{ref:u,args:[_,void 0,t],children:Ie.jsx("meshStandardMaterial",{map:y,roughness:e==="CANDY"?.2:.15,metalness:e==="CRYSTAL"?.9:.5,emissive:e==="CRYSTAL"?"#112244":"#000000",emissiveIntensity:.2})})},Tee=({mixFactor:n})=>{const t=we.useRef(null),r=we.useMemo(()=>new dr,[]),s=we.useRef(1),{target:i,chaos:o}=we.useMemo(()=>fee(300,19,7.5,9),[]);return we.useLayoutEffect(()=>{if(!t.current)return;const a=new Nt("#fffae0");for(let l=0;l<300;l++)t.current.setColorAt(l,a),r.position.set(i[l*3],i[l*3+1],i[l*3+2]),r.scale.setScalar(.15),r.updateMatrix(),t.current.setMatrixAt(l,r.matrix);t.current.instanceColor&&(t.current.instanceColor.needsUpdate=!0),t.current.instanceMatrix.needsUpdate=!0},[i,r]),Ka((a,l)=>{if(!t.current)return;const u=2*l;s.current=mi(s.current,n,u);const c=s.current,h=a.clock.elapsedTime;for(let d=0;d<300;d++){const p=i[d*3],g=i[d*3+1],w=i[d*3+2],y=o[d*3],x=o[d*3+1],_=o[d*3+2],T=mi(y,p,c),E=mi(x,g,c),N=mi(_,w,c);r.position.set(T,E,N);const M=Math.sin(h*3+d*.1)*.05+.15;r.scale.setScalar(M),r.updateMatrix(),t.current.setMatrixAt(d,r.matrix)}t.current.instanceMatrix.needsUpdate=!0}),Ie.jsxs("instancedMesh",{ref:t,args:[void 0,void 0,300],children:[Ie.jsx("sphereGeometry",{args:[1,8,8]}),Ie.jsx("meshBasicMaterial",{color:"#fffae0",toneMapped:!1})]})},Eee=`
  precision highp float;
  uniform float uTime; // Global Time
  uniform float uMix;  // Still used for drift amplitude
  
  attribute float aScale;
  attribute vec3 aVelocity;
  
  varying float vAlpha;

  void main() {
    vec3 pos = position;
    
    // Physics
    // Fall down based on Global Time.
    float fallSpeed = aVelocity.y; 
    
    pos.y = mod(pos.y - uTime * fallSpeed + 15.0, 30.0) - 15.0; // Wrap Y (-15 to 15)
    
    // Side drift
    // uMix still controls the Amplitude of the drift (Chaos = wider drift)
    float drift = sin(uTime * aVelocity.x + pos.y) * (0.5 + (1.0 - uMix) * 2.0);
    pos.x += drift;
    pos.z += cos(uTime * aVelocity.z + pos.x) * 0.5;

    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;
    
    // Size
    gl_PointSize = aScale * (15.0 / -mvPosition.z);
    
    // Fade at edges of box
    vAlpha = 1.0 - smoothstep(12.0, 15.0, abs(pos.y));
  }
`,Cee=`
  precision highp float;
  varying float vAlpha;

  void main() {
    vec2 coord = gl_PointCoord - vec2(0.5);
    float dist = length(coord);
    if (dist > 0.5) discard;
    
    float alpha = (1.0 - smoothstep(0.3, 0.5, dist)) * vAlpha * 0.8;
    gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
  }
`,Iee=({mixFactor:n})=>{const t=we.useRef(null),r=we.useRef(null),s=we.useRef(1),{camera:i}=wl(),{positions:o,scales:a,velocities:l}=we.useMemo(()=>{const c=new Float32Array(9e3),h=new Float32Array(3e3),d=new Float32Array(3e3*3);for(let p=0;p<3e3;p++)c[p*3]=(Math.random()-.5)*50,c[p*3+1]=(Math.random()-.5)*30,c[p*3+2]=(Math.random()-.5)*40,h[p]=Math.random()*2+1,d[p*3]=Math.random()*.5+.2,d[p*3+1]=Math.random()*2+1,d[p*3+2]=Math.random()*.5+.2;return{positions:c,scales:h,velocities:d}},[3e3]),u=we.useMemo(()=>({uTime:{value:0},uMix:{value:1}}),[]);return Ka((c,h)=>{r.current&&t.current&&(s.current=mi(s.current,n,h*2),r.current.uniforms.uTime.value=c.clock.elapsedTime,r.current.uniforms.uMix.value=s.current,t.current.position.x=i.position.x,t.current.position.y=i.position.y)}),Ie.jsxs("points",{ref:t,frustumCulled:!1,children:[Ie.jsxs("bufferGeometry",{children:[Ie.jsx("bufferAttribute",{attach:"attributes-position",count:3e3,array:o,itemSize:3}),Ie.jsx("bufferAttribute",{attach:"attributes-aScale",count:3e3,array:a,itemSize:1}),Ie.jsx("bufferAttribute",{attach:"attributes-aVelocity",count:3e3,array:l,itemSize:3})]}),Ie.jsx("shaderMaterial",{ref:r,vertexShader:Eee,fragmentShader:Cee,uniforms:u,transparent:!0,depthWrite:!1})]})},Nee=(n,e,t)=>{const r=new sh,s=Math.PI*2/(t*2);r.moveTo(0,n);for(let i=0;i<t*2;i++){const o=i%2===0?n:e,l=i*s+Math.PI/2;r.lineTo(Math.cos(l)*o,Math.sin(l)*o)}return r.closePath(),r},Aee=({mixFactor:n})=>{const e=we.useRef(null),t=we.useRef(null),r=we.useRef(null),s=we.useRef(1),i=we.useMemo(()=>{const o=Nee(1.2,.6,5),a=new Vy(o,{depth:.4,bevelEnabled:!0,bevelThickness:.1,bevelSize:.1,bevelSegments:4});return a.center(),a},[]);return Ka((o,a)=>{if(!e.current||!t.current||!r.current)return;const l=2*a;s.current=mi(s.current,n,l);const u=s.current,d=mi(13,9.2,u);if(e.current.position.set(0,d,0),r.current.rotation.y+=a*.5,u<.9){const p=(1-u)*.5;e.current.rotation.z=Math.sin(o.clock.elapsedTime)*p,e.current.rotation.x=Math.cos(o.clock.elapsedTime*.8)*p}else e.current.rotation.z=mi(e.current.rotation.z,0,l),e.current.rotation.x=mi(e.current.rotation.x,0,l);t.current.scale.setScalar(1)}),Ie.jsxs("group",{ref:e,children:[Ie.jsx("group",{ref:t,children:Ie.jsx("mesh",{ref:r,geometry:i,children:Ie.jsx("meshStandardMaterial",{color:"#FFD700",emissive:"#FFD700",emissiveIntensity:2,roughness:.1,metalness:.9,toneMapped:!1})})}),Ie.jsx("pointLight",{color:"#ffeebf",intensity:3,distance:15,decay:2})]})},vP=({mixFactor:n,phaseOffset:e=0,yOffset:t=0,radiusScale:r=1,speed:s=1})=>{const i=we.useRef(null),o=we.useRef(null),a=we.useRef(1),l=we.useRef(0),u=we.useMemo(()=>({red:new Fu({color:"#D32F2F",roughness:.3}),white:new Fu({color:"#FFFFFF",roughness:.9}),skin:new Fu({color:"#FFCCAA",roughness:.5}),gold:new Fu({color:"#FFD700",metalness:.8,roughness:.2}),brown:new Fu({color:"#5D4037",roughness:.8}),black:new Fu({color:"#111111",roughness:.5})}),[]);return Ka((c,h)=>{if(!i.current||!o.current)return;const d=2*h;a.current=mi(a.current,n,d);const p=a.current;l.current+=h*.8*s;const w=mi(25,12,p)*r,y=Math.sin(l.current*1.5+e)*1.5,x=2+t+y,_=l.current+e,T=Math.cos(_)*w,E=Math.sin(_)*w;i.current.position.set(T,x,E);const N=Math.cos(_+.1)*w,M=Math.sin(_+.1)*w;i.current.lookAt(N,x,M),o.current.rotation.z=-.3,i.current.scale.setScalar(.8)}),Ie.jsx("group",{ref:i,children:Ie.jsxs("group",{ref:o,children:[Ie.jsx("mesh",{position:[0,0,0],material:u.red,children:Ie.jsx("boxGeometry",{args:[1.8,.8,1.2]})}),Ie.jsx("mesh",{position:[0,.45,0],material:u.gold,children:Ie.jsx("boxGeometry",{args:[1.9,.1,1.3]})}),Ie.jsxs("group",{position:[0,-.6,0],children:[Ie.jsx("mesh",{position:[0,0,.4],material:u.gold,children:Ie.jsx("boxGeometry",{args:[2.2,.1,.1]})}),Ie.jsx("mesh",{position:[0,0,-.4],material:u.gold,children:Ie.jsx("boxGeometry",{args:[2.2,.1,.1]})}),Ie.jsx("mesh",{position:[.5,.3,.4],material:u.brown,children:Ie.jsx("cylinderGeometry",{args:[.05,.05,.6]})}),Ie.jsx("mesh",{position:[-.5,.3,.4],material:u.brown,children:Ie.jsx("cylinderGeometry",{args:[.05,.05,.6]})}),Ie.jsx("mesh",{position:[.5,.3,-.4],material:u.brown,children:Ie.jsx("cylinderGeometry",{args:[.05,.05,.6]})}),Ie.jsx("mesh",{position:[-.5,.3,-.4],material:u.brown,children:Ie.jsx("cylinderGeometry",{args:[.05,.05,.6]})})]}),Ie.jsxs("group",{position:[-.2,.6,0],children:[Ie.jsx("mesh",{position:[0,0,0],material:u.red,children:Ie.jsx("sphereGeometry",{args:[.5,16,16]})}),Ie.jsx("mesh",{position:[0,.5,0],material:u.skin,children:Ie.jsx("sphereGeometry",{args:[.25,16,16]})}),Ie.jsx("mesh",{position:[.15,.4,0],rotation:[0,0,-.2],material:u.white,children:Ie.jsx("coneGeometry",{args:[.2,.3,16]})}),Ie.jsxs("group",{position:[0,.7,0],rotation:[0,0,-.2],children:[Ie.jsx("mesh",{material:u.red,children:Ie.jsx("coneGeometry",{args:[.26,.5,16]})}),Ie.jsx("mesh",{position:[0,-.25,0],material:u.white,children:Ie.jsx("torusGeometry",{args:[.26,.08,8,16]})}),Ie.jsx("mesh",{position:[0,.25,0],material:u.white,children:Ie.jsx("sphereGeometry",{args:[.08]})})]})]}),Ie.jsx("mesh",{position:[-.7,.6,0],rotation:[0,0,.2],material:u.brown,children:Ie.jsx("sphereGeometry",{args:[.45,12,12]})}),Ie.jsx("pointLight",{color:"#ffaa00",intensity:2,distance:8,decay:2,position:[1,.5,0]})]})})},Mee=["#FF0000","#00FF00","#0000FF"],kee=["#FF0000","#00FF00","#0000FF"],Ree=["#FFD700","#FDB931"],Dee=["#F0F8FF","#E0FFFF","#B0E0E6"],$ee=["#FFFFFF"],Pee=({inputRef:n,ringStateRef:e})=>{const t=we.useRef(null),r=we.useRef(null),s=we.useRef(null),{camera:i}=wl(),o=we.useMemo(()=>new le,[]);return Ka((a,l)=>{if(!t.current||!r.current||!s.current)return;const{x:u,y:c,isDetected:h,gesture:d}=n.current,p=h&&d==="PINCH",g=e.current.isHovering,w=p?g?1.2:1:0;if(t.current.scale.lerp(new le(w,w,w),l*15),w<.01&&!p){t.current.visible=!1;return}t.current.visible=!0;const y=15;o.set(u,c,.5),o.unproject(i),o.sub(i.position).normalize();const x=i.position.clone().add(o.multiplyScalar(y));t.current.position.lerp(x,l*25),t.current.lookAt(i.position);const _=r.current.material,T=g?new Nt("#00FFFF"):new Nt("#FFD700");_.color.lerp(T,l*10),g?(s.current.scale.setScalar(.8+Math.sin(a.clock.elapsedTime*10)*.1),s.current.material.color.set("#00FFFF")):(s.current.scale.setScalar(1),s.current.material.color.set("#FFFFFF"))}),Ie.jsxs("group",{ref:t,visible:!1,children:[Ie.jsxs("mesh",{ref:r,children:[Ie.jsx("torusGeometry",{args:[.5,.04,16,64]}),Ie.jsx("meshBasicMaterial",{color:"#FFD700",transparent:!0,opacity:.9})]}),Ie.jsxs("mesh",{ref:s,scale:[.5,.5,.5],children:[Ie.jsx("torusGeometry",{args:[.3,.02,16,64]}),Ie.jsx("meshBasicMaterial",{color:"#FFFFFF",transparent:!0,opacity:.6})]})]})},Lee=({inputRef:n,groupRef:e})=>{const{camera:t,gl:r}=wl(),s=we.useMemo(()=>new le,[]),i=we.useRef(32),o=we.useRef(!1),a=we.useRef(0),l=we.useRef(null),u=we.useRef(.002),c=we.useRef(!1),h=we.useRef(0),d=we.useRef({x:0,y:0});return we.useEffect(()=>{const p=r.domElement;p.style.touchAction="none";const g=N=>{N.preventDefault(),i.current+=N.deltaY*.02,i.current=Ua.clamp(i.current,12,55)},w=N=>{N.isPrimary&&N.button===0&&(o.current=!0,a.current=N.clientX,p.setPointerCapture(N.pointerId),u.current=0)},y=N=>{N.isPrimary&&(o.current=!1,p.releasePointerCapture(N.pointerId))},x=N=>{if(N.isPrimary&&o.current&&e.current&&l.current===null){const M=N.clientX-a.current;a.current=N.clientX;const $=M*.005;e.current.rotation.y+=$,u.current=$}},_=N=>{if(N.touches.length===2){const M=N.touches[0].clientX-N.touches[1].clientX,$=N.touches[0].clientY-N.touches[1].clientY;l.current=Math.sqrt(M*M+$*$)}},T=N=>{if(N.touches.length===2){N.cancelable&&N.preventDefault();const M=N.touches[0].clientX-N.touches[1].clientX,$=N.touches[0].clientY-N.touches[1].clientY,L=Math.sqrt(M*M+$*$);if(l.current!==null){const k=l.current-L,R=.15;i.current+=k*R,i.current=Ua.clamp(i.current,12,55)}l.current=L}},E=()=>{l.current=null};return p.addEventListener("wheel",g,{passive:!1}),p.addEventListener("pointerdown",w),p.addEventListener("pointerup",y),p.addEventListener("pointermove",x),p.addEventListener("pointerleave",y),p.addEventListener("pointercancel",y),p.addEventListener("touchstart",_,{passive:!1}),p.addEventListener("touchmove",T,{passive:!1}),p.addEventListener("touchend",E),p.addEventListener("touchcancel",E),()=>{p.removeEventListener("wheel",g),p.removeEventListener("pointerdown",w),p.removeEventListener("pointerup",y),p.removeEventListener("pointermove",x),p.removeEventListener("pointerleave",y),p.removeEventListener("pointercancel",y),p.removeEventListener("touchstart",_),p.removeEventListener("touchmove",T),p.removeEventListener("touchend",E),p.removeEventListener("touchcancel",E)}},[r,e]),Ka((p,g)=>{const w=Math.min(g,.1),y=n.current.x*1.2,x=n.current.y,_=!!n.current.isDetected,T=n.current.handSize||0,E=4*w;d.current.x=Ua.lerp(d.current.x,y,E),d.current.y=Ua.lerp(d.current.y,x,E);let N=i.current;if(_&&T>0){const P=Ua.clamp((T-.05)/.2,0,1),B=Ua.lerp(55,15,P);N=B,i.current=Ua.lerp(i.current,B,.05)}const M=d.current.x*4,$=d.current.y*2,L=N+Math.abs(d.current.x)*2;if(t.position.lerp(s.set(M,$,L),4*w),t.lookAt(0,0,0),e.current){if(_&&n.current.gesture!=="POINT"&&n.current.gesture!=="PINCH"){const k=Math.PI*1.2,R=d.current.x*k;c.current||(h.current=e.current.rotation.y-R,u.current=0);const P=R+h.current,B=6*w,Z=e.current.rotation.y;e.current.rotation.y=Ua.lerp(Z,P,B),u.current=e.current.rotation.y-Z,c.current=!0}else if(c.current&&(Math.abs(u.current)<1e-4&&(u.current=.002),c.current=!1),!o.current){e.current.rotation.y+=u.current;const k=.002;u.current=Ua.lerp(u.current,k,w*.5)}}}),null},Oee=({mixFactor:n,colors:e,inputRef:t,userImages:r,signatureText:s})=>{const i=we.useRef(null),o=we.useRef({isHovering:!1}),a=r&&r.length>0?r.length:10;return Ie.jsxs(Ie.Fragment,{children:[Ie.jsx(Lee,{inputRef:t,groupRef:i}),Ie.jsx(Pee,{inputRef:t,ringStateRef:o}),Ie.jsx("ambientLight",{intensity:.4}),Ie.jsx("spotLight",{position:[20,20,20],angle:.4,penumbra:1,intensity:2,color:"#fff5d0",castShadow:!0}),Ie.jsx("pointLight",{position:[-10,5,-10],intensity:1.2,color:"#00ff00"}),Ie.jsx("pointLight",{position:[10,-5,10],intensity:1.2,color:"#ff0000"}),Ie.jsx("pointLight",{position:[0,10,10],intensity:.5,color:"#ffffff"}),Ie.jsx(zJ,{files:"public/hdri/potsdamer_platz_1k.hdr",background:!1}),Ie.jsx(VJ,{color:"#FFD700",size:3,count:200,scale:30,opacity:.6}),Ie.jsx(Iee,{mixFactor:n}),Ie.jsxs("group",{ref:i,position:[0,0,0],children:[Ie.jsx(Aee,{mixFactor:n}),Ie.jsx(gee,{mixFactor:n,colors:e}),Ie.jsx(Tee,{mixFactor:n}),Ie.jsx(vP,{mixFactor:n,phaseOffset:0,yOffset:0,speed:1,radiusScale:1}),Ie.jsx(vP,{mixFactor:n,phaseOffset:Math.PI,yOffset:4,speed:1.2,radiusScale:.8}),Ie.jsx(Bg,{mixFactor:n,type:"BALL",count:60,scale:.5,colors:Mee}),Ie.jsx(Bg,{mixFactor:n,type:"BOX",count:30,scale:.6,colors:kee}),Ie.jsx(Bg,{mixFactor:n,type:"STAR",count:25,scale:.5,colors:Ree}),Ie.jsx(Bg,{mixFactor:n,type:"CRYSTAL",count:40,scale:.4,colors:Dee}),Ie.jsx(Bg,{mixFactor:n,type:"CANDY",count:40,scale:.8,colors:$ee}),Ie.jsx(Bg,{mixFactor:n,type:"PHOTO",count:a,userImages:r,signatureText:s,inputRef:t,ringStateRef:o})]}),Ie.jsxs(aee,{enableNormalPass:!1,multisampling:0,children:[Ie.jsx(uee,{luminanceThreshold:.9,mipmapBlur:!0,intensity:1.2,radius:.6}),Ie.jsx(cee,{eskil:!1,offset:.1,darkness:1.1})]})]})},Fee=n=>Ie.jsx(dJ,{dpr:[1,1.25],camera:{position:[0,0,32],fov:45,near:.1,far:100},gl:{antialias:!1,toneMapping:U_,toneMappingExposure:1},shadows:!0,style:{touchAction:"none"},children:Ie.jsx(Oee,{...n})});var RS={exports:{}},zee=RS.exports,xP;function Bee(){return xP||(xP=1,(function(n,e){(function(r,s){n.exports=s(Vx())})(zee,function(t){return(function(r){var s={};function i(o){if(s[o])return s[o].exports;var a=s[o]={i:o,l:!1,exports:{}};return r[o].call(a.exports,a,a.exports,i),a.l=!0,a.exports}return i.m=r,i.c=s,i.d=function(o,a,l){i.o(o,a)||Object.defineProperty(o,a,{enumerable:!0,get:l})},i.r=function(o){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(o,"__esModule",{value:!0})},i.t=function(o,a){if(a&1&&(o=i(o)),a&8||a&4&&typeof o=="object"&&o&&o.__esModule)return o;var l=Object.create(null);if(i.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:o}),a&2&&typeof o!="string")for(var u in o)i.d(l,u,(function(c){return o[c]}).bind(null,u));return l},i.n=function(o){var a=o&&o.__esModule?function(){return o.default}:function(){return o};return i.d(a,"a",a),a},i.o=function(o,a){return Object.prototype.hasOwnProperty.call(o,a)},i.p="",i(i.s="./src/react-webcam.tsx")})({"./src/react-webcam.tsx":(function(r,s,i){i.r(s);var o=i("react"),a=(function(){var d=function(p,g){return d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(w,y){w.__proto__=y}||function(w,y){for(var x in y)y.hasOwnProperty(x)&&(w[x]=y[x])},d(p,g)};return function(p,g){d(p,g);function w(){this.constructor=p}p.prototype=g===null?Object.create(g):(w.prototype=g.prototype,new w)}})(),l=function(){return l=Object.assign||function(d){for(var p,g=1,w=arguments.length;g<w;g++){p=arguments[g];for(var y in p)Object.prototype.hasOwnProperty.call(p,y)&&(d[y]=p[y])}return d},l.apply(this,arguments)},u=function(d,p){var g={};for(var w in d)Object.prototype.hasOwnProperty.call(d,w)&&p.indexOf(w)<0&&(g[w]=d[w]);if(d!=null&&typeof Object.getOwnPropertySymbols=="function")for(var y=0,w=Object.getOwnPropertySymbols(d);y<w.length;y++)p.indexOf(w[y])<0&&Object.prototype.propertyIsEnumerable.call(d,w[y])&&(g[w[y]]=d[w[y]]);return g};(function(){typeof window>"u"||(navigator.mediaDevices===void 0&&(navigator.mediaDevices={}),navigator.mediaDevices.getUserMedia===void 0&&(navigator.mediaDevices.getUserMedia=function(p){var g=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return g?new Promise(function(w,y){g.call(navigator,p,w,y)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}))})();function c(){return!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)}var h=(function(d){a(p,d);function p(g){var w=d.call(this,g)||this;return w.canvas=null,w.ctx=null,w.requestUserMediaId=0,w.unmounted=!1,w.state={hasUserMedia:!1},w}return p.prototype.componentDidMount=function(){var g=this,w=g.state,y=g.props;if(this.unmounted=!1,!c()){y.onUserMediaError("getUserMedia not supported");return}w.hasUserMedia||this.requestUserMedia(),y.children&&typeof y.children!="function"&&console.warn("children must be a function")},p.prototype.componentDidUpdate=function(g){var w=this.props;if(!c()){w.onUserMediaError("getUserMedia not supported");return}var y=JSON.stringify(g.audioConstraints)!==JSON.stringify(w.audioConstraints),x=JSON.stringify(g.videoConstraints)!==JSON.stringify(w.videoConstraints),_=g.minScreenshotWidth!==w.minScreenshotWidth,T=g.minScreenshotHeight!==w.minScreenshotHeight;(x||_||T)&&(this.canvas=null,this.ctx=null),(y||x)&&(this.stopAndCleanup(),this.requestUserMedia())},p.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},p.stopMediaStream=function(g){g&&(g.getVideoTracks&&g.getAudioTracks?(g.getVideoTracks().map(function(w){g.removeTrack(w),w.stop()}),g.getAudioTracks().map(function(w){g.removeTrack(w),w.stop()})):g.stop())},p.prototype.stopAndCleanup=function(){var g=this.state;g.hasUserMedia&&(p.stopMediaStream(this.stream),g.src&&window.URL.revokeObjectURL(g.src))},p.prototype.getScreenshot=function(g){var w=this,y=w.state,x=w.props;if(!y.hasUserMedia)return null;var _=this.getCanvas(g);return _&&_.toDataURL(x.screenshotFormat,x.screenshotQuality)},p.prototype.getCanvas=function(g){var w=this,y=w.state,x=w.props;if(!this.video||!y.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var _=this.video.videoWidth,T=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var E=_/T;_=x.minScreenshotWidth||this.video.clientWidth,T=_/E,x.minScreenshotHeight&&T<x.minScreenshotHeight&&(T=x.minScreenshotHeight,_=T*E)}this.canvas=document.createElement("canvas"),this.canvas.width=(g==null?void 0:g.width)||_,this.canvas.height=(g==null?void 0:g.height)||T,this.ctx=this.canvas.getContext("2d")}var N=this,M=N.ctx,$=N.canvas;return M&&$&&($.width=(g==null?void 0:g.width)||$.width,$.height=(g==null?void 0:g.height)||$.height,x.mirrored&&(M.translate($.width,0),M.scale(-1,1)),M.imageSmoothingEnabled=x.imageSmoothing,M.drawImage(this.video,0,0,(g==null?void 0:g.width)||$.width,(g==null?void 0:g.height)||$.height),x.mirrored&&(M.scale(-1,1),M.translate(-$.width,0))),$},p.prototype.requestUserMedia=function(){var g=this,w=this.props,y=function(T,E){var N={video:typeof E<"u"?E:!0};w.audio&&(N.audio=typeof T<"u"?T:!0),g.requestUserMediaId++;var M=g.requestUserMediaId;navigator.mediaDevices.getUserMedia(N).then(function($){g.unmounted||M!==g.requestUserMediaId?p.stopMediaStream($):g.handleUserMedia(null,$)}).catch(function($){g.handleUserMedia($)})};if("mediaDevices"in navigator)y(w.audioConstraints,w.videoConstraints);else{var x=function(T){return{optional:[{sourceId:T}]}},_=function(T){var E=T.deviceId;return typeof E=="string"?E:Array.isArray(E)&&E.length>0?E[0]:typeof E=="object"&&E.ideal?E.ideal:null};MediaStreamTrack.getSources(function(T){var E=null,N=null;T.forEach(function(L){L.kind==="audio"?E=L.id:L.kind==="video"&&(N=L.id)});var M=_(w.audioConstraints);M&&(E=M);var $=_(w.videoConstraints);$&&(N=$),y(x(E),x(N))})}},p.prototype.handleUserMedia=function(g,w){var y=this.props;if(g||!w){this.setState({hasUserMedia:!1}),y.onUserMediaError(g);return}this.stream=w;try{this.video&&(this.video.srcObject=w),this.setState({hasUserMedia:!0})}catch{this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(w)})}y.onUserMedia(w)},p.prototype.render=function(){var g=this,w=this,y=w.state,x=w.props,_=x.audio;x.forceScreenshotSourceSize;var T=x.disablePictureInPicture;x.onUserMedia,x.onUserMediaError,x.screenshotFormat,x.screenshotQuality,x.minScreenshotWidth,x.minScreenshotHeight,x.audioConstraints,x.videoConstraints,x.imageSmoothing;var E=x.mirrored,N=x.style,M=N===void 0?{}:N,$=x.children,L=u(x,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),k=E?l(l({},M),{transform:(M.transform||"")+" scaleX(-1)"}):M,R={getScreenshot:this.getScreenshot.bind(this)};return o.createElement(o.Fragment,null,o.createElement("video",l({autoPlay:!0,disablePictureInPicture:T,src:y.src,muted:!_,playsInline:!0,ref:function(P){g.video=P},style:k},L)),$&&$(R))},p.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},p})(o.Component);s.default=h}),react:(function(r,s){r.exports=t})}).default})})(RS)),RS.exports}var Uee=Bee();const Vee=Ux(Uee);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wee=1e-7,Gee=1e-4;class $B{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}let yM=class{refCount(e){return fa("refCount")}incRef(e){return fa("incRef")}timerAvailable(){return!0}time(e){return fa("time")}read(e){return fa("read")}readSync(e){return fa("readSync")}readToGPU(e,t){return fa("readToGPU")}numDataIds(){return fa("numDataIds")}disposeData(e,t){return fa("disposeData")}write(e,t,r){return fa("write")}move(e,t,r,s,i){return fa("move")}createTensorFromGPUData(e,t,r){return fa("createTensorFromGPUData")}memory(){return fa("memory")}floatPrecision(){return fa("floatPrecision")}epsilon(){return this.floatPrecision()===32?Wee:Gee}dispose(){return fa("dispose")}};function fa(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hee(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Xg(n,e,t)}function zp(n,e,t){return Math.max(n,Math.min(e,t))}function vM(n){return n%2===0?n:n+1}function Xg(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function jee(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function ie(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function xM(n,e,t=""){ie(_r(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function PB(n){ie(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Qe(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function _r(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Sy(n){return n%1===0}function rN(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function ay(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function wP(n,e=s=>0,t,r){return new Promise((s,i)=>{let o=0;const a=()=>{if(n()){s();return}o++;const l=e(o);if(t!=null&&o>=t){i();return}r!=null?r(a,l):setTimeout(a,l)};a()})}function LB(n,e){let t=1,r=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${i}`);r=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const s=n.slice();return s[r]=e/t,s}function qn(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),ie(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),ie(n.every(r=>Sy(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function Kd(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||s?null:qn(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),i[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function Yi(n,e){return Cs(n,e)}function Cs(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function Xee(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function qee(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function OB(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function e_(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function Kee(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function t1(n){return typeof n=="string"||n instanceof String}function Yee(n){return typeof n=="boolean"}function sN(n){return typeof n=="number"}function jy(n){return Array.isArray(n)?jy(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":sN(n)?"float32":t1(n)?"string":Yee(n)?"bool":"float32"}function iN(n){return!!(n&&n.constructor&&n.call&&n.apply)}function oN(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function nn(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function FB(n,e,t,r=!1){const s=new Array;if(e.length===1){const i=e[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=t[n+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<i;l++)s[l]=FB(n+l*a,o,t,r)}return s}function du(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,i)=>s*i)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return FB(0,n,e,t)}function Zee(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function wM(n,e){const t=Zi(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function Zi(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function zB(n,e){const t=n.reduce((r,s)=>r*s,1);if(e==null||e==="float32")return du(n,new Float32Array(t));if(e==="int32")return du(n,new Int32Array(t));if(e==="bool")return du(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function yh(n){n.forEach(e=>{ie(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Xu(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=t[s]*n[s];return r}function Xy(n,e,t){if(e===0)return[];if(e===1)return[n];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/t[s]),n-=r[s]*t[s];return r[r.length-1]=n,r}function bM(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bP="tfjsflags";let Jee=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Qee,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(je().getBool("IS_TEST")||je().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];je().getBool("IS_TEST")||je().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(bM(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);bP in e&&e[bP].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=tte(s,i)})}};function Qee(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(ete(e,r[0],r[1]),r.join("="))),e}function ete(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function tte(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function je(){return BB}let BB=null;function nte(n){BB=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let P2;function UB(){if(P2==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");P2=n}return P2}function rte(){const n=UB();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function SM(n,e){const t=rte();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const pT="Abs",n1="Acos",r1="Acosh",qy="Add",_M="AddN",TM="All",EM="Any",mT="ArgMax",gT="ArgMin",s1="Asin",i1="Asinh",o1="Atan",a1="Atanh",l1="Atan2",yT="AvgPool",CM="AvgPoolGrad",vT="AvgPool3D",IM="AvgPool3DGrad",xT="BatchMatMul",wT="BatchToSpaceND",NM="Bincount",AM="BitwiseAnd",ste="BroadcastTo",VB="BroadcastArgs",u1="Cast",c1="Ceil",h1="ClipByValue",MM="Complex",bT="ComplexAbs",ST="Concat",_T="Conv2D",kM="Conv2DBackpropFilter",TT="Conv2DBackpropInput",ET="Conv3D",RM="Conv3DBackpropFilterV2",DM="Conv3DBackpropInputV2",d1="Cos",f1="Cosh",$M="Cumprod",CT="Cumsum",PM="CropAndResize",LM="DenseBincount",OM="DepthToSpace",IT="DepthwiseConv2dNative",FM="DepthwiseConv2dNativeBackpropFilter",zM="DepthwiseConv2dNativeBackpropInput",WB="Diag",NT="Dilation2D",aN="Dilation2DBackpropInput",lN="Dilation2DBackpropFilter",ite="Draw",p1="RealDiv",BM="Einsum",m1="Elu",UM="EluGrad",g1="Erf",AT="Equal",y1="Exp",MT="ExpandDims",v1="Expm1",VM="FFT",WM="Fill",GM="FlipLeftRight",x1="Floor",w1="FloorDiv",kT="FusedBatchNorm",RT="GatherV2",GB="GatherNd",DT="Greater",b1="GreaterEqual",S1="Identity",HM="IFFT",jM="Imag",_1="IsFinite",T1="IsInf",E1="IsNan",$T="LeakyRelu",PT="Less",LT="LessEqual",HB="LinSpace",C1="Log",I1="Log1p",OT="LogicalAnd",FT="LogicalNot",zT="LogicalOr",ote="LogSoftmax",BT="LRN",XM="LRNGrad",UT="Max",N1="Maximum",VT="MaxPool",qM="MaxPoolGrad",WT="MaxPool3D",KM="MaxPool3DGrad",jB="MaxPoolWithArgmax",GT="Mean",HT="Min",A1="Minimum",jT="MirrorPad",M1="Mod",XB="Multinomial",k1="Multiply",XT="Neg",qT="NotEqual",YM="NonMaxSuppressionV3",ZM="NonMaxSuppressionV4",JM="NonMaxSuppressionV5",KT="OnesLike",YT="OneHot",ZT="Pack",JT="PadV2",R1="Pow",QT="Prelu",eE="Prod",qB="RaggedGather",KB="RaggedRange",YB="RaggedTensorToTensor",QM="Range",ek="Real",D1="Reciprocal",$1="Relu",tE="Reshape",nE="ResizeNearestNeighbor",tk="ResizeNearestNeighborGrad",rE="ResizeBilinear",nk="ResizeBilinearGrad",P1="Relu6",sE="Reverse",L1="Round",O1="Rsqrt",ZB="ScatterNd",JB="TensorScatterUpdate",QB="SearchSorted",iE="Select",F1="Selu",oE="Slice",z1="Sin",B1="Sinh",U1="Sign",V1="Sigmoid",W1="Softplus",G1="Sqrt",aE="Sum",lE="SpaceToBatchND",uE="SplitV",cE="Softmax",eU="SparseFillEmptyRows",tU="SparseReshape",nU="SparseSegmentMean",rU="SparseSegmentSum",sU="SparseToDense",H1="SquaredDifference",rk="Square",sk="StaticRegexReplace",ik="StridedSlice",iU="StringNGrams",oU="StringSplit",aU="StringToHashBucketFast",j1="Sub",X1="Tan",q1="Tanh",K1="Tile",ok="TopK",ak="Transform",ly="Transpose",lk="Unique",hE="Unpack",dE="UnsortedSegmentSum",fE="ZerosLike",Y1="Step",ate="FromPixels",uk="RotateWithOffset",t_="_FusedMatMul",n_="FusedConv2D",lU="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wa(...n){je().getBool("IS_TEST")||je().getBool("PROD")||console.warn(...n)}function lte(...n){je().getBool("IS_TEST")||je().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r_=SM("kernelRegistry",()=>new Map),uN=SM("gradRegistry",()=>new Map);function SP(n,e){const t=cU(n,e);return r_.get(t)}function _P(n){return uN.get(n)}function TP(n){const e=r_.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&t.push(o)}return t}function uU(n){const{kernelName:e,backendName:t}=n,r=cU(e,t);r_.has(r)&&Wa(`The kernel '${e}' for backend '${t}' is already registered`),r_.set(r,n)}function ute(n){const{kernelName:e}=n;uN.has(e)&&je().getBool("DEBUG")&&Wa(`Overriding the gradient for '${e}'`),uN.set(e,n)}function cU(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hU(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var L2,EP;function cte(){if(EP)return L2;EP=1,L2=e;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function e(R,P,B){this.low=R|0,this.high=P|0,this.unsigned=!!B}e.prototype.__isLong__,Object.defineProperty(e.prototype,"__isLong__",{value:!0});function t(R){return(R&&R.__isLong__)===!0}e.isLong=t;var r={},s={};function i(R,P){var B,Z,V;return P?(R>>>=0,(V=0<=R&&R<256)&&(Z=s[R],Z)?Z:(B=a(R,(R|0)<0?-1:0,!0),V&&(s[R]=B),B)):(R|=0,(V=-128<=R&&R<128)&&(Z=r[R],Z)?Z:(B=a(R,R<0?-1:0,!1),V&&(r[R]=B),B))}e.fromInt=i;function o(R,P){if(isNaN(R))return P?_:x;if(P){if(R<0)return _;if(R>=g)return $}else{if(R<=-w)return L;if(R+1>=w)return M}return R<0?o(-R,P).neg():a(R%p|0,R/p|0,P)}e.fromNumber=o;function a(R,P,B){return new e(R,P,B)}e.fromBits=a;var l=Math.pow;function u(R,P,B){if(R.length===0)throw Error("empty string");if(R==="NaN"||R==="Infinity"||R==="+Infinity"||R==="-Infinity")return x;if(typeof P=="number"?(B=P,P=!1):P=!!P,B=B||10,B<2||36<B)throw RangeError("radix");var Z;if((Z=R.indexOf("-"))>0)throw Error("interior hyphen");if(Z===0)return u(R.substring(1),P,B).neg();for(var V=o(l(B,8)),X=x,q=0;q<R.length;q+=8){var se=Math.min(8,R.length-q),W=parseInt(R.substring(q,q+se),B);if(se<8){var J=o(l(B,se));X=X.mul(J).add(o(W))}else X=X.mul(V),X=X.add(o(W))}return X.unsigned=P,X}e.fromString=u;function c(R,P){return typeof R=="number"?o(R,P):typeof R=="string"?u(R,P):a(R.low,R.high,typeof P=="boolean"?P:R.unsigned)}e.fromValue=c;var h=65536,d=1<<24,p=h*h,g=p*p,w=g/2,y=i(d),x=i(0);e.ZERO=x;var _=i(0,!0);e.UZERO=_;var T=i(1);e.ONE=T;var E=i(1,!0);e.UONE=E;var N=i(-1);e.NEG_ONE=N;var M=a(-1,2147483647,!1);e.MAX_VALUE=M;var $=a(-1,-1,!0);e.MAX_UNSIGNED_VALUE=$;var L=a(0,-2147483648,!1);e.MIN_VALUE=L;var k=e.prototype;return k.toInt=function(){return this.unsigned?this.low>>>0:this.low},k.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},k.toString=function(P){if(P=P||10,P<2||36<P)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(L)){var B=o(P),Z=this.div(B),V=Z.mul(B).sub(this);return Z.toString(P)+V.toInt().toString(P)}else return"-"+this.neg().toString(P);for(var X=o(l(P,6),this.unsigned),q=this,se="";;){var W=q.div(X),J=q.sub(W.mul(X)).toInt()>>>0,K=J.toString(P);if(q=W,q.isZero())return K+se;for(;K.length<6;)K="0"+K;se=""+K+se}},k.getHighBits=function(){return this.high},k.getHighBitsUnsigned=function(){return this.high>>>0},k.getLowBits=function(){return this.low},k.getLowBitsUnsigned=function(){return this.low>>>0},k.getNumBitsAbs=function(){if(this.isNegative())return this.eq(L)?64:this.neg().getNumBitsAbs();for(var P=this.high!=0?this.high:this.low,B=31;B>0&&(P&1<<B)==0;B--);return this.high!=0?B+33:B+1},k.isZero=function(){return this.high===0&&this.low===0},k.eqz=k.isZero,k.isNegative=function(){return!this.unsigned&&this.high<0},k.isPositive=function(){return this.unsigned||this.high>=0},k.isOdd=function(){return(this.low&1)===1},k.isEven=function(){return(this.low&1)===0},k.equals=function(P){return t(P)||(P=c(P)),this.unsigned!==P.unsigned&&this.high>>>31===1&&P.high>>>31===1?!1:this.high===P.high&&this.low===P.low},k.eq=k.equals,k.notEquals=function(P){return!this.eq(P)},k.neq=k.notEquals,k.ne=k.notEquals,k.lessThan=function(P){return this.comp(P)<0},k.lt=k.lessThan,k.lessThanOrEqual=function(P){return this.comp(P)<=0},k.lte=k.lessThanOrEqual,k.le=k.lessThanOrEqual,k.greaterThan=function(P){return this.comp(P)>0},k.gt=k.greaterThan,k.greaterThanOrEqual=function(P){return this.comp(P)>=0},k.gte=k.greaterThanOrEqual,k.ge=k.greaterThanOrEqual,k.compare=function(P){if(t(P)||(P=c(P)),this.eq(P))return 0;var B=this.isNegative(),Z=P.isNegative();return B&&!Z?-1:!B&&Z?1:this.unsigned?P.high>>>0>this.high>>>0||P.high===this.high&&P.low>>>0>this.low>>>0?-1:1:this.sub(P).isNegative()?-1:1},k.comp=k.compare,k.negate=function(){return!this.unsigned&&this.eq(L)?L:this.not().add(T)},k.neg=k.negate,k.add=function(P){t(P)||(P=c(P));var B=this.high>>>16,Z=this.high&65535,V=this.low>>>16,X=this.low&65535,q=P.high>>>16,se=P.high&65535,W=P.low>>>16,J=P.low&65535,K=0,G=0,Q=0,ne=0;return ne+=X+J,Q+=ne>>>16,ne&=65535,Q+=V+W,G+=Q>>>16,Q&=65535,G+=Z+se,K+=G>>>16,G&=65535,K+=B+q,K&=65535,a(Q<<16|ne,K<<16|G,this.unsigned)},k.subtract=function(P){return t(P)||(P=c(P)),this.add(P.neg())},k.sub=k.subtract,k.multiply=function(P){if(this.isZero())return x;if(t(P)||(P=c(P)),n){var B=n.mul(this.low,this.high,P.low,P.high);return a(B,n.get_high(),this.unsigned)}if(P.isZero())return x;if(this.eq(L))return P.isOdd()?L:x;if(P.eq(L))return this.isOdd()?L:x;if(this.isNegative())return P.isNegative()?this.neg().mul(P.neg()):this.neg().mul(P).neg();if(P.isNegative())return this.mul(P.neg()).neg();if(this.lt(y)&&P.lt(y))return o(this.toNumber()*P.toNumber(),this.unsigned);var Z=this.high>>>16,V=this.high&65535,X=this.low>>>16,q=this.low&65535,se=P.high>>>16,W=P.high&65535,J=P.low>>>16,K=P.low&65535,G=0,Q=0,ne=0,ce=0;return ce+=q*K,ne+=ce>>>16,ce&=65535,ne+=X*K,Q+=ne>>>16,ne&=65535,ne+=q*J,Q+=ne>>>16,ne&=65535,Q+=V*K,G+=Q>>>16,Q&=65535,Q+=X*J,G+=Q>>>16,Q&=65535,Q+=q*W,G+=Q>>>16,Q&=65535,G+=Z*K+V*J+X*W+q*se,G&=65535,a(ne<<16|ce,G<<16|Q,this.unsigned)},k.mul=k.multiply,k.divide=function(P){if(t(P)||(P=c(P)),P.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&P.low===-1&&P.high===-1)return this;var B=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,P.low,P.high);return a(B,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?_:x;var Z,V,X;if(this.unsigned){if(P.unsigned||(P=P.toUnsigned()),P.gt(this))return _;if(P.gt(this.shru(1)))return E;X=_}else{if(this.eq(L)){if(P.eq(T)||P.eq(N))return L;if(P.eq(L))return T;var q=this.shr(1);return Z=q.div(P).shl(1),Z.eq(x)?P.isNegative()?T:N:(V=this.sub(P.mul(Z)),X=Z.add(V.div(P)),X)}else if(P.eq(L))return this.unsigned?_:x;if(this.isNegative())return P.isNegative()?this.neg().div(P.neg()):this.neg().div(P).neg();if(P.isNegative())return this.div(P.neg()).neg();X=x}for(V=this;V.gte(P);){Z=Math.max(1,Math.floor(V.toNumber()/P.toNumber()));for(var se=Math.ceil(Math.log(Z)/Math.LN2),W=se<=48?1:l(2,se-48),J=o(Z),K=J.mul(P);K.isNegative()||K.gt(V);)Z-=W,J=o(Z,this.unsigned),K=J.mul(P);J.isZero()&&(J=T),X=X.add(J),V=V.sub(K)}return X},k.div=k.divide,k.modulo=function(P){if(t(P)||(P=c(P)),n){var B=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,P.low,P.high);return a(B,n.get_high(),this.unsigned)}return this.sub(this.div(P).mul(P))},k.mod=k.modulo,k.rem=k.modulo,k.not=function(){return a(~this.low,~this.high,this.unsigned)},k.and=function(P){return t(P)||(P=c(P)),a(this.low&P.low,this.high&P.high,this.unsigned)},k.or=function(P){return t(P)||(P=c(P)),a(this.low|P.low,this.high|P.high,this.unsigned)},k.xor=function(P){return t(P)||(P=c(P)),a(this.low^P.low,this.high^P.high,this.unsigned)},k.shiftLeft=function(P){return t(P)&&(P=P.toInt()),(P&=63)===0?this:P<32?a(this.low<<P,this.high<<P|this.low>>>32-P,this.unsigned):a(0,this.low<<P-32,this.unsigned)},k.shl=k.shiftLeft,k.shiftRight=function(P){return t(P)&&(P=P.toInt()),(P&=63)===0?this:P<32?a(this.low>>>P|this.high<<32-P,this.high>>P,this.unsigned):a(this.high>>P-32,this.high>=0?0:-1,this.unsigned)},k.shr=k.shiftRight,k.shiftRightUnsigned=function(P){if(t(P)&&(P=P.toInt()),P&=63,P===0)return this;var B=this.high;if(P<32){var Z=this.low;return a(Z>>>P|B<<32-P,B>>>P,this.unsigned)}else return P===32?a(B,0,this.unsigned):a(B>>>P-32,0,this.unsigned)},k.shru=k.shiftRightUnsigned,k.shr_u=k.shiftRightUnsigned,k.toSigned=function(){return this.unsigned?a(this.low,this.high,!1):this},k.toUnsigned=function(){return this.unsigned?this:a(this.low,this.high,!0)},k.toBytes=function(P){return P?this.toBytesLE():this.toBytesBE()},k.toBytesLE=function(){var P=this.high,B=this.low;return[B&255,B>>>8&255,B>>>16&255,B>>>24,P&255,P>>>8&255,P>>>16&255,P>>>24]},k.toBytesBE=function(){var P=this.high,B=this.low;return[P>>>24,P>>>16&255,P>>>8&255,P&255,B>>>24,B>>>16&255,B>>>8&255,B&255]},e.fromBytes=function(P,B,Z){return Z?e.fromBytesLE(P,B):e.fromBytesBE(P,B)},e.fromBytesLE=function(P,B){return new e(P[0]|P[1]<<8|P[2]<<16|P[3]<<24,P[4]|P[5]<<8|P[6]<<16|P[7]<<24,B)},e.fromBytesBE=function(P,B){return new e(P[4]<<24|P[5]<<16|P[6]<<8|P[7],P[0]<<24|P[1]<<16|P[2]<<8|P[3],B)},L2}var dU=cte();const fU=Ux(dU),hte=p8({__proto__:null,default:fU},[dU]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hp=fU||hte;function pE(n){return hp.fromString(n,!0,16)}const pU=pE("c3a5c85c97cb3127"),up=pE("b492b66fbe98f273"),po=pE("9ae16a3b2f90404f");function cN(n){return n.xor(n.shru(47))}function mU(n,e,t){const r=n.slice(e,e+t);return hp.fromBytes(Array.from(r),!0,!0)}function jr(n,e){return mU(n,e,8)}function CP(n,e){return mU(n,e,4)}function pi(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Sd(n,e,t=pE("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let s=e.xor(r).mul(t);return s=s.xor(s.shru(47)),s=s.mul(t),s}function dte(n,e,t,r,s,i){s=s.add(n),i=pi(i.add(s).add(r),21);const o=s;return s=s.add(e),s=s.add(t),i=i.add(pi(s,44)),[s.add(r),i.add(o)]}function uS(n,e,t,r){return dte(jr(n,e),jr(n,e+8),jr(n,e+16),jr(n,e+24),t,r)}function fte(n,e=n.length){if(e>=8){const t=po.add(e*2),r=jr(n,0).add(po),s=jr(n,e-8),i=pi(s,37).mul(t).add(r),o=pi(r,25).add(s).mul(t);return Sd(i,o,t)}if(e>=4){const t=po.add(e*2),r=CP(n,0);return Sd(r.shl(3).add(e),CP(n,e-4),t)}if(e>0){const t=n[0],r=n[e>>1],s=n[e-1],i=t+(r<<8),o=e+(s<<2);return cN(po.mul(i).xor(pU.mul(o))).mul(po)}return po}function pte(n,e=n.length){const t=po.add(e*2),r=jr(n,0).mul(up),s=jr(n,8),i=jr(n,e-8).mul(t),o=jr(n,e-16).mul(po);return Sd(pi(r.add(s),43).add(pi(i,30)).add(o),r.add(pi(s.add(po),18)).add(i),t)}function mte(n,e=n.length){const t=po.add(e*2),r=jr(n,0).mul(po),s=jr(n,8),i=jr(n,e-8).mul(t),o=jr(n,e-16).mul(po),a=pi(r.add(s),43).add(pi(i,30)).add(o),l=Sd(a,r.add(pi(s.add(po),18)).add(i),t),u=jr(n,16).mul(t),c=jr(n,24),h=a.add(jr(n,e-32)).mul(t),d=l.add(jr(n,e-24)).mul(t);return Sd(pi(u.add(c),43).add(pi(h,30)).add(d),u.add(pi(c.add(r),18)).add(h),t)}function gte(n,e=n.length){const t=hp.fromNumber(81,!0);if(e<=32)return e<=16?fte(n,e):pte(n,e);if(e<=64)return mte(n,e);let r=t,s=t.mul(up).add(113),i=cN(s.mul(po).add(113)).mul(po),o=[hp.UZERO,hp.UZERO],a=[hp.UZERO,hp.UZERO];r=r.mul(po).add(jr(n,0));let l=0;const u=(e-1>>6)*64,c=u+(e-1&63)-63;do r=pi(r.add(s).add(o[0]).add(jr(n,l+8)),37).mul(up),s=pi(s.add(o[1]).add(jr(n,l+48)),42).mul(up),r=r.xor(a[1]),s=s.add(o[0]).add(jr(n,l+40)),i=pi(i.add(a[0]),33).mul(up),o=uS(n,l,o[1].mul(up),r.add(a[0])),a=uS(n,l+32,i.add(a[1]),s.add(jr(n,l+16))),[i,r]=[r,i],l+=64;while(l!==u);const h=up.add(i.and(255).shl(1));return l=c,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),r=pi(r.add(s).add(o[0]).add(jr(n,l+8)),37).mul(h),s=pi(s.add(o[1]).add(jr(n,l+48)),42).mul(h),r=r.xor(a[1].mul(9)),s=s.add(o[0].mul(9).add(jr(n,l+40))),i=pi(i.add(a[0]),33).mul(h),o=uS(n,l,o[1].mul(h),r.add(a[0])),a=uS(n,l+32,i.add(a[1]),s.add(jr(n,l+16))),[i,r]=[r,i],Sd(Sd(o[0],a[0],h).add(cN(s).mul(pU)).add(i),Sd(o[1],a[1],h).add(r),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yd(n,e){return e==="string"?_d(n):lm([n],e)}function yte(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function lm(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Bp(n)),je().getBool("DEBUG")&&Xee(n,e),yte(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Bo(){return je().platform.now()}function _d(n,e="utf-8"){return e=e||"utf-8",je().platform.encode(n,e)}function Rd(n,e="utf-8"){return e=e||"utf-8",je().platform.decode(n,e)}function bl(n){return je().platform.isTypedArray!=null?je().platform.isTypedArray(n):hU(n)}function Bp(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||bM(n)||n==null||bl(n)&&t)e.push(n);else if(Array.isArray(n)||bl(n))for(let r=0;r<n.length;++r)Bp(n[r],e,t);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Bp(n[s],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let vte=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new wte)}profileKernel(e,t,r){let s;const i=()=>{s=r()};let o;const a=Bo();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const u of s)u.dataSync();o=Promise.resolve({kernelMs:Bo()-a})}if(je().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(h=>{xte(h,c.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:o.then(u=>u.kernelMs),extraInfo:o.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:i,extraInfo:o}=e;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],i,l[2])})})}};function xte(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}let wte=class{logKernelProfile(e,t,r,s,i,o){const a=typeof s=="number"?ay(`${s}ms`,9):s.error,l=ay(e,25),u=t.rank,c=t.size,h=ay(t.shape.toString(),14);let d="";for(const p in i){const g=i[p];if(g!=null){const w=g.shape||t.shape,y=w.length;d+=`${p}: ${y}D ${y>0?w:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${h}	%c${c}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bte(n,e,t){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<n.length;l++){const u=n[l],c=u.inputs;for(const h in c){const d=c[h];let p=!1;for(let g=0;g<e.length;g++)if(r[d.id]){u.outputs.forEach(w=>r[w.id]=!0),p=!0,s[u.id]=!0;break}if(p)break}}const i={};i[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const u=n[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(i[u.outputs[h].id]){for(const d in c)i[c[d].id]=!0,o[u.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const u=n[l];if(s[u.id]&&o[u.id]){const c={};for(const d in u.inputs){const p=u.inputs[d];r[p.id]&&(c[d]=p)}const h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,a.push(h)}}return a}function Ste(n,e,t,r){for(let s=e.length-1;s>=0;s--){const i=e[s],o=[];if(i.outputs.forEach(l=>{const u=n[l.id];u!=null?o.push(u):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=t(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=i.inputs[l];if(!_r(u.shape,c.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(n[c.id]==null)n[c.id]=u;else{const h=n[c.id];n[c.id]=r(h,u),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IP=20,Tv=3,O2=7;function _te(n,e,t,r){const s=nn(e),i=Tte(n,e,t,s),o=e.length,a=DS(n,e,t,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function Tte(n,e,t,r){const s=Qe(e),i=r[r.length-1],o=new Array(i).fill(0),a=e.length,l=t==="complex64"?Dv(n):n;if(a>1)for(let u=0;u<s/i;u++){const c=u*i;for(let h=0;h<i;h++)o[h]=Math.max(o[h],Rv(l[c+h],0,t).length)}return o}function Rv(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(O2))} + ${parseFloat(n[1].toFixed(O2))}j`:t1(n)?r=`'${n}'`:t==="bool"?r=gU(n):r=parseFloat(n.toFixed(O2)).toString(),ay(r,e)}function gU(n){return n===0?"false":"true"}function DS(n,e,t,r,s,i=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const w=Dv(n);return[Rv(w[0],0,t)]}return t==="bool"?[gU(n[0])]:[n[0].toString()]}if(l===1){if(a>IP){const y=Tv*o;let x=Array.from(n.slice(0,y)),_=Array.from(n.slice((a-Tv)*o,a*o));return t==="complex64"&&(x=Dv(x),_=Dv(_)),["["+x.map((T,E)=>Rv(T,s[E],t)).join(", ")+", ..., "+_.map((T,E)=>Rv(T,s[a-Tv+E],t)).join(", ")+"]"]}return["["+(t==="complex64"?Dv(n):Array.from(n)).map((y,x)=>Rv(y,s[x],t)).join(", ")+"]"]}const u=e.slice(1),c=r.slice(1),h=r[0]*o,d=[];if(a>IP){for(let w=0;w<Tv;w++){const y=w*h,x=y+h;d.push(...DS(n.slice(y,x),u,t,c,s,!1))}d.push("...");for(let w=a-Tv;w<a;w++){const y=w*h,x=y+h;d.push(...DS(n.slice(y,x),u,t,c,s,w===a-1))}}else for(let w=0;w<a;w++){const y=w*h,x=y+h;d.push(...DS(n.slice(y,x),u,t,c,s,w===a-1))}const p=l===2?",":"";d[0]="["+(a>0?d[0]+p:"");for(let w=1;w<d.length-1;w++)d[w]=" "+d[w]+p;let g=`,
`;for(let w=2;w<l;w++)g+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":g),d}function Dv(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $i=class{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=Qe(e),r!=null){const s=r.length;ie(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Cs(t,this.size),this.strides=nn(e)}set(e,...t){t.length===0&&(t=[0]),ie(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return au().makeTensor(this.values,this.shape,this.dtype)}},au=null,qg=null;function Ete(n){au=n}function Cte(n){qg=n}let Zs=class{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Qe(e),this.strides=nn(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return qg.buffer(this.shape,this.dtype,e)}bufferSync(){return qg.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return du(this.shape,e,this.dtype==="complex64")}arraySync(){return du(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=au().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>Rd(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),au().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=au().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Rd(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await au().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),au().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return qg.print(this,e)}clone(){return this.throwIfDisposed(),qg.clone(this)}toString(e=!1){const t=this.dataSync();return _te(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),qg.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),au().makeVariable(this,e,t,r)}};Object.defineProperty(Zs,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Je(){return SM("Tensor",()=>Zs)}Je();let s_=class extends Zs{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!_r(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);au().disposeTensor(this),this.dataId=e.dataId,au().incRef(this,null)}dispose(){au().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(s_,Symbol.hasInstance,{value:n=>n instanceof Zs&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var NP;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(NP||(NP={}));var hN;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(hN||(hN={}));var dN;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(dN||(dN={}));var fN;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(fN||(fN={}));var pN;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(pN||(pN={}));const Ite={float32:fN,int32:hN,bool:dN,complex64:pN};function _a(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return Ite[n][e]}function ck(n){return _a(n,"int32")}function yU(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function vU(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function As(n,e){if(n.dtype===e.dtype)return[n,e];const t=_a(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function xU(n){const e=[];return wU(n,e,new Set),e}function wU(n,e,t){if(n==null)return;if(n instanceof Zs){e.push(n);return}if(!Nte(n))return;const r=n;for(const s in r){const i=r[s];t.has(i)||(t.add(i),wU(i,e,t))}}function Nte(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F2(n){return n.kernelName!=null}let AP=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}},hk=class mN{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new AP}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(Wa(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new vte(this.backendInstance),!0}setupRegisteredKernels(){TP(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){TP(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof yM)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,i=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Wa(`Initialization of backend ${e} failed`),Wa(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return Wa(`Initialization of backend ${e} failed`),Wa(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:i}=this.initializeBackend(r);if(i||s)return{name:r,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,i=this.readSync(t),o=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,i,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return mN.nextTensorId++}nextVariableId(){return mN.nextVariableId++}clone(e){const t=Me.runKernel(S1,{x:e}),r={x:e},s=o=>({x:()=>{const a="float32",l={x:o},u={dtype:a};return Me.runKernel(u1,l,u)}}),i=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,i,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(SP(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let i=0;r.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-t-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const u=F2(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(F2(e)){const{kernelName:g,inputs:w,attrs:y}=e;this.backendName==null&&this.backend;const x=SP(g,this.backendName);ie(x!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),a=()=>{const _=this.backend.numDataIds();l=x.kernelFunc({inputs:w,attrs:y,backend:this.backend});const T=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,_,T);const E=T.map(N=>N.rank!=null?N:this.makeTensorFromTensorInfo(N));if(s){const N=this.getTensorsForGradient(g,w,E);r=this.saveTensorsForBackwardMode(N)}return E}}else{const{forwardFunc:g}=e,w=y=>{s&&(r=y.map(x=>this.keep(this.clone(x))))};a=()=>{const y=this.backend.numDataIds();l=this.tidy(()=>g(this.backend,w));const x=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,x),x}}const{inputs:c,attrs:h}=e,d=F2(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(p=this.profiler.profileKernel(u,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),s&&this.addTapeNode(u,c,t,d,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(g=>c[g]!=null?c[g].shape:null),outputShapes:t.map(g=>g.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=_P(e);if(s!=null){const i=s.inputsToSave||[],o=s.outputsToSave||[];let a;s.saveAllInputs?(ie(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(u=>t[u])):a=i.map(u=>t[u]);const l=r.filter((u,c)=>o[c]);return a.concat(l)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let i=e;r==="string"&&t1(e[0])&&(i=e.map(l=>_d(l)));const o=s.write(i,t,r),a=new Zs(t,r,o,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const l=this.state.tensorInfo.get(o),u=Kee(i);this.state.numBytes+=u-l.bytes,l.bytes=u}return a}makeTensorFromDataId(e,t,r,s){r=r||"float32";const i={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:i}=e,o=new Zs(s,i,r,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const i=new s_(e,t,r,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*e_(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof s_||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*e_(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:i},l=_P(e);l!=null&&(s=l.gradFunc),s!=null&&(a.gradient=u=>(u=u.map((c,h)=>{if(c==null){const d=r[h],p=Zi(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return c}),s(u.length>1?u:u[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=xU(e),r=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,t,r,s=!1){if(ie(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));ie(i instanceof Zs,()=>"The result y returned by f() must be a tensor.");const o=bte(this.state.activeTape,t,i);if(!s&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=r??Ate(i.shape),Ste(a,o,u=>this.tidy(u),Mte);const l=t.map(u=>a[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return ie(iN(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{ie(t.every(a=>a instanceof Zs),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((a,l)=>{s[l]=a});const i=(a,l)=>(r=e(...t,l),ie(r.value instanceof Zs,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),ie(iN(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(a,l)=>{const u=r.gradFunc(a,l),c=Array.isArray(u)?u:[u];ie(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),ie(c.every(d=>d instanceof Zs),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Bo(),r=await this.backend.time(e);return r.wallMs=Bo()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new AP;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};hk.nextTensorId=0;hk.nextVariableId=0;function Ate(n){const e=wM(Qe(n),"float32");return Me.makeTensor(e,n,"float32")}function bU(){const n=UB();if(n._tfengine==null){const e=new Jee(n);n._tfengine=new hk(e)}return nte(n._tfengine.ENV),Ete(()=>n._tfengine),n._tfengine}const Me=bU();function Mte(n,e){const t={a:n,b:e};return Me.runKernel(qy,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kte(){return typeof navigator<"u"&&navigator!=null}function SU(n){if(n||kte()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function _U(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ko=je();Ko.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Ko.registerFlag("IS_BROWSER",()=>_U());Ko.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Ko.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Ko.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Ko.registerFlag("PROD",()=>!1);Ko.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ko.getBool("DEBUG"));Ko.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Ko.registerFlag("IS_TEST",()=>!1);Ko.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Ko.getBool("DEBUG"));Ko.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Ko.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Ko.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mE(n,e){let t=n;if(bl(n))return e==="string"?[]:[n.length];if(yU(n)){const s=n.channels||"RGBA";return[n.height,n.width*s.length]}else if(vU(n))return[n.buffer.size/(e==null?4:e_(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||bl(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&je().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&TU(n,r,[]),r}function TU(n,e,t){if(t=t||[],!Array.isArray(n)&&!bl(n)){ie(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}ie(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),ie(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)TU(n[s],r,t.concat(s))}function MP(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function ge(n,e,t,r="numeric"){if(n instanceof Je())return MP(r,n.dtype,e,t),n;let s=jy(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),MP(r,s,e,t),n==null||!bl(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=mE(n,s);!bl(n)&&!Array.isArray(n)&&(n=[n]);const a=s!=="string"?lm(n,s):Bp(n,[],!0);return Me.makeTensor(a,i,s)}function EU(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>ge(i,`${e}[${o}]`,t,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rte="__op";function Pe(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Rte;const s=(...i)=>{Me.startScope(t);try{const o=r(...i);return bM(o)&&console.error("Cannot return a Promise inside of tidy."),Me.endScope(o),o}catch(o){throw Me.endScope(null),o}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dte(n,e){const t=ge(n,"real","complex"),r=ge(e,"imag","complex");xM(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return Me.runKernel(MM,s)}const _y=Pe({complex_:Dte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gE(n,e,t,r){if(r==null)r=jy(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(vU(n)||yU(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return Me.backend.createTensorFromGPUData(n,e||t,r)}if(!bl(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){yh(e);const s=Qe(e),i=Qe(t);ie(s===i,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Qe(e.slice(o)):!0;ie(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!bl(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?lm(n,r):Bp(n,[],!0),Me.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CU(n,e,t){const r=mE(n,t);return gE(n,e,r,t)}let yE=class IU{static join(e){return new IU(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>bl(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+s.byteLength;this.shards.push({buffer:s,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=t-e,i=new ArrayBuffer(s),o=new Uint8Array(i);let a=0;for(let l=r;l<this.shards.length;l++){const u=this.shards[l],h=e+a-u.start,d=a,g=Math.min(t,u.end)-u.start,w=new Uint8Array(u.buffer,h,g-h);if(o.set(w,d),a+=w.length,t<u.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(s){return e<s.start?-1:e>=s.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=$te(this.shards,t);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function $te(n,e){let t=0,r=n.length;for(;t<=r;){const s=Math.floor((r-t)/2)+t,i=e(n[s]);if(i===0)return s;i<0?r=s:t=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ou(){return Me}function kP(){return Me.memory()}function ze(n,e){return Me.tidy(n,e)}function Yn(n){xU(n).forEach(t=>t.dispose())}function qu(n){return Me.keep(n)}function Pte(){return Me.ready()}function NU(n,e,t=1){return Me.registerBackend(n,e,t)}function Lte(){return Me.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RP=4;async function DP(n,e){const t=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const a=s[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async h=>{const d=await l.bytes(),p=d.reduce((y,x)=>y+x.length,0)+RP*d.length,g=new Uint8Array(p);let w=0;for(let y=0;y<d.length;y++){const x=d[y],_=new Uint8Array(new Uint32Array([x.length]).buffer);g.set(_,w),w+=RP,g.set(x,w),w+=x.length}h(g)});r.push(c)}else r.push(l.data());e!=null&&(u.group=e),t.push(u)}const i=await Promise.all(r);return{data:Ote(i),specs:t}}function Ote(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const r=new Uint8Array(e);let s=0;return t.forEach(i=>{r.set(new Uint8Array(i.buffer),s),s+=i.byteLength}),r.buffer}const dk=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function $P(n){return dk?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function Fte(n){if(dk)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function zte(n){if(dk){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function Bte(n){return yE.join(n)}function AU(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:$P(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:$P(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new yE(n.weightData).byteLength}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Z1=class ru{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return ru.instance==null&&(ru.instance=new ru),ru.instance}static registerSaveRouter(e){ru.getInstance().saveRouters.push(e)}static registerLoadRouter(e){ru.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return ru.getHandlers(e,"save")}static getLoadHandlers(e,t){return ru.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?ru.getInstance().loadRouters:ru.getInstance().saveRouters).forEach(o=>{const a=o(e,r);a!==null&&s.push(a)}),s}};const Ute=n=>Z1.getSaveHandlers(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gN="tensorflowjs",yN=1,Sp="models_store",gd="model_info_store";function MU(){if(!je().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function vN(n){const e=n.result;e.createObjectStore(Sp,{keyPath:"modelPath"}),e.createObjectStore(gd,{keyPath:"modelPath"})}let Up=class{constructor(e){if(this.indexedDB=MU(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,s)=>{const i=this.indexedDB.open(gN,yN);i.onupgradeneeded=()=>vN(i),i.onsuccess=()=>{const o=i.result;if(t==null){const a=o.transaction(Sp,"readonly"),u=a.objectStore(Sp).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return o.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(u.result.modelArtifacts)},u.onerror=c=>(o.close(),s(u.error)),a.oncomplete=()=>o.close()}else{t.weightData=yE.join(t.weightData);const a=AU(t),l=o.transaction(gd,"readwrite");let u=l.objectStore(gd),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(d){return s(d)}let h;c.onsuccess=()=>{h=o.transaction(Sp,"readwrite");const d=h.objectStore(Sp);let p;try{p=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(g){return s(g)}p.onsuccess=()=>r({modelArtifactsInfo:a}),p.onerror=g=>{u=l.objectStore(gd);const w=u.delete(this.modelPath);w.onsuccess=()=>(o.close(),s(p.error)),w.onerror=y=>(o.close(),s(p.error))}},c.onerror=d=>(o.close(),s(c.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},i.onerror=o=>s(i.error)})}};Up.URL_SCHEME="indexeddb://";const kU=n=>je().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Up.URL_SCHEME)?Vte(n.slice(Up.URL_SCHEME.length)):null;Z1.registerSaveRouter(kU);Z1.registerLoadRouter(kU);function Vte(n){return new Up(n)}function Wte(n){return n.startsWith(Up.URL_SCHEME)?n.slice(Up.URL_SCHEME.length):n}let Gte=class{constructor(){this.indexedDB=MU()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(gN,yN);r.onupgradeneeded=()=>vN(r),r.onsuccess=()=>{const s=r.result,i=s.transaction(gd,"readonly"),a=i.objectStore(gd).getAll();a.onsuccess=()=>{const l={};for(const u of a.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},a.onerror=l=>(s.close(),t(a.error)),i.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})}async removeModel(e){return e=Wte(e),new Promise((t,r)=>{const s=this.indexedDB.open(gN,yN);s.onupgradeneeded=()=>vN(s),s.onsuccess=()=>{const i=s.result,o=i.transaction(gd,"readwrite"),a=o.objectStore(gd),l=a.get(e);let u;l.onsuccess=()=>{if(l.result==null)return i.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=a.delete(e),h=()=>{u=i.transaction(Sp,"readwrite");const p=u.objectStore(Sp).delete(e);p.onsuccess=()=>t(l.result.modelArtifactsInfo),p.onerror=g=>r(l.error)};c.onsuccess=h,c.onerror=d=>(h(),i.close(),r(l.error))}},l.onerror=c=>(i.close(),r(l.error)),o.oncomplete=()=>{u==null?i.close():u.oncomplete=()=>i.close()}},s.onerror=i=>r(s.error)})}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qc="/",Kg="tensorflowjs_models",RU="info",Hte="model_topology",jte="weight_specs",Xte="weight_data",qte="model_metadata";function DU(n){return{info:[Kg,n,RU].join(Qc),topology:[Kg,n,Hte].join(Qc),weightSpecs:[Kg,n,jte].join(Qc),weightData:[Kg,n,Xte].join(Qc),modelMetadata:[Kg,n,qte].join(Qc)}}function $U(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function Kte(n){const e=n.split(Qc);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Qc)}function Yte(n){return n.startsWith(Vp.URL_SCHEME)?n.slice(Vp.URL_SCHEME.length):n}let Vp=class{constructor(e){if(!je().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=DU(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=AU(e),i=yE.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,Fte(i));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw $U(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=zte(o),t}};Vp.URL_SCHEME="localstorage://";const PU=n=>je().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Vp.URL_SCHEME)?Zte(n.slice(Vp.URL_SCHEME.length)):null;Z1.registerSaveRouter(PU);Z1.registerLoadRouter(PU);function Zte(n){return new Vp(n)}let Jte=class{constructor(){ie(je().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),ie(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Kg+Qc,r=Qc+RU;for(let s=0;s<this.LS.length;++s){const i=this.LS.key(s);if(i.startsWith(t)&&i.endsWith(r)){const o=Kte(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=Yte(e);const t=DU(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return $U(t),r}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PP="://";let LP=class hd{constructor(){this.managers={}}static getInstance(){return hd.instance==null&&(hd.instance=new hd),hd.instance}static registerManager(e,t){ie(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(PP)&&(e=e.slice(0,e.indexOf(PP))),ie(e.length>0,()=>"scheme must not be an empty string.");const r=hd.getInstance();ie(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=hd.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(hd.getInstance().managers)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qte=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!je().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return hU(e)}};if(je().get("IS_BROWSER")){je().setPlatform("browser",new Qte);try{LP.registerManager(Vp.URL_SCHEME,new Jte)}catch{}try{LP.registerManager(Up.URL_SCHEME,new Gte)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ene={importFetch:()=>require("node-fetch")};let z2,tne=class{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return je().global.fetch!=null?je().global.fetch(e,t):(z2==null&&(z2=ene.importFetch()),z2(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};je().get("IS_NODE")&&!je().get("IS_BROWSER")&&je().setPlatform("node",new tne);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xn(n,e="float32",t){return e=e||"float32",yh(n),new $i(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nne(n,e){const t=ge(n,"x","cast");if(!qee(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return Me.runKernel(u1,r,s)}const Ot=Pe({cast_:nne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rne(n){const t={x:ge(n,"x","clone","string_or_numeric")};return Me.runKernel(S1,t)}const kp=Pe({clone_:rne});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sne(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */bU();const ine={buffer:Xn,cast:Ot,clone:kp,print:sne};Cte(ine);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function one(n,e){let t=ge(n,"a","add"),r=ge(e,"b","add");[t,r]=As(t,r);const s={a:t,b:r};return Me.runKernel(qy,s)}const xt=Pe({add_:one});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ane(n,e){let t=ge(n,"a","floorDiv"),r=ge(e,"b","floorDiv");[t,r]=As(t,r);const s={a:t,b:r};return Me.runKernel(w1,s)}const LU=Pe({floorDiv_:ane});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lne(n,e){let t=ge(n,"a","div"),r=ge(e,"b","div");if([t,r]=As(t,r),t.dtype==="int32"&&r.dtype==="int32")return LU(t,r);const s={a:t,b:r},i={};return Me.runKernel(p1,s,i)}const hn=Pe({div_:lne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function une(n,e){let t=ge(n,"a","mul"),r=ge(e,"b","mul");[t,r]=As(t,r);const s={a:t,b:r};return Me.runKernel(k1,s)}const Ae=Pe({mul_:une});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cne(n){const e=ge(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return Me.runKernel(bT,t)}else{const t={x:e};return Me.runKernel(pT,t)}}const ho=Pe({abs_:cne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hne(n){const t={x:ge(n,"x","acos")};return Me.runKernel(n1,t)}const dne=Pe({acos_:hne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fne(n){const t={x:ge(n,"x","acosh")};return Me.runKernel(r1,t)}const pne=Pe({acosh_:fne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mne(n,e=null,t=!1){const s={x:ge(n,"x","all","bool")},i={axis:e,keepDims:t};return Me.runKernel(TM,s,i)}const OU=Pe({all_:mne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gne(n,e=null,t=!1){const s={x:ge(n,"x","any","bool")},i={axis:e,keepDims:t};return Me.runKernel(EM,s,i)}const xN=Pe({any_:gne});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yne(n,e=0){const r={x:ge(n,"x","argMax")},s={axis:e};return Me.runKernel(mT,r,s)}const vx=Pe({argMax_:yne});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vne(n,e=0){const r={x:ge(n,"x","argMin")},s={axis:e};return Me.runKernel(gT,r,s)}const xne=Pe({argMin_:vne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wne(n){const t={x:ge(n,"x","asin")};return Me.runKernel(s1,t)}const bne=Pe({asin_:wne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sne(n){const t={x:ge(n,"x","asinh")};return Me.runKernel(i1,t)}const _ne=Pe({asinh_:Sne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tne(n){const t={x:ge(n,"x","atan")};return Me.runKernel(o1,t)}const Ene=Pe({atan_:Tne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cne(n,e){let t=ge(n,"a","atan2"),r=ge(e,"b","atan2");[t,r]=As(t,r);const s={a:t,b:r};return Me.runKernel(l1,s)}const Ine=Pe({atan2_:Cne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nne(n){const t={x:ge(n,"x","atanh")};return Me.runKernel(a1,t)}const Ane=Pe({atanh_:Nne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J1(n,e,t,r,s="NHWC",i){const o=n[3],a=[...e,o],l=xh(s);return Pi(n,a,t,i,r,null,null,l)}function El(n,e,t,r,s,i,o="channelsLast"){const[a,l]=xx(e);let u;if(o==="channelsLast")u=[a,l,n[3],n[3]];else if(o==="channelsFirst")u=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Pi(n,u,t,r,s,i,!1,o)}function vh(n,e,t,r,s,i,o="NDHWC"){const[a,l,u]=wN(e);let c,h;if(o==="NDHWC")h="channelsLast",c=[a,l,u,n[4],n[4]];else if(o==="NCDHW")h="channelsFirst",c=[a,l,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Zd(n,c,t,r,s,!1,h,i)}function Pi(n,e,t,r,s,i,o=!1,a="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,h]=n;else if(a==="channelsFirst")[l,h,u,c]=n;else throw new Error(`Unknown dataFormat ${a}`);const[d,p,,g]=e,[w,y]=xx(t),[x,_]=xx(r),T=uy(d,x),E=uy(p,_),{padInfo:N,outHeight:M,outWidth:$}=Rne(s,u,c,w,y,T,E,i,a),L=o?g*h:g;let k;return a==="channelsFirst"?k=[l,L,M,$]:a==="channelsLast"&&(k=[l,M,$,L]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:h,outHeight:M,outWidth:$,outChannels:L,padInfo:N,strideHeight:w,strideWidth:y,filterHeight:d,filterWidth:p,effectiveFilterHeight:T,effectiveFilterWidth:E,dilationHeight:x,dilationWidth:_,inShape:n,outShape:k,filterShape:e}}function Zd(n,e,t,r,s,i=!1,o="channelsLast",a){let[l,u,c,h,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,h,d]=n;else if(o==="channelsFirst")[l,d,u,c,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[p,g,w,,y]=e,[x,_,T]=wN(t),[E,N,M]=wN(r),$=uy(p,E),L=uy(g,N),k=uy(w,M),{padInfo:R,outDepth:P,outHeight:B,outWidth:Z}=Dne(s,u,c,h,x,_,T,$,L,k,a),V=i?y*d:y;let X;return o==="channelsFirst"?X=[l,V,P,B,Z]:o==="channelsLast"&&(X=[l,P,B,Z,V]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:P,outHeight:B,outWidth:Z,outChannels:V,padInfo:R,strideDepth:x,strideHeight:_,strideWidth:T,filterDepth:p,filterHeight:g,filterWidth:w,effectiveFilterDepth:$,effectiveFilterHeight:L,effectiveFilterWidth:k,dilationDepth:E,dilationHeight:N,dilationWidth:M,inShape:n,outShape:X,filterShape:e}}function Mne(n,e,t,r,s){r==null&&(r=fk(n,e,t));const i=n[0],o=n[1],a=wx((i-e+2*r)/t+1,s),l=wx((o-e+2*r)/t+1,s);return[a,l]}function kne(n,e,t,r,s,i){s==null&&(s=fk(n,e[0],r[0]));const o=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*s>=e[a]&&(o[a]=wx((n[a]-e[a]+2*s)/r[a]+1,i));return o}function fk(n,e,t,r=1){const s=uy(e,r);return Math.floor((n[0]*(t-1)-t+s)/2)}function xx(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function wN(n){return typeof n=="number"?[n,n,n]:n}function uy(n,e){return e<=1?n:n+(n-1)*(e-1)}function Rne(n,e,t,r,s,i,o,a,l){let u,c,h;if(typeof n=="number"){u={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const p=Mne([e,t],i,r,n,a);c=p[0],h=p[1]}else if(n==="same"){c=Math.ceil(e/r),h=Math.ceil(t/s);const d=Math.max(0,(c-1)*r+i-e),p=Math.max(0,(h-1)*s+o-t),g=Math.floor(d/2),w=d-g,y=Math.floor(p/2),x=p-y;u={top:g,bottom:w,left:y,right:x,type:"SAME"}}else if(n==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-i+1)/r),h=Math.ceil((t-o+1)/s);else if(typeof n=="object"){const d=l==="channelsLast"?n[1][0]:n[2][0],p=l==="channelsLast"?n[1][1]:n[2][1],g=l==="channelsLast"?n[2][0]:n[3][0],w=l==="channelsLast"?n[2][1]:n[3][1];u={top:d,bottom:p,left:g,right:w,type:d===0&&p===0&&g===0&&w===0?"VALID":"EXPLICIT"},c=wx((e-i+d+p)/r+1,a),h=wx((t-o+g+w)/s+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:u,outHeight:c,outWidth:h}}function Dne(n,e,t,r,s,i,o,a,l,u,c){let h,d,p,g;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const y=kne([e,t,r,1],[a,l,u],1,[s,i,o],n,c);d=y[0],p=y[1],g=y[2]}else if(n==="same"){d=Math.ceil(e/s),p=Math.ceil(t/i),g=Math.ceil(r/o);const w=(d-1)*s+a-e,y=(p-1)*i+l-t,x=(g-1)*o+u-r,_=Math.floor(w/2),T=w-_,E=Math.floor(y/2),N=y-E,M=Math.floor(x/2),$=x-M;h={top:E,bottom:N,left:M,right:$,front:_,back:T,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:g}}function wx(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Wp(n){const[e,t,r]=xx(n);return e===1&&t===1&&r===1}function Ji(n,e){return Wp(n)||Wp(e)}function Gp(n){return xx(n).every(e=>e>0)}function xh(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Qo(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")ie(Sy(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{ie(Sy(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ne(n,e){const r={x:ge(n,"x","reshape","string_or_numeric")},s={shape:e};return Me.runKernel(tE,r,s)}const $e=Pe({reshape_:$ne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pne(n,e,t,r,s){const i=ge(n,"x","avgPool","float32"),o=1;ie(Ji(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=$e(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ie(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Qo("avgPool",r,s);const u={x:a},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let h=Me.runKernel(yT,u,c);return h=Ot(h,i.dtype),l?$e(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const pk=Pe({avgPool_:Pne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lne(n,e,t,r,s,i="NDHWC"){const o=ge(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=$e(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ie(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),ie(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),ie(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Qo("avgPool3d",r,s);const u={x:a},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:i};let h=Me.runKernel(vT,u,c);return h=Ot(h,a.dtype),l?$e(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const One=Pe({avgPool3d_:Lne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fne(n,e=0){ie(n.length>=1,()=>"Pass at least one tensor to concat");const t=EU(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return kp(t[0]);const r=t,s={axis:e};return Me.runKernel(ST,r,s)}const Xo=Pe({concat_:Fne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zne(n,e,t=!1,r=!1){let s=ge(n,"a","matMul"),i=ge(e,"b","matMul");[s,i]=As(s,i);const o={a:s,b:i},a={transposeA:t,transposeB:r};return Me.runKernel(xT,o,a)}const wr=Pe({matMul_:zne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bne(n){const t={x:ge(n,"x","sigmoid","float32")};return Me.runKernel(V1,t)}const Ky=Pe({sigmoid_:Bne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Une(n,e,t){const r=ge(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},i={begin:e,size:t};return Me.runKernel(oE,s,i)}const Xr=Pe({slice_:Une});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vne(n){const t={x:ge(n,"x","tanh","float32")};return Me.runKernel(q1,t)}const mk=Pe({tanh_:Vne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wne(n,e,t){const r=ge(n,"x","batchToSpaceND"),s=e.reduce((a,l)=>a*l);ie(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),ie(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),ie(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const i={x:r},o={blockShape:e,crops:t};return Me.runKernel(wT,i,o)}const gk=Pe({batchToSpaceND_:Wne});function Gne(n){let e;return n.rank===0||n.rank===1?e=$e(n,[1,1,1,n.size]):n.rank===2?e=$e(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=$e(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hne(n,e,t,r,s,i){i==null&&(i=.001);const o=ge(n,"x","batchNorm"),a=ge(e,"mean","batchNorm"),l=ge(t,"variance","batchNorm");let u;s!=null&&(u=ge(s,"scale","batchNorm"));let c;r!=null&&(c=ge(r,"offset","batchNorm")),ie(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ie(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ie(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:Gne(o),scale:u,offset:c,mean:a,variance:l},p={varianceEpsilon:i},g=Me.runKernel(kT,d,p);return $e(g,o.shape)}const vE=Pe({batchNorm_:Hne});function jne(n,e,t,r,s,i){const o=ge(n,"x","batchNorm"),a=ge(e,"mean","batchNorm"),l=ge(t,"variance","batchNorm");let u;s!=null&&(u=ge(s,"scale","batchNorm"));let c;return r!=null&&(c=ge(r,"offset","batchNorm")),ie(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),ie(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),ie(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&ie(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&ie(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),vE(o,a,l,c,u,i)}const Xne=Pe({batchNorm2d_:jne});function qne(n,e,t,r,s,i){const o=ge(n,"x","batchNorm"),a=ge(e,"mean","batchNorm"),l=ge(t,"variance","batchNorm");let u;s!=null&&(u=ge(s,"scale","batchNorm"));let c;return r!=null&&(c=ge(r,"offset","batchNorm")),ie(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),ie(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),ie(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&ie(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&ie(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),vE(o,a,l,c,u,i)}const Kne=Pe({batchNorm3d_:qne});function Yne(n,e,t,r,s,i){const o=ge(n,"x","batchNorm"),a=ge(e,"mean","batchNorm"),l=ge(t,"variance","batchNorm");let u;s!=null&&(u=ge(s,"scale","batchNorm"));let c;return r!=null&&(c=ge(r,"offset","batchNorm")),ie(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),ie(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),ie(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&ie(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&ie(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),vE(o,a,l,c,u,i)}const Zne=Pe({batchNorm4d_:Yne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jne(n,e,t){const r=ge(n,"x","bincount"),s=ge(e,"weights","bincount");ie(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),ie(t>=0,()=>`size must be non-negative, but got ${t}.`),ie(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const i={x:r,weights:s},o={size:t};return Me.runKernel(NM,i,o)}const Qne=Pe({bincount_:Jne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ere(n,e){let t=ge(n,"broadcastTo","x");const r=t.shape;if(yh(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const u=t.shape.slice();for(;u.length<e.length;)u.unshift(1);t=$e(t,u)}const s=t.shape,i=Array.from(e);for(let u=e.length-1;u>=0;u--)if(s[u]===e[u])i[u]=1;else if(t.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(i.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return kp(t);const a={x:t},l={reps:i};return Me.runKernel(K1,a,l)}const Xv=Pe({broadcastTo_:ere});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tre(n){const t={x:ge(n,"x","ceil","float32")};return Me.runKernel(c1,t)}const nre=Pe({ceil_:tre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xE(n,e,t){yh(n),t=t||jy(e);const r={shape:n,value:e,dtype:t};return Me.runKernel(WM,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rre(n,e,t){const r=ge(n,"x","clipByValue");if(ie(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return xE(r.shape,e,r.dtype);const s={x:r},i={clipValueMin:e,clipValueMax:t};return Me.runKernel(h1,s,i)}const qa=Pe({clipByValue_:rre});function sre(n){return Xo(n,0)}const ire=Pe({concat1d_:sre});function ore(n,e){return Xo(n,e)}const are=Pe({concat2d_:ore});function lre(n,e){return Xo(n,e)}const ure=Pe({concat3d_:lre});function cre(n,e){return Xo(n,e)}const hre=Pe({concat4d_:cre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dre(n,e,t,r,s="NHWC",i=[1,1],o){const a=ge(n,"x","conv2d","float32"),l=ge(e,"filter","conv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=$e(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ie(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),ie(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Qo("conv2d",r,o);const h=s==="NHWC"?u.shape[3]:u.shape[1];ie(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),ie(Ji(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),ie(Gp(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),ie(Gp(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:u,filter:l},p={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o},g=Me.runKernel(_T,d,p);return c?$e(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const Hp=Pe({conv2d_:dre});function fre(n,e,t,r,s="NWC",i=1,o){const a=ge(n,"x","conv1d"),l=ge(e,"filter","conv1d");let u=a,c=!1;a.rank===2&&(c=!0,u=$e(a,[1,a.shape[0],a.shape[1]])),ie(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),ie(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Qo("conv1d",r,o),ie(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),ie(Ji(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),ie(Gp(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),ie(Gp(t),()=>"Error in conv1D: Stride should be larger than 0."),ie(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=$e(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=$e(u,[u.shape[0],1,u.shape[1],u.shape[2]]),y=Hp(d,h,[1,t],r,"NHWC",[1,i],o);return c?$e(y,[y.shape[2],y.shape[3]]):$e(y,[y.shape[0],y.shape[2],y.shape[3]])}const FU=Pe({conv1d_:fre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pre(n,e,t,r,s,i="NHWC",o){ie(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,u=!1;e.rank===3&&(u=!0,l=$e(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),ie(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),ie(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),ie(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=i==="NHWC"?a[3]:a[1],h=i==="NHWC"?l.shape[3]:l.shape[1];ie(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),ie(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),Qo("conv2dDerInput",s,o);const d={dy:l,filter:t},p={strides:r,pad:s,dataFormat:i,dimRoundingMode:o,inputShape:a},g=Me.runKernel(TT,d,p);return u?$e(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const yk=Pe({conv2DBackpropInput_:pre});function mre(n,e,t,r,s,i){const o=ge(n,"x","conv2dTranspose"),a=ge(e,"filter","conv2dTranspose");return yk(t,o,a,r,s,"NHWC",i)}const zU=Pe({conv2dTranspose_:mre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gre(n,e,t,r,s="NDHWC",i=[1,1,1]){const o=ge(n,"x","conv3d"),a=ge(e,"filter","conv3d");let l=o,u=!1;o.rank===4&&(u=!0,l=$e(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ie(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),ie(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),ie(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),ie(Ji(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),ie(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),ie(Gp(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),ie(Gp(t),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:a},h={strides:t,pad:r,dataFormat:s,dilations:i},d=Me.runKernel(ET,c,h);return u?$e(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const yre=Pe({conv3d_:gre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vre(n,e,t,r,s){ie(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,o=e,a=!1;e.rank===4&&(a=!0,o=$e(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],u=o.shape[4];ie(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),ie(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),ie(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),ie(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),ie(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);const c={dy:o,filter:t},h={pad:s,strides:r,inputShape:i},d=Me.runKernel(DM,c,h);return a?$e(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const BU=Pe({conv3DBackpropInput_:vre});function xre(n,e,t,r,s){const i=ge(n,"x","conv3dTranspose"),o=ge(e,"filter","conv3dTranspose");return BU(t,i,o,r,s)}const wre=Pe({conv3dTranspose_:xre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bre(n){const t={x:ge(n,"x","cos","float32")};return Me.runKernel(d1,t)}const vk=Pe({cos_:bre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sre(n){const t={x:ge(n,"x","cosh","float32")};return Me.runKernel(f1,t)}const UU=Pe({cosh_:Sre});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _re(n,e=0,t=!1,r=!1){const i={x:ge(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:r};return Me.runKernel($M,i,o)}const bN=Pe({cumprod_:_re});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tre(n,e=0,t=!1,r=!1){const i={x:ge(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:r};return Me.runKernel(CT,i,o)}const VU=Pe({cumsum_:Tre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ere(n,e,t,r=!1){const s=ge(n,"x","denseBincount"),i=ge(e,"weights","denseBincount");ie(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),ie(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),ie(t>=0,()=>`size must be non-negative, but got ${t}.`),ie(i.size===s.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${i.shape}.`);const o={x:s,weights:i},a={size:t,binaryOutput:r};return Me.runKernel(LM,o,a)}const OP=Pe({denseBincount_:Ere});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cre(n,e,t="NHWC"){const r=ge(n,"x","depthToSpace","float32"),s=t==="NHWC"?r.shape[1]:r.shape[2],i=t==="NHWC"?r.shape[2]:r.shape[3],o=t==="NHWC"?r.shape[3]:r.shape[1];ie(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),ie(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),ie(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${r.shape}`),ie(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const a={x:r},l={blockSize:e,dataFormat:t};return Me.runKernel(OM,a,l)}const Ire=Pe({depthToSpace_:Cre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nre(n,e,t,r,s="NHWC",i=[1,1],o){const a=ge(n,"x","depthwiseConv2d","float32"),l=ge(e,"filter","depthwiseConv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=$e(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ie(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),ie(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=s==="NHWC"?u.shape[3]:u.shape[1];ie(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),Qo("depthwiseConv2d",r,o);const d={x:u,filter:l},p={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o},g=Me.runKernel(IT,d,p);return c?$e(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const xk=Pe({depthwiseConv2d_:Nre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Are(n,e,t,r,s=[1,1],i="NHWC"){const o=ge(n,"x","dilation2d"),a=ge(e,"filter","dilation2d");ie(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),ie(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),ie(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,u=!1;o.rank===3&&(l=$e(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0),ie(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const c={x:l,filter:a},h={strides:t,pad:r,dilations:s},d=Me.runKernel(NT,c,h);return u?$e(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Mre=Pe({dilation2d_:Are});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ty(n,e){const t=n.length,r=[];for(let s=0;s<t;s++){const i=t-1-s,o=n[i]||1;(e[e.length-1-s]||1)>1&&o===1&&r.unshift(i)}return r}function ri(n,e){const t=[];for(let r=0;r<e.length;r++){const s=n[n.length-r-1],i=e.length-r-1,o=e[i];(s==null||s===1&&o>1)&&t.unshift(i)}return t}function $n(n,e){const t=Math.max(n.length,e.length),r=new Array(t);for(let s=0;s<t;s++){let i=n[n.length-s-1];i==null&&(i=1);let o=e[e.length-s-1];if(o==null&&(o=1),i===1)r[t-s-1]=o;else if(o===1)r[t-s-1]=i;else if(i!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else r[t-s-1]=i}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kre(n,e){let t=ge(n,"a","equal","string_or_numeric"),r=ge(e,"b","equal","string_or_numeric");[t,r]=As(t,r),$n(t.shape,r.shape);const s={a:t,b:r};return Me.runKernel(AT,s)}const nc=Pe({equal_:kre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rre(n,e,t){const r=ge(e,"a","where"),s=ge(t,"b","where"),i=ge(n,"condition","where","bool"),o=$n($n(i.shape,r.shape),s.shape),a=Xv(i,o),l=Xv(r,o),u=Xv(s,o),c={condition:a,t:l,e:u};return Me.runKernel(iE,c)}const _o=Pe({where_:Rre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dre(n){const t={x:ge(n,"x","zerosLike")};return Me.runKernel(fE,t)}const or=Pe({zerosLike_:Dre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $re(n,e){let t=ge(n,"a","div"),r=ge(e,"b","div");[t,r]=As(t,r);const s=hn(t,r),i=or(s),o=nc(r,i);return _o(o,i,s)}const Pre=Pe({divNoNan_:$re});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lre(n,e){const t=ge(n,"t1","dot"),r=ge(e,"t2","dot");ie((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const s=t.rank===1?t.size:t.shape[1],i=r.rank===1?r.size:r.shape[0];if(ie(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),t.rank===1&&r.rank===1){const o=$e(t,[1,-1]),a=$e(r,[-1,1]),l=wr(o,a);return $e(l,[])}else if(t.rank===1&&r.rank===2){const o=$e(t,[1,-1]),a=$e(r,[r.shape[0],r.shape[1]]),l=wr(o,a);return $e(l,[l.size])}else if(t.rank===2&&r.rank===1){const o=$e(r,[-1,1]),a=wr(t,o);return $e(a,[a.size])}else{const o=$e(r,[r.shape[0],r.shape[1]]);return wr(t,o)}}const Ore=Pe({dot_:Lre});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fre(n,...e){const t=e.map((s,i)=>ge(s,`tensors${i}`,"einsum")),r={equation:n};return Me.runKernel(BM,t,r)}const Ev=Pe({einsum_:Fre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zre(n){const t={x:ge(n,"x","elu","float32")};return Me.runKernel(m1,t)}const wE=Pe({elu_:zre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bre(n){let e=ge(n,"x","erf");ie(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ot(e,"float32"));const t={x:e};return Me.runKernel(g1,t)}const Ure=Pe({erf_:Bre});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wk(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function WU(n,e,t){const r=n.length+e.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?s.push(n[i++]):s.push(e[o++]);return s}function _i(n,e){const t=[],r=n.length;for(let i=0;i<r;i++)e.indexOf(i)===-1&&t.push(n[i]);const s=e.map(i=>n[i]);return[t,s]}function Vs(n,e){const t=e.map(r=>1);return WU(n,t,e)}function Li(n,e,t){ie(wk(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function ps(n,e){if(wk(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function Jd(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Ms(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vre(n,e=null,t=!1){const s={x:ge(n,"x","max")},i={reductionIndices:e,keepDims:t};return Me.runKernel(UT,s,i)}const fu=Pe({max_:Vre});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wre(n,e=null,t=!1){const s={x:ge(n,"x","min")},i={axis:e,keepDims:t};return Me.runKernel(HT,s,i)}const i_=Pe({min_:Wre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gre(n,e){let t=ge(n,"base","pow"),r=ge(e,"exp","pow");[t,r]=As(t,r);const s={a:t,b:r};return Me.runKernel(R1,s)}const Ey=Pe({pow_:Gre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sr(n,e){if((bl(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&bl(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return gE(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hre(n){const t={x:ge(n,"x","sqrt","float32")};return Me.runKernel(G1,t)}const Eo=Pe({sqrt_:Hre});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jre(n){const e=ge(n,"x","square"),t={};return Me.runKernel("Square",{x:e},t)}const Qr=Pe({square_:jre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xre(n,e=null,t=!1){let r=ge(n,"x","sum");r.dtype==="bool"&&(r=Ot(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return Me.runKernel(aE,s,i)}const an=Pe({sum_:Xre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qre(n,e="euclidean",t=null,r=!1){n=ge(n,"x","norm");const s=GU(n,e,t);let i=s.shape;if(r){const o=qn(t,n.shape);i=Vs(s.shape,o)}return $e(s,i)}function GU(n,e,t=null){if(n.rank===0)return ho(n);if(n.rank!==1&&t===null)return GU($e(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return an(ho(n),t);if(e===1/0)return fu(ho(n),t);if(e===-1/0)return i_(ho(n),t);if(e==="euclidean"||e===2)return Eo(an(Ey(ho(n),Sr(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return fu(an(ho(n),t[0]),t[1]-1);if(e===1/0)return fu(an(ho(n),t[1]),t[0]);if(e===-1/0)return i_(an(ho(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Eo(an(Qr(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const bE=Pe({norm_:qre});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kre(n,e=null,t=!1){return bE(n,"euclidean",e,t)}const Yre=Pe({euclideanNorm_:Kre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zre(n){const t={x:ge(n,"x","exp")};return Me.runKernel(y1,t)}const rc=Pe({exp_:Zre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jre(n,e=0){const t=ge(n,"x","expandDims","string_or_numeric");ie(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return Me.runKernel(MT,r,s)}const Uo=Pe({expandDims_:Jre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qre(n){const t={x:ge(n,"x","expm1")};return Me.runKernel(v1,t)}const ese=Pe({expm1_:Qre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tse(n,e){const t=ge(n,"x","tile","string_or_numeric");ie(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return Me.runKernel(K1,r,s)}const hu=Pe({tile_:tse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nse(n,e,t,r="float32"){e==null&&(e=n);const s=Xn([n,e],r),i=n<=e?n:e;for(let a=0;a<i;++a)s.set(1,a,a);const o=$e(s.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return hu(Uo(o,0),[t[0],1,1]);if(t.length===2)return hu(Uo(Uo(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return hu(Uo(Uo(Uo(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const HU=Pe({eye_:nse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rse(n){const t={x:ge(n,"x","floor","float32")};return Me.runKernel(x1,t)}const SE=Pe({floor_:rse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sse(n,e,t=0,r=0){const s=ge(n,"x","gather"),i=ge(e,"indices","gather","int32"),o={x:s,indices:i},a={axis:t,batchDims:r};return Me.runKernel(RT,o,a)}const bk=Pe({gather_:sse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ise(n,e){let t=ge(n,"a","greater","string_or_numeric"),r=ge(e,"b","greater","string_or_numeric");[t,r]=As(t,r),$n(t.shape,r.shape);const s={a:t,b:r};return Me.runKernel(DT,s)}const Ya=Pe({greater_:ise});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ose(n,e){let t=ge(n,"a","greaterEqual","string_or_numeric"),r=ge(e,"b","greaterEqual","string_or_numeric");[t,r]=As(t,r),$n(t.shape,r.shape);const s={a:t,b:r};return Me.runKernel(b1,s)}const um=Pe({greaterEqual_:ose});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ase(n){const t={input:ge(n,"input","imag")};return Me.runKernel(jM,t)}const Sk=Pe({imag_:ase});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lse(n){const t={x:ge(n,"x","isFinite")};return Me.runKernel(_1,t)}const use=Pe({isFinite_:lse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cse(n){const t={x:ge(n,"x","isInf")};return Me.runKernel(T1,t)}const hse=Pe({isInf_:cse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dse(n){const t={x:ge(n,"x","isNaN")};return Me.runKernel(E1,t)}const fse=Pe({isNaN_:dse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pse(n,e=.2){const r={x:ge(n,"x","leakyRelu")},s={alpha:e};return Me.runKernel($T,r,s)}const _k=Pe({leakyRelu_:pse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mse(n,e){let t=ge(n,"a","less","string_or_numeric"),r=ge(e,"b","less","string_or_numeric");[t,r]=As(t,r),$n(t.shape,r.shape);const s={a:t,b:r};return Me.runKernel(PT,s)}const o_=Pe({less_:mse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gse(n,e){let t=ge(n,"a","lessEqual","string_or_numeric"),r=ge(e,"b","lessEqual","string_or_numeric");[t,r]=As(t,r),$n(t.shape,r.shape);const s={a:t,b:r};return Me.runKernel(LT,s)}const Yy=Pe({lessEqual_:gse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yse(n,e=5,t=1,r=1,s=.5){const i=ge(n,"x","localResponseNormalization");ie(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),ie(Sy(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=$e(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},u={depthRadius:e,bias:t,alpha:r,beta:s},c=Me.runKernel(BT,l,u);return a?$e(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const vse=Pe({localResponseNormalization_:yse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xse(n){const t={x:ge(n,"x","log","float32")};return Me.runKernel(C1,t)}const sc=Pe({log_:xse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wse(n){const t={x:ge(n,"x","log1p")};return Me.runKernel(I1,t)}const jU=Pe({log1p_:wse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bse(n,e){ie(iN(n),()=>"The f passed in variableGrads(f) must be a function"),ie(e==null||Array.isArray(e)&&e.every(u=>u instanceof s_),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const u in Me.registeredVariables)e.push(Me.registeredVariables[u])}const r=t?e.filter(u=>!u.trainable):null,s=e.length;e=e.filter(u=>u.trainable),ie(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const i=!0,{value:o,grads:a}=Me.gradients(n,e,null,i);ie(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),ie(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:o,grads:l}}function Cy(n){return Me.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sse(n){const t={x:ge(n,"x","neg")};return Me.runKernel(XT,t)}const Is=Pe({neg_:Sse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _se(n){const t={x:ge(n,"x","softplus")};return Me.runKernel(W1,t)}const Q1=Pe({softplus_:_se});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tse(n){const e=ge(n,"x","logSigmoid");return Cy(r=>({value:Is(Q1(Is(r))),gradFunc:o=>Ae(o,Ky(Is(r)))}))(e)}const Ese=Pe({logSigmoid_:Tse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cse(n,e){let t=ge(n,"a","sub"),r=ge(e,"b","sub");[t,r]=As(t,r);const s={a:t,b:r};return Me.runKernel(j1,s)}const yn=Pe({sub_:Cse});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ise(n,e=-1){const t=ge(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Cy((s,i)=>{const a=fu(s,e,!0),l=yn(s,a),u=yn(Ot(l,"float32"),sc(an(rc(l),e,!0)));return i([u]),{value:u,gradFunc:(h,d)=>{const[p]=d,g=!0,w=rc(p);return yn(h,Ae(an(h,e,g),w))}}})(t)}const XU=Pe({logSoftmax_:Ise});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nse(n,e=null,t=!1){const r=ge(n,"x","logSumExp"),s=qn(e,r.shape),i=fu(r,s,!0),o=yn(r,i),a=rc(o),l=an(a,s),u=sc(l),c=xt($e(i,u.shape),u);if(t){const h=Vs(c.shape,s);return $e(c,h)}return c}const qU=Pe({logSumExp_:Nse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ase(n,e){const t=ge(n,"a","logicalAnd","bool"),r=ge(e,"b","logicalAnd","bool");$n(t.shape,r.shape);const s={a:t,b:r};return Me.runKernel(OT,s)}const lh=Pe({logicalAnd_:Ase});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mse(n){const t={x:ge(n,"x","logicalNot","bool")};return Me.runKernel(FT,t)}const Tk=Pe({logicalNot_:Mse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kse(n,e){const t=ge(n,"a","logicalOr","bool"),r=ge(e,"b","logicalOr","bool");$n(t.shape,r.shape);const s={a:t,b:r};return Me.runKernel(zT,s)}const KU=Pe({logicalOr_:kse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rse(n,e){const t=ge(n,"a","logicalXor","bool"),r=ge(e,"b","logicalXor","bool");return $n(t.shape,r.shape),lh(KU(n,e),Tk(lh(n,e)))}const Dse=Pe({logicalXor_:Rse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $se(n,e,t,r,s){const i=ge(n,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=$e(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ie(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),ie(Ji(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Qo("maxPool",r,s);const u={x:a},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s},h=Me.runKernel(VT,u,c);return l?$e(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Ek=Pe({maxPool_:$se});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pse(n,e=[1,1,1],t,r,s,i="NDHWC"){const o=ge(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=$e(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ie(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),ie(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),Qo("maxPool3d",r,s);const u={x:a},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:i},h=Me.runKernel(WT,u,c);return l?$e(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Lse=Pe({maxPool3d_:Pse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ose(n,e){let t=ge(n,"a","maximum"),r=ge(e,"b","maximum");[t,r]=As(t,r),t.dtype==="bool"&&(t=Ot(t,"int32"),r=Ot(r,"int32")),$n(t.shape,r.shape);const s={a:t,b:r};return Me.runKernel(N1,s)}const Qd=Pe({maximum_:Ose});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fse(n,e=null,t=!1){const s={x:ge(n,"x","mean")},i={axis:e,keepDims:t};return Me.runKernel(GT,s,i)}const Fs=Pe({mean_:Fse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gi(n,e="float32"){if(yh(n),e==="complex64"){const r=gi(n,"float32"),s=gi(n,"float32");return _y(r,s)}const t=Zi(Qe(n),e);return Me.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ef(n,e="float32"){if(yh(n),e==="complex64"){const r=ef(n,"float32"),s=gi(n,"float32");return _y(r,s)}const t=wM(Qe(n),e);return Me.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zse(n,e){let t=ge(n,"a","minimum"),r=ge(e,"b","minimum");[t,r]=As(t,r),t.dtype==="bool"&&(t=Ot(t,"int32"),r=Ot(r,"int32")),$n(t.shape,r.shape);const s={a:t,b:r};return Me.runKernel(A1,s)}const bx=Pe({minimum_:zse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bse(n,e,t){ie(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=ge(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");ie(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let a=0;a<r.rank;a++)ie(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ie(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const i={paddings:e,mode:t},o={x:r};return Me.runKernel(jT,o,i)}const Use=Pe({mirrorPad_:Bse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vse(n,e){let t=ge(n,"a","mod"),r=ge(e,"b","mod");[t,r]=As(t,r);const s={a:t,b:r};return Me.runKernel(M1,s)}const Wse=Pe({mod_:Vse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gse(n,e=null,t=!1){n=ge(n,"x","moments");const r=qn(e,n.shape),s=Fs(n,r,t);let i=s.shape;t||(i=Vs(s.shape,r));const o=Qr(yn(Ot(n,"float32"),$e(s,i))),a=Fs(o,r,t);return{mean:s,variance:a}}const Ck=Pe({moments_:Gse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hse(n,e){let t=ge(n,"a","notEqual","string_or_numeric"),r=ge(e,"b","notEqual","string_or_numeric");[t,r]=As(t,r),$n(t.shape,r.shape);const s={a:t,b:r};return Me.runKernel(qT,s)}const a_=Pe({notEqual_:Hse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jse(n,e,t=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:ge(n,"indices","oneHot","int32")},a={dtype:s,depth:e,onValue:t,offValue:r};return Me.runKernel(YT,o,a)}const YU=Pe({oneHot_:jse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xse(n){const t={x:ge(n,"x","onesLike")};return Me.runKernel(KT,t)}const Sl=Pe({onesLike_:Xse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qse(n,e,t=0){const r=ge(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},i={x:r};return Me.runKernel(JT,i,s)}const Ik=Pe({pad_:qse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kse(n,e,t){const r=ge(n,"x","spaceToBatchND");ie(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),ie(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),ie(r.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},i={blockShape:e,paddings:t};return Me.runKernel(lE,s,i)}const Nk=Pe({spaceToBatchND_:Kse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yse(n,e,t,r,s,i,o){s==null&&(s=[1,1]),i==null&&(i=1),r===0&&(r="valid");const a=ge(n,"x","maxPool");let l=a,u=!1;a.rank===3&&(u=!0,l=$e(a,[1,a.shape[0],a.shape[1],a.shape[2]])),ie(Ji(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const c=El(l.shape,e,i,s,r),h=[c.dilationHeight,c.dilationWidth];let d;r==="same"?d=Jse([c.filterHeight,c.filterWidth],h):d=[[0,0],[0,0]];const p=h[0]===1&&h[1]===1,[g,w]=Zse([c.inHeight,c.inWidth],h,d),y=p?r:"valid",x=p?l:Nk(l,h,g),T=(t==="avg"?()=>pk(x,e,i,y,o):()=>Ek(x,e,i,y,o))(),E=p?T:gk(T,h,w);return u?$e(E,[E.shape[1],E.shape[2],E.shape[3]]):E}function Zse(n,e,t){const r=t.map(c=>c[0]),s=t.map(c=>c[1]),i=n.concat(r,s),o=e.map((c,h)=>(c-i[h]%c)%c),a=s.map((c,h)=>c+o[h]),l=e.map((c,h)=>[r[h],a[h]]),u=e.map((c,h)=>[0,o[h]]);return[l,u]}function Jse(n,e){const r=n.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),i=r.map((o,a)=>o-s[a]);return r.map((o,a)=>[s[a],i[a]])}const Qse=Pe({pool_:Yse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eie(n,e){const t=ge(n,"x","prelu"),r=ge(e,"alpha","prelu"),s={x:t,alpha:r};return Me.runKernel(QT,s)}const Ak=Pe({prelu_:eie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tie(n,e=null,t=!1){let r=ge(n,"x","prod");r.dtype==="bool"&&(r=Ot(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return Me.runKernel(eE,s,i)}const nie=Pe({prod_:tie});var $S={exports:{}},rie=$S.exports,FP;function sie(){return FP||(FP=1,(function(n){(function(e,t,r){function s(l){var u=this,c=a();u.next=function(){var h=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=h-(u.c=h|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function i(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function o(l,u){var c=new s(l),h=u&&u.state,d=c.next;return d.int32=function(){return c.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&i(h,c),d.state=function(){return i(c,{})}),d}function a(){var l=4022871197,u=function(c){c=String(c);for(var h=0;h<c.length;h++){l+=c.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=o:this.alea=o})(rie,n)})($S)),$S.exports}var PS={exports:{}},iie=PS.exports,zP;function oie(){return zP||(zP=1,(function(n){(function(e,t,r){function s(a){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var u=new s(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,g=(d+p)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&i(c,u),h.state=function(){return i(u,{})}),h}t&&t.exports?t.exports=o:this.xor128=o})(iie,n)})(PS)),PS.exports}var LS={exports:{}},aie=LS.exports,BP;function lie(){return BP||(BP=1,(function(n){(function(e,t,r){function s(a){var l=this,u="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:u+=a;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var u=new s(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,g=(d+p)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&i(c,u),h.state=function(){return i(u,{})}),h}t&&t.exports?t.exports=o:this.xorwow=o})(aie,n)})(LS)),LS.exports}var OS={exports:{}},uie=OS.exports,UP;function cie(){return UP||(UP=1,(function(n){(function(e,t,r){function s(a){var l=this;l.next=function(){var c=l.x,h=l.i,d,p;return d=c[h],d^=d>>>7,p=d^d<<24,d=c[h+1&7],p^=d^d>>>10,d=c[h+3&7],p^=d^d>>>3,d=c[h+4&7],p^=d^d<<7,d=c[h+7&7],d=d^d<<13,p^=d^d<<9,c[h]=p,l.i=h+1&7,p};function u(c,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8?p[7]=-1:p[d],c.x=p,c.i=0,d=256;d>0;--d)c.next()}u(l,a)}function i(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var u=new s(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,g=(d+p)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(c.x&&i(c,u),h.state=function(){return i(u,{})}),h}t&&t.exports?t.exports=o:this.xorshift7=o})(uie,n)})(OS)),OS.exports}var FS={exports:{}},hie=FS.exports,VP;function die(){return VP||(VP=1,(function(n){(function(e,t,r){function s(a){var l=this;l.next=function(){var c=l.w,h=l.X,d=l.i,p,g;return l.w=c=c+1640531527|0,g=h[d+34&127],p=h[d=d+1&127],g^=g<<13,p^=p<<17,g^=g>>>15,p^=p>>>12,g=h[d]=g^p,l.i=d,g+(c^c>>>16)|0};function u(c,h){var d,p,g,w,y,x=[],_=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,_=Math.max(_,h.length)),g=0,w=-32;w<_;++w)h&&(p^=h.charCodeAt((w+32)%h.length)),w===0&&(y=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,w>=0&&(y=y+1640531527|0,d=x[w&127]^=p+y,g=d==0?g+1:0);for(g>=128&&(x[(h&&h.length||0)&127]=-1),g=127,w=512;w>0;--w)p=x[g+34&127],d=x[g=g+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,x[g]=p^d;c.w=y,c.X=x,c.i=g}u(l,a)}function i(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var u=new s(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,g=(d+p)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(c.X&&i(c,u),h.state=function(){return i(u,{})}),h}t&&t.exports?t.exports=o:this.xor4096=o})(hie,n)})(FS)),FS.exports}var zS={exports:{}},fie=zS.exports,WP;function pie(){return WP||(WP=1,(function(n){(function(e,t,r){function s(a){var l=this,u="";l.next=function(){var h=l.b,d=l.c,p=l.d,g=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^g,g=g-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^g,l.a=g-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):u+=a;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function i(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var u=new s(a),c=l&&l.state,h=function(){return(u.next()>>>0)/4294967296};return h.double=function(){do var d=u.next()>>>11,p=(u.next()>>>0)/4294967296,g=(d+p)/(1<<21);while(g===0);return g},h.int32=u.next,h.quick=h,c&&(typeof c=="object"&&i(c,u),h.state=function(){return i(u,{})}),h}t&&t.exports?t.exports=o:this.tychei=o})(fie,n)})(zS)),zS.exports}var BS={exports:{}};const mie={},gie=Object.freeze(Object.defineProperty({__proto__:null,default:mie},Symbol.toStringTag,{value:"Module"})),yie=m8(gie);var vie=BS.exports,GP;function xie(){return GP||(GP=1,(function(n){(function(e,t,r){var s=256,i=6,o=52,a="random",l=r.pow(s,i),u=r.pow(2,o),c=u*2,h=s-1,d;function p(E,N,M){var $=[];N=N==!0?{entropy:!0}:N||{};var L=x(y(N.entropy?[E,T(t)]:E??_(),3),$),k=new g($),R=function(){for(var P=k.g(i),B=l,Z=0;P<u;)P=(P+Z)*s,B*=s,Z=k.g(1);for(;P>=c;)P/=2,B/=2,Z>>>=1;return(P+Z)/B};return R.int32=function(){return k.g(4)|0},R.quick=function(){return k.g(4)/4294967296},R.double=R,x(T(k.S),t),(N.pass||M||function(P,B,Z,V){return V&&(V.S&&w(V,k),P.state=function(){return w(k,{})}),Z?(r[a]=P,B):P})(R,L,"global"in N?N.global:this==r,N.state)}function g(E){var N,M=E.length,$=this,L=0,k=$.i=$.j=0,R=$.S=[];for(M||(E=[M++]);L<s;)R[L]=L++;for(L=0;L<s;L++)R[L]=R[k=h&k+E[L%M]+(N=R[L])],R[k]=N;($.g=function(P){for(var B,Z=0,V=$.i,X=$.j,q=$.S;P--;)B=q[V=h&V+1],Z=Z*s+q[h&(q[V]=q[X=h&X+B])+(q[X]=B)];return $.i=V,$.j=X,Z})(s)}function w(E,N){return N.i=E.i,N.j=E.j,N.S=E.S.slice(),N}function y(E,N){var M=[],$=typeof E,L;if(N&&$=="object")for(L in E)try{M.push(y(E[L],N-1))}catch{}return M.length?M:$=="string"?E:E+"\0"}function x(E,N){for(var M=E+"",$,L=0;L<M.length;)N[h&L]=h&($^=N[h&L]*19)+M.charCodeAt(L++);return T(N)}function _(){try{var E;return d&&(E=d.randomBytes)?E=E(s):(E=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(E)),T(E)}catch{var N=e.navigator,M=N&&N.plugins;return[+new Date,e,M,e.screen,T(t)]}}function T(E){return String.fromCharCode.apply(0,E)}if(x(r.random(),t),n.exports){n.exports=p;try{d=yie}catch{}}else r["seed"+a]=p})(typeof self<"u"?self:vie,[],Math)})(BS)),BS.exports}var B2,HP;function wie(){if(HP)return B2;HP=1;var n=sie(),e=oie(),t=lie(),r=cie(),s=die(),i=pie(),o=xie();return o.alea=n,o.xor128=e,o.xorwow=t,o.xorshift7=r,o.xor4096=s,o.tychei=i,B2=o,B2}var Zy=wie();/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ZU=class{constructor(e,t,r,s,i){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=Zy.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,i,o;do s=2*this.random()-1,i=2*this.random()-1,o=s*s+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*s*a,t=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},bie=class{constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Zy.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sie(n,e=0,t=1,r,s){if(yh(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const i=new ZU(e,t,r,!1,s),o=Xn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const _ie=Pe({randomNormal_:Sie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tie(n,e=0,t=1,r="float32",s){yh(n);const i=Xn(n,r),o=new bie(e,t,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const ew=Pe({randomUniform_:Tie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sx(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return Me.runKernel(QM,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eie(n){const t={input:ge(n,"input","real")};return Me.runKernel(ek,t)}const l_=Pe({real_:Eie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cie(n){const t={x:ge(n,"x","reciprocal")};return Me.runKernel(D1,t)}const Iie=Pe({reciprocal_:Cie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nie(n){const t={x:ge(n,"x","relu")};return Me.runKernel($1,t)}const cm=Pe({relu_:Nie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aie(n){const t={x:ge(n,"x","relu6")};return Me.runKernel(P1,t)}const JU=Pe({relu6_:Aie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mie(n,e){const r={x:ge(n,"x","reverse")},s={dims:e};return Me.runKernel(sE,r,s)}const jp=Pe({reverse_:Mie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kie(n){const t={x:ge(n,"x","round")};return Me.runKernel(L1,t)}const QU=Pe({round_:kie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rie(n){const t={x:ge(n,"x","rsqrt","float32")};return Me.runKernel(O1,t)}const e4=Pe({rsqrt_:Rie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Die(n){const t={x:ge(n,"x","selu")};return Me.runKernel(F1,t)}const t4=Pe({selu_:Die});function $ie(n,e,t,r,s,i=[1,1],o="NHWC"){const a=ge(n,"x","separableConv2d"),l=ge(e,"depthwiseFilter","separableConv2d"),u=ge(t,"pointwiseFilter","separableConv2d");let c=a,h=!1;if(a.rank===3&&(h=!0,c=$e(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ie(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),ie(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),ie(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),ie(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),ie(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];ie(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const g=xk(c,l,r,s,o,i),y=Hp(g,u,1,"valid",o);return h?$e(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const n4=Pe({separableConv2d_:$ie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pie(n){const t={x:ge(n,"x","sign")};return Me.runKernel(U1,t)}const Lie=Pe({sign_:Pie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oie(n){const t={x:ge(n,"x","sin","float32")};return Me.runKernel(z1,t)}const r4=Pe({sin_:Oie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fie(n){const t={x:ge(n,"x","sinh")};return Me.runKernel(B1,t)}const s4=Pe({sinh_:Fie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zie(n,e,t){const r=ge(n,"x","slice1d");return ie(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Xr(r,[e],[t])}const Mk=Pe({slice1d_:zie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bie(n,e,t){const r=ge(n,"x","slice2d");return ie(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Xr(r,e,t)}const i4=Pe({slice2d_:Bie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uie(n,e,t){const r=ge(n,"x","slice3d");return ie(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Xr(r,e,t)}const kk=Pe({slice3d_:Uie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vie(n,e,t){const r=ge(n,"x","slice4d");return ie(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Xr(r,e,t)}const u_=Pe({slice4d_:Vie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wie(n,e=-1){const t=ge(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return Me.runKernel(cE,r,s)}const Rk=Pe({softmax_:Wie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gie(n){ie(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Me.runKernel(VM,e)}const o4=Pe({fft_:Gie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hie(n){ie(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Me.runKernel(HM,e)}const SN=Pe({ifft_:Hie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jie(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=$e(n,[t,e]);r=SN(s)}else{const s=[t,2*(e-1)],i=$e(l_(n),[t,e]),o=$e(Sk(n),[t,e]),a=jp(Xr(i,[0,1],[t,e-2]),1),l=Ae(jp(Xr(o,[0,1],[t,e-2]),1),Sr(-1)),u=Xo([i,a],1),c=Xo([o,l],1),h=$e(_y(u,c),[s[0],s[1]]);r=SN(h)}if(r=l_(r),n.rank===3&&n.shape[0]!==0){const s=r,i=n.shape[0];r=$e(r,[i,r.shape[0]/i,r.shape[1]]),s.dispose()}return r}const Xie=Pe({irfft_:jie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qie(n,e,t=0){const s={x:ge(n,"x","split")},i={numOrSizeSplits:e,axis:t};return Me.runKernel(uE,s,i)}const ja=Pe({split_:qie});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kie(n,e){ie(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const g=n.shape.map(y=>0),w=n.shape.map(y=>y);w[n.shape.length-1]=e,s=Xr(n,g,w),t=e}else if(e!=null&&e>t){const g=n.shape.map(w=>w);g[n.shape.length-1]=e-t,s=Xo([n,gi(g)],n.shape.length-1),t=e}else s=n;const i=or(s),o=$e(_y(s,i),[r,t]),a=o4(o),l=Math.floor(t/2)+1,u=l_(a),c=Sk(a),h=ja(u,[l,t-l],u.shape.length-1),d=ja(c,[l,t-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,$e(_y(h[0],d[0]),p)}const Yie=Pe({rfft_:Kie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zie(n,e){let t=ge(n,"a","squaredDifference"),r=ge(e,"b","squaredDifference");[t,r]=As(t,r),$n(t.shape,r.shape);const s={a:t,b:r},i={};return Me.runKernel(H1,s,i)}const Jie=Pe({squaredDifference_:Zie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qie(n,e){const t=ge(n,"x","squeeze","string_or_numeric");return $e(t,Kd(t.shape,e).newShape)}const tw=Pe({squeeze_:Qie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eoe(n,e=0){const t=EU(n,"tensors","stack","string_or_numeric");ie(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&ie(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return Me.runKernel(ZT,r,s)}const uh=Pe({stack_:eoe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function toe(n,e=0){const r={x:ge(n,"x","step")},s={alpha:e};return Me.runKernel(Y1,r,s)}const nw=Pe({step_:toe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function noe(n,e,t,r,s=0,i=0,o=0,a=0,l=0){const c={x:ge(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:r,beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return Me.runKernel(ik,c,h)}const roe=Pe({stridedSlice_:noe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function soe(n){const t={x:ge(n,"x","tan","float32")};return Me.runKernel(X1,t)}const ioe=Pe({tan_:soe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ba(n,e){PB(n);const t=mE(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return gE(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U2(n,e,t){if(PB(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=mE(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return gE(n,e,r,t)}function a4(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(i+` update.rank < ${s}. `);if(n.length<r+(t.rank-s))throw new Error(i+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+n.length-r)throw new Error(i+` update.rank != ${s+n.length-r}`);for(let o=0;o<s;++o)if(t.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-s;++o)if(t.shape[o+s]!==n[o+r])throw new Error(i+` updates.shape[${o+s}] (${t.shape[o+s]}) != shape[${o+s}] (${n[o+s]})`)}function ooe(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}a4(t,e,n)}function hm(n,e,t){const r=e.shape.length,s=r>1?e.shape[r-1]:1,i=t.length;let o=1;for(let h=s;h<i;++h)o*=t[h];const a=s<1?1:s,l=Qe(e.shape)/a,u=[...nn(t.slice(0,s)),1],c=Qe(t);return{sliceRank:s,numUpdates:l,sliceSize:o,strides:u,outputSize:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aoe(n,e=1,t=!0){const r=ge(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const i={x:r},o={k:e,sorted:t},[a,l]=Me.runKernel(ok,i,o);return{values:a,indices:l}}const loe=Pe({topk_:aoe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uoe(n,e=0,t=1,r,s){if(yh(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new ZU(e,t,r,!0,s),o=Xn(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const l4=Pe({truncatedNormal_:uoe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function coe(n,e=0){const t=ge(n,"x","unique","string_or_numeric");ie(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[i,o]=Me.runKernel(lk,r,s);return{values:i,indices:o}}const hoe=Pe({unique_:coe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function doe(n,e,t){const r=ge(n,"x","unsortedSegmentSum"),s=ge(e,"segmentIds","unsortedSegmentSum","int32");ie(Sy(t),()=>"numSegments must be of dtype int");const i={x:r,segmentIds:s},o={numSegments:t};return Me.runKernel(dE,i,o)}const u4=Pe({unsortedSegmentSum_:doe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function foe(n,e=0){const t=ge(n,"x","unstack","string_or_numeric");ie(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return Me.runKernel(hE,r,s)}const Xp=Pe({unstack_:foe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function poe(n,e=!0,t,r){return Me.makeVariable(n,e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c4(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const r=Xn(n,"int32"),s=Xn([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const o=r.indexToLoc(t[i]),a=i*n.length;s.values.set(o,a)}return s.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function moe(n,e,t){const r=ge(n,"x","transpose");if(e==null&&(e=r.shape.map((o,a)=>a).reverse()),ie(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{ie(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},i={perm:e};return r.dtype==="complex64"?ze(()=>{let o=l_(r),a=Sk(r);return o=Me.runKernel(ly,{x:o},i),a=Me.runKernel(ly,{x:a},i),t&&(a=Is(a)),_y(o,a)}):Me.runKernel(ly,s,i)}const ir=Pe({transpose_:moe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function goe(n,e){if(e==null)return n.shape.slice();if(_r(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yoe(n,e,t,r){const s=ge(n,"x","dropout");if(ie(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),ie(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Zs?s.clone():s;const i=goe(s,t),o=1-e,a=hn(SE(xt(ew(i,0,1,"float32",r),o)),o);return Ae(s,a)}const voe=Pe({dropout_:yoe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xoe(n,e,t,r,s,i="NHWC",o){let a=n;n.rank===3&&(a=$e(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=$e(e,[1,e.shape[0],e.shape[1],e.shape[2]])),ie(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),ie(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),ie(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const u=i==="NHWC"?a.shape[3]:a.shape[1],c=i==="NHWC"?l.shape[3]:l.shape[1];ie(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),ie(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),Qo("conv2dDerFilter",s,o);const h={x:a,dy:l},d={strides:r,pad:s,dataFormat:i,dimRoundingMode:o,filterShape:t};return Me.runKernel(kM,h,d)}const Dk=Pe({conv2DBackpropFilter_:xoe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $k(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return Ae(n,nw(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Pk(n,e){let t=e;const r=ri(n.shape,e.shape);return r.length>0&&(t=an(t,r)),$e(t,n.shape)}function Lk(n,e,t,r){if(e==="linear")return n;if(e==="relu")return cm(n);if(e==="elu")return wE(n);if(e==="relu6")return JU(n);if(e==="prelu")return Ak(n,t);if(e==="leakyrelu")return _k(n,r);if(e==="sigmoid")return Ky(n);throw new Error(`Unknown fused activation ${e}.`)}const Ok=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function woe({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",Ok(Me.state.gradientDepth,l)===!1){ie(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let M=Hp(n,e,t,r,s,i,o);return a!=null&&(M=xt(M,a)),Lk(M,l,u,c)}const h=ge(n,"x","conv2d","float32"),d=ge(e,"filter","conv2d","float32");let p=h,g=!1;h.rank===3&&(g=!0,p=$e(h,[1,h.shape[0],h.shape[1],h.shape[2]])),ie(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),ie(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Qo("fused conv2d",r,o);const w=s==="NHWC"?p.shape[3]:p.shape[1];ie(d.shape[2]===w,()=>`Error in conv2d: depth of input (${w}) must match input depth for filter ${d.shape[2]}.`),ie(Ji(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const y=Pi(p.shape,d.shape,t,i,r,o);let x;a!=null&&(x=ge(a,"bias","fused conv2d"),[x]=As(x,h),s==="NHWC"?$n(y.outShape,x.shape):(ie(x.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`),ie(x.shape.length===0||x.shape[0]===y.outChannels||x.shape[0]===1,()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let _;if(u!=null){const M=u.shape;if(ie(M.length<=1||M.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${M.length}.`),M.length===1)ie(M[0]===1||M[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${M}) is not compatible with the number of output channels (${y.outChannels}).`);else if(M.length===3)try{$n(M,y.outShape)}catch{const L=`Error in fused conv2d: PReLU activation weights (${M}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(L)}_=ge(u,"prelu weights","fused conv2d")}const T=(M,$)=>{ie(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[L,k,R,P]=$,B=$k(M,R,l);ie(Wp(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const Z=yk(k.shape,B,L,t,r),V=Dk(k,B,L.shape,t,r),X=[Z,V];if(P!=null){const q=Pk(P,B);X.push(q)}return X},E={x:p,filter:d,bias:x,preluActivationWeights:_},N={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return a==null?Cy(($,L,k)=>{let R=Me.runKernel(n_,E,N);return k([L,$,R]),g&&(R=$e(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:T}})(p,d):Cy(($,L,k,R)=>{let P=Me.runKernel(n_,E,N);return R([L,$,P,k]),g&&(P=$e(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:T}})(p,d,x)}const boe=Pe({fusedConv2d_:woe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Soe(n,e,t,r,s,i=[1,1],o){let a=n;n.rank===3&&(a=$e(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=$e(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:a,dy:l},c={strides:r,pad:s,dimRoundingMode:o,dilations:i,filterShape:t};return Me.runKernel(FM,u,c)}const _oe=Pe({depthwiseConv2dNativeBackpropFilter_:Soe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Toe(n,e,t,r,s,i=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=$e(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:a,filter:t},c={strides:r,pad:s,dimRoundingMode:o,dilations:i,inputShape:n},h=Me.runKernel(zM,u,c);return l?$e(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Eoe=Pe({depthwiseConv2dNativeBackpropInput_:Toe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Coe({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(Ok(Me.state.gradientDepth,i)===!1){let P=wr(n,e,t,r);return s!=null&&(P=xt(P,s)),Lk(P,i,o,a)}let l=ge(n,"a","fused matMul"),u=ge(e,"b","fused matMul");[l,u]=As(l,u);const c=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=t?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],g=l.shape.slice(0,-2),w=u.shape.slice(0,-2),y=Qe(g),x=Qe(w);ie(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${t} and transposeB=${r} must match.`);const T=$n(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,p]),E=t?$e(l,[y,c,d]):$e(l,[y,d,c]),N=r?$e(u,[x,p,h]):$e(u,[x,h,p]);let M;s!=null&&(M=ge(s,"bias","fused matMul"),[M]=As(M,l),$n(T,M.shape));let $;o!=null&&($=ge(o,"prelu weights","fused matMul"));const L=(P,B)=>{const[Z,V,X,q]=B,se=$k($e(P,X.shape),X,i);let W,J;if(!t&&!r?(W=wr(se,V,!1,!0),J=wr(Z,se,!0,!1)):!t&&r?(W=wr(se,V,!1,!1),J=wr(se,Z,!0,!1)):t&&!r?(W=wr(V,se,!1,!0),J=wr(Z,se,!1,!1)):(W=wr(V,se,!0,!0),J=wr(se,Z,!0,!0)),s!=null){const K=Pk(q,se);return[W,J,K]}else return[W,J]},k={a:E,b:N,bias:M,preluActivationWeights:$},R={transposeA:t,transposeB:r,activation:i,leakyreluAlpha:a};return s==null?Cy((B,Z,V)=>{const X=Me.runKernel(t_,k,R);return V([B,Z,X]),{value:$e(X,T),gradFunc:L}})(E,N):Cy((B,Z,V,X)=>{const q=Me.runKernel(t_,k,R);return X([B,Z,q,V]),{value:$e(q,T),gradFunc:L}})(E,N,M)}const jP=Pe({fusedMatMul_:Coe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ioe(n,e,t,r,s="bilinear",i=0){const o=ge(n,"image","cropAndResize"),a=ge(e,"boxes","cropAndResize","float32"),l=ge(t,"boxInd","cropAndResize","int32"),u=a.shape[0];ie(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),ie(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),ie(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),ie(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),ie(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),ie(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:o,boxes:a,boxInd:l},h={method:s,extrapolationValue:i,cropSize:r};return Me.runKernel(PM,c,h)}const Noe=Pe({cropAndResize_:Ioe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aoe(n){const e=ge(n,"image","flipLeftRight","float32");ie(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return Me.runKernel(GM,t,{})}const Moe=Pe({flipLeftRight_:Aoe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function koe(n){const e=ge(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];ie(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),ie(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,hu(e,s)}const Roe=Pe({grayscaleToRGB_:koe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Doe(n){const e=ge(n,"image","RGBToGrayscale"),t=e.rank-1,r=e.shape[t];ie(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),ie(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,i=Ot(e,"float32"),o=ba([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Ev("ij,j->i",i,o);break;case 3:a=Ev("ijk,k->ij",i,o);break;case 4:a=Ev("ijkl,l->ijk",i,o);break;case 5:a=Ev("ijklm,m->ijkl",i,o);break;case 6:a=Ev("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=Uo(a,-1),Ot(a,s)}const $oe=Pe({rgbToGrayscale_:Doe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Poe(n,e,t=0,r=.5){const s=ge(n,"image","rotateWithOffset","float32");ie(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const i={image:s},o={radians:e,fillValue:t,center:r};return Me.runKernel(uk,i,o)}const Loe=Pe({rotateWithOffset_:Poe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jy(n,e,t,r,s,i){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return t=Math.min(t,o),ie(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),ie(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),ie(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),ie(e.rank===1,()=>"scores must be a 1D tensor"),ie(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),ie(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ooe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const i=ge(n,"boxes","nonMaxSuppression","float32"),o=ge(e,"scores","nonMaxSuppression","float32"),a=Jy(i,o,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:r,scoreThreshold:s};return Me.runKernel(YM,{boxes:i,scores:o},l)}const Foe=Pe({nonMaxSuppression_:Ooe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zoe(n,e,t){const r=Boe(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function Boe(n,e,t){return Voe(n,e,t||Uoe)}function Uoe(n,e){return n>e?1:n<e?-1:0}function Voe(n,e,t){let r=0,s=n.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=t(e,n[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fk(n,e,t,r,s){return Uk(n,e,t,r,s,0)}function zk(n,e,t,r,s,i){return Uk(n,e,t,r,s,0,!1,i,!0)}function Bk(n,e,t,r,s,i){return Uk(n,e,t,r,s,i,!0)}function Uk(n,e,t,r,s,i,o=!1,a=!1,l=!1){const u=[];for(let y=0;y<e.length;y++)e[y]>s&&u.push({score:e[y],boxIndex:y,suppressBeginIndex:0});u.sort(XP);const c=i>0?-.5/i:0,h=[],d=[];for(;h.length<t&&u.length>0;){const y=u.pop(),{score:x,boxIndex:_,suppressBeginIndex:T}=y;if(x<s)break;let E=!1;for(let N=h.length-1;N>=T;--N){const M=Woe(n,_,h[N]);if(M>=r){E=!0;break}if(y.score=y.score*Goe(r,c,M),y.score<=s)break}y.suppressBeginIndex=h.length,E||(y.score===x?(h.push(_),d.push(y.score)):y.score>s&&zoe(u,y,XP))}const p=h.length,g=t-p;a&&g>0&&(h.push(...new Array(g).fill(0)),d.push(...new Array(g).fill(0)));const w={selectedIndices:h};return o&&(w.selectedScores=d),l&&(w.validOutputs=p),w}function Woe(n,e,t){const r=n.subarray(e*4,e*4+4),s=n.subarray(t*4,t*4+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(a-i)*(l-o),g=(h-u)*(d-c);if(p<=0||g<=0)return 0;const w=Math.max(i,u),y=Math.max(o,c),x=Math.min(a,h),_=Math.min(l,d),T=Math.max(x-w,0)*Math.max(_-y,0);return T/(p+g-T)}function Goe(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function XP(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Hoe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const i=ge(n,"boxes","nonMaxSuppressionAsync"),o=ge(e,"scores","nonMaxSuppressionAsync"),a=Jy(i,o,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),u=l[0],c=l[1],{selectedIndices:h}=Fk(u,c,t,r,s);return i!==n&&i.dispose(),o!==e&&o.dispose(),ba(h,"int32")}const joe=Hoe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xoe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=ge(n,"boxes","nonMaxSuppression"),a=ge(e,"scores","nonMaxSuppression"),l=Jy(o,a,t,r,s,i);t=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const u={boxes:o,scores:a},c={maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:i},h=Me.runKernel(JM,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}const qoe=Pe({nonMaxSuppressionWithScore_:Xoe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Koe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=ge(n,"boxes","nonMaxSuppressionAsync"),a=ge(e,"scores","nonMaxSuppressionAsync"),l=Jy(o,a,t,r,s,i);t=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const u=await Promise.all([o.data(),a.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=Bk(c,h,t,r,s,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:ba(d,"int32"),selectedScores:ba(p)}}const Yoe=Koe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zoe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=ge(n,"boxes","nonMaxSuppression"),a=ge(e,"scores","nonMaxSuppression"),l=Jy(o,a,t,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,d={boxes:o,scores:a},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:i},g=Me.runKernel(ZM,d,p);return{selectedIndices:g[0],validOutputs:g[1]}}const Joe=Pe({nonMaxSuppressionPadded_:Zoe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Qoe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=ge(n,"boxes","nonMaxSuppressionAsync"),a=ge(e,"scores","nonMaxSuppressionAsync"),l=Jy(o,a,t,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:g,validOutputs:w}=zk(d,p,u,c,h,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:ba(g,"int32"),validOutputs:Sr(w,"int32")}}const eae=Qoe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tae(n,e,t=!1,r=!1){const s=ge(n,"images","resizeBilinear");ie(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),ie(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),ie(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;s.rank===3&&(o=!0,i=$e(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:r,size:e},u=Me.runKernel(rE,a,l);return o?$e(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const h4=Pe({resizeBilinear_:tae});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nae(n,e,t=!1,r=!1){const s=ge(n,"images","resizeNearestNeighbor");ie(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),ie(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),ie(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),ie(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;s.rank===3&&(o=!0,i=$e(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:r,size:e},u=Me.runKernel(nE,a,l);return o?$e(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const d4=Pe({resizeNearestNeighbor_:nae});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rae(n,e="binary",t=!1,r=.5){const s=ge(n,"image","threshold"),i=.2989,o=.587,a=.114,l=s.shape[0]*s.shape[1];let u=Ae(ba([r]),255),c,h,d,p;if(ie(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),ie(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),ie(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),ie(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[c,h,d]=ja(s,[1,1,1],-1);const y=Ae(c,i),x=Ae(h,o),_=Ae(d,a);p=xt(xt(y,x),_)}else p=n;if(e==="otsu"){const y=Qne(Ot(QU(p),"int32"),CU([]),256);u=sae(y,l)}const g=t?Yy(p,u):Ya(p,u);return Ot(Ae(g,255),"int32")}function sae(n,e){let t=ba([-1]),r=ba([0]),s=ba([0]),i,o,a,l,u,c;for(let h=0;h<n.size-1;h++){i=Xr(n,0,h+1),o=Xr(n,h+1),u=hn(an(i),e),c=hn(an(o),e);const d=an(Ae(i,Sx(0,i.size)));a=hn(d,an(i));const p=xE(o.shape,i.size),g=xt(Sx(0,o.size),p),w=Ae(o,g);l=hn(an(w),an(o));const y=yn(a,l),x=yn(a,l),_=Ae(u,c);s=Ae(Ae(_,y),x);const T=Ya(s,r);r=_o(T,s,r),t=_o(T,ba([h]),t)}return t}const iae=Pe({threshold_:rae});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oae(n,e,t="nearest",r="constant",s=0,i){const o=ge(n,"image","transform","float32"),a=ge(e,"transforms","transform","float32");ie(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),ie(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),ie(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},u={interpolation:t,fillMode:r,fillValue:s,outputShape:i};return Me.runKernel(ak,l,u)}const aae=Pe({transform_:oae});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lae(n,e,t){const r=ge(n,"a","bandPart");ie(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);let a,l;typeof e=="number"?(ie(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),ie(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),a=ge(e<0?i:e,"numLower","bandPart")):(ie(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=_o(o_(e,0),i,bx(e,i))),typeof t=="number"?(ie(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),ie(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),l=ge(t<0?o:t,"numUpper","bandPart")):(ie(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=_o(o_(t,0),o,bx(t,o)));const u=$e(Sx(0,i,1,"int32"),[-1,1]),c=Sx(0,o,1,"int32"),h=yn(u,c),d=lh(Yy(h,a),um(h,Is(l))),p=gi([i,o],r.dtype);return $e(uh(Xp($e(r,[-1,i,o])).map(g=>_o(d,g,p))),s)}const uae=Pe({bandPart_:lae});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cae(n){let e;if(Array.isArray(n)){e=!1,ie(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let i=1;i<n.length;++i)ie(n[i].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${s})`)}else e=!0,n=ja(n,n.shape[0],0).map(s=>tw(s,[0]));ie(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(Me.tidy(()=>{let i=r[s];if(s>0)for(let o=0;o<s;++o){const a=Ae(an(Ae(t[o],i)),t[o]);i=yn(i,a)}return hn(i,bE(i,"euclidean"))}));return e?uh(t,0):t}const hae=Pe({gramSchmidt_:cae});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dae(n,e=!1){if(ie(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return qP(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),r=Xp($e(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],i=[];r.forEach(l=>{const[u,c]=qP(l,e);s.push(u),i.push(c)});const o=$e(uh(s,0),n.shape),a=$e(uh(i,0),n.shape);return[o,a]}}function qP(n,e=!1){return Me.tidy(()=>{ie(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=HU(t),i=kp(n);const o=U2([[1]],[1,1]);let a=kp(o);const l=t>=r?r:t;for(let u=0;u<l;++u){const c=i,h=a,d=s;[a,i,s]=Me.tidy(()=>{const p=Xr(i,[u,u],[t-u,1]),g=bE(p),w=Xr(i,[u,u],[1,1]),y=_o(Ya(w,0),U2([[-1]]),U2([[1]])),x=yn(w,Ae(y,g)),_=hn(p,x);_.shape[0]===1?a=kp(o):a=Xo([o,Xr(_,[1,0],[_.shape[0]-1,_.shape[1]])],0);const T=Is(hn(wr(y,x),g)),E=Xr(i,[u,0],[t-u,r]),N=Ae(T,a),M=ir(a);if(u===0)i=yn(E,wr(N,wr(M,E)));else{const k=yn(E,wr(N,wr(M,E)));i=Xo([Xr(i,[0,0],[u,r]),k],0)}const $=ir(N),L=Xr(s,[0,u],[t,s.shape[1]-u]);if(u===0)s=yn(L,wr(wr(L,a),$));else{const k=yn(L,wr(wr(L,a),$));s=Xo([Xr(s,[0,0],[t,u]),k],1)}return[a,i,s]}),Yn([c,h,d])}return!e&&t>r&&(s=Xr(s,[0,0],[t,r]),i=Xr(i,[0,0],[r,r])),[s,i]})}const fae=Pe({qr_:dae});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nh={flipLeftRight:Moe,grayscaleToRGB:Roe,resizeNearestNeighbor:d4,resizeBilinear:h4,rgbToGrayscale:$oe,rotateWithOffset:Loe,cropAndResize:Noe,nonMaxSuppression:Foe,nonMaxSuppressionAsync:joe,nonMaxSuppressionWithScore:qoe,nonMaxSuppressionWithScoreAsync:Yoe,nonMaxSuppressionPadded:Joe,nonMaxSuppressionPaddedAsync:eae,threshold:iae,transform:aae},pae={bandPart:uae,gramSchmidt:hae,qr:fae};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mae=new Map,gae=new Map;let Qy=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},e0=class Yg{constructor(){this.classNameMap={}}static getMap(){return Yg.instance==null&&(Yg.instance=new Yg),Yg.instance}static register(e){Yg.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function ft(n,e,t){ie(n.className!=null,()=>"Class being registered does not have the static className property defined."),ie(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),ie(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const r=t,s=e+">"+r;return e0.register(n),mae.set(s,n),gae.set(n,s),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tf=class extends Qy{minimize(e,t=!1,r){const{value:s,grads:i}=this.computeGradients(e,r);if(r!=null){const o=r.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return Yn(i),t?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return bse(e,t)}dispose(){this.iterations_!=null&&Yn(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Sr(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(tf,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let f4=class extends tf{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=Me.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Me.registeredVariables[r],o=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:ze(()=>or(i).variable(o))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:ze(()=>or(i).variable(o))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedGrads[s].variable,u=this.accumulatedUpdates[s].variable;ze(()=>{const c=xt(Ae(l,this.rho),Ae(Qr(a),1-this.rho)),h=Ae(hn(Eo(xt(u,this.epsilon)),Eo(xt(l,this.epsilon))),a),d=xt(Ae(u,this.rho),Ae(Qr(h),1-this.rho));l.assign(c),u.assign(d);const p=xt(Ae(h,-this.learningRate),i);i.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Yn(this.accumulatedGrads.map(e=>e.variable)),Yn(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let p4=class extends tf{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Me.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:ze(()=>xE(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const a=this.accumulatedGrads[s].variable;ze(()=>{const l=xt(a,Qr(o));a.assign(l);const u=xt(Ae(hn(o,Eo(xt(l,Me.backend.epsilon()))),-this.learningRate),i);i.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Yn(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let m4=class extends tf{static get className(){return"Adam"}constructor(e,t,r,s=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ze(()=>{this.accBeta1=Sr(t).variable(),this.accBeta2=Sr(r).variable()}),s==null&&(this.epsilon=Me.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);ze(()=>{const r=yn(1,this.accBeta1),s=yn(1,this.accBeta2);t.forEach((i,o)=>{const a=Me.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:ze(()=>or(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:ze(()=>or(a).variable(l))});const u=Array.isArray(e)?e[o].tensor:e[i];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,d=xt(Ae(c,this.beta1),Ae(u,1-this.beta1)),p=xt(Ae(h,this.beta2),Ae(Qr(u),1-this.beta2)),g=hn(d,r),w=hn(p,s);c.assign(d),h.assign(p);const y=xt(Ae(hn(g,xt(Eo(w),this.epsilon)),-this.learningRate),a);a.assign(y)}),this.accBeta1.assign(Ae(this.accBeta1,this.beta1)),this.accBeta2.assign(Ae(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Yn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Yn(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),ze(()=>{this.accBeta1.assign(Ey(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ey(this.beta2,this.iterations_+1))});const t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let g4=class extends tf{static get className(){return"Adamax"}constructor(e,t,r,s=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ze(()=>{this.iteration=Sr(0).variable(),this.accBeta1=Sr(t).variable()}),s==null&&(this.epsilon=Me.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);ze(()=>{const r=yn(1,this.accBeta1),s=hn(-this.learningRate,xt(Ae(this.iteration,this.decay),1));t.forEach((i,o)=>{const a=Me.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:or(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:or(a).variable(l)});const u=Array.isArray(e)?e[o].tensor:e[i];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,d=xt(Ae(c,this.beta1),Ae(u,1-this.beta1)),p=Ae(h,this.beta2),g=ho(u),w=Qd(p,g);c.assign(d),h.assign(w);const y=xt(Ae(hn(s,r),hn(d,xt(w,this.epsilon))),a);a.assign(y)}),this.iteration.assign(xt(this.iteration,1)),this.accBeta1.assign(Ae(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Yn(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Yn(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Vk=class extends tf{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const o=Me.registeredVariables[r];ze(()=>{const a=xt(Ae(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=qu(Sr(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let y4=class extends Vk{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=Sr(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Me.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:ze(()=>or(i).variable(!1))});const o=this.accumulations[s].variable,a=Array.isArray(e)?e[s].tensor:e[r];a!=null&&ze(()=>{let l;const u=xt(Ae(this.m,o),a);this.useNesterov?l=xt(Ae(this.c,xt(a,Ae(u,this.m))),i):l=xt(Ae(this.c,u),i),o.assign(u),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Yn(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let v4=class extends tf{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,s=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,s==null&&(this.epsilon=Me.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Me.registeredVariables[r],o=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:ze(()=>or(i).variable(o))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:ze(()=>or(i).variable(o))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:ze(()=>or(i).variable(o))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedMeanSquares[s].variable,u=this.accumulatedMoments[s].variable;ze(()=>{const c=xt(Ae(l,this.decay),Ae(Qr(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[s].variable,d=xt(Ae(h,this.decay),Ae(a,1-this.decay)),p=hn(Ae(a,this.learningRate),Eo(yn(c,xt(Qr(d),this.epsilon)))),g=xt(Ae(u,this.momentum),p);l.assign(c),h.assign(d),u.assign(g);const w=yn(i,g);i.assign(w)}else{const h=xt(Ae(l,this.decay),Ae(Qr(a),1-this.decay)),d=xt(Ae(u,this.momentum),hn(Ae(a,this.learningRate),Eo(xt(h,this.epsilon))));l.assign(h),u.assign(d);const p=yn(i,d);i.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Yn(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Yn(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Yn(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yae=[f4,p4,m4,g4,y4,v4,Vk];function vae(){for(const n of yae)ft(n)}function Wk(n,e){const t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(Qe(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=e.shape,i=s[s.length-1];let o=1;for(let h=0;h<s.length-1;++h)o*=s[h];const a=n.shape,l=s.slice();l.pop();let u=1;for(let h=i;h<t;++h)u*=a[h],l.push(a[h]);const c=[...nn(n.shape).map(h=>h/u),1].slice(0,i);return[l,o,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _N=-2,xae=-1;function Gk(n,e,t){const r=n.shape.length;ie(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),ie(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)ie(e[s]+t[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+t[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function wae(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function Hk(n,e,t){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((e[s]-n[s])/t[s]);return r}function x4(n,e,t,r){const s=[...n];for(let i=s.length;i<r.length;i++)s.push(1);for(let i=0;i<t;i++)i===0?s[e]=1:(s.splice(e,0,1),s.pop());return s}function w4(n,e,t){return t<=n?t:t-(e-1)}function b4(n,e){const t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function bae(n,e,t,r,s,i,o,a,l){const u=n.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(e.length&&t>0){const p=e[0],g=t+1;c=S4(o,p,g,r,n),h=_4(a,p,g,s,n),d=x4(i,p,g,n)}else for(let p=0;p<u;p++)c[p]=E4(o,r,i,n,p,l),h[p]=C4(a,s,i,n,p,l),d[p]=T4(i,p,l);return{begin:c,end:h,strides:d}}function S4(n,e,t,r,s){const i=[...s],o=b4(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=w4(e,t,a);let u=r[l];n&1<<l&&(u=0),i[a]=u}return i}function _4(n,e,t,r,s){const i=[...s],o=b4(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=w4(e,t,a);let u=r[l];n&1<<l&&(u=Number.MAX_SAFE_INTEGER),i[a]=u}for(let a=0;a<i.length;a++){const l=s[a];i[a]<0&&(i[a]+=l),i[a]=zp(0,i[a],s[a])}return i}function T4(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function E4(n,e,t,r,s,i){let o=e[s];const a=t[s]||1;(n&1<<s||i&1<<s||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),o=zp(0,o,l-1),o}function C4(n,e,t,r,s,i){let o=e[s];const a=t[s]||1;(n&1<<s||i&1<<s||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=r[s];return o<0&&(o+=l),a>0?o=zp(0,o,l):o=zp(-1,o,l-1),o}function jk(n,e,t){let r=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){r=s;break}for(let s=r+1;s<t.length;s++)if(e[s]>0||t[s]!==n[s])return!1;return!0}function Xk(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function _E(n,e,t){let r;const s=n.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(o=>{ie(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(s).fill(-1):typeof t=="number"?i=[t,...new Array(s-1).fill(-1)]:t.length<s?i=t.concat(new Array(s-t.length).fill(-1)):i=t,i=i.map((o,a)=>o>=0?o:(ie(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,i]}function qk(n,e,t,r,s,i,o,a,l){let u;if(r==null?(u=new Array(e.length),u.fill(1)):u=r,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:u.slice(),beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let T=0;T<h.dims;T++)c&&(1<<T&a)!==0&&h.numAddAxisAfterEllipsis++,1<<T&o&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Sae(h,d);let p=!0,g=!0,w=!0;const y=[],x=[];for(let T=0;T<n.length;++T){if(d.strides[T]===0)throw Error(`strides[${T}] must be non-zero`);const E=!!(d.shrinkAxisMask&1<<T),N=n[T];if(N===-1){y.push(E?1:-1);continue}const M=[d.beginMask&1<<T,d.endMask&1<<T],$=[d.strides[T]>0?0:-1,d.strides[T]>0?N:N-1];if(E&&d.strides[T]<=0)throw Error("only stride 1 allowed on non-range indexing.");w=w&&d.strides[T]===1;const L=!!(d.beginMask&1<<T&&d.endMask&1<<T);if(d.beginValid&&d.endValid){if(E){const B=d.begin[T]<0?N+d.begin[T]:d.begin[T];if(d.begin[T]=B,d.end[T]=d.begin[T]+1,B<0||B>=N)throw Error(`slice index ${d.begin[T]} of dimension ${T} out of bounds.`)}else d.begin[T]=KP(d.begin[T],0,d.strides[T],N,M,$),d.end[T]=KP(d.end[T],1,d.strides[T],N,M,$);const P=d.strides[T]===1&&d.begin[T]===0&&d.end[T]===N;p=p&&P,g=g&&(T===0&&d.strides[T]===1||P)}else p=p&&d.strides[T]===1&&L,g=g&&(T===0&&d.strides[T]===1||L);let k,R=!1;if(d.beginValid&&d.endValid?(k=d.end[T]-d.begin[T],R=!0):E?(k=1,R=!0):L&&N>=0&&(d.strides[T]<0?k=-N:k=N,R=!0),R){let P;k===0||k<0!=d.strides[T]<0?P=0:P=Math.trunc(k/d.strides[T])+(k%d.strides[T]!==0?1:0),y.push(P)}else y.push(-1)}for(let T=0;T<d.finalShapeGatherIndices.length;++T){const E=d.finalShapeGatherIndices[T];E>=0?x.push(y[E]):E===_N&&x.push(1)}return{finalShapeSparse:x.filter((T,E)=>d.finalShapeGatherIndices[E]!==_N),finalShape:x,isIdentity:p,sliceDim0:g,isSimpleSlice:w,begin:d.begin,end:d.end,strides:d.strides}}function Sae(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<s;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(_N),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(xae),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function KP(n,e,t,r,s,i){if(s[e])return t>0?i[e]:i[e+1&1];{const o=n<0?r+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}const _ae=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Gk,computeFlatOffset:Xk,computeOutShape:Hk,getNormalizedAxes:bae,isSliceContinous:jk,maskToAxes:wae,parseSliceParams:_E,sliceInfo:qk,startForAxis:E4,startIndicesWithElidedDims:S4,stopForAxis:C4,stopIndicesWithElidedDims:_4,stridesForAxis:T4,stridesWithElidedDims:x4},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tae{static sgd(e){return new Vk(e)}static momentum(e,t,r=!1){return new y4(e,t,r)}static rmsprop(e,t=.9,r=0,s=null,i=!1){return new v4(e,t,r,s,i)}static adam(e=.001,t=.9,r=.999,s=null){return new m4(e,t,r,s)}static adadelta(e=.001,t=.95,r=null){return new f4(e,t,r)}static adamax(e=.002,t=.9,r=.999,s=null,i=0){return new g4(e,t,r,s,i)}static adagrad(e,t=.1){return new p4(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ug=Tae;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eae=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function I4(){return new Promise(n=>Eae(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kk(n,e){const t=n[0].length;n.forEach((s,i)=>{ie(s.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),ie(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=n[0];n.forEach((s,i)=>{for(let o=0;o<t;o++)ie(o===e||s[o]===r[o],()=>`Error in concat${t}D: Shape of tensors[${i}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${i}.`)})}function Ku(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var lu;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(lu||(lu={}));function N4(n,e,t){let r=new Array;if(t==null&&e==null)return r;if(e==null)for(;r.length<n+t.length;)r.push(-1);else r=e.slice();if(t==null)return r;if(n+t.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${r.length}`);for(let s=1;s<t.length;++s){const i=t[s],o=r[r.length-t.length+s],a=r[o];if(i>=0)if(a>=0){if(a!==i)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+n}] = ${i} but shape[${s+n}] = ${a}`)}else r[o]=i}return r}function A4(n){const e={FIRST_DIM_SIZE:lu.FIRST_DIM_SIZE,VALUE_ROWIDS:lu.VALUE_ROWIDS,ROW_LENGTHS:lu.ROW_LENGTHS,ROW_SPLITS:lu.ROW_SPLITS,ROW_LIMITS:lu.ROW_LIMITS,ROW_STARTS:lu.ROW_STARTS},t=[];for(const r of n)if(r in e)t.push(e[r]);else break;return t}function M4(n){return n.length===0?0:n[0]===lu.FIRST_DIM_SIZE?n.length-1:n.length}function k4(n,e){if(n==null||e==null)return;const t=n.length,r=e.length;if(t>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(t,r-1);++s){const i=n[s],o=e[s+1];if(i>=0&&o>=0&&i!==1&&i!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-n.length}] = ${i} but ragged tensor input.flatValues.shape[${s-n.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yk=30;function TE(n){return n<=Yk?n:oN(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zk(n,e,t){const r=t*(typeof n=="number"?n:n[0]),s=e*(typeof n=="number"?n:n[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rw(n,e,t,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(n[0]/t),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const i=e.length;for(let o=0;o<i;++o)s=s.concat([n[o+1]/e[o],e[o]]);s=s.concat(n.slice(i+1))}return s}function sw(n,e,t=!0){const r=[];if(t){r.push(e);for(let s=e+1;s<n;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],i=[];for(let o=1;o<n;++o)o>=e*2+1||o%2===1?i.push(o):s.push(o);r.push(...s),r.push(0),r.push(...i)}return r}function iw(n,e,t,r=!0){const s=[];r?s.push(n[0]/t):s.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?r?s.push(e[i-1]*n[i]):s.push(n[i]/e[i-1]):s.push(n[i]);return s}function Jk(n,e){const t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function Qk(n,e,t){const r=n.slice(0,1);for(let s=0;s<t;++s)r.push(n[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EE=1.7580993408473768,CE=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eR=.3275911,tR=.254829592,nR=-.284496736,rR=1.421413741,sR=-1.453152027,iR=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ch(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function R4(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function D4(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=0;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function $4(n){const e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let s=2;s<n.length;s+=4)t[Math.floor(s/4)]=n[s],r[Math.floor(s/4)]=n[s+1];return{real:t,imag:r}}function oR(n,e){const t=n[e*2],r=n[e*2+1];return{real:t,imag:r}}function P4(n,e,t,r){n[r*2]=e,n[r*2+1]=t}function L4(n,e){const t=new Float32Array(n/2),r=new Float32Array(n/2);for(let s=0;s<Math.ceil(n/2);s++){const i=(e?2:-2)*Math.PI*(s/n);t[s]=Math.cos(i),r[s]=Math.sin(i)}return{real:t,imag:r}}function O4(n,e,t){const r=(t?2:-2)*Math.PI*(n/e),s=Math.cos(r),i=Math.sin(r);return{real:s,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V2="->",Cae=/->/g,YP=",",ZP="...";function aR(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(Cae,"").length)/V2.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${V2}").`);const[r,s]=n.split(V2);ie(r.indexOf(ZP)===-1,()=>`The ellipsis notation ("${ZP}") is not supported yet.`);const i=r.split(YP),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<s.length;++d){const p=s[d];if(!i.some(g=>g.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);a.indexOf(p)===-1&&a.push(p)}for(let d=0;d<r.length;++d){const p=r[d];a.indexOf(p)===-1&&p!==YP&&a.push(p)}const l=new Array(i.length);for(let d=0;d<o;++d){if(new Set(i[d].split("")).size!==i[d].length)throw new Error(`Found duplicate axes in input component ${i[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<i[d].length;++p)l[d].push(a.indexOf(i[d][p]))}const u=a.length,c=s.length,h=[];for(let d=c;d<u;++d)h.push(d);return{allDims:a,summedDims:h,idDims:l}}function lR(n,e){let t=new Array(n);t.fill(-1);for(let s=0;s<e.length;++s)t[e[s]]=s;const r=[];for(let s=0;s<n;++s)t[s]===-1&&r.push(s);return t=t.filter(s=>s!==-1),{permutationIndices:t,expandDims:r}}function uR(n,e,t){const r=new Array(n);for(let s=0;s<t.length;++s){const i=t[s].shape;for(let o=0;o<e[s].length;++o)r[e[s][o]]===void 0?r[e[s][o]]=i[o]:ie(r[e[s][o]]===i[o],()=>`Expected dimension ${r[e[s][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function cR(n,e){const t=n,r=[];let s=0;n.length===0&&t.push(-1),s=n.length+1;for(let o=0;o<s;++o)r.push([]);const i=[];for(let o=0;o<t.length;++o){const a=t[o],l=Iae(e,a);for(const u of l)i.indexOf(u)===-1&&(r[o].push(u),i.push(u))}return{path:t,steps:r}}function hR(n){return n.every((e,t)=>e===t)}function Iae(n,e){const t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}function dR(n,e,t=0){let r=[];if(typeof e=="number")ie(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{const s=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);ie(s<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[i]=n.shape[t]-o}ie(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F4(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function z4(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function B4(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U4(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function V4(n,e){return`size ${n} must be non-negative, not ${e}`}function W4(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function G4(n,e){const t=Qe(n),r=Qe(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function H4(n,e){const t=Qe(n),r=Qe(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TN(){return"segment ids must be >= 0"}function j4(){return"segment ids are not increasing"}function X4(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function q4(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K4(n,e){let t=!1,r;for(n<=Yk?(r=n,t=!0):r=oN(n,Math.floor(Math.sqrt(n)));!t;)r>e||r===n?t=!0:r=oN(n,r+1);return r}function Y4(n,e,t){const r=[],s=n.length;for(let i=0;i<s;i++)i!==e?r.push(n[i]):r.push(t);return r}function fR(n,e,t,r){const s=e.shape.length,i=n.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>i)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${i}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let h=0;h<r;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=n.shape[t],a=[];let l=1,u=1,c=1;for(let h=0;h<r;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=r;h<t;h++)a.push(n.shape[h]),u*=n.shape[h];for(let h=r;h<s;h++)a.push(e.shape[h]);for(let h=t+1;h<i;h++)a.push(n.shape[h]),c*=n.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:o,outputShape:a}}const Nae=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:fR,computeOutShape:Y4,segOpComputeOptimalWindowSize:K4},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hh(n){try{return n.map(e=>Rd(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Z4(n){return n.map(e=>_d(e))}const Aae=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:tR,ERF_A2:nR,ERF_A3:rR,ERF_A4:sR,ERF_A5:iR,ERF_P:eR,PARALLELIZE_THRESHOLD:Yk,get RowPartitionType(){return lu},SELU_SCALE:CE,SELU_SCALEALPHA:EE,applyActivation:Lk,assertAndGetBroadcastShape:$n,assertAxesAreInnerMostDims:Li,assertParamsConsistent:Kk,assignToTypedArray:P4,axesAreInnerMostDims:wk,calculateShapes:hm,checkEinsumDimSizes:uR,checkPadOnDimRoundingMode:Qo,combineLocations:WU,combineRaggedTensorToTensorShapes:N4,complexWithEvenIndex:D4,complexWithOddIndex:$4,computeConv2DInfo:Pi,computeConv3DInfo:Zd,computeDefaultPad:fk,computeDilation2DInfo:J1,computeOptimalWindowSize:TE,computeOutAndReduceShapes:_i,computeOutShape:Ku,computePool2DInfo:El,computePool3DInfo:vh,convertConv2DDataFormat:xh,decodeEinsumEquation:aR,eitherStridesOrDilationsAreOne:Ji,expandShapeToKeepDim:Vs,exponent:O4,exponents:L4,fromStringArrayToUint8:Z4,fromUint8ToStringArray:hh,getAxesPermutation:ps,getBroadcastDims:Ty,getComplexWithIndex:oR,getEinsumComputePath:cR,getEinsumPermutation:lR,getFusedBiasGradient:Pk,getFusedDyActivation:$k,getImageCenter:Zk,getInnerMostAxes:Ms,getPermuted:sw,getRaggedRank:M4,getReductionAxes:ri,getReshaped:rw,getReshapedPermuted:iw,getRowPartitionTypesHelper:A4,getSliceBeginCoords:Jk,getSliceSize:Qk,getSparseFillEmptyRowsIndicesDenseShapeMismatch:F4,getSparseFillEmptyRowsNegativeIndexErrorMessage:z4,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:B4,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:W4,getSparseReshapeInputOutputMismatchErrorMessage:H4,getSparseReshapeInputOutputMultipleErrorMessage:G4,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:U4,getSparseReshapeNegativeOutputDimErrorMessage:V4,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:q4,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:TN,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:j4,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:X4,getUndoAxesPermutation:Jd,isIdentityPermutation:hR,log:lte,mergeRealAndImagArrays:ch,prepareAndValidate:Wk,prepareSplitSize:dR,segment_util:Nae,shouldFuse:Ok,slice_util:_ae,splitRealAndImagArrays:R4,stridesOrDilationsArePositive:Gp,tupleValuesAreOne:Wp,upcastType:_a,validateDefaultValueShape:k4,validateInput:ooe,validateUpdateShape:a4,warn:Wa},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */vae();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J4={kernelName:pT,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ae(n,nw(Ot(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mae={kernelName:n1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=Qr(Ot(t,"float32")),s=Eo(yn(Sr(1),r));return Is(hn(n,s))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kae={kernelName:r1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=Eo(yn(Qr(Ot(t,"float32")),1));return hn(n,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rae={kernelName:qy,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=$n(t.shape,r.shape);return{a:()=>{let a=n;const l=ri(t.shape,s);return l.length>0&&(a=an(a,l)),$e(a,t.shape)},b:()=>{let a=n;const l=ri(r.shape,s);return l.length>0&&(a=an(a,l)),$e(a,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dae={kernelName:_M,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((r,s)=>{t[s]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ae={kernelName:mT,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>or(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pae={kernelName:gT,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>or(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lae={kernelName:s1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>hn(n,Eo(yn(Sr(1),Qr(Ot(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oae={kernelName:i1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=Eo(xt(Sr(1),Qr(Ot(t,"float32"))));return hn(n,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fae={kernelName:l1,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=$n(t.shape,r.shape);return{a:()=>{const a=xt(Qr(t),Qr(r));let l=Ae(n,hn(r,a));const u=ri(t.shape,s);return u.length>0&&(l=an(l,u)),$e(l,t.shape)},b:()=>{const a=xt(Qr(t),Qr(r));let l=Is(Ae(n,hn(t,a)));const u=ri(r.shape,s);return u.length>0&&(l=an(l,u)),$e(l,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zae={kernelName:o1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>hn(n,xt(Qr(Ot(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bae={kernelName:a1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>hn(n,yn(Sr(1),Qr(Ot(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uae(n,e,t,r,s,i){const o=ge(n,"dy","avgPool3dGrad"),a=ge(e,"input","avgPool3dGrad");let l=o,u=a,c=!1;a.rank===4&&(c=!0,l=$e(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=$e(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),ie(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),ie(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Qo("avgPool3dGrad",s,i);const h={dy:l,input:u},d={filterSize:t,strides:r,pad:s,dimRoundingMode:i},p=Me.runKernel(IM,h,d);return c?$e(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Vae=Pe({avgPool3dGrad_:Uae});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wae={kernelName:vT,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:s,strides:i,pad:o,dimRoundingMode:a}=t;return{x:()=>Vae(n,r,s,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gae(n,e,t,r,s){const i=ge(n,"dy","avgPoolGrad"),o=ge(e,"input","avgPoolGrad");ie(o.rank===i.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${i.rank})`);let a=o,l=i,u=!1;o.rank===3&&(u=!0,a=$e(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=$e(i,[1,i.shape[0],i.shape[1],i.shape[2]])),ie(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),ie(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const c={dy:l,input:a},h={filterSize:t,strides:r,pad:s},d=Me.runKernel(CM,c,h);return u?$e(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Hae=Pe({avgPoolGrad_:Gae});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jae={kernelName:yT,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:s,strides:i,pad:o}=t;return{x:()=>Hae(n,r,s,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xae={kernelName:xT,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[r,s]=e,{transposeA:i,transposeB:o}=t;return!i&&!o?{a:()=>wr(n,s,!1,!0),b:()=>wr(r,n,!0,!1)}:!i&&o?{a:()=>wr(n,s,!1,!1),b:()=>wr(n,r,!0,!1)}:i&&!o?{a:()=>wr(s,n,!1,!0),b:()=>wr(r,n,!1,!1)}:{a:()=>wr(s,n,!0,!0),b:()=>wr(n,r,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qae={kernelName:wT,gradFunc:(n,e,t)=>{const{blockShape:r,crops:s}=t;return{x:()=>Nk(n,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kae={kernelName:ste,gradFunc:(n,e,t)=>{const r=t,s=r.inputShape,i=r.shape,o=Array.from(i);for(let l=s.length-1;l>=0;l--)if(s[l]===i[l])o[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${i}].`);const a=[];for(let l=0;l<o.length;l++)o[l]>1&&a.push(l);return{x:()=>an(n,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yae={kernelName:u1,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zae={kernelName:c1,gradFunc:n=>({x:()=>or(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jae={kernelName:h1,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{clipValueMin:s,clipValueMax:i}=t;return{x:()=>_o(lh(um(r,s),Yy(r,i)),n,or(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qae={kernelName:bT,inputsToSave:["x"],gradFunc:J4.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ele={kernelName:ST,saveAllInputs:!0,gradFunc:(n,e,t)=>{const r=e.map(l=>l.shape),{axis:s}=t,i=qn(s,e[0].shape)[0],o=r.map(l=>l[i]);return ja(n,o,i).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tle={kernelName:_T,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,{dilations:i,strides:o,pad:a,dataFormat:l}=t;return ie(Wp(i),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`),{x:()=>yk(r.shape,n,s,o,a,l),filter:()=>Dk(r,n,s.shape,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nle={kernelName:TT,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,{strides:i,pad:o,dataFormat:a,dimRoundingMode:l}=t;return{dy:()=>Hp(n,s,i,o,a,1,l),filter:()=>Dk(n,r,s.shape,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rle(n,e,t,r,s){let i=n;n.rank===4&&(i=$e(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=e;o.rank===4&&(o=$e(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),ie(i.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`),ie(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),ie(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),ie(i.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${t[3]}.`),ie(o.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${t[4]}).`);const a={x:i,dy:o},l={strides:r,pad:s,filterShape:t};return Me.runKernel(RM,a,l)}const sle=Pe({conv3DBackpropFilter_:rle});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ile={kernelName:ET,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:s,pad:i}=t;ie(Wp(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,a]=e;return{x:()=>BU(o.shape,n,a,s,i),filter:()=>sle(o,n,a.shape,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ole={kernelName:d1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ae(Is(r4(Ot(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ale={kernelName:f1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ae(s4(Ot(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lle={kernelName:CT,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s,exclusive:i,reverse:o}=t;return{x:()=>{const a=ps([s],r.rank);let l=VU(n,s,i,!o);return a!=null&&(l=ir(l,a)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ule={kernelName:IT,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:s,pad:i,dimRoundingMode:o}=t,a=r??[1,1];ie(Wp(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[l,u]=e;return ie(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),ie(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),ie(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),ie(Ji(s,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${a}'.`),Qo("depthwiseConv2d",i,o),{x:()=>Eoe(l.shape,n,u,s,i,a,o),filter:()=>_oe(l,n,u.shape,s,i,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cle={kernelName:NT,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,s]=e,i={x:r,filter:s,dy:n},o={x:r,filter:s,dy:n};return{x:()=>Me.runKernel(aN,i,t),filter:()=>Me.runKernel(lN,o,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hle={kernelName:m1,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,r={dy:n,y:t};return{x:()=>Me.runKernel(UM,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dle={kernelName:g1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=Ae(rc(Is(Qr(t))),2/Math.sqrt(Math.PI));return{x:()=>Ae(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fle={kernelName:y1,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ae(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ple={kernelName:MT,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>$e(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mle={kernelName:v1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ae(n,rc(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gle={kernelName:x1,gradFunc:n=>({x:()=>or(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yle={kernelName:w1,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=$n(t.shape,r.shape);return{a:()=>{const a=hn(n,Ot(r,"float32")),l=ri(t.shape,s);return l.length>0?$e(an(a,l),t.shape):a},b:()=>{let a=Ae(n,Ot(t,"float32"));const l=ri(r.shape,s);l.length>0&&(a=$e(an(a,l),r.shape));const u=Qr(r);return Is(hn(a,Ot(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vle={kernelName:kT,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:r}=t,[s,i,o,a]=e,l=a??Sr(1),u=ri(i.shape,s.shape),c=[];if(i.rank===1){for(let E=0;E<s.shape.length-1;++E)c.push(s.shape[E]);c.push(1)}const h=yn(s,i),d=Ae(n,l),p=e4(xt(o,Sr(r))),g=Ae(Ae(Ae(p,p),p),Sr(-.5));return{x:()=>i.rank===1?$e(Ae(Ae(n,hu($e(p,[1,1,1,i.shape[0]]),c)),l),s.shape):$e(Ae(Ae(n,p),l),s.shape),mean:()=>{let E=Ae(Ae(p,Sr(-1)),d);return i.rank===1&&(E=an(E,u)),$e(E,i.shape)},variance:()=>{let E=Ae(Ae(g,h),d);return i.rank===1&&(E=an(E,u)),$e(E,i.shape)},scale:()=>{const E=Ae(h,p);let N=Ae(n,E);return i.rank===1&&(N=an(N,u)),$e(N,i.shape)},offset:()=>{let E=n;return i.rank===1&&(E=an(E,u)),$e(E,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xle={kernelName:RT,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[r,s]=e,{axis:i,batchDims:o}=t,a=qn(i,r.shape)[0],l=(u,c,h)=>()=>{const d=u.shape,p=c.size,g=d.slice(0,a),w=g.length,y=d.slice(i,d.length).slice(1),x=y.length,_=JP(0,w),T=JP(w+1,w+1+x),E=QP([g,[p],y]),N=$e(h,E),M=$e(c,[p]),$=QP([[w],_,T]),L=ir(N,$);let k=u4(L,M,u.shape[a]);const R=Jd($);return k=ir(k,R),k};if(o===1){const u=r.shape[0],c=r.split(u,0);return{x:()=>uh(c.map((p,g)=>l(p,s.slice(g,1),n.slice(g,1))())).reshape(r.shape),indices:()=>s}}else return{x:l(r,s,n),indices:()=>s}}};function JP(n,e){const t=[];for(let r=n;r<e;++r)t.push(r);return t}function QP(n){const e=[];for(let t=0;t<n.length;++t)for(let r=0;r<n[t].length;++r)e.push(n[t][r]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wle={kernelName:b1,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>or(t),b:()=>or(r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ble={kernelName:S1,gradFunc:n=>({x:()=>Ot(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sle={kernelName:_1,gradFunc:n=>({x:()=>or(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _le={kernelName:T1,gradFunc:n=>({x:()=>or(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tle={kernelName:E1,gradFunc:n=>({x:()=>or(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ele={kernelName:$T,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{alpha:s}=t,i=Ya(r,0);return{x:()=>_o(i,n,Ae(n,s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cle={kernelName:I1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>hn(n,xt(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ile={kernelName:C1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>hn(n,Ot(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nle={kernelName:ote,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t;return{logits:()=>{const o=rc(r);return yn(n,Ae(an(n,s,!0),o))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ale(n,e,t,r=5,s=1,i=1,o=.5){const a={x:n,y:e,dy:t},l={depthRadius:r,bias:s,alpha:i,beta:o};return Me.runKernel(XM,a,l)}const Mle=Pe({localResponseNormalizationBackprop_:Ale});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kle={kernelName:BT,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{depthRadius:i,bias:o,alpha:a,beta:l}=t;return{x:()=>Mle(r,s,n,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q4(n,e,t,r){return e.rank<t.rank&&(e=$e(e,Vs(e.shape,r))),n.rank<t.rank&&(n=$e(n,Vs(n.shape,r))),{x:()=>Ae(n,Ot(nc(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eL={kernelName:UT,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{reductionIndices:s}=r,i=e[0],o=e[1],a=qn(s,i.shape),l=Q4(n,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rle={kernelName:N1,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>Ae(n,Ot(um(t,r),"float32")),b:()=>Ae(n,Ot(o_(t,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dle(n,e,t,r,s,i,o){const a=ge(n,"dy","maxPool3dGrad"),l=ge(e,"input","maxPool3dGrad"),u=ge(t,"output","maxPool3dGrad");let c=a,h=l,d=u,p=!1;l.rank===4&&(p=!0,c=$e(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=$e(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=$e(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),ie(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),ie(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),ie(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),Qo("maxPool3dGrad",i,o);const g={dy:c,input:h,output:d},w={filterSize:r,strides:s,pad:i,dimRoundingMode:o},y=Me.runKernel(KM,g,w);return p?$e(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const $le=Pe({maxPool3dGrad_:Dle});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ple={kernelName:WT,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=t;return{x:()=>$le(n,r,s,i,o,a,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lle(n,e,t,r,s,i,o){const a=ge(n,"dy","maxPoolGrad"),l=ge(e,"input","maxPoolGrad"),u=ge(t,"output","maxPoolGrad");ie(l.rank===a.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${a.rank})`),ie(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),ie(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Qo("maxPoolGrad",i,o);const c={dy:a,input:l,output:u},h={filterSize:r,strides:s,pad:i,dimRoundingMode:o};return Me.runKernel(qM,c,h)}const Ole=Pe({maxPoolGrad_:Lle});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fle={kernelName:VT,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,s]=e,{filterSize:i,strides:o,pad:a}=t;return{x:()=>Ole(n,r,s,i,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zle={kernelName:GT,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t,i=qn(s,r.shape),a=_i(r.shape,i)[1],l=Qe(a);return{x:()=>{const c=r.shape.slice();i.forEach(p=>{c[p]=1});const h=$e(n,c);return hn(Ae(h,ef(r.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ble={kernelName:HT,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{axis:s}=r,[i,o]=e,a=qn(s,i.shape),l=Q4(n,o,i,a);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ule={kernelName:A1,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>Ae(n,Ot(Yy(t,r),"float32")),b:()=>Ae(n,Ot(Ya(t,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vle={kernelName:jT,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:s}=t,i=s.map(o=>o[0]);return{x:()=>Xr(n,i,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wle={kernelName:M1,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=$n(t.shape,r.shape);return{a:()=>{const a=ri(t.shape,s);return a.length>0?$e(an(n,a),t.shape):n},b:()=>{const a=Ae(n,Is(SE(hn(t,r)))),l=ri(r.shape,s);return l.length>0?$e(an(a,l),r.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gle={kernelName:k1,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=$n(t.shape,r.shape);return{a:()=>{const a=Ae(n,Ot(r,"float32")),l=ri(t.shape,s);return l.length>0?$e(an(a,l),t.shape):a},b:()=>{const a=Ae(n,Ot(t,"float32")),l=ri(r.shape,s);return l.length>0?$e(an(a,l),r.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hle={kernelName:XT,gradFunc:n=>({x:()=>Is(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jle={kernelName:YT,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>gi(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xle={kernelName:KT,gradFunc:n=>({x:()=>or(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qle={kernelName:ZT,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:r}=t;return Xp(n,r).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tL={kernelName:JT,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:s}=t,i=s.map(o=>o[0]);return{x:()=>Xr(n,i,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kle={kernelName:R1,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,r,s]=e,i=t,o=r,a=$n(i.shape,o.shape);return{a:()=>{const c=Ot(o,"float32");let h=Ae(n,Ae(c,Ey(i,yn(c,Sr(1)))));const d=ri(i.shape,a);return d.length>0&&(h=an(h,d)),$e(h,i.shape)},b:()=>{const c=Ya(i,0),h=_o(c,sc(i),or(i));let d=Ae(n,Ae(s,h));const p=ri(o.shape,a);return p.length>0&&(d=an(d,p)),$e(d,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yle={kernelName:QT,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,r]=e,s=Ya(t,0);return{x:()=>_o(s,n,Ae(n,r)),alpha:()=>{let i=_o(s,or(n),Ae(n,t));const o=ri(r.shape,n.shape);return o.length>0&&(i=an(i,o)),$e(i,r.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zle(n,e,t){const r=n.shape.slice();r[t]=1;const s=$e(e,r),i=bN(n,t,!0,!1),o=bN(n,t,!0,!0),a=Ae(i,o);return Ae(s,a)}function Jle(n,e,t){const r=n.shape.length,s=r-t.length,i=ps(t,r);let o=n;i!=null&&(o=ir(n,i));const a=o.shape.slice(),u=a.splice(r-t.length,t.length).reduce((d,p)=>d*p,1);a.push(u);const c=o.reshape(a);let h=Zle(c,e,s);if(h=h.reshape(o.shape),i!=null){const d=Jd(i);h=ir(h,d)}return h}const Qle={kernelName:eE,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:s}=t;let i=[];return s==null?i=r.shape.map((o,a)=>a):typeof s=="number"?i=[s]:i=s,{x:()=>Jle(r,n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eue={kernelName:p1,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=$n(t.shape,r.shape);return{a:()=>{const a=hn(n,Ot(r,"float32")),l=ri(t.shape,s);return l.length>0?$e(an(a,l),t.shape):a},b:()=>{let a=Ae(n,Ot(t,"float32"));const l=ri(r.shape,s);l.length>0&&(a=$e(an(a,l),r.shape));const u=Qr(r);return Is(hn(a,Ot(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tue={kernelName:D1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>hn(n,Is(Qr(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nue={kernelName:P1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=Ae(Yy(t,6),nw(t));return{x:()=>Ae(n,Ot(r,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rue={kernelName:$1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ae(n,Ot(nw(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sue={kernelName:tE,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>$e(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iue={kernelName:rE,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,s={dy:n,images:r};return{images:()=>Me.runKernel(nk,s,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oue={kernelName:nE,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,s={dy:n,images:r};return{images:()=>Me.runKernel(tk,s,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aue={kernelName:sE,gradFunc:(n,e,t)=>{const{dims:r}=t,s=qn(r,n.shape);return{x:()=>jp(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lue={kernelName:L1,gradFunc:n=>({x:()=>or(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uue={kernelName:O1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Is(hn(n,Ae(Ey(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cue={kernelName:iE,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Ot(or(t),"float32"),t:()=>Ae(n,Ot(t,n.dtype)),e:()=>Ae(n,Ot(Tk(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hue={kernelName:F1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=Ya(t,Sr(0)),s=Sr(EE),i=Sr(CE),o=Ae(n,i),a=Ae(Ae(n,s),rc(Ot(t,"float32")));return _o(r,o,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const due={kernelName:V1,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ae(n,Ae(t,yn(Sr(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fue={kernelName:U1,gradFunc:n=>({x:()=>or(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pue={kernelName:z1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ae(vk(Ot(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mue={kernelName:B1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ae(UU(Ot(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gue={kernelName:oE,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{begin:s,size:i}=t,o=r.shape,[a,l]=_E(r,s,i),u=[];for(let c=0;c<n.rank;c++)u.push([a[c],o[c]-a[c]-l[c]]);return{x:()=>Ik(n,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yue={kernelName:cE,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{dim:s}=t,i=!0,o=Ae(n,r);return{logits:()=>yn(o,Ae(an(o,[s],i),r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vue={kernelName:W1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ae(n,Ky(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nL={kernelName:lE,gradFunc:(n,e,t)=>{const{blockShape:r,paddings:s}=t;return{x:()=>gk(n,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rL={kernelName:uE,gradFunc:(n,e,t)=>{const{axis:r}=t;return{x:()=>Xo(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xue={kernelName:G1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>hn(n,Ae(Eo(Ot(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wue={kernelName:rk,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ae(n,Ae(Ot(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bue={kernelName:H1,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=Sr(2);return{a:()=>Ae(n,Ae(s,yn(t,r))),b:()=>Ae(n,Ae(s,yn(r,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sue={kernelName:Y1,gradFunc:n=>({x:()=>or(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ue={kernelName:j1,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,s=$n(t.shape,r.shape);return{a:()=>{let a=n;const l=ri(t.shape,s);return l.length>0&&(a=an(a,l)),$e(a,t.shape)},b:()=>{let a=n;const l=ri(r.shape,s);return l.length>0&&(a=an(a,l)),$e(Is(a),r.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tue={kernelName:aE,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,s=r.shape.slice(),{axis:i}=t;qn(i,r.shape).forEach(u=>{s[u]=1});const a=$e(n,s),l=Ae(a,ef(r.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eue={kernelName:X1,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>hn(n,Qr(vk(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cue={kernelName:q1,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ae(yn(Sr(1),Qr(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iue={kernelName:K1,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{reps:s}=t;return{x:()=>{let o=or(r);if(r.rank===1)for(let a=0;a<s[0];++a)o=xt(o,Xr(n,[a*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)o=xt(o,Xr(n,[a*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)o=xt(o,Xr(n,[a*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let a=0;a<s[0];++a)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)o=xt(o,Xr(n,[a*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nue={kernelName:ly,gradFunc:(n,e,t)=>{const r=t,{perm:s}=r,i=Jd(s);return{x:()=>ir(n,i)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aue={kernelName:hE,gradFunc:(n,e,t)=>{const r=t,{axis:s}=r;return{value:()=>uh(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mue={kernelName:dE,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>kue(n,t)}}};function kue(n,e){const t=Qd(e,or(e)),r=bk(n,t);let s=um(e,Sr(0,"int32"));const i=r.rank-s.rank;for(let a=0;a<i;++a)s=Uo(s,a+1);s=lh(s,ef(r.shape,"bool"));const o=or(r);return _o(s,r,o)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rue={kernelName:fE,gradFunc:n=>({x:()=>or(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Due=[J4,Mae,kae,Rae,Dae,$ae,Pae,Lae,Oae,Fae,zae,Bae,Wae,jae,Xae,qae,Kae,Yae,Zae,Jae,Qae,ele,nle,tle,ile,ole,ale,lle,ule,cle,eue,hle,dle,fle,ple,mle,yle,gle,vle,xle,wle,ble,Sle,_le,Tle,Ele,Cle,Ile,Nle,kle,eL,eL,Rle,Ple,Fle,zle,Ble,Ule,Vle,Wle,Gle,Hle,jle,Xle,qle,tL,tL,Kle,Yle,Qle,tue,nue,rue,sue,iue,oue,aue,lue,uue,cue,hue,due,fue,pue,mue,gue,yue,vue,nL,nL,rL,rL,xue,bue,wue,Sue,_ue,Tue,Eue,Cue,Iue,Nue,Aue,Mue,Rue];for(const n of Due)ute(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.abs=function(){return this.throwIfDisposed(),ho(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.acos=function(){return this.throwIfDisposed(),dne(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.acosh=function(){return this.throwIfDisposed(),pne(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.add=function(n){return this.throwIfDisposed(),xt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.all=function(n,e){return this.throwIfDisposed(),OU(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.any=function(n,e){return this.throwIfDisposed(),xN(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.argMax=function(n){return this.throwIfDisposed(),vx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.argMin=function(n){return this.throwIfDisposed(),xne(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.asScalar=function(){return this.throwIfDisposed(),ie(this.size===1,()=>"The array must have only 1 element."),$e(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.asType=function(n){return this.throwIfDisposed(),Ot(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.as1D=function(){return this.throwIfDisposed(),$e(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.as2D=function(n,e){return this.throwIfDisposed(),$e(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),$e(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.as4D=function(n,e,t,r){return this.throwIfDisposed(),$e(this,[n,e,t,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.as5D=function(n,e,t,r,s){return this.throwIfDisposed(),$e(this,[n,e,t,r,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.asin=function(){return this.throwIfDisposed(),bne(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.asinh=function(){return this.throwIfDisposed(),_ne(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.atan=function(){return this.throwIfDisposed(),Ene(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.atan2=function(n){return this.throwIfDisposed(),Ine(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.atanh=function(){return this.throwIfDisposed(),Ane(this)};Je().prototype.avgPool=function(n,e,t,r){return this.throwIfDisposed(),pk(this,n,e,t,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),gk(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.batchNorm=function(n,e,t,r,s){return this.throwIfDisposed(),vE(this,n,e,t,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Xv(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.cast=function(n){return this.throwIfDisposed(),Ot(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.ceil=function(){return this.throwIfDisposed(),nre(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),qa(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof Zs&&(n=[n]),Xo([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.conv1d=function(n,e,t,r,s,i){return this.throwIfDisposed(),FU(this,n,e,t,r,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.conv2dTranspose=function(n,e,t,r,s){return this.throwIfDisposed(),zU(this,n,e,t,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.conv2d=function(n,e,t,r,s,i){return this.throwIfDisposed(),Hp(this,n,e,t,r,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.cos=function(){return this.throwIfDisposed(),vk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.cosh=function(){return this.throwIfDisposed(),UU(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),bN(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),VU(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),Ire(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.depthwiseConv2d=function(n,e,t,r,s,i){return this.throwIfDisposed(),xk(this,n,e,t,r,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.dilation2d=function(n,e,t,r,s){return this.throwIfDisposed(),Mre(this,n,e,t,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.divNoNan=function(n){return this.throwIfDisposed(),Pre(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.div=function(n){return this.throwIfDisposed(),hn(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.dot=function(n){return this.throwIfDisposed(),Ore(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.elu=function(){return this.throwIfDisposed(),wE(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.equal=function(n){return this.throwIfDisposed(),nc(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.erf=function(){return this.throwIfDisposed(),Ure(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),Yre(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.exp=function(){return this.throwIfDisposed(),rc(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.expandDims=function(n){return this.throwIfDisposed(),Uo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.expm1=function(){return this.throwIfDisposed(),ese(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.fft=function(){return this.throwIfDisposed(),o4(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.flatten=function(){return this.throwIfDisposed(),$e(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.floor=function(){return this.throwIfDisposed(),SE(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.floorDiv=function(n){return this.throwIfDisposed(),LU(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.gather=function(n,e,t){return this.throwIfDisposed(),bk(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.greaterEqual=function(n){return this.throwIfDisposed(),um(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.greater=function(n){return this.throwIfDisposed(),Ya(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.ifft=function(){return this.throwIfDisposed(),SN(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.irfft=function(){return this.throwIfDisposed(),Xie(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.isFinite=function(){return this.throwIfDisposed(),use(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.isInf=function(){return this.throwIfDisposed(),hse(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.isNaN=function(){return this.throwIfDisposed(),fse(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.leakyRelu=function(n){return this.throwIfDisposed(),_k(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.lessEqual=function(n){return this.throwIfDisposed(),Yy(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.less=function(n){return this.throwIfDisposed(),o_(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.localResponseNormalization=function(n,e,t,r){return this.throwIfDisposed(),vse(this,n,e,t,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.logSigmoid=function(){return this.throwIfDisposed(),Ese(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.logSoftmax=function(n){return this.throwIfDisposed(),XU(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),qU(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.log=function(){return this.throwIfDisposed(),sc(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.log1p=function(){return this.throwIfDisposed(),jU(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.logicalAnd=function(n){return this.throwIfDisposed(),lh(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.logicalNot=function(){return this.throwIfDisposed(),Tk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.logicalOr=function(n){return this.throwIfDisposed(),KU(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.logicalXor=function(n){return this.throwIfDisposed(),Dse(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),wr(this,n,e,t)};Je().prototype.maxPool=function(n,e,t,r){return this.throwIfDisposed(),Ek(this,n,e,t,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.max=function(n,e){return this.throwIfDisposed(),fu(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.maximum=function(n){return this.throwIfDisposed(),Qd(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.mean=function(n,e){return this.throwIfDisposed(),Fs(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.min=function(n,e){return this.throwIfDisposed(),i_(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.minimum=function(n){return this.throwIfDisposed(),bx(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),Use(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.mod=function(n){return this.throwIfDisposed(),Wse(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.mul=function(n){return this.throwIfDisposed(),Ae(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.neg=function(){return this.throwIfDisposed(),Is(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.norm=function(n,e,t){return this.throwIfDisposed(),bE(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.notEqual=function(n){return this.throwIfDisposed(),a_(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),YU(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.onesLike=function(){return this.throwIfDisposed(),Sl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.pad=function(n,e){return this.throwIfDisposed(),Ik(this,n,e)};Je().prototype.pool=function(n,e,t,r,s,i){return this.throwIfDisposed(),Qse(this,n,e,t,r,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.pow=function(n){return this.throwIfDisposed(),Ey(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.prelu=function(n){return this.throwIfDisposed(),Ak(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.prod=function(n,e){return this.throwIfDisposed(),nie(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.reciprocal=function(){return this.throwIfDisposed(),Iie(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.relu=function(){return this.throwIfDisposed(),cm(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.relu6=function(){return this.throwIfDisposed(),JU(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.reshapeAs=function(n){return this.throwIfDisposed(),$e(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.reshape=function(n){return this.throwIfDisposed(),$e(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),h4(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),d4(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.reverse=function(n){return this.throwIfDisposed(),jp(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.rfft=function(){return this.throwIfDisposed(),Yie(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.round=function(){return this.throwIfDisposed(),QU(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.rsqrt=function(){return this.throwIfDisposed(),e4(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.selu=function(){return this.throwIfDisposed(),t4(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.separableConv2d=function(n,e,t,r,s,i){return this.throwIfDisposed(),n4(this,n,e,t,r,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.sigmoid=function(){return this.throwIfDisposed(),Ky(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.sign=function(){return this.throwIfDisposed(),Lie(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.sin=function(){return this.throwIfDisposed(),r4(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.sinh=function(){return this.throwIfDisposed(),s4(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.slice=function(n,e){return this.throwIfDisposed(),Xr(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.softmax=function(n){return this.throwIfDisposed(),Rk(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.softplus=function(){return this.throwIfDisposed(),Q1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),Nk(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.split=function(n,e){return this.throwIfDisposed(),ja(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.sqrt=function(){return this.throwIfDisposed(),Eo(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.square=function(){return this.throwIfDisposed(),Qr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.squaredDifference=function(n){return this.throwIfDisposed(),Jie(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.squeeze=function(n){return this.throwIfDisposed(),tw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof Zs?[this,n]:[this,...n];return uh(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.step=function(n){return this.throwIfDisposed(),nw(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.stridedSlice=function(n,e,t,r,s,i,o,a){return this.throwIfDisposed(),roe(this,n,e,t,r,s,i,o,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.sub=function(n){return this.throwIfDisposed(),yn(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.sum=function(n,e){return this.throwIfDisposed(),an(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.tan=function(){return this.throwIfDisposed(),ioe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.tanh=function(){return this.throwIfDisposed(),mk(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.tile=function(n){return this.throwIfDisposed(),hu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.toBool=function(){return this.throwIfDisposed(),Ot(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.toFloat=function(){return this.throwIfDisposed(),Ot(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.toInt=function(){return this.throwIfDisposed(),Ot(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.topk=function(n,e){return this.throwIfDisposed(),loe(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.transpose=function(n){return this.throwIfDisposed(),ir(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.unique=function(n){return this.throwIfDisposed(),hoe(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),u4(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.unstack=function(n){return this.throwIfDisposed(),Xp(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.where=function(n,e){return this.throwIfDisposed(),_o(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Je().prototype.zerosLike=function(){return this.throwIfDisposed(),or(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class zu extends Error{constructor(e){super(e),Object.setPrototypeOf(this,zu.prototype)}}class yl extends Error{constructor(e){super(e),Object.setPrototypeOf(this,yl.prototype)}}class Ce extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ce.prototype)}}class Fn extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Fn.prototype)}}class pR extends Error{constructor(e){super(e),Object.setPrototypeOf(this,pR.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class eV{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qp(n,e){if(Array.isArray(n)){let t=[];for(let r=0;r<e;r++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function Bu(n,e){if(!n)throw new pR(e)}function sL(n,e){let t=0;for(const r of n)r===e&&t++;return t}function Vo(n){return n.length===1?n[0]:n}function Ar(n){return Array.isArray(n)?n:[n]}function qc(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function dp(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let dl={};function mR(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function EN(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>EN(e));else{const e=Object.keys(n);for(const t of e){const r=n[t];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?n[t]=r.value:EN(r))}}}function ow(n,e={},t={},r="object",s=!1){if(typeof n=="string"){const i=n;let o;if(i in t)o=t[i];else if(i in dl)o=dl[i];else if(o=e[i],o==null)throw new Ce(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const i=n;if(i.className==null||i.config==null)throw new Ce(`${r}: Improper config format: ${JSON.stringify(i)}.
'className' and 'config' must set.`);const o=i.className;let a,l;if(o in t?[a,l]=t[o]:o in dl?[a,l]=dl.className:o in e&&([a,l]=e[o]),a==null)throw new Ce(`Unknown ${r}: ${o}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const p of Object.keys(dl))u[p]=dl[p];for(const p of Object.keys(t))u[p]=t[p];const c=i.config;c.customObjects=u;const h=Object.assign({},dl);for(const p of Object.keys(t))dl[p]=t[p];EN(i.config);const d=l(a,i.config,t,s);return dl=Object.assign({},h),d}else{const u=Object.assign({},dl);for(const h of Object.keys(t))dl[h]=t[h];const c=new a(i.config);return dl=Object.assign({},u),c}}}function $ue(n,e){return n<e?-1:n>e?1:0}function cS(n,e){return-1*$ue(n,e)}function Td(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function Pue(n){if(n==null)throw new Ce(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function dm(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new Ce(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function gR(n,e,t=0,r=1/0){return Bu(t>=0),Bu(r>=t),Array.isArray(n)&&n.length>=t&&n.length<=r&&n.every(s=>typeof s===e)}function vi(n,e){Array.isArray(n)?(ie(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,r)=>vi(t,`element ${r+1} of ${e}`))):ie(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${tV(n)}.`)}function tV(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>tV(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function Lue(n,e,t){let r=t!=null?t():Bo(),s;return(...o)=>{const a=t!=null?t():Bo();return a-r<e||(r=a,s=n(...o)),s}}function nV(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Oue=0;function rV(){return Oue++}const hS={};function IE(n=""){return n in hS||(hS[n]=0),hS[n]+=1,n+hS[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Fue=["channelsFirst","channelsLast"],zue=["nearest","bilinear"],Bue=["valid","same","causal"],Uue=["max","avg"],Vue=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Vg=new Map;function ks(n){dm(Fue,"DataFormat",n)}function Wue(n){dm(zue,"InterpolationFormat",n)}function Za(n){dm(Bue,"PaddingMode",n)}function sV(n){dm(Uue,"PoolMode",n)}const qv=[],iL="/";function Rp(n,e){qv.push(n);try{const t=e();return qv.pop(),t}catch(t){throw qv.pop(),t}}function Gue(){return qv.length===0?"":qv.join(iL)+iL}function iV(n){if(!aV(n))throw new Error("Not a valid tensor name: '"+n+"'");return Gue()+n}function oV(n){if(!aV(n))throw new Error("Not a valid tensor name: '"+n+"'");Vg.has(n)||Vg.set(n,0);const e=Vg.get(n);if(Vg.set(n,Vg.get(n)+1),e>0){const t=`${n}_${e}`;return Vg.set(t,1),t}else return n}const Hue=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function aV(n){return!!n.match(Hue)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function jue(n){return n===parseInt(n.toString(),10)}function Ed(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let r=1;for(let s=e;s<t;++s)r*=n[s];return r}function Iy(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r<e&&(e=r)}return e}function Dd(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r>e&&(e=r)}return e}function gu(n,e){if(e<n)throw new Ce(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let r=n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let W2;function Js(){return W2==null&&(W2=Lte().epsilon()),W2}function yu(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Yu(n,e){return Ot(n,e)}function aw(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),$e(n,t)}function Xue(n,e){return ze(()=>{if(n.shape.length!==2)throw new Ce(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=aw(n,1);return CN(t,[1,e,1])})}function que(n){const e=[Ed(n.shape)];return $e(n,e)}function Kue(n){if(n.rank<=1)throw new Ce(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Ed(n.shape,1)];return $e(n,e)}function Dp(n,e,t){return ze(()=>{switch(n.rank){case 1:return Mk(n,e,t);case 2:return i4(n,[e,0],[t,n.shape[1]]);case 3:return kk(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return u_(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Xr(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Xr(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new Ce(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function G2(n,e,t){return ze(()=>{switch(n.rank){case 1:return Mk(n,e,t);case 2:return i4(n,[0,e],[n.shape[0],t]);case 3:return kk(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return u_(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new Ce(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function dS(n,e,t,r){return ze(()=>{switch(n.rank){case 1:return Mk(n,e,t);case 2:switch(r){case 1:return Dp(n,e,t);case 2:return G2(n,e,t);default:throw new Ce(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Dp(n,e,t);case 2:return kk(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return G2(n,e,t);default:throw new Ce(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Dp(n,e,t);case 2:return u_(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return u_(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return G2(n,e,t);default:throw new Ce(`The axis is not within the rank of the tensor ${r}`)}default:throw new Ce(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function yR(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),Xo(n,e)}function oL(n,e){switch(n.rank){case 1:return ire([n,e]);case 2:return are([n,e],0);case 3:return ure([n,e],0);case 4:return hre([n,e],0);default:throw new Ce(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function CN(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new Ce(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return hu(n,e)}function NE(n,e=0,t=1,r,s){return _ie(n,e,t,r,s)}function Zu(n,e,t,r){if(n.rank<2||e.rank<2)throw new Fn(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const s=n.shape.slice(-1)[0],i=e.shape.slice(-2)[0];if(s!==i)throw new Fn(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return jP({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?IN(n.rank,r,yu()):null,activation:t});{const s=n.shape.slice(),i=s.pop();n=$e(n,[-1,i]);const o=e.shape.slice(),a=o.pop(),l=o.pop(),u=[...o,a],c=Array.from({length:e.rank},(g,w)=>w===0?e.rank-2:w<=e.rank-2?w-1:w);e=$e(ir(e,c),[l,-1]);const h=[...s,...u];return $e(jP({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?IN(n.rank,r,yu()):null,activation:t}),h)}}function lV(n,e,t){return ze(()=>(Array.isArray(e)?e=ba(e,"int32"):e=Ot(e,"int32"),bk(n,e,t)))}function lw(n){return Ae(n,n)}function IN(n,e,t){const r=e.shape;if(e.rank!==1&&e.rank!==n)throw new Ce(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return r.length===1?$e(e,[1,r[0],1,1,1]):$e(e,[1,r[3],r[0],r[1],r[2]]);if(t==="channelsLast")return r.length===1?$e(e,[1,1,1,1,r[0]]):$e(e,[1].concat(r))}else if(n===4){if(t==="channelsFirst")return r.length===1?$e(e,[1,r[0],1,1]):$e(e,[1,r[2],r[0],r[1]]);if(t==="channelsLast")return r.length===1?$e(e,[1,1,1,r[0]]):$e(e,[1].concat(r))}else if(n===3){if(t==="channelsFirst")return r.length===1?$e(e,[1,r[0],1]):$e(e,[1,r[1],r[0]]);if(t==="channelsLast")return r.length===1?$e(e,[1,1,r[0]]):$e(e,[1].concat(r))}else if(n<3)return e;throw new Ce(`Unsupported input rank by biasAdd: ${e.rank}`)}function bu(n,e,t){return ze(()=>(t==null&&(t=yu()),ks(t),xt(n,IN(n.rank,e,t))))}function Yue(n,e=1){if(e!==1)throw new Fn(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return wE(n)}function Zue(n){return ze(()=>hn(n,xt(ho(n),1)))}function uV(n,e,t,r){return ze(()=>voe(n,e,t,r))}function Jue(n){return ze(()=>{const e=xt(.5,Ae(.2,n));return qa(e,0,1)})}function uw(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Que=["fanIn","fanOut","fanAvg"],ece=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tce(n){dm(Que,"FanMode",n)}function nce(n){dm(ece,"Distribution",n)}class Cl extends Qy{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class cV extends Cl{apply(e,t){return gi(e,t)}}cV.className="Zeros";ft(cV);class vR extends Cl{apply(e,t){return ef(e,t)}}vR.className="Ones";ft(vR);class hV extends Cl{constructor(e){if(super(),typeof e!="object")throw new Ce(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new Ce(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ze(()=>Ae(Sr(this.value),ef(e,t)))}getConfig(){return{value:this.value}}}hV.className="Constant";ft(hV);class dV extends Cl{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return ew(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}dV.className="RandomUniform";ft(dV);class fV extends Cl{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Fn(`randomNormal does not support dType ${t}.`);return NE(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}fV.className="RandomNormal";ft(fV);class pV extends Cl{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Fn(`truncatedNormal does not support dType ${t}.`);return l4(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}pV.className="TruncatedNormal";ft(pV);let mV=class extends Cl{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return ze(()=>{if(e.length!==2||e[0]!==e[1])throw new Ce("Identity matrix initializer can only be used for 2D square matrices.");return Ae(this.gain,HU(e[0]))})}getConfig(){return{gain:this.gain}}};mV.className="Identity";ft(mV);function rce(n,e="channelsLast"){let t,r;if(ks(e),n.length===2)t=n[0],r=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const s=Ed(n,2);t=n[1]*s,r=n[0]*s}else if(e==="channelsLast"){const s=Ed(n,0,n.length-2);t=n[n.length-2]*s,r=n[n.length-1]*s}}else{const s=Ed(n);t=Math.sqrt(s),r=Math.sqrt(s)}return[t,r]}class Ta extends Cl{constructor(e){if(super(),e.scale<0)throw new Ce(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,tce(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,nce(this.distribution),this.seed=e.seed}apply(e,t){const r=rce(e),s=r[0],i=r[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,s):this.mode==="fanOut"?o/=Math.max(1,i):o/=Math.max(1,(s+i)/2),this.distribution==="normal"){const a=Math.sqrt(o);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Fn(`${this.getClassName()} does not support dType ${t}.`);return l4(e,0,a,t,this.seed)}else{const a=Math.sqrt(3*o);return ew(e,-a,a,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Ta.className="VarianceScaling";ft(Ta);class xR extends Ta{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ta.className}}xR.className="GlorotUniform";ft(xR);class wR extends Ta{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ta.className}}wR.className="GlorotNormal";ft(wR);class bR extends Ta{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ta.className}}bR.className="HeNormal";ft(bR);class SR extends Ta{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ta.className}}SR.className="HeUniform";ft(SR);class _R extends Ta{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ta.className}}_R.className="LeCunNormal";ft(_R);class TR extends Ta{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ta.className}}TR.className="LeCunUniform";ft(TR);class gV extends Cl{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return ze(()=>{if(e.length<2)throw new Fn("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const r=Qe(e.slice(0,-1)),s=e[e.length-1],i=r*s;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const o=[Math.max(s,r),Math.min(s,r)],a=NE(o,0,1,t,this.seed),l=pae.qr(a,!1);let u=l[0];const h=l[1].flatten().stridedSlice([0],[Math.min(s,r)*Math.min(s,r)],[Math.min(s,r)+1]);return u=Ae(u,h.sign()),r<s&&(u=u.transpose()),Ae(Sr(this.gain),u.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}gV.className="Orthogonal";ft(gV);const aL={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function lL(n,e={}){return ow(n,e0.getMap().classNameMap,e,"initializer")}function ds(n){return mR(n)}function os(n){if(typeof n=="string"){const e=n in aL?aL[n]:n;if(e==="GlorotNormal")return new wR;if(e==="GlorotUniform")return new xR;if(e==="HeNormal")return new bR;if(e==="HeUniform")return new SR;if(e==="LeCunNormal")return new _R;if(e==="LeCunUniform")return new TR;{const t={};return t.className=e,t.config={},lL(t)}}else return n instanceof Cl?n:lL(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function NN(n){return Array.isArray(n)&&Array.isArray(n[0])}function c_(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function wn(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new Ce(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function fr(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new Ce(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function h_(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((r,s)=>r*s);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const uL="Variable";class sce{constructor(e,t="float32",r=uL,s=!0,i=null){this.dtype=t??"float32",this.shape=e.shape,this.id=rV(),r=r??uL,this.originalName=iV(r),this.name=oV(this.originalName),this.trainable_=s,this.constraint=i,this.val=poe(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),ice(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function ice(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function AN(n){return n.map(e=>e.read())}function ER(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Qs{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class ic{constructor(e,t,r,s,i,o,a){this.dtype=e,this.shape=t,this.sourceLayer=r,this.inputs=s,this.callArgs=i,this.outputTensorIndex=a,this.id=rV(),o!=null&&(this.originalName=iV(o),this.name=oV(this.originalName)),this.rank=t.length}}let oce=0;class AE{constructor(e,t){this.callArgs=t,this.id=oce++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const r of e.inboundLayers)r!=null&&r.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let ace=0;class Kn extends Qy{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=ace++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const r=this.getClassName();t=qc(r)+"_"+IE(r)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let r;if(e.batchInputShape!=null)r=e.batchInputShape;else if(e.inputShape!=null){let i=null;e.batchSize!=null&&(i=e.batchSize),r=[i].concat(e.inputShape)}this.batchInputShape=r;let s=e.dtype;s==null&&(s=e.inputDType),s==null&&(s="float32"),this.dtype=s}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new yl(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Ce(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Vo(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Vo(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new zu(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new zu(`Layer ${this.name} is not connected, no input to return.`);return Vo(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new zu(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new zu(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Vo(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Ar(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const r=Ar(this.inputSpec);if(t.length!==r.length)throw new Ce(`Layer ${this.name} expects ${r.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let s=0;s<t.length;s++){const i=t[s],o=r[s];if(o==null)continue;const a=i.rank;if(o.ndim!=null&&a!==o.ndim)throw new Ce(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new Ce(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new Ce(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&i.dtype!==o.dtype)throw new Ce(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${i.dtype}.`);if(o.axes){const l=i.shape;for(const u in o.axes){const c=Number(u),h=o.axes[u],d=c>=0?l[c]:l[l.length+c];if(h!=null&&[h,null].indexOf(d)===-1)throw new Ce(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){const u=o.shape[l],c=i.shape[l];if(u!=null&&c!=null&&u!==c)throw new Ce(`Input ${s} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const r=Ar(e),s=cce(e),i=hce(e);if(s===i)throw new Ce("Arguments to apply() must be all SymbolicTensors or all Tensors");return Rp(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const o=[];for(const a of Ar(e))o.push(a.shape);this.build(Vo(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&i&&(this._refCount=1)}if(this.assertInputCompatibility(e),i){let o=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,o);const a=Ar(o),l=[];for(let u of a)r.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(o=Vo(l),this.activityRegularizer!=null)throw new Fn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=lce(e),a=this.computeOutputShape(o);let l;const u=uce(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?o[0]:o),a!=null&&a.length>0&&Array.isArray(a[0])?l=a.map((c,h)=>new ic(u,c,this,Ar(e),t,this.name,h)):l=new ic(u,a,this,Ar(e),t,this.name),this.addInboundNode(e,l,null,null,o,a,t),this._refCount++,this.activityRegularizer!=null)throw new Fn("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&e[s]!=null&&e[s]!==r&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new zu(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const r=JSON.stringify(t.outputShapes);e.indexOf(r)===-1&&e.push(r)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new zu(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new yl(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return h_(this.weights)}build(e){this.built=!0}getWeights(e=!1){return AN(e?this.trainableWeights:this.weights)}setWeights(e){ze(()=>{const t=this.weights;if(t.length!==e.length)throw new Ce(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const r=[],s=AN(t);for(let i=0;i<s.length;++i){const o=s[i],a=t[i],l=e[i];if(!_r(o.shape,l.shape))throw new Ce(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);r.push([a,l])}ER(r)})}addWeight(e,t,r,s,i,o,a,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new Ce(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=l!=null?l():os("zeros"));const u=s.apply(t,r),c=new sce(u,r,e,o,a);return u.dispose(),i!=null&&this.addLoss(()=>i.apply(c.read())),o==null&&(o=!0),o?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Ar(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,r){if(!this.supportsMasking)return;const s=this.computeMask(e,r),i=Ar(t),o=Ar(s);if(i.length!==o.length)throw new Error(`${this.name} outputs ${i.length} tensors but ${i.length} masks for those tensors`);for(let a=0;a<i.length;a++)i[a].kerasMask=o[a]}addInboundNode(e,t,r,s,i,o,a=null){const l=Ar(e);t=Ar(t),r=Ar(r),s=Ar(s),i=c_(i),o=c_(o);const u=[],c=[],h=[];for(const d of l)u.push(d.sourceLayer),c.push(d.nodeIndex),h.push(d.tensorIndex);new AE({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:r,outputMasks:s,inputShapes:i,outputShapes:o},a);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function lce(n){n=Ar(n);const e=[];for(const t of n)e.push(t.shape);return Vo(e)}function uce(n){return"float32"}function yV(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const r=e.inboundNodes[t];if(r.inboundLayers.length===0)return r.inputTensors;{const s=[];for(let i=0;i<r.inboundLayers.length;i++){const o=r.inputTensors[i],a=r.inboundLayers[i],l=r.nodeIndices[i],u=yV(o,a,l);for(const c of u)s.indexOf(c)===-1&&s.push(c)}return s}}}function cce(n){let e=!0;for(const t of Ar(n))if(!(t instanceof ic)){e=!1;break}return e}function hce(n){let e=!0;for(const t of Ar(n))if(t instanceof ic){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class cw extends Kn{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:IE("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new Ce("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new Ce("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new Ce("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=t,this.dtype=r,this.inputSpec=[{shape:t}];const s=new ic(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new AE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Ce(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}cw.className="InputLayer";ft(cw);function dce(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new Ce("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new cw({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fce(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Ot(e,n.dtype)}catch{throw new Ce(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class yd{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof yd)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,r){if(this.id2Value[e.id]==null)this.id2Value[e.id]=fce(e,t),this.name2Id[e.name]=e.id,r!=null&&(this.id2Mask[e.id]=r);else throw new Ce(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof ic){if(this.id2Value[e.id]==null)throw new Ce(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new Ce(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof ic){if(this.id2Value[e.id]==null)throw new Ce(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new Ce(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Yn(this.id2Mask)}}const d_=new eV,f_=new eV;function pce(n){d_!=null&&d_.setMaxEntries(n),f_!=null&&f_.setMaxEntries(n)}function $v(n,e,t,r){const s=t==null?!1:t.training,i=Array.isArray(n),o=i?n:[n],a=o.map(g=>g.name),l=[],u=e.names();for(const g of a)u.indexOf(g)!==-1?l.push(e.getValue(g)):l.push(null);const c=a.join(",")+"|"+e.names().sort().join(",");let h=d_.get(c),d;if(h==null){const g=mce(o,e);h=g.sorted,d=g.recipientCounts,d_.put(c,h),f_.put(c,d)}d={},s||Object.assign(d,f_.get(c));const p=new yd(e);for(let g=0;g<h.length;++g){const w=h[g],y=w.sourceLayer;if(y instanceof cw)continue;const x=[],_=[],T=[];let E=!1;for(const k of w.inputs){const R=p.getValue(k),P=p.getMask(k);x.push(R),_.push(P),P!=null&&(E=!0),s||(d[k.name]--,d[k.name]===0&&!e.hasKey(k)&&a.indexOf(k.name)===-1&&!R.isDisposed&&k.sourceLayer.stateful!==!0&&T.push(R))}E&&(t=t||{},t.mask=_[0]);const N=Ar(y.apply(x,t));let M=null;y.supportsMasking&&(M=y.computeMask(x,_));const $=yce(w),L=Array.isArray($)?$:[$];for(let k=0;k<L.length;++k){p.hasKey(L[k])||p.add(L[k],N[k],Array.isArray(M)?M[0]:M);const R=a.indexOf(L[k].name);R!==-1&&(l[R]=N[k])}s||Yn(T)}return p.disposeMasks(),i?l:l[0]}function mce(n,e){ie(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],r={};if(n.length===1){const s=cL(n[0],e);t=s.sorted,r=s.recipientMap}else{const s=new Set;for(const i of n){const{sorted:o,recipientMap:a}=cL(i,e);for(const l of o)s.has(l.name)||(t.push(l),s.add(l.name));for(const l in a)r[l]==null&&(r[l]=new Set),a[l].forEach(u=>r[l].add(u))}}return{sorted:t,recipientCounts:gce(r)}}function gce(n){const e={};for(const t in n)e[t]=n[t].size;return e}function cL(n,e){const t=new Set,r=[],s={};for(const a of e.names())t.add(a);const i=[],o=[];for(i.push(n);i.length>0;){const a=i[i.length-1];if(t.has(a.name)){i.pop();continue}const l=o[o.length-1]===i.length-1;if(a.inputs.length===0||l)i.pop(),r.push(a),t.add(a.name),l&&o.pop();else{o.push(i.length-1);for(const u of a.inputs)s[u.name]==null&&(s[u.name]=new Set),s[u.name].add(a.name),!t.has(u.name)&&i.push(u)}}return{sorted:r,recipientMap:s}}function yce(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const s of n.sourceLayer.inboundNodes[r].outputTensors)if(s.id===n.id){t=r;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vce=je();vce.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,pce);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function CR(n,e){return ze(()=>Eo(an(Ae(n,n),e,!0)))}class hw extends Qy{getConfig(){return{}}}class vV extends hw{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ze(()=>{const t=CR(e,this.axis),r=qa(t,0,this.maxValue);return Ae(e,hn(r,xt(Js(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}vV.className="MaxNorm";ft(vV);class xV extends hw{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ze(()=>hn(e,xt(Js(),CR(e,this.axis))))}getConfig(){return{axis:this.axis}}}xV.className="UnitNorm";ft(xV);class wV extends hw{apply(e){return cm(e)}}wV.className="NonNeg";ft(wV);class bV extends hw{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ze(()=>{const t=CR(e,this.axis),r=xt(Ae(this.rate,qa(t,this.minValue,this.maxValue)),Ae(1-this.rate,t));return Ae(e,hn(r,xt(Js(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}bV.className="MinMaxNorm";ft(bV);const hL={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ei(n){return mR(n)}function dL(n,e={}){return ow(n,e0.getMap().classNameMap,e,"constraint")}function ti(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in hL?hL[n]:n,config:{}};return dL(t)}else return n instanceof hw?n:dL(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function sp(n){if(n==null)return;const e=[],t=[],r=[];for(const s in n){const i=n[s];if(typeof i!="number"){const o=i;e.push(o.data()),t.push(s),r.push(o)}}if(e.length>0){const s=await Promise.all(e);for(let i=0;i<s.length;++i)n[t[i]]=s[i][0];Yn(r)}}function SV(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var fL;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(fL||(fL={}));const xce=125;class _x{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class wce{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class bce extends _x{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const r=t.size==null?0:t.size;this.seen+=r;for(const s in t){const i=t[s];if(typeof i=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+i*r;else{let o;s in this.totals?o=this.totals[s]:this.totals[s]=0;const a=ze(()=>xt(this.totals[s],Ae(i,r)));this.totals[s]=a,o!=null&&o.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?t[r]=this.totals[r]/this.seen:ze(()=>{const s=Ae(hn(1,this.seen),this.totals[r]);t[r]=s,this.totals[r].dispose(),qu(t[r])}))}}class Sce extends _x{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const r in t)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(t[r])}async syncData(){const e=[],t=[],r=[];for(const i in this.history){const o=this.history[i];for(let a=0;a<o.length;++a)if(typeof o[a]!="number"){const l=o[a];e.push(l.data()),t.push(i),r.push(a)}}const s=await Promise.all(e);for(let i=0;i<s.length;++i)this.history[t[i]][r[i]].dispose(),this.history[t[i]][r[i]]=s[i][0]}}class _ce extends _x{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||I4,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=xce),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");sN(this.yieldEvery)&&(this.maybeWait=Lue(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,r){const s=[];this.yield!=null&&(await sp(r),s.push(this.yield(e,t,r))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await sp(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const r=[];this.epochEnd!=null&&(await sp(t),r.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(e,t){this.batchBegin!=null&&(await sp(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const r=[];this.batchEnd!=null&&(await sp(t),r.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):sN(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(r)}async onTrainBegin(e){this.trainBegin!=null&&(await sp(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await sp(e),await this.trainEnd(e))}}function _V(n,e){return n==null&&(n={}),n instanceof _x?[n]:Array.isArray(n)&&n[0]instanceof _x?n:Ar(n).map(r=>new _ce(r,e))}class pl{constructor(){}static registerCallbackConstructor(e,t){ie(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),pl.checkForDuplicate(t),pl.constructors[e]==null&&(pl.constructors[e]=[]),pl.constructors[e].push(t)}static checkForDuplicate(e){for(const t in pl.constructors)pl.constructors[+t].forEach(s=>{if(s===e)throw new Ce("Duplicate callback constructor.")})}static clear(){pl.constructors={}}static createCallbacks(e){const t=[];for(const r in pl.constructors){const s=+r;e>=s&&t.push(...pl.constructors[s])}return t.map(r=>new r)}}pl.constructors={};function TV(n,e,t,r,s,i,o,a,l){const u=new Sce,c=[new bce,...pl.createCallbacks(e)];n!=null&&c.push(...n),c.push(u);const h=new wce(c);return h.setParams({epochs:t,initialEpoch:r,samples:s,steps:i,batchSize:o,verbose:e,doValidation:a,metrics:l}),{callbackList:h,history:u}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function oh(n,e={},t=!1){return ow(n,e0.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function p_(n,e){return ze(()=>{n.dtype!=="float32"&&(n=Ot(n,"float32"));const t=an(lw(n),e,!0),r=xE(t.shape,Js()),s=Eo(Qd(t,r));return hn(n,s)})}function ME(n,e){return ze(()=>Fs(lw(yn(e,n)),-1))}function IR(n,e){return ze(()=>Fs(ho(yn(e,n)),-1))}function NR(n,e){return ze(()=>{const t=yn(n,e),r=qa(ho(n),Js(),Number.MAX_VALUE),s=ho(hn(t,r));return Ae(100,Fs(s,-1))})}function Tce(n,e){return ze(()=>{const t=qa(e,Js(),Number.MAX_VALUE),r=sc(xt(1,t)),s=qa(n,Js(),Number.MAX_VALUE),i=sc(xt(1,s));return Fs(lw(yn(r,i)),-1)})}function Ece(n,e){return ze(()=>{const t=Qd(0,yn(1,Ae(n,e)));return Fs(lw(t),-1)})}function Cce(n,e){return ze(()=>{const t=Qd(0,yn(1,Ae(n,e)));return Fs(t,-1)})}function Ice(n,e){return ze(()=>{const t=an(Ae(n,e),-1),r=fu(Ae(yn(1,n),e),-1);return Qd(0,xt(1,yn(r,t)))})}function Nce(n,e){return ze(()=>{const t=Math.log(2),r=yn(e,n),s=yn(xt(r,Q1(Ae(-2,r))),t);return Fs(s,-1)})}function Tx(n,e,t=!1){return ze(()=>{if(t)e=Rk(e);else{const r=an(e,e.shape.length-1,!0);e=hn(e,r)}return e=qa(e,Js(),1-Js()),Is(an(Ae(Ot(n,"float32"),sc(e)),e.shape.length-1))})}function m_(n,e,t=!1){return ze(()=>{const r=Ot(SE(que(n)),"int32");e=qa(e,Js(),1-Js());const s=e.shape,i=$e(YU(r,s[s.length-1]),s);return Tx(i,e,t)})}function Ace(n,e){if(!_r(n.shape,e.shape))throw new Ce(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return ze(()=>{const t=cm(e),r=Is(ho(e));return xt(yn(t,Ae(e,n)),jU(rc(r)))})}function kE(n,e){return ze(()=>{let t;return t=qa(e,Js(),1-Js()),t=sc(hn(t,yn(1,t))),Fs(Ace(n,t),-1)})}function Mce(n,e){return ze(()=>{const t=qa(n,Js(),1),r=qa(e,Js(),1);return an(Ae(n,sc(hn(t,r))),-1)})}function kce(n,e){return ze(()=>{const t=sc(xt(Js(),e));return Fs(yn(e,Ae(n,t)),-1)})}function EV(n,e){return ze(()=>{const t=p_(n,-1),r=p_(e,-1),s=Ae(t,r);return Is(an(s,-1))})}const g_={meanSquaredError:ME,meanAbsoluteError:IR,meanAbsolutePercentageError:NR,meanSquaredLogarithmicError:Tce,squaredHinge:Ece,hinge:Cce,categoricalHinge:Ice,logcosh:Nce,categoricalCrossentropy:Tx,sparseCategoricalCrossentropy:m_,binaryCrossentropy:kE,kullbackLeiblerDivergence:Mce,poisson:kce,cosineProximity:EV};function H2(n){if(typeof n=="string"){if(n in g_)return g_[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Ce(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function CV(n,e){return ze(()=>{const t=Ae(.5,Sl(e)),r=Yu(Ya(e,t),n.dtype);return Fs(nc(n,r),-1)})}function IV(n,e){return ze(()=>Yu(nc(vx(n,-1),vx(e,-1)),"float32"))}function Rce(n,e){return ze(()=>Ot(an(lh(nc(n,1),nc(e,1))),"float32"))}function Dce(n,e){return ze(()=>Ot(an(lh(nc(n,0),nc(e,1))),"float32"))}function $ce(n,e){return ze(()=>{const t=Rce(n,e),r=Dce(n,e),s=xt(t,r);return Ot(_o(Ya(s,0),hn(t,s),0),"float32")})}function Pce(n,e){return kE(n,e)}function Lce(n,e){return n.rank===e.rank&&(n=tw(n,[n.rank-1])),e=vx(e,-1),e.dtype!==n.dtype&&(e=Ot(e,n.dtype)),Ot(nc(n,e),"float32")}const Oce=ME,Fce=ME,zce=IR,Bce=IR,Uce=NR,Vce=NR,NV=Tx,Wce=EV,AV=m_,y_={binaryAccuracy:CV,categoricalAccuracy:IV,precision:$ce,categoricalCrossentropy:NV,sparseCategoricalCrossentropy:AV,mse:Oce,MSE:Fce,mae:zce,MAE:Bce,mape:Uce,MAPE:Vce,cosine:Wce};function Gce(n){if(typeof n=="string"&&n in y_)return y_[n];if(typeof n!="string"&&n!=null)return n;throw new Ce(`Unknown metric ${n}`)}function fS(n){if(Bu(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(g_))if(g_[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(y_))if(y_[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Hce(n){const e={Adagrad:()=>Ug.adagrad(.01),Adadelta:()=>Ug.adadelta(1,.95,Js()),Adam:()=>Ug.adam(.001,.9,.999,Js()),Adamax:()=>Ug.adamax(.002,.9,.999,Js(),0),RMSProp:()=>Ug.rmsprop(.001,.9,0,Js()),SGD:()=>Ug.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new Ce(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const pL=1*1024*1024;function mL(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!MN(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const r=JSON.stringify(n);r.length>pL&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${pL}.`)}}function MN(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!MN(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!MN(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function jce(n,e,t,r=console.log){const s=qce(n),i=["Layer (type)","Input Shape","Output shape","Param #"];s?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(c=>Math.floor(e*c)));let o;if(!s){i.push("Receives inputs"),o=[];for(const c in n.nodesByDepth)o.push(...n.nodesByDepth[c])}r("_".repeat(e)),v_(i,t,r),r("=".repeat(e));const a=n.layers;for(let c=0;c<a.length;++c)s?Kce(a[c],t,r):Yce(a[c],t,o,r),r((c===a.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=Xce(n),u=h_(n.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(e))}function Xce(n){let e;return n.collectedTrainableWeights!=null?e=h_(n.collectedTrainableWeights):e=h_(n.trainableWeights),e}function qce(n){let e=!0;const t=[],r=[];for(const s in n.nodesByDepth)t.push(n.nodesByDepth[s]);for(const s of t){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){e=!1;break}r.push(...s)}if(e)for(const s of n.layers){let i=!1;for(const o of s.inboundNodes)if(r.indexOf(o)!==-1)if(i){e=!1;break}else i=!0;if(!e)break}return e}function v_(n,e,t=console.log){let r="";for(let s=0;s<n.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=n[s],r=r.slice(0,e[s]),r+=" ".repeat(e[s]-r.length);t(r)}function Kce(n,e,t){let r,s;try{s=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const i=n.name,o=n.getClassName(),a=[`${i} (${o})`,s,r,n.countParams().toString()];v_(a,e,t)}function Yce(n,e,t,r){let s,i;try{i=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const o=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){const p=h.inboundLayers[d].name,g=h.nodeIndices[d],w=h.tensorIndices[d];o.push(`${p}[${g}][${w}]`)}const a=n.name,l=n.getClassName(),u=o.length===0?"":o[0],c=[`${a} (${l})`,i,s,n.countParams().toString(),u];v_(c,e,r);for(let h=1;h<o.length;++h)v_(["","","","",o[h]],e,r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function MV(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function kN(n,e){if(n===null)return null;if(typeof n=="string")return dp(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];MV(e,s,i)?t.push(i):t.push(kN(i,e))}return t}else{const t={};for(const r of Object.keys(n)){const s=n[r];if(r==="name"&&typeof s=="string")t[r]=s;else{const i=dp(r);t[i]=kN(s,i)}}return t}}function RN(n,e){if(n==null)return null;if(typeof n=="string")return qc(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let s=0;s<r;++s){const i=n[s];MV(e,s,i)?t.push(i):t.push(RN(i,e))}return t}else{const t={};for(const r of Object.keys(n)){const s=n[r],i=qc(r);(r==="name"||r==="className")&&typeof s=="string"?t[i]=s:t[i]=RN(s,r)}return t}}/** @license See the LICENSE file. */const kV="4.17.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Zce=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class su extends Kn{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const _=this.getClassName().toLowerCase();this.name=IE(_)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Td(this.inputs).length!==this.inputs.length)throw new Ce(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(_=>_.name)}`);Td(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(_=>_.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const _ of this.outputs){const T=_.sourceLayer,E=_.nodeIndex,N=_.tensorIndex;this.outputLayers.push(T),this.outputLayersNodeIndices.push(E),this.outputLayersTensorIndices.push(N)}for(const _ of this.inputs){const T=_.sourceLayer,E=_.nodeIndex,N=_.tensorIndex;Bu(E===0,"input layer has >1 nodes"),Bu(N===0,"input layer has >1 tensors"),this.inputLayers.push(T),this.inputLayersNodeIndices.push(E),this.inputLayersTensorIndices.push(N)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let _=0;_<this.inputLayers.length;_++){const T=this.inputLayers[_];if(!(T instanceof cw))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${_} (0-based) originates from layer type ${T.getClassName()}.`);this.inputNames.push(T.name),this.feedInputShapes.push(T.batchInputShape),this.feedInputNames.push(T.name)}for(const _ of this.outputLayers)this.outputNames.push(_.name);this.internalInputShapes=this.inputs.map(_=>_.shape),this.internalOutputShapes=this.outputs.map(_=>_.shape);const t={},r={},s={},i={},o={},a=[],l=(_,T,E,N,M,$)=>{(N==null||M==null||$==null)&&(N=_.sourceLayer,M=_.nodeIndex,$=_.tensorIndex);const L=N.inboundNodes[M];if(E.indexOf(L)!==-1)throw new yl(`The tensor ${_.name} at layer "${N.name}" is part of a cycle.`);if(T.indexOf(L)!==-1)return;this.containerNodes.add(su.nodeKey(N,M)),N.id in o||(o[N.id]=Object.keys(o).length),E.indexOf(L)===-1&&E.push(L);const k=L.inboundLayers.length;for(let R=0;R<k;R++){const P=L.inputTensors[R],B=L.inboundLayers[R],Z=L.nodeIndices[R],V=L.tensorIndices[R];l(P,T,E,B,Z,V)}for(T.push(L);E.indexOf(L)>=0;)E.splice(E.indexOf(L),1);a.push(L)},u=[],c=[];for(const _ of this.outputs)l(_,u,c);const h=a.slice().reverse();for(const _ of h){r[_.id]=_,_.id in t||(t[_.id]=0);let T=t[_.id];const E=s[_.outboundLayer.id]==null?0:s[_.outboundLayer.id];T=Math.max(T,E),s[_.outboundLayer.id]=T,i[_.outboundLayer.id]=_.outboundLayer,t[_.id]=T;for(let N=0;N<_.inboundLayers.length;N++){const M=_.inboundLayers[N],$=_.nodeIndices[N],L=M.inboundNodes[$],k=t[L.id]==null?0:t[L.id];t[L.id]=Math.max(T+1,k),r[L.id]=L}}const d={};for(const _ in t){const T=t[_];T in d||(d[T]=[]),d[T].push(r[_])}const p={};for(const _ in s){const T=s[_];T in p||(p[T]=[]),p[T].push(i[_])}let g=Object.keys(p).map(_=>parseInt(_,10)).sort(cS);this.layers=[];for(const _ of g){const T=p[_];T.sort((E,N)=>{const M=o[E.id],$=o[N.id];return M<$?-1:M>$?1:0});for(const E of T)E instanceof su&&this.internalContainerRefs.push(E),this.layers.push(E)}this.layersByDepth=p,g=Object.keys(d).map(_=>parseInt(_,10)).sort(cS);const w=this.inputs.slice(),y=[];for(const _ of g)for(const T of d[_]){const E=T.outboundLayer;if(E!=null){for(const N of T.inputTensors)if(w.indexOf(N)===-1)throw new yl(`Graph disconnected: cannot obtain value for tensor ${N} at layer "${E.name}". The following previous layers were accessed without issue: ${y}`);for(const N of T.outputTensors)w.push(N);y.push(E.name)}}this.nodesByDepth=d;const x=this.layers.map(_=>_.name);for(const _ of x){const T=x.filter(E=>E===_).length;if(T!==1)throw new yl(`The name "${_}" is used ${T} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(x))}this.outboundNodes=[],this.inboundNodes=[],new AE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(_=>null),outputMasks:this.outputs.map(_=>null),inputShapes:this.inputs.map(_=>_.shape),outputShapes:this.outputs.map(_=>_.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(r=>r.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Ce("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.layers)t.push(...r.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const r={};let s=0;const i=Zce(e);i&&this.parseWeights(e);for(const a of this.layers)for(const[l,u]of a.weights.entries()){const c=i?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(r[c]!=null)throw new Ce(`Duplicate weight name: ${c}`);r[c]=u,s++}const o=[];for(const a in e){let l=a;if(r[a]==null){const u=a.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(r[l]!=null)o.push([r[l],e[a]]);else if(t)throw new Ce(`Provided weight data has no target variable: ${a}`);delete r[l]}if(t){const a=[];for(const l in r)a.push(l);if(a.length>0)throw new Ce(`${a.length} of ${s} weights are not set: ${a}`)}ER(o)}parseWeights(e){for(const t in Object.keys(e)){const r=t.split("/"),s=["vars","layer_checkpoint_dependencies"],i=r.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!s.includes(o)).join("/");i!==t&&(e[i]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${kV}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const r=RN(this.updatedConfig());return t?JSON.stringify(r):r}call(e,t){return ze(()=>{e=Ar(e);const r=new yd;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],e[s]);return $v(this.outputs,r,t)})}computeMask(e,t){return ze(()=>{e=Ar(e);let r;return t==null?r=qp(null,e.length):r=Ar(t),this.runInternalGraph(e,r)[1]})}computeOutputShape(e){const t=c_(e);if(t.length!==this.inputLayers.length)throw new Ce(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let a=0;a<t.length;a++){const l=this.inputLayers[a],u=t[a],c=l.name+"_0_0";r[c]=u}const s=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(cS);if(s.length>1)for(const a of s){const l=this.nodesByDepth[a];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(w=>w.id).indexOf(c.id)!==-1)continue;const h=[];for(let w=0;w<u.inboundLayers.length;w++){const y=u.inboundLayers[w],x=u.nodeIndices[w],_=u.tensorIndices[w],T=`${y.name}_${x}_${_}`,E=r[T];h.push(E)}const d=c.computeOutputShape(Vo(h)),p=c_(d),g=c.inboundNodes.indexOf(u);for(let w=0;w<p.length;w++){const y=`${c.name}_${g}_${w}`;r[y]=p[w]}}}const i=[],o=[];for(let a=0;a<this.outputLayers.length;a++){const l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],h=`${l.name}_${u}_${c}`;o.push(h)}for(let a=0;a<o.length;a++){const l=o[a];Bu(l in r),i.push(r[l])}return Vo(i)}runInternalGraph(e,t){t==null&&(t=qp(null,e.length));const r={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=e[l],h=t[l];r[u.id]=[c,h]}const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(cS);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const h=c.outboundLayer,d=c.inputTensors,p=c.outputTensors,g=new Array;for(const w of d)w.id in r&&g.push(r[w.id]);if(g.length===d.length){let w={},y,x,_,T;if(c.callArgs!=null&&(w=c.callArgs),g.length===1){const[E,N]=g[0];w.mask==null&&(w.mask=N),_=Ar(h.call(E,w)),T=Ar(h.computeMask(E,N)),y=[E],x=[N]}else y=g.map(E=>E[0]),x=g.map(E=>E[1]),w.mask==null&&(w.mask=x),_=Ar(h.call(y,w)),T=Ar(h.computeMask(y,x));if(h.activityRegularizer)throw new Fn("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let E=0;E<p.length;++E){const N=p[E],M=_[E],$=T[E];r[N.id]=[M,$]}}}}const i=[],o=[],a=[];for(const l of this.outputs){Bu(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];a.push(u.shape),i.push(u),o.push(c)}return[i,o,a]}buildNodeConversionMap(e){const t={};let r;for(const s of this.layers){r=s instanceof su?1:0;for(let i=0;i<s.inboundNodes.length;i++){const o=su.nodeKey(s,i);this.containerNodes.has(o)&&(t[o]=r,r+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new Ce("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const r of this.layers)if(r.name===e)return r;throw new Ce(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new Ce(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return ze(()=>{const e=[];for(const t of this.layers)for(let r=0;r<t.inboundNodes.length;++r){const s=su.nodeKey(t,r);this.containerNodes.has(s)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const a=o.getClassName(),l=o.getConfig(),u=[];for(let h=0;h<o.inboundNodes.length;h++){const d=o.inboundNodes[h],p=su.nodeKey(o,h);let g={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),g=d.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),g={}}if(d.inboundLayers.length>0){const w=[];for(let y=0;y<d.inboundLayers.length;y++){const x=d.inboundLayers[y],_=d.nodeIndices[y],T=d.tensorIndices[y],E=su.nodeKey(x,_);let N=t[E];N==null&&(N=0),w.push([x.name,N,T,g])}u.push(w)}}}const c={};c.name=o.name,c.className=a,c.config=l,c.inboundNodes=u,r.push(c)}e.layers=r;const s=[];for(let o=0;o<this.inputLayers.length;o++){const a=this.inputLayers[o],l=this.inputLayersNodeIndices[o],u=su.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const h=this.inputLayersTensorIndices[o];s.push([a.name,c,h])}e.inputLayers=s;const i=[];for(let o=0;o<this.outputLayers.length;o++){const a=this.outputLayers[o],l=this.outputLayersNodeIndices[o],u=su.nodeKey(a,l);if(!this.containerNodes.has(u))continue;let c=t[u];c==null&&(c=0);const h=this.outputLayersTensorIndices[o];i.push([a.name,c,h])}return e.outputLayers=i,e}static fromConfig(e,t,r={},s=!1){const i={},o={};function a(y,x){y.name in o?o[y.name].push(x):o[y.name]=[x]}function l(y,x){const _=[];let T;for(const E of x){const N=E[0],M=E[1],$=E[2];if(T=E[3]==null?{}:E[3],!(N in i)){a(y,x);return}const L=i[N];if(L.inboundNodes.length<=M){a(y,x);return}const k=L.inboundNodes[M];_.push(k.outputTensors[$])}_.length>0&&y.apply(Vo(_),T)}function u(y){const x=y.name,_=oh(y,t.customObjects!=null?t.customObjects:{});_.setFastWeightInitDuringBuild(s),i[x]=_,y.inboundNodes.forEach(E=>{if(!(E instanceof Array))throw new Ce(`Corrupted configuration, expected array for nodeData: ${E}`);a(_,E)})}const c=t.name,h=t.layers;for(const y of h)u(y);for(;!Pue(o);)for(const y of h){const x=i[y.name];if(x.name in o){const _=o[x.name];delete o[x.name];for(const T of _)l(x,T)}}const d=[],p=[],g=t.inputLayers;for(const y of g){const x=y[0],_=y[1],T=y[2];Bu(x in i);const N=i[x].inboundNodes[_].outputTensors;d.push(N[T])}const w=t.outputLayers;for(const y of w){const x=y[0],_=y[1],T=y[2];Bu(x in i);const N=i[x].inboundNodes[_].outputTensors;p.push(N[T])}return new e({inputs:d,outputs:p,name:c})}get stateful(){if(this._stateful)throw new Ce("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){ze(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Jce(n,e,t){const r=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>null);if(r===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const s=[];return e.forEach(i=>{i in n?s.push(n[i]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${t} must be either an array with ${r} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function RV(n,e){return Jce(n,e,"classWeight")}async function DV(n,e,t,r){if(t!=null){const s=ze(()=>{if(n.shape.length===1)return kp(n);if(n.shape.length===2){if(n.shape[1]>1)return vx(n,1);if(n.shape[1]===1)return $e(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),i=Array.from(await s.data());Yn(s);const o=[];return i.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);o.push(t[a])}),ba(o,"float32")}else return null}function Qce(n,e){return Ae(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ehe=32;function $V(n,e){let t,r;const s=e;t=s.xs,r=s.ys,ie(t!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const i=gL("input",n.inputNames,t),o=gL("output",n.outputNames,r),a=i[0].shape[0];ie(i.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),ie(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<i.length;l++)ie(i[l].shape[0]===a,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${i[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)ie(o[l].shape[0]===a,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${a} based on input ${n.inputNames[0]}.`);return{xs:i,ys:o}}function gL(n,e,t){if(t instanceof Zs)return[t];if(Array.isArray(t))return ie(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const r=[];for(const s of e){if(t[s]==null)throw new Ce(`The feature data generated by the dataset lacks the required ${n} key '${s}'.`);r.push(t[s])}return r}}function the(n){if(n.length===3)throw new Fn("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function nhe(n,e,t){const r=t.batchesPerEpoch!=null;if(ie(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),ie(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),ie(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),ie(!r||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),ie(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const s=t.validationData!=null;let i,o;if(s)if(yL(t.validationData))ie(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const y=the(t.validationData);i=y.xs,o=y.ys}const a=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let u;s?u=l.slice().concat(l.map(y=>"val_"+y)):u=l.slice();const c=_V(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:d,history:p}=TV(c,h,t.epochs,null,null,rhe(e,t),null,s,u);d.setModel(n),n.history=p,await d.onTrainBegin(),n.stopTraining_=!1;let g=t.initialEpoch==null?0:t.initialEpoch,w=await e.iterator();for(;g<t.epochs;){const y={};await d.onEpochBegin(g);let x=0,_=0;for(r||(w=await e.iterator());!r||x<t.batchesPerEpoch;){const T=await w.next();if(r&&T.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${x} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(T.value!=null){const{xs:E,ys:N}=$V(n,T.value),M={};M.batch=_,M.size=E[0].shape[0],await d.onBatchBegin(_,M);const $=[];if(t.classWeight!=null){const R=RV(t.classWeight,n.outputNames);for(let P=0;P<R.length;++P)$.push(await DV(N[P],null,R[P]))}const L=E.concat(N).concat($),k=a(L);Yn(L);for(let R=0;R<l.length;++R){const P=l[R],B=k[R];M[P]=B,qu(B)}await d.onBatchEnd(_,M),SV(M),_++,x++}if(r?x>=t.batchesPerEpoch:T.done){if(s){let E;yL(t.validationData)?E=Ar(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):E=Ar(n.evaluate(i,o,{batchSize:t.validationBatchSize==null?ehe:t.validationBatchSize,verbose:0}));for(let N=0;N<n.metricsNames.length;++N)y[`val_${n.metricsNames[N]}`]=E[N]}break}if(n.stopTraining_)break}if(await d.onEpochEnd(g,y),g++,n.stopTraining_)break}return await d.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function rhe(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function yL(n){return typeof n.iterator=="function"}function she(n){return typeof n.next=="function"}async function ihe(n,e,t){t=t||{};const r=t.batches!=null,s=n.testFunction;let i=[];if(t.verbose>0)throw new Fn("Verbose mode is not implemented yet.");ie(!r||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const o=she(e)?e:await e.iterator();let a=0,l=0;for(;!r||l<t.batches;){const u=await o.next();if(i=ze(()=>{if(u.value){const{xs:c,ys:h}=$V(n,u.value),d=c.concat(h),p=ze(()=>s(d));if(Yn(d),l===0)for(let w=0;w<p.length;++w)i.push(Sr(0));const g=d[0].shape[0];for(let w=0;w<p.length;++w){const y=p[w],x=i[w];i[w]=ze(()=>xt(i[w],Ae(g,y))),l>0&&Yn(x)}Yn(p),a+=g,++l}return i}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<i.length;++u){const c=i[u];i[u]=hn(i[u],a),Yn(c)}return Vo(i)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function j2(n){ie(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function Cv(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(r=>Dp(r,e,t-e)):Dp(n,e,t-e)}function DN(n,e){return ze(()=>n==null?null:Array.isArray(n)?n.map(t=>DN(t,e)):lV(n,e.dtype==="int32"?e:Ot(e,"int32")))}function X2(n,e){const t=[];let r=0,s=null;for(;r<n;)s=r+e,s>=n&&(s=n),t.push([r,s]),r=s;return t}function PV(n){const e=[];n instanceof Zs&&(n=[n]);for(let t=0;t<n.length;++t){const r=n[t];if(r.rank===1)e.push(aw(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function nu(n,e){if(n==null)return;const t=[];if(e instanceof Zs)t.push(e.id);else if(Array.isArray(e))e.forEach(s=>t.push(s.id));else if(e!=null)for(const s in e){const i=e[s];t.push(i.id)}const r=[];if(n instanceof Zs)t.indexOf(n.id)===-1&&r.push(n);else if(Array.isArray(n))n.forEach(s=>{t.indexOf(s.id)===-1&&r.push(s)});else if(n!=null)for(const s in n){const i=n[s];t.indexOf(i.id)===-1&&r.push(i)}r.forEach(s=>{s.isDisposed||s.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ohe(n){return n instanceof Zs}function $N(n){return Array.isArray(n)}function vL(n){return!ohe(n)&&!$N(n)}function xL(n,e,t,r=!0,s=""){if(e==null||e.length===0){if(n!=null){let o=!1;if($N(n)&&n.length>0)o=!0;else if(vL(n)){for(const a in n)if(n.hasOwnProperty(a)){o=!0;break}}else o=!0;if(o)throw new Ce(`Error when checking model ${s} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(o=>null);let i;if(vL(n)){n=n,i=[];for(const o of e){if(n[o]==null)throw new Ce(`No data provided for "${o}". Need data for each key in: ${e}`);i.push(n[o])}}else if($N(n)){if(n=n,n.length!==e.length)throw new Ce(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);i=n}else{if(n=n,e.length>1)throw new Ce(`The model ${s} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);i=[n]}if(i=PV(i),t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new Ce(`Error when checking ${s}: expected ${e[o]} to have ${t[o].length} dimension(s). but got array with shape ${a.shape}`);for(let l=0;l<t[o].length;++l){if(l===0&&!r)continue;const u=a.shape[l],c=t[o][l];if(c!=null&&c>=0&&u!==c)throw new Ce(`${s} expected a batch of elements where each example has shape [${t[o].slice(1,t[o].length)}] (i.e.,tensor shape [*,${t[o].slice(1,t[o].length)}]) but the ${s} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return i}function ahe(n,e,t){const r=Td(n.map(i=>i.shape[0]));r.sort();const s=Td(e.map(i=>i.shape[0]));if(s.sort(),r.length>1)throw new Ce(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(i=>i.shape))}`);if(s.length>1)throw new Ce(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(i=>i.shape))}`);if(r.length>0&&s.length>0&&!_r(r,s))throw new Ce(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function lhe(n,e,t){const r=[ME,kE,Tx];for(let s=0;s<n.length;++s){const i=n[s],o=e[s],a=t[s];if(o!=null){if(o===Tx&&i.shape[i.shape.length-1]===1)throw new Ce(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(o)!==-1){const l=i.shape.slice(1),u=a.slice(1);for(let c=0;c<l.length;++c){const h=l[c],d=u[c];if(d!=null&&h!==d)throw new Ce(`A target Tensor with shape ${i.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function wL(n,e,t,r=!0,s=""){let i;if(Array.isArray(n)){if(n.length!==e.length)throw new Ce(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);i=n}else{if(e.length>1)throw new Ce(`The model expects ${e.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);i=[n]}if(t!=null)for(let o=0;o<e.length;++o){if(t[o]==null)continue;const a=i[o];if(a.shape.length!==t[o].length)throw new Ce(`Error when checking ${s}: expected ${e[o]} to have ${t[o].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let l=0;l<t[o].length;++l){if(l===0&&!r)continue;const u=a.shape[l],c=t[o][l];if(c!=null&&c!==u)throw new Ce(`Error when checking ${s}: expected ${e[o]} to have shape ${JSON.stringify(t[o])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function uhe(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(r=>t);{const r=[];for(const s of e){let i=t.hasOwnProperty(s)?t[s]:[];Array.isArray(i)||(i=[i]),r.push(i)}return r}}const che="layers-model";class cy extends su{constructor(e){super(e),this.isTraining=!1}summary(e,t,r=console.log){if(!this.built)throw new Ce("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");jce(this,e,t,r)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=Hce(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof tf))throw new Ce("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const o in e.loss)if(this.outputNames.indexOf(o)===-1)throw new Ce(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)e.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),t.push(H2(e.loss[o]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Ce(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>H2(a))}else{const o=H2(e.loss);this.outputs.forEach(a=>{t.push(o)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const a=this.internalOutputShapes[o],l=this.outputNames[o];this.feedOutputNames.push(l),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[o])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Rp("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const a=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([a,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const s=uhe(e.metrics,this.outputNames),i=(o,a,l)=>{this.outputNames.length>1&&(a=this.outputNames[o]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([l,o])};Rp("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const a=s[o];(u=>{let h,d,p;for(const g of u){if(typeof g=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(g)!==-1){const y=this.internalOutputShapes[o];y[y.length-1]===1||this.lossFunctions[o]===kE?["accuracy","acc"].indexOf(g)!==-1?d=CV:["crossentropy","ce"].indexOf(g)!==-1&&(d=Pce):this.lossFunctions[o]===m_?["accuracy","acc"].indexOf(g)!==-1?d=Lce:["crossentropy","ce"].indexOf(g)!==-1&&(d=AV):["accuracy","acc"].indexOf(g)!==-1?d=IV:["crossentropy","ce"].indexOf(g)!==-1&&(d=NV);let x;["accuracy","acc"].indexOf(g)!==-1?x="acc":["crossentropy","ce"].indexOf(g)!==-1&&(x="ce"),p=d,h=""+x}else p=Gce(g),h=""+fS(g);let w;Rp(h,()=>{w=p}),i(o,h,w)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,r={}){const s=r.batchSize==null?32:r.batchSize;j2(s);const o=this.standardizeUserDataXY(e,t,!0,s);try{const a=o[0].concat(o[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,a,s,r.verbose,r.steps);return Vo(u)}finally{nu(o[0],e),nu(o[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),ihe(this,e,t)}checkNumSamples(e,t,r,s="steps"){let i;if(r!=null){if(i=null,t!=null)throw new Ce(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?i=e[0].shape[0]:i=e.shape[0];else throw new Ce(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return i}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new Ce("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(t),s=r?t:[t],i=this.retrieveSymbolicTensors(s),o=new yd;if(e instanceof Zs&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Ce(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)o.add(this.inputs[l],e[l])}else for(const l of this.inputs){const u=e[l.name];if(u==null)throw new Ce(`No value is provided for the model's input ${l.name}`);o.add(l,u)}const a=$v(i,o);return r?a:a[0]}retrieveSymbolicTensors(e){const t=qp(null,e.length);let r=e.length;for(const s of this.layers){const i=Array.isArray(s.output)?s.output:[s.output],o=i.map(a=>a.name);for(let a=0;a<e.length;++a){const l=o.indexOf(e[a]);if(l!==-1&&(t[a]=i[l],r--),r===0)break}if(r===0)break}if(r>0){const s=[];throw t.forEach((i,o)=>{i==null&&s.push(e[o])}),new Ce(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return t}predictLoop(e,t=32,r=!1){return ze(()=>{const s=this.checkNumSamples(e);if(r)throw new Fn("Verbose predictLoop() is not implemented yet.");const i=X2(s,t),o=this.outputs.map(a=>[]);for(let a=0;a<i.length;++a)ze(()=>{const u=i[a][0],c=i[a][1],h=Cv(e,u,c),d=[];if(Array.isArray(h))for(let g=0;g<h.length;++g)d.push({key:this.inputs[g],value:h[g]});else d.push({key:this.inputs[0],value:h});const p=new yd(d);return $v(this.outputs,p)}).forEach((u,c)=>o[c].push(u));return Vo(o.map(a=>Xo(a,0)))})}predict(e,t={}){const r=PV(e);wL(r,this.inputNames,this.feedInputShapes,!1);try{const s=t.batchSize==null?32:t.batchSize;return j2(s),this.predictLoop(r,s)}finally{nu(r,e)}}predictOnBatch(e){wL(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,r=!0,s){if(this.optimizer_==null)throw new yl("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const a=this.feedOutputShapes[o];this.feedLossFns[o]===m_?i.push(a.slice(0,a.length-1).concat([1])):i.push(a)}if(e=xL(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=xL(t,this.feedOutputNames,i,!1,"target"),ahe(e,t),lhe(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&e[0].shape[0]%s!==0)throw new Ce(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,r,s,i=!0,o){const[a,l]=this.standardizeUserDataXY(e,t,i,o);if(r!=null)throw new Error("sample weight is not supported yet.");let u=null;if(s!=null){const c=RV(s,this.outputNames);u=[];for(let h=0;h<c.length;++h)u.push(await DV(l[h],null,c[h]))}return[a,l,u]}testLoop(e,t,r,s=0,i){return ze(()=>{const o=this.checkNumSamples(t,r,i,"steps"),a=[];if(s>0)throw new Fn("Verbose mode is not implemented yet.");if(i!=null)throw new Fn("steps mode in testLoop() is not implemented yet");{const l=X2(o,r),u=ba(gu(0,o));for(let c=0;c<l.length;++c){const h=l[c][0],d=l[c][1],p=Dp(u,h,d-h),g=DN(t,p),w=e(g);if(c===0)for(let y=0;y<w.length;++y)a.push(Sr(0));for(let y=0;y<w.length;++y){const x=w[y];a[y]=xt(a[y],Ae(d-h,x))}}for(let c=0;c<a.length;++c)a[c]=hn(a[c],o)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let r=0;r<e.length;++r){const s=e[r];let i=s;if(sL(e,s)>1){const o=sL(e.slice(0,r),s);i+=`_${o}`}t.push(i)}return t}makeTrainFunction(){return e=>{const t=[],r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],a=()=>{const h=[];for(let w=0;w<this.inputs.length;++w)h.push({key:this.inputs[w],value:r[w]});const d=new yd(h),p=$v(this.outputs,d,{training:!0});let g;for(let w=0;w<this.lossFunctions.length;++w){const y=this.lossFunctions[w];let x=y(s[w],p[w]);i[w]!=null&&(x=Qce(x,i[w]));const _=Fs(x);t.push(_),w===0?g=x:g=xt(g,x)}for(let w=0;w<this.metricsTensors.length;++w){let y;if(this.outputs.length>1&&w<this.outputs.length)y=t[w];else{const x=this.metricsTensors[w][0],_=this.metricsTensors[w][1];y=Fs(x(s[_],p[_]))}qu(y),o.push(y)}return g=Fs(g),this.calculateLosses().forEach(w=>{g=xt(g,w)}),g},l=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(a,!0,l)].concat(o)}}makeTestFunction(){this.testFunction=e=>ze(()=>{const t=[];let r;const s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let u=0;u<this.inputs.length;++u)o.push({key:this.inputs[u],value:s[u]});const a=new yd(o),l=$v(this.outputs,a);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],h=Fs(c(i[u],l[u]));u===0?r=h:r=xt(r,h),t.push(r)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],h=this.metricsTensors[u][1],d=Fs(c(i[h],l[h]));t.push(d)}return t})}async fit(e,t,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let s,i,o,a,l,u,c,h,d;try{const p=r.batchSize==null?32:r.batchSize;j2(p);const w=await this.standardizeUserData(e,t,r.sampleWeight,r.classWeight,!1,p);s=w[0],i=w[1],d=w[2];let y=!1,x;if(r.validationData!=null&&r.validationData.length>0){if(y=!0,r.validationData.length===2)l=r.validationData[0],u=r.validationData[1];else throw r.validationData.length===3?new Fn("validationData including sample weights is not supported yet."):new Ce(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const R=await this.standardizeUserData(l,u,null,null,!0,p);c=R[0],h=R[1],x=c.concat(h)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){y=!0;const k=Math.floor(s[0].shape[0]*(1-r.validationSplit)),R=s[0].shape[0];c=Cv(s,k,R),o=s,s=Cv(s,0,k),h=Cv(i,k,R),a=i,i=Cv(i,0,k),x=c.concat(h)}else r.validationSteps!=null&&(y=!0);const _=s.concat(i).concat(d);this.checkTrainableWeightsConsistency();const T=this.makeTrainFunction(),E=this.getDedupedMetricsNames();let N,M;y?(this.makeTestFunction(),N=this.testFunction,M=E.slice().concat(E.map(k=>"val_"+k))):(N=null,x=[],M=E.slice());const $=_V(r.callbacks,r.yieldEvery);return await this.fitLoop(T,_,E,p,r.epochs,r.verbose,$,N,x,r.shuffle,M,r.initialEpoch,null,null)}finally{this.isTraining=!1,nu(s,e),nu(i,t),nu(o,e),nu(a,t),nu(c,l),nu(h,u),d!=null&&Yn(d)}}async fitLoop(e,t,r,s,i,o,a,l,u,c,h,d,p,g){s==null&&(s=32),i==null&&(i=1),c==null&&(c=!0),d==null&&(d=0);let w=!1;if(l!=null&&u!=null&&(w=!0),g!=null&&(w=!0,p==null))throw new Ce("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const y=this.checkNumSamples(t,s,p,"steps_per_epoch");let x;y!=null&&(x=gu(0,y)),o==null&&(o=1);const{callbackList:_,history:T}=TV(a,o,i,d,y,p,s,w,h);_.setModel(this),this.history=T,await _.onTrainBegin(),this.stopTraining_=!1;for(let E=d;E<i;++E){await _.onEpochBegin(E);const N={};if(p!=null)throw new Fn("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Fn("batch shuffling is not implemneted yet");c&&Hee(x);const M=ba(x),$=X2(y,s);for(let L=0;L<$.length;++L){const k={};if(await _.onBatchBegin(L,k),ze(()=>{const R=$[L][0],P=$[L][1],B=Dp(M,R,P-R);k.batch=L,k.size=P-R;const Z=DN(t,B),V=e(Z);for(let X=0;X<r.length;++X){const q=r[X],se=V[X];k[q]=se,qu(se)}if(L===$.length-1&&w){const X=this.testLoop(l,u,s);for(let q=0;q<r.length;++q){const se=r[q],W=X[q];qu(W),N["val_"+se]=W}}}),await _.onBatchEnd(L,k),SV(k),this.stopTraining_)break}M.dispose()}if(await _.onEpochEnd(E,N),this.stopTraining_)break}return await _.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return nhe(this,e,t)}async trainOnBatch(e,t){const r=await this.standardizeUserData(e,t),s=r[0],i=r[1],a=this.makeTrainFunction()(s.concat(i)),l=[];for(const u of a){const c=await u.data();l.push(c[0])}return Yn(a),nu(r[0],e),nu(r[1],t),Vo(l)}getNamedWeights(e){const t=[],r=e!=null&&e.trainableOnly,s=r?this.trainableWeights:this.weights,i=this.getWeights(r);for(let o=0;o<s.length;++o)r&&!s[o].trainable||t.push({name:s[o].originalName,tensor:i[o]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=kP().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-kP().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=qc(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>qc(t))}else{const t=Object.keys(this.loss);e={};const r=this.loss;for(const s of t)if(typeof r[s]=="string")e[s]=qc(r[s]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[qc(fS(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>qc(fS(e)));{const e={};for(const t in this.metrics)e[t]=qc(fS(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=kN(e.optimizer_config),r=oh(t);let s;if(typeof e.loss=="string")s=dp(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(o=>dp(o));else if(e.loss!=null){s={};for(const o in e.loss)s[o]=dp(e.loss[o])}let i;if(Array.isArray(e.metrics))i=e.metrics.map(o=>dp(o));else if(e.metrics!=null){i={};for(const o in e.metrics)i[o]=dp(e.metrics[o])}this.compile({loss:s,metrics:i,optimizer:r})}async save(e,t){if(typeof e=="string"){const u=Ute(e);if(u.length===0)throw new Ce(`Cannot find any save handlers for URL '${e}'`);if(u.length>1)throw new Ce(`Found more than one (${u.length}) save handlers for URL '${e}'`);e=u[0]}if(e.save==null)throw new Ce("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await DP(this.getNamedWeights(t)),a={modelTopology:this.toJSON(null,!1),format:che,generatedBy:`TensorFlow.js tfjs-layers v${kV}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:h}=await DP(await this.optimizer.getWeights(),u);r.specs.push(...h),r.data=Bte([r.data,c])}return this.userDefinedMetadata!=null&&(mL(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=r.data,a.weightSpecs=r.specs,e.save(a)}setUserDefinedMetadata(e){mL(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}cy.className="Model";ft(cy);class LV extends cy{}LV.className="Functional";ft(LV);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ex extends cy{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:IE("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new Ce(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Ex||e instanceof cy;let r;if(t){if(r=e,r.outputs.length!==1)throw new Ce("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new Ce("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new Ce("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=dce({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(t)this.outputs=r.outputs,this.inputs=r.inputs;else{if(e.inboundNodes.length!==1)throw new Ce(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new Ce("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=yV(this.outputs[0])}this.inboundNodes=[],new AE({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:qp(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(fr(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new cy({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,r=console.log){this.built||this.build(),super.summary(e,t,r)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,r={}){if(!this.built)throw new yl("The model needs to be compiled before being used.");return this.model.evaluate(e,t,r)}async evaluateDataset(e,t){if(!this.built)throw new yl("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,r={}){if(!this.built)throw new yl("The model needs to be compiled before being used.");return this.model.fit(e,t,r)}async fitDataset(e,t){if(!this.built)throw new yl("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,r={},s=!1){let i,o={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new Ce("Legacy serialization format not supported yet.");i=t}else ie(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=t.layers,delete t.layers,o=t;const a=new e(o);if(!(a instanceof Ex))throw new Fn(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const l of i){const c=oh(l,void 0,s);s&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(e){if(this.model==null)throw new Ce("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new Ce("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const r={};r.className=t.getClassName(),r.config=t.getConfig(),e.push(r)}return{name:this.name,layers:e}}}Ex.className="Sequential";ft(Ex);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let ea=class extends Qy{getConfig(){return{}}},OV=class extends ea{apply(e,t=1){return Yue(e,t)}};OV.className="elu";ft(OV);let FV=class extends ea{apply(e){return t4(e)}};FV.className="selu";ft(FV);let zV=class extends ea{apply(e){return cm(e)}};zV.className="relu";ft(zV);let BV=class extends ea{apply(e){return ze(()=>bx(6,cm(e)))}};BV.className="relu6";ft(BV);class UV extends ea{apply(e){return e}}UV.className="linear";ft(UV);let VV=class extends ea{apply(e){return Ky(e)}};VV.className="sigmoid";ft(VV);class WV extends ea{apply(e){return Jue(e)}}WV.className="hardSigmoid";ft(WV);let GV=class extends ea{apply(e){return Q1(e)}};GV.className="softplus";ft(GV);class HV extends ea{apply(e){return Zue(e)}}HV.className="softsign";ft(HV);let jV=class extends ea{apply(e){return mk(e)}};jV.className="tanh";ft(jV);let AR=class extends ea{apply(e,t=-1){return Rk(e,t)}};AR.className="softmax";ft(AR);class XV extends ea{apply(e,t=-1){return XU(e,t)}}XV.className="logSoftmax";ft(XV);class qV extends ea{apply(e,t=1){return ze(()=>Ae(Ky(Ae(e,t)),e))}}qV.className="swish";ft(qV);class KV extends ea{apply(e){return ze(()=>Ae(e,mk(Q1(e))))}}KV.className="mish";ft(KV);function $d(n){return n.getClassName()}function q2(n,e={}){return ow(n,e0.getMap().classNameMap,e,"activation")}function Pd(n){if(n==null){const e={};return e.className="linear",e.config={},q2(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},q2(e)}else return n instanceof ea?n:q2(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hhe(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class YV extends Qy{}class ZV extends YV{constructor(e){super(),hhe(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ze(()=>{let t=gi([1]);return this.hasL1&&(t=xt(t,an(Ae(this.l1,ho(e))))),this.hasL2&&(t=xt(t,an(Ae(this.l2,lw(e))))),$e(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}ZV.className="L1L2";ft(ZV);const bL={l1l2:"L1L2"};function Ur(n){return mR(n)}function SL(n,e={}){return ow(n,e0.getMap().classNameMap,e,"regularizer")}function as(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in bL?bL[n]:n,config:{}};return SL(t)}else return n instanceof YV?n:SL(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class JV extends Kn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=wn(e);let r=cm(e);return this.maxValue!=null&&(r=qa(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}JV.className="ReLU";ft(JV);class QV extends Kn{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=wn(e);return _k(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}QV.className="LeakyReLU";ft(QV);class eW extends Kn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=os(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=as(e.alphaRegularizer),this.alphaConstraint=ti(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new Ce(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=fr(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const s of this.sharedAxes)t[s-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let s=1;s<e.length;++s)r[s]=e[s];this.inputSpec=[new Qs({ndim:e.length,axes:r})],this.built=!0}call(e,t){return e=wn(e),Ak(e,this.alpha.read())}getConfig(){const e={alphaInitializer:ds(this.alphaInitializer),alphaRegularizer:Ur(this.alphaRegularizer),alphaConstraint:ei(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}eW.className="PReLU";ft(eW);let tW=class extends Kn{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Fn(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=wn(e);return wE(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};tW.className="ELU";ft(tW);class nW extends Kn{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const r=wn(e);return Ae(r,Ot(Ya(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}nW.className="ThresholdedReLU";ft(nW);let rW=class extends Kn{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new AR().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return ze(()=>{let r=wn(e);const s=t.mask;if(s!=null){const i=Ae(yn(ef(r.shape),Ot(s,r.dtype)),Sr(-1e9));r=xt(r,i)}return this.axis instanceof Array?this.axis.length>1?rc(yn(r,qU(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};rW.className="Softmax";ft(rW);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hy(n,e,t){if(typeof n=="number")return qp(n,e);if(n.length!==e)throw new Ce(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let r=0;r<e;++r){const s=n[r];if(!jue(s))throw new Ce(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${s}`)}return n}function pu(n,e,t,r,s=1){if(n==null)return n;const i=e+(e-1)*(s-1);let o;return t==="same"?o=n:o=n-i+1,Math.floor((o+r-1)/r)}function Uu(n,e,t,r){if(n==null)return null;if(r==="valid")n=n*e+Dd([t-e,0]);else if(r==="same")n=n*e;else throw new Ce(`Unsupport padding mode: ${r}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function MR(n,e){return ze(()=>(ks(e),e==="channelsFirst"?ir(n,[0,2,3,1]):n))}function sW(n,e){return ze(()=>(ks(e),e==="channelsFirst"?ir(n,[0,2,3,4,1]):n))}function dhe(n,e,t,r=1,s="valid",i,o=1){return ze(()=>{if(i==null&&(i=yu()),ks(i),n.shape.length!==3)throw new Ce(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new Ce(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new Ce(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(i==="channelsFirst"&&(n=ir(n,[0,2,1])),s==="causal")throw new Fn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=FU(n,e,r,s==="same"?"same":"valid","NWC",o);return t!=null&&(a=bu(a,t)),a})}function _L(n,e,t,r=[1,1],s="valid",i,o,a=null){return ze(()=>{if(i==null&&(i=yu()),ks(i),n.rank!==3&&n.rank!==4)throw new Ce(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new Ce(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=MR(n,i);if(s==="causal")throw new Fn("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=boe({x:l,filter:e,strides:r,pad:s==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:t,activation:a}),i==="channelsFirst"&&(l=ir(l,[0,3,1,2])),l})}function fhe(n,e,t,r=[1,1,1],s="valid",i,o){return ze(()=>{if(i==null&&(i=yu()),ks(i),n.rank!==4&&n.rank!==5)throw new Ce(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new Ce(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let a=sW(n,i);if(s==="causal")throw new Fn("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=yre(a,e,r,s==="same"?"same":"valid","NDHWC",o),t!=null&&(a=bu(a,t)),i==="channelsFirst"&&(a=ir(a,[0,4,1,2,3])),a})}class RE extends Kn{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",RE.verifyArgs(t),this.rank=e,vi(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Fn(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=hy(t.kernelSize,e,"kernelSize"),this.strides=hy(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,Za(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,ks(this.dataFormat),this.activation=Pd(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=os(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=ti(t.biasConstraint),this.biasRegularizer=as(t.biasRegularizer),this.activityRegularizer=as(t.activityRegularizer),this.dilationRate=hy(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Ce(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Ce(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Ce(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Bu("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!gR(e.kernelSize,"number",1,3))throw new Ce(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:$d(this.activation),useBias:this.useBias,biasInitializer:ds(this.biasInitializer),biasRegularizer:Ur(this.biasRegularizer),activityRegularizer:Ur(this.activityRegularizer),biasConstraint:ei(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class t0 extends RE{constructor(e,t){super(e,t),this.kernel=null,t0.verifyArgs(t),this.filters=t.filters,vi(this.filters,"filters"),this.kernelInitializer=os(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=ti(t.kernelConstraint),this.kernelRegularizer=as(t.kernelRegularizer)}build(e){e=fr(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Ce(`The channel dimension of the input should be defined. Found ${e[t]}`);const r=e[t],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:r}}],this.built=!0}call(e,t){return ze(()=>{e=wn(e);let r;const s=this.bias==null?null:this.bias.read(),i=nV(this.activation.getClassName());if(i!=null&&this.rank===2)r=_L(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,i);else{if(this.rank===1)r=dhe(e,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=_L(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=fhe(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Fn("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(e){e=fr(e);const t=[],r=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let i=0;i<r.length;++i){const o=pu(r[i],this.kernelSize[i],this.padding,this.strides[i],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[i]);t.push(o)}let s=[e[0]];return this.dataFormat==="channelsLast"?(s=s.concat(t),s.push(this.filters)):(s.push(this.filters),s=s.concat(t)),s}getConfig(){const e={filters:this.filters,kernelInitializer:ds(this.kernelInitializer),kernelRegularizer:Ur(this.kernelRegularizer),kernelConstraint:ei(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new Ce(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}let kR=class iW extends t0{constructor(e){super(2,e),iW.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!gR(e.kernelSize,"number",1,2))throw new Ce(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};kR.className="Conv2D";ft(kR);let RR=class oW extends t0{constructor(e){super(3,e),oW.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new Ce(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};RR.className="Conv3D";ft(RR);class aW extends kR{constructor(e){if(super(e),this.inputSpec=[new Qs({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Ce(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=fr(e),e.length!==4)throw new Ce("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Ce("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qs({ndim:4,axes:{[t]:r}})],this.built=!0}call(e,t){return ze(()=>{let r=wn(e);if(r.shape.length!==4)throw new Ce(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,i=s[0];let o,a;this.dataFormat==="channelsFirst"?(o=2,a=3):(o=1,a=2);const l=s[o],u=s[a],c=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],p=this.strides[1],g=Uu(l,d,c,this.padding),w=Uu(u,p,h,this.padding),y=[i,g,w,this.filters];this.dataFormat!=="channelsLast"&&(r=ir(r,[0,2,3,1]));let x=zU(r,this.kernel.read(),y,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=ir(x,[0,3,1,2])),this.bias!=null&&(x=bu(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(e){e=fr(e);const t=e.slice();let r,s,i;this.dataFormat==="channelsFirst"?(r=1,s=2,i=3):(r=3,s=1,i=2);const o=this.kernelSize[0],a=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return t[r]=this.filters,t[s]=Uu(t[s],l,o,this.padding),t[i]=Uu(t[i],u,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}aW.className="Conv2DTranspose";ft(aW);class lW extends RR{constructor(e){if(super(e),this.inputSpec=[new Qs({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Ce(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=fr(e),e.length!==5)throw new Ce("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Ce("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Qs({ndim:5,axes:{[t]:r}})],this.built=!0}call(e,t){return ze(()=>{let r=wn(e);if(r.shape.length!==5)throw new Ce(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,i=s[0];let o,a,l;this.dataFormat==="channelsFirst"?(l=2,o=3,a=4):(l=1,o=2,a=3);const u=s[l],c=s[o],h=s[a],d=this.kernelSize[0],p=this.kernelSize[1],g=this.kernelSize[2],w=this.strides[0],y=this.strides[1],x=this.strides[2],_=Uu(u,w,d,this.padding),T=Uu(c,y,p,this.padding),E=Uu(h,x,g,this.padding),N=[i,_,T,E,this.filters];this.dataFormat!=="channelsLast"&&(r=ir(r,[0,2,3,4,1]));let M=wre(r,this.kernel.read(),N,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(M=ir(M,[0,4,1,2,3])),this.bias!==null&&(M=bu(M,this.bias.read(),this.dataFormat)),this.activation!==null&&(M=this.activation.apply(M)),M})}computeOutputShape(e){e=fr(e);const t=e.slice();let r,s,i,o;this.dataFormat==="channelsFirst"?(r=1,s=2,i=3,o=4):(r=4,s=1,i=2,o=3);const a=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],h=this.strides[1],d=this.strides[2];return t[r]=this.filters,t[s]=Uu(t[s],c,a,this.padding),t[i]=Uu(t[i],h,l,this.padding),t[o]=Uu(t[o],d,u,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}lW.className="Conv3DTranspose";ft(lW);class uW extends t0{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new Ce("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new Ce("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new Ce(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=os(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=as(t.depthwiseRegularizer),this.depthwiseConstraint=ti(t.depthwiseConstraint),this.pointwiseInitializer=os(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=as(t.pointwiseRegularizer),this.pointwiseConstraint=ti(t.pointwiseConstraint)}build(e){if(e=fr(e),e.length<this.rank+2)throw new Ce(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new Ce(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const r=e[t],s=this.kernelSize.concat([r,this.depthMultiplier]),i=[];for(let a=0;a<this.rank;++a)i.push(1);i.push(r*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new Qs({ndim:this.rank+2,axes:{[t]:r}})],this.built=!0}call(e,t){return ze(()=>{e=wn(e);let r;if(this.rank===1)throw new Fn("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=ir(e,[0,2,3,1])),r=n4(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=bu(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=ir(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=ds(this.depthwiseInitializer),e.pointwiseInitializer=ds(this.pointwiseInitializer),e.depthwiseRegularizer=Ur(this.depthwiseRegularizer),e.pointwiseRegularizer=Ur(this.pointwiseRegularizer),e.depthwiseConstraint=ei(this.depthwiseConstraint),e.pointwiseConstraint=ei(this.pointwiseConstraint),e}}uW.className="SeparableConv";class cW extends uW{constructor(e){super(2,e)}}cW.className="SeparableConv2D";ft(cW);class DE extends t0{constructor(e){super(1,e),DE.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!gR(e.kernelSize,"number",1,1))throw new Ce(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}DE.className="Conv1D";ft(DE);class hW extends Kn{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ze(()=>{if(e=wn(e),this.dataFormat==="channelsLast"){const r=dS(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return dS(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=dS(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return dS(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}hW.className="Cropping2D";ft(hW);class dW extends Kn{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ks(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,Wue(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],r=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,r]}else{const t=e[1]==null?null:this.size[0]*e[1],r=e[2]==null?null:this.size[1]*e[2];return[e[0],t,r,e[3]]}}call(e,t){return ze(()=>{let r=wn(e);const s=r.shape;if(this.dataFormat==="channelsFirst"){r=ir(r,[0,2,3,1]);const i=this.size[0]*s[2],o=this.size[1]*s[3],a=this.interpolation==="nearest"?nh.resizeNearestNeighbor(r,[i,o]):nh.resizeBilinear(r,[i,o]);return ir(a,[0,3,1,2])}else{const i=this.size[0]*s[1],o=this.size[1]*s[2];return this.interpolation==="nearest"?nh.resizeNearestNeighbor(r,[i,o]):nh.resizeBilinear(r,[i,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}dW.className="UpSampling2D";ft(dW);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function phe(n,e,t=[1,1],r="valid",s,i){return ze(()=>{s==null&&(s=yu()),ks(s);let o=MR(n,s);if(n.rank!==4)throw new Ce(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new Ce(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return o=xk(o,e,t,r==="same"?"same":"valid","NHWC",i),s==="channelsFirst"&&(o=ir(o,[0,3,1,2])),o})}class fW extends RE{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=os(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=ti(e.depthwiseConstraint),this.depthwiseRegularizer=as(e.depthwiseRegularizer)}build(e){if(e=fr(e),e.length<4)throw new Ce(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new Ce(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const r=e[t],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ze(()=>{e=wn(e);let r=phe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=bu(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=fr(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=pu(t,this.kernelSize[0],this.padding,this.strides[0]),o=pu(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],s,i,o]:[e[0],i,o,s]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=ds(this.depthwiseInitializer),e.depthwiseRegularizer=Ur(this.depthwiseRegularizer),e.depthwiseConstraint=ei(this.depthwiseRegularizer),e}}fW.className="DepthwiseConv2D";ft(fW);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function pW(n,e,t,r){if(Array.isArray(n)){if(e!=null||t!=null)throw new Ce("When inputs is an array, neither initialState or constants should be provided");r!=null&&(t=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function s(i){return i==null||Array.isArray(i)?i:[i]}return e=s(e),t=s(t),{inputs:n,initialState:e,constants:t}}function mW(n,e,t,r=!1,s,i,o=!1,a=!1){return ze(()=>{const l=e.shape.length;if(l<3)throw new Ce(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(gu(2,l));e=ir(e,u),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=Ot(Ot(s,"bool"),"float32"),s.rank===l-1&&(s=Uo(s,-1)),s=ir(s,u)),r&&(e=jp(e,0),s!=null&&(s=jp(s,0)));const c=[];let h,d=t;const p=e.shape[0],g=Xp(e);let w;s!=null&&(w=Xp(s));for(let x=0;x<p;++x){const _=g[x],T=ze(()=>n(_,d));if(s==null)h=T[0],d=T[1];else{const E=ze(()=>{const N=w[x],M=yn(Sl(N),N),$=xt(Ae(T[0],N),Ae(d[0],M)),L=d.map((k,R)=>xt(Ae(T[1][R],N),Ae(k,M)));return{output:$,newStates:L}});h=E.output,d=E.newStates}a&&c.push(h)}let y;return a&&(y=uh(c,1)),[h,y,d]})}class nf extends Kn{constructor(e){super(e);let t;if(e.cell==null)throw new Ce("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new PR({cells:e.cell}):t=e.cell,t.stateSize==null)throw new Ce("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Qs({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return gu(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){NN(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const r=t[0];let s;if(this.returnSequences?s=[e[0],e[1],r]:s=[e[0],r],this.returnState){const i=[];for(const o of t)i.push([e[0],o]);return[s].concat(i)}else return s}computeMask(e,t){return ze(()=>{Array.isArray(t)&&(t=t[0]);const r=this.returnSequences?t:null;if(this.returnState){const s=this.states.map(i=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let r=0;r<e;++r)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Fn("Constants support is not implemented in RNN yet.");NN(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new Qs({shape:[t,null,...r]});const s=[e[0]].concat(e.slice(2));this.cell.build(s);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!_r(this.stateSpec.map(o=>o.shape[o.shape.length-1]),i))throw new Ce(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(o=>new Qs({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){ze(()=>{if(!this.stateful)throw new zu("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new Ce("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>gi([r,s])):this.states_=[gi([r,this.cell.stateSize])];else if(e==null)Yn(this.states_),this.keptStates!=null&&(Yn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>gi([r,s])):this.states_[0]=gi([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Ce(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Yn(this.states_);for(let s=0;s<this.states_.length;++s){const i=e[s],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,a=[r,o];if(!_r(i.shape,a))throw new Ce(`State ${s} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(s=>qu(s.clone()))})}apply(e,t){let r=t==null?null:t.initialState,s=t==null?null:t.constants;t==null&&(t={});const i=pW(e,r,s,this.numConstants);e=i.inputs,r=i.initialState,s=i.constants;let o=[],a=[];if(r!=null){t.initialState=r,o=o.concat(r),this.stateSpec=[];for(const u of r)this.stateSpec.push(new Qs({shape:u.shape}));a=a.concat(this.stateSpec)}if(s!=null&&(t.constants=s,o=o.concat(s),this.numConstants=s.length),o[0]instanceof ic){const u=[e].concat(o),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const d=super.apply(u,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return ze(()=>{const r=t==null?null:t.mask,s=t==null?null:t.training;let i=t==null?null:t.initialState;e=wn(e),i==null&&(this.stateful?i=this.states_:i=this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new Ce(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:s},u=mW((g,w)=>{const y=this.cell.call([g].concat(w),a);return[y[0],y.slice(1)]},e,i,this.goBackwards,r,null,this.unroll,this.returnSequences),c=u[0],h=u[1],d=u[2];this.stateful&&this.resetStates(d,s);const p=this.returnSequences?h:c;return this.returnState?[p].concat(d):p})}getInitialState(e){return ze(()=>{let t=gi(e.shape);return t=an(t,[1,2]),t=aw(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?CN(t,[1,r]):t):this.cell.stateSize>1?[CN(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===nf.className&&(t.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),t)}static fromConfig(e,t,r={}){const s=t.cell,i=oh(s,r);return new e(Object.assign(t,{cell:i}))}}nf.className="RNN";ft(nf);class $E extends Kn{}class DR extends $E{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,vi(this.units,"units"),this.activation=Pd(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=os(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=os(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=os(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=as(e.kernelRegularizer),this.recurrentRegularizer=as(e.recurrentRegularizer),this.biasRegularizer=as(e.biasRegularizer),this.kernelConstraint=ti(e.kernelConstraint),this.recurrentConstraint=ti(e.recurrentConstraint),this.biasConstraint=ti(e.biasConstraint),this.dropout=Iy([1,Dd([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Iy([1,Dd([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=fr(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ze(()=>{if(e=e,e.length!==2)throw new Ce(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const s=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ld({ones:()=>Sl(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ld({ones:()=>Sl(r),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let i;const o=this.dropoutMask,a=this.recurrentDropoutMask;o!=null?i=Zu(Ae(e,o),this.kernel.read()):i=Zu(e,this.kernel.read()),this.bias!=null&&(i=bu(i,this.bias.read())),a!=null&&(r=Ae(r,a));let l=xt(i,Zu(r,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:$d(this.activation),useBias:this.useBias,kernelInitializer:ds(this.kernelInitializer),recurrentInitializer:ds(this.recurrentInitializer),biasInitializer:ds(this.biasInitializer),kernelRegularizer:Ur(this.kernelRegularizer),recurrentRegularizer:Ur(this.recurrentRegularizer),biasRegularizer:Ur(this.biasRegularizer),activityRegularizer:Ur(this.activityRegularizer),kernelConstraint:ei(this.kernelConstraint),recurrentConstraint:ei(this.recurrentConstraint),biasConstraint:ei(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}DR.className="SimpleRNNCell";ft(DR);class gW extends nf{constructor(e){e.cell=new DR(e),super(e)}call(e,t){return ze(()=>{this.cell.dropoutMask!=null&&(Yn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,t){return new e(t)}}gW.className="SimpleRNN";ft(gW);class $R extends $E{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Ce("GRUCell does not support reset_after parameter set to true.");this.units=e.units,vi(this.units,"units"),this.activation=Pd(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Pd(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=os(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=os(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=os(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=as(e.kernelRegularizer),this.recurrentRegularizer=as(e.recurrentRegularizer),this.biasRegularizer=as(e.biasRegularizer),this.kernelConstraint=ti(e.kernelConstraint),this.recurrentConstraint=ti(e.recurrentConstraint),this.biasConstraint=ti(e.biasConstraint),this.dropout=Iy([1,Dd([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Iy([1,Dd([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=fr(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ze(()=>{if(e=e,e.length!==2)throw new Ce(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training==null?!1:t.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ld({ones:()=>Sl(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ld({ones:()=>Sl(s),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let a,l,u;0<this.dropout&&this.dropout<1&&(e=Ae(e,i[0]));let c=Zu(e,this.kernel.read());this.useBias&&(c=bu(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Ae(s,o[0]));const h=this.recurrentKernel.read(),[d,p]=ja(h,[2*this.units,this.units],h.rank-1),g=Zu(s,d),[w,y,x]=ja(c,3,c.rank-1),[_,T]=ja(g,2,g.rank-1);a=this.recurrentActivation.apply(xt(w,_)),l=this.recurrentActivation.apply(xt(y,T));const E=Zu(Ae(l,s),p);u=this.activation.apply(xt(x,E));const N=xt(Ae(a,s),Ae(xt(1,Is(a)),u));return[N,N]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:$d(this.activation),recurrentActivation:$d(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ds(this.kernelInitializer),recurrentInitializer:ds(this.recurrentInitializer),biasInitializer:ds(this.biasInitializer),kernelRegularizer:Ur(this.kernelRegularizer),recurrentRegularizer:Ur(this.recurrentRegularizer),biasRegularizer:Ur(this.biasRegularizer),activityRegularizer:Ur(this.activityRegularizer),kernelConstraint:ei(this.kernelConstraint),recurrentConstraint:ei(this.recurrentConstraint),biasConstraint:ei(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}$R.className="GRUCell";ft($R);class yW extends nf{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new $R(e),super(e)}call(e,t){return ze(()=>{this.cell.dropoutMask!=null&&(Yn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}yW.className="GRU";ft(yW);class PE extends $E{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,vi(this.units,"units"),this.activation=Pd(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Pd(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=os(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=os(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=os(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=as(e.kernelRegularizer),this.recurrentRegularizer=as(e.recurrentRegularizer),this.biasRegularizer=as(e.biasRegularizer),this.kernelConstraint=ti(e.kernelConstraint),this.recurrentConstraint=ti(e.recurrentConstraint),this.biasConstraint=ti(e.biasConstraint),this.dropout=Iy([1,Dd([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Iy([1,Dd([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=fr(e);const r=e[e.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;s=new(t=class extends Cl{apply(l,u){const c=i.apply([o]),h=new vR().apply([o]),d=i.apply([o*2]);return oL(oL(c,h),d)}},t.className="CustomInit",t)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ze(()=>{const r=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new Ce(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ld({ones:()=>Sl(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ld({ones:()=>Sl(s),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,a=this.recurrentDropoutMask;let l,u,c,h;0<this.dropout&&this.dropout<1&&(e=Ae(e,o[0]));let d=Zu(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Ae(s,a[0])),d=xt(d,Zu(s,this.recurrentKernel.read())),this.useBias&&(d=bu(d,this.bias.read()));const[p,g,w,y]=ja(d,4,d.rank-1);l=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(g),c=xt(Ae(u,i),Ae(l,this.activation.apply(w))),h=this.recurrentActivation.apply(y);const x=Ae(h,this.activation.apply(c));return[x,x,c]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:$d(this.activation),recurrentActivation:$d(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ds(this.kernelInitializer),recurrentInitializer:ds(this.recurrentInitializer),biasInitializer:ds(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ur(this.kernelRegularizer),recurrentRegularizer:Ur(this.recurrentRegularizer),biasRegularizer:Ur(this.biasRegularizer),activityRegularizer:Ur(this.activityRegularizer),kernelConstraint:ei(this.kernelConstraint),recurrentConstraint:ei(this.recurrentConstraint),biasConstraint:ei(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}PE.className="LSTMCell";ft(PE);class vW extends nf{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new PE(e),super(e)}call(e,t){return ze(()=>{this.cell.dropoutMask!=null&&(Yn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}vW.className="LSTM";ft(vW);class PR extends $E{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ze(()=>{e=e;let r=e.slice(1);const s=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?s.push(r.splice(0,a.stateSize.length)):s.push(r.splice(0,1));s.reverse();const i=[];let o;for(let a=0;a<this.cells.length;++a){const l=this.cells[a];r=s[a],a===0?o=[e[0]].concat(r):o=[o[0]].concat(r),o=l.call(o,t),i.push(o.slice(1))}r=[];for(const a of i.slice().reverse())r.push(...a);return[o[0]].concat(r)})}build(e){NN(e)&&(e=e[0]),e=e;let t;this.cells.forEach((r,s)=>{Rp(`RNNCell_${s}`,()=>{r.build(e),Array.isArray(r.stateSize)?t=r.stateSize[0]:t=r.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),s={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),s)}static fromConfig(e,t,r={}){const s=[];for(const i of t.cells)s.push(oh(i,r));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.cells)t.push(...r.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return AN(e)}setWeights(e){const t=[];for(const r of this.cells){const s=r.weights.length,i=e.splice(s);for(let o=0;o<r.weights.length;++o)t.push([r.weights[o],i[o]])}ER(t)}}PR.className="StackedRNNCells";ft(PR);function Ld(n){const{ones:e,rate:t,training:r=!1,count:s=1,dropoutFunc:i}=n,o=()=>i!=null?i(e(),t):uV(e(),t),a=()=>uw(o,e,r);return!s||s<=1?qu(a().clone()):Array(s).fill(void 0).map(a).map(u=>qu(u.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var mhe=function(n,e){var t={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&e.indexOf(r)<0&&(t[r]=n[r]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(n);s<r.length;s++)e.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(n,r[s])&&(t[r[s]]=n[r[s]]);return t};class xW extends nf{constructor(e){if(e.unroll)throw new Fn("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Fn("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Qs({ndim:5})]}call(e,t){return ze(()=>{if(this.cell.dropoutMask!=null&&(Yn(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Yn(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Ce("ConvRNN2D cell does not support constants");const r=t==null?null:t.mask,s=t==null?null:t.training,i=t==null?null:t.initialState;return super.call(e,{mask:r,training:s,initialState:i})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ze(()=>{const{stateSize:t}=this.cell,r=e.shape,s=this.computeSingleOutputShape(r),i=[s[0],...s.slice(2)],o=gi(i);return Array.isArray(t)?Array(t.length).fill(o):[o]})}resetStates(e,t=!1){ze(()=>{if(!this.stateful)throw new zu("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),i=[s[0],...s.slice(2)];if(r[0]==null)throw new Ce("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>gi(i)):this.states_=[gi(i)];else if(e==null)Yn(this.states_),this.keptStates!=null&&(Yn(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>gi(i)):this.states_[0]=gi(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Ce(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Yn(this.states_);for(let a=0;a<this.states_.length;++a){const l=e[a],u=i;if(!_r(l.shape,u))throw new Ce(`State ${a} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[a]=l}}this.states_=this.states_.map(a=>qu(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:r,kernelSize:s,padding:i,strides:o,dilationRate:a}=this.cell,l=t==="channelsFirst",u=e[l?3:2],c=e[l?4:3],h=pu(u,s[0],i,o[0],a[0]),d=pu(c,s[1],i,o[1],a[1]);return[...e.slice(0,2),...l?[r,h,d]:[h,d,r]]}}xW.className="ConvRNN2D";class LR extends PE{constructor(e){const{filters:t,kernelSize:r,strides:s,padding:i,dataFormat:o,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,vi(this.filters,"filters"),this.kernelSize=hy(r,2,"kernelSize"),this.kernelSize.forEach(l=>vi(l,"kernelSize")),this.strides=hy(s||1,2,"strides"),this.strides.forEach(l=>vi(l,"strides")),this.padding=i||"valid",Za(this.padding),this.dataFormat=o||"channelsLast",ks(this.dataFormat),this.dilationRate=hy(a||1,2,"dilationRate"),this.dilationRate.forEach(l=>vi(l,"dilationRate"))}build(e){var t;e=fr(e);const r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new Ce(`The channel dimension of the input should be defined. Found ${e[r]}`);const s=e[r],i=4,o=this.kernelSize.concat([s,this.filters*i]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*i]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(t=class extends Cl{apply(d,p){const g=u.apply([c]),w=ef([c]),y=u.apply([c*2]);return yR([g,w,y])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*i],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ze(()=>{if(e.length!==3)throw new Ce(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training||!1,s=e[0],i=e[1],o=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ld({ones:()=>Sl(s),rate:this.dropout,training:r,count:a,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(K,G,Q)=>!G||!G[Q]?K:Ae(G[Q],K);let c=u(s,l,0),h=u(s,l,1),d=u(s,l,2),p=u(s,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ld({ones:()=>Sl(i),rate:this.recurrentDropout,training:r,count:a,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let w=u(i,g,0),y=u(i,g,1),x=u(i,g,2),_=u(i,g,3);const T=3,[E,N,M,$]=ja(this.kernel.read(),a,T),[L,k,R,P]=this.useBias?ja(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,E,L,this.padding),h=this.inputConv(h,N,k,this.padding),d=this.inputConv(d,M,R,this.padding),p=this.inputConv(p,$,P,this.padding);const[B,Z,V,X]=ja(this.recurrentKernel.read(),a,T);w=this.recurrentConv(w,B),y=this.recurrentConv(y,Z),x=this.recurrentConv(x,V),_=this.recurrentConv(_,X);const q=this.recurrentActivation.apply(xt(c,w)),se=this.recurrentActivation.apply(xt(h,y)),W=xt(Ae(se,o),Ae(q,this.activation.apply(xt(d,x)))),J=Ae(this.recurrentActivation.apply(xt(p,_)),this.activation.apply(W));return[J,J,W]})}getConfig(){const e=super.getConfig(),{units:t}=e,r=mhe(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},r),s)}inputConv(e,t,r,s){const i=Hp(e,t,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?bu(i,r,this.dataFormat):i}recurrentConv(e,t){return Hp(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}LR.className="ConvLSTM2DCell";ft(LR);class wW extends xW{constructor(e){const t=new LR(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}wW.className="ConvLSTM2D";ft(wW);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class OR extends Kn{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?t[s]:this.noiseShape[s]);return r}call(e,t){return ze(()=>{this.invokeCallHook(e,t);const r=wn(e);if(0<this.rate&&this.rate<1){const s=t.training==null?!1:t.training,i=this.getNoiseShape(r);return uw(()=>uV(r,this.rate,i,this.seed),()=>r,s)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}OR.className="Dropout";ft(OR);class bW extends OR{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}bW.className="SpatialDropout1D";ft(bW);class SW extends Kn{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,vi(this.units,"units"),this.activation=Pd(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=os(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=os(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=ti(e.kernelConstraint),this.biasConstraint=ti(e.biasConstraint),this.kernelRegularizer=as(e.kernelRegularizer),this.biasRegularizer=as(e.biasRegularizer),this.activityRegularizer=as(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=fr(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=fr(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return ze(()=>{this.invokeCallHook(e,t);const r=wn(e),s=nV(this.activation.getClassName());let i;return s!=null?i=Zu(r,this.kernel.read(),s,this.bias?this.bias.read():null):(i=Zu(r,this.kernel.read()),this.bias!=null&&(i=bu(i,this.bias.read())),this.activation!=null&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:$d(this.activation),useBias:this.useBias,kernelInitializer:ds(this.kernelInitializer),biasInitializer:ds(this.biasInitializer),kernelRegularizer:Ur(this.kernelRegularizer),biasRegularizer:Ur(this.biasRegularizer),activityRegularizer:Ur(this.activityRegularizer),kernelConstraint:ei(this.kernelConstraint),biasConstraint:ei(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}SW.className="Dense";ft(SW);class _W extends Kn{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=fr(e);for(const t of e.slice(1))if(t==null)throw new Ce(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Ed(e,1)]}call(e,t){return ze(()=>{this.invokeCallHook(e,t);let r=wn(e);if(this.dataFormat==="channelsFirst"&&r.rank>1){const s=[0];for(let i=2;i<r.rank;++i)s.push(i);s.push(1),r=ir(r,s)}return Kue(r)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}_W.className="Flatten";ft(_W);class TW extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.activation=Pd(e.activation)}call(e,t){return ze(()=>{this.invokeCallHook(e,t);const r=wn(e);return this.activation.apply(r)})}getConfig(){const e={activation:$d(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}TW.className="Activation";ft(TW);class EW extends Kn{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ze(()=>(e=wn(e),Xue(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}EW.className="RepeatVector";ft(EW);let CW=class extends Kn{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const r="Total size of new array must be unchanged.",s=t.slice();let i=1,o=null;for(let l=0;l<s.length;++l){const u=s[l];if(this.isUnknown(u))if(o===null)o=l;else throw new Ce("Can only specifiy one unknown dimension.");else i*=u}const a=Ed(e);if(o!==null){if(i===0||a%i!==0)throw new Ce(r);s[o]=a/i}else if(a!==i)throw new Ce(r);return s}computeOutputShape(e){let t=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ze(()=>{this.invokeCallHook(e,t);const r=wn(e),s=r.shape,i=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return $e(r,i)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};CW.className="Reshape";ft(CW);class IW extends Kn{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=gu(1,e.dims.length+1);if(!_r(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Qs({ndim:this.dims.length+1})]}computeOutputShape(e){e=fr(e);const t=e.slice();return this.dims.forEach((r,s)=>{t[s+1]=e[r]}),t}call(e,t){return ir(wn(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}IW.className="Permute";ft(IW);class NW extends Kn{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const r=wn(e);return xN(a_(r,this.maskValue),-1)}call(e,t){return ze(()=>{this.invokeCallHook(e,t);const r=wn(e),o=xN(a_(r,this.maskValue),-1,!0);return Ae(r,Ot(o,r.dtype))})}}NW.className="Masking";ft(NW);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class AW extends Kn{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Ar(e.inputLength))}this.inputDim=e.inputDim,vi(this.inputDim,"inputDim"),this.outputDim=e.outputDim,vi(this.outputDim,"outputDim"),this.embeddingsInitializer=os(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=as(e.embeddingsRegularizer),this.activityRegularizer=as(e.activityRegularizer),this.embeddingsConstraint=ti(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ze(()=>this.maskZero?(e=wn(e),a_(e,or(e))):null)}computeOutputShape(e){if(e=fr(e),this.inputLength==null)return[...e,this.outputDim];const t=Ar(this.inputLength);if(t.length!==e.length-1)throw new Ce(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let s=0;s<t.length;++s){const i=t[s],o=e[s+1];if(i!=null&&o!=null&&i!==o)throw new Ce(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);i==null&&(t[r]=o),r++}}return[e[0],...t,this.outputDim]}call(e,t){return ze(()=>{this.invokeCallHook(e,t);let r=wn(e);r.dtype!=="int32"&&(r=Yu(r,"int32"));const s=lV(this.embeddings.read(),$e(r,[r.size]));return $e(s,fr(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ds(this.embeddingsInitializer),embeddingsRegularizer:Ur(this.embeddingsRegularizer),activityRegularizer:Ur(this.activityRegularizer),embeddingsConstraint:ei(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}AW.className="Embedding";ft(AW);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class fm extends Kn{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Fn}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const r=e.slice(0,e.length-t.length);for(let s=0;s<t.length;++s){const i=e[e.length-t.length+s],o=t[s];if(i==null||o==null||i<0||o<0)r.push(null);else if(i===1)r.push(o);else if(o===1)r.push(i);else{if(i!==o)throw new Ce("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));r.push(i)}}return r}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[fr(e)]),e=e,e.length<2)throw new Ce(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const i of e)i!=null&&i[0]!==null&&t.push(i[0]);if(t=Td(t),t.length>1)throw new Ce(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let r=e[0]==null?null:e[0].slice(1);for(let i=1;i<e.length;++i){const o=e[i]==null?null:e[i].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const s=e.map(i=>i.length);e.indexOf(null)===-1&&Td(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ze(()=>{if(e=e,this.reshapeRequired){const r=[],s=e.map(i=>i.rank);if(s.indexOf(null)===-1){const i=Dd(s);for(let o of e){const a=o.rank;for(let l=0;l<i-a;++l)o=aw(o,1);r.push(o)}return this.mergeFunction(r)}else{let i=!1;for(const l of e){const u=l.rank;if(u==null){const c=l.shape,h=c[0],d=c.slice(1).concat([h]);let p=$e(l,[h].concat(Ed(c.slice(1))));p=ir(p,[1,0]),p=$e(p,d),r.push(p),i=!0}else if(u>1){const c=gu(1,u).concat([0]);r.push(ir(l,c)),i=!0}else r.push(l)}let o=this.mergeFunction(r);const a=o.rank;if(i){if(a==null){const l=o.shape,u=l.length,c=l[u-1],h=[c].concat(l.slice(0,l.length-1));o=$e(ir($e(o,[-1,c]),[1,0]),h)}else if(a>1){const l=[a-1].concat(gu(0,a-1));o=ir(o,l)}}return o}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let s=1;s<e.length;++s){const i=e[s]==null?null:e[s].slice(1);t=this.computeElementwiseOpOutputShape(t,i)}let r=[];for(const s of e)s!=null&&s[0]!==null&&r.push(s[0]);return r=Td(r),r.length===1?t=r.concat(t):t=[null].concat(t),t}computeMask(e,t){return ze(()=>{if(t==null)return null;if(!Array.isArray(t))throw new Ce("`mask` should be an Array");if(!Array.isArray(e))throw new Ce("`inputs` should be an Array");if(t.length!==e.length)throw new Ce(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(s=>s==null))return null;t=t.map(s=>s==null?s:Uo(s,0));let r=t[0];for(let s=1;s<t.length-1;++s)r=lh(r,t[s]);return r})}}let MW=class extends fm{constructor(e){super(e)}mergeFunction(e){return ze(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=xt(t,e[r]);return t})}};MW.className="Add";ft(MW);let kW=class extends fm{constructor(e){super(e)}mergeFunction(e){return ze(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=Ae(t,e[r]);return t})}};kW.className="Multiply";ft(kW);class RW extends fm{constructor(e){super(e)}mergeFunction(e){return ze(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=xt(t,e[r]);return Ae(1/e.length,t)})}}RW.className="Average";ft(RW);let DW=class extends fm{constructor(e){super(e)}mergeFunction(e){return ze(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=Qd(t,e[r]);return t})}};DW.className="Maximum";ft(DW);let $W=class extends fm{constructor(e){super(e)}mergeFunction(e){return ze(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=bx(t,e[r]);return t})}};$W.className="Minimum";ft($W);class PW extends fm{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new Ce("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const s of e)if(s!=null){t=!1;break}if(t)return;const r=[];for(let s=0;s<e.length;++s){const i=e[s].slice();i.splice(this.axis,1);let o=!1;for(const a of r)if(_r(a,i)){o=!0;break}o||r.push(i)}if(r.length>1)throw new Ce("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ze(()=>yR(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new Ce("A `Concatenate` layer should be called on a list of inputs.");const t=e,r=t[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(const i of t.slice(1)){if(r[s]==null||i[s]==null){r[s]=null;break}r[s]+=i[s]}return r}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new Ce("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Ce("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Ce(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ze(()=>{let r=!0;if(t.forEach(o=>{if(o!=null){r=!1;return}}),r)return null;const s=[];for(let o=0;o<e.length;++o)t[o]==null?s.push(Ot(Sl(e[o]),"bool")):t[o].rank<e[o].rank?s.push(Uo(t[o],-1)):s.push(t[o]);const i=Xo(s,this.axis);return OU(i,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}PW.className="Concatenate";ft(PW);function Iv(n,e){for(;n<0;)n+=e;return n}function ghe(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Fn("batchDot is not implemented for tensors of 4D or higher rank yet");if(ie(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),ie(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Fn("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,s=e.shape.length;t==null&&(t=[r-1,s-2]);const i=t;return ze(()=>{let o;if(r>s){o=r-s;const l=[];for(let u=0;u<o;++u)l.push(1);e=$e(e,e.shape.concat(l))}else if(s>r){o=s-r;const l=[];for(let u=0;u<o;++u)l.push(1);n=$e(n,n.shape.concat(l))}else o=0;let a;if(n.shape.length===2&&e.shape.length===2)i[0]===i[1]?a=an(Ae(n,e),i[0]):a=an(Ae(ir(n,[1,0]),e),i[1]);else{const l=i[0]!==n.shape.length-1,u=i[1]===e.shape.length-1;a=wr(n,e,l,u)}if(o>0){let l;r>s?l=r+s-3:l=r-1;const u=[];for(let c=l;c<l+o;++c)u.push(c);a=tw(a,u)}return a.shape.length===1&&(a=Uo(a,1)),a})}class LW extends fm{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){ie(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],r=e[1];if(t.length>3||r.length>3)throw new Fn("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,r);if(t[s[0]]!==r[s[1]])throw new Ce(`Dimension incompatibility: ${t[s[0]]} !== ${r[s[1]]}`)}mergeFunction(e){if(e.length!==2)throw new Ce(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],r=e[1],s;return Array.isArray(this.axes)?s=this.axes.map((i,o)=>Iv(i,e[o].shape.length)):s=[Iv(this.axes,t.shape.length),Iv(this.axes,r.shape.length)],this.normalize&&(t=p_(t,s[0]),r=p_(r,s[1])),ghe(t,r,s)}interpretAxes(e,t){let r;return Array.isArray(this.axes)?r=this.axes:r=[Iv(this.axes,e.length),Iv(this.axes,t.length)],r}computeOutputShape(e){ie(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),r=e[1].slice();if(t.length>3||r.length>3)throw new Fn("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,r);t.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);const i=t.concat(r);return i.length===1&&i.push(1),i}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}LW.className="Dot";ft(LW);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class OW extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return ze(()=>{this.invokeCallHook(e,t);const r=wn(e);return uw(()=>xt(NE(r.shape,0,this.stddev),r),()=>r,t.training||!1)})}}OW.className="GaussianNoise";ft(OW);class FW extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ze(()=>{this.invokeCallHook(e,t);const r=wn(e);return this.rate>0&&this.rate<1?uw(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return Ae(r,NE(r.shape,1,i))},()=>r,t.training||!1):r})}}FW.className="GaussianDropout";ft(FW);class zW extends Kn{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||wn(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ze(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return uw(()=>{const i=wn(e),a=-1.6732632423543772*1.0507009873554805;let l=um(ew(r),this.rate);l=Yu(l,"float32");const u=((1-this.rate)*(1+this.rate*a**2))**-.5,c=-u*a*this.rate,h=xt(Ae(i,l),Ae(xt(l,-1),a));return xt(Ae(h,u),c)},()=>wn(e),t.training||!1)}return e})}}zW.className="AlphaDropout";ft(zW);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Cx(n,e,t,r,s,i=.001){let o;if(n.rank===2)o=Xne(n,e,t,r,s,i);else if(n.rank===3)o=Kne(n,e,t,r,s,i);else if(n.rank===4)o=Zne(n,e,t,r,s,i);else throw new Fn(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function yhe(n,e,t,r,s=.001){return ze(()=>{const i=Ck(n,r),o=i.mean,a=i.variance;return[Cx(n,o,a,t,e,s),o,a]})}function vhe(n,e,t,r,s=.001){return ze(()=>{const i=Ck(n,r),o=i.mean,a=i.variance,l=[];for(const g of gu(0,n.rank))r.indexOf(g)!==-1?l.push(1):l.push(n.shape[g]);const u=$e(o,l),c=$e(a,l),h=e==null?null:$e(e,l),d=t==null?null:$e(t,l);return[Cx(n,u,c,d,h,s),o,a]})}function xhe(n,e,t,r,s=.001){return _r(r.slice().sort(),gu(0,n.rank-1))?yhe(n,e,t,r,s):vhe(n,e,t,r,s)}class BW extends Kn{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=os(e.betaInitializer||"zeros"),this.gammaInitializer=os(e.gammaInitializer||"ones"),this.movingMeanInitializer=os(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=os(e.movingVarianceInitializer||"ones"),this.betaConstraint=ti(e.betaConstraint),this.gammaConstraint=ti(e.gammaConstraint),this.betaRegularizer=as(e.betaRegularizer),this.gammaRegularizer=as(e.gammaRegularizer)}build(e){e=fr(e);const t=this.axis>=0?this.axis:this.axis+e.length,r=e[t];if(r==null)throw new Ce(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Qs({ndim:e.length,axes:{[t]:r}})];const s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ze(()=>{const r=t.training==null?!1:t.training,s=wn(e),i=s.shape,o=i.length,a=gu(0,o),l=this.axis>=0?this.axis:this.axis+o;a.splice(l,1);const u=qp(1,o);u[l]=i[l];const c=a.slice();c.sort();const h=!_r(c,gu(0,o).slice(0,o-1)),d=()=>{if(h){const _=$e(this.movingMean.read(),u),T=$e(this.movingVariance.read(),u),E=this.center?$e(this.beta.read(),u):null,N=this.scale?$e(this.gamma.read(),u):null;return Cx(s,_,T,E,N,this.epsilon)}else return Cx(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return d();const[p,g,w]=xhe(s,this.gamma.read(),this.beta.read(),a,this.epsilon),y=(_,T,E)=>{ze(()=>{const N=1-E,M=_.read(),$=Ae(yn(M,T),N);_.write(yn(M,$))})};return(()=>{y(this.movingMean,g,this.momentum),y(this.movingVariance,w,this.momentum)})(),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ds(this.betaInitializer),gammaInitializer:ds(this.gammaInitializer),movingMeanInitializer:ds(this.movingMeanInitializer),movingVarianceInitializer:ds(this.movingVarianceInitializer),betaRegularizer:Ur(this.betaRegularizer),gammaRegularizer:Ur(this.gammaRegularizer),betaConstraint:ei(this.betaConstraint),gammaConstraint:ei(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}BW.className="BatchNormalization";ft(BW);class UW extends Kn{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=os(e.betaInitializer||"zeros"),this.gammaInitializer=os(e.gammaInitializer||"ones"),this.betaRegularizer=as(e.betaRegularizer),this.gammaRegularizer=as(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=fr(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=t);for(const i of this.axis)if(i<0||i>=t)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Td(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(i=>e[i]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,t){const r=wn(e),s=r.shape,i=s.length;return ze(()=>{let{mean:a,variance:l}=Ck(r,this.axis,!0);const u=qp(1,i);for(const w of this.axis)u[w]=s[w];const c=w=>w!=null&&w.shape.length!==i?$e(w,u):w;let h=this.scale?c(this.gamma.read()):null,d=this.center?c(this.beta.read()):null;const p=[],g=[];for(let w=0;w<i;++w)this.axis.indexOf(w)!==-1?(p.push(s[w]),g.push(1)):(p.push(1),g.push(s[w]));return a=hu(a,p),l=hu(l,p),h!=null&&(h=hu(h,g)),d!=null&&(d=hu(d,g)),Cx(r,a,l,d,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ds(this.betaInitializer),gammaInitializer:ds(this.gammaInitializer),betaRegularizer:Ur(this.betaRegularizer),gammaRegularizer:Ur(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}UW.className="LayerNormalization";ft(UW);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function whe(n,e,t){return ze(()=>{if(n.rank!==4)throw new Ce(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new Ce("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=yu()),t!=="channelsLast"&&t!=="channelsFirst")throw new Ce(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return t==="channelsFirst"?r=[[0,0],[0,0],e[0],e[1]]:r=[[0,0],e[0],e[1],[0,0]],Ik(n,r)})}class VW extends Kn{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?yu():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new Ce(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,r;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new Ce(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new Ce(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[t,r]}this.inputSpec=[new Qs({ndim:4})]}computeOutputShape(e){e=fr(e);let t,r;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?r=e[3]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],e[1],t,r]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?r=e[2]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],t,r,e[3]])}call(e,t){return ze(()=>whe(wn(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}VW.className="ZeroPadding2D";ft(VW);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function LE(n,e,t,r,s,i){return ze(()=>{ks(s),sV(i),Za(r),t==null&&(t=[1,1]),r==null&&(r="valid"),s==null&&(s=yu()),i==null&&(i="max"),n=MR(n,s);let o;const a=r==="same"?"same":"valid";return i==="max"?o=Ek(n,e,t,a):o=pk(n,e,t,a),s==="channelsFirst"&&(o=ir(o,[0,3,1,2])),o})}function WW(n,e,t,r,s,i){return ze(()=>{ks(s),sV(i),Za(r),t==null&&(t=[1,1,1]),r==null&&(r="valid"),s==null&&(s=yu()),i==null&&(i="max"),n=sW(n,s);let o;const a=r==="same"?"same":"valid";return i==="max"?o=Lse(n,e,t,a):o=One(n,e,t,a),s==="channelsFirst"&&(o=ir(o,[0,4,1,2,3])),o})}class GW extends Kn{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new Ce(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(vi(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new Ce(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);vi(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Za(this.padding),this.inputSpec=[new Qs({ndim:3})]}computeOutputShape(e){e=fr(e);const t=pu(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ze(()=>{this.invokeCallHook(e,t),e=aw(wn(e),2);const r=this.poolingFunction(wn(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return tw(r,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class HW extends GW{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ks(i),Za(s),LE(e,t,r,s,i,"max")}}HW.className="MaxPooling1D";ft(HW);class jW extends GW{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ks(i),Za(s),LE(e,t,r,s,i,"avg")}}jW.className="AveragePooling1D";ft(jW);class XW extends Kn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new Ce(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];vi(this.poolSize,"poolSize"),vi(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ks(this.dataFormat),Za(this.padding),this.inputSpec=[new Qs({ndim:4})]}computeOutputShape(e){e=fr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=pu(t,this.poolSize[0],this.padding,this.strides[0]),r=pu(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r]:[e[0],t,r,e[3]]}call(e,t){return ze(()=>(this.invokeCallHook(e,t),this.poolingFunction(wn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class qW extends XW{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ks(i),Za(s),LE(e,t,r,s,i,"max")}}qW.className="MaxPooling2D";ft(qW);class KW extends XW{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ks(i),Za(s),LE(e,t,r,s,i,"avg")}}KW.className="AveragePooling2D";ft(KW);class YW extends Kn{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new Ce(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];vi(this.poolSize,"poolSize"),vi(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ks(this.dataFormat),Za(this.padding),this.inputSpec=[new Qs({ndim:5})]}computeOutputShape(e){e=fr(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=pu(t,this.poolSize[0],this.padding,this.strides[0]),r=pu(r,this.poolSize[1],this.padding,this.strides[1]),s=pu(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r,s]:[e[0],t,r,s,e[4]]}call(e,t){return ze(()=>(this.invokeCallHook(e,t),this.poolingFunction(wn(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class ZW extends YW{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ks(i),Za(s),WW(e,t,r,s,i,"max")}}ZW.className="MaxPooling3D";ft(ZW);class JW extends YW{constructor(e){super(e)}poolingFunction(e,t,r,s,i){return ks(i),Za(s),WW(e,t,r,s,i,"avg")}}JW.className="AveragePooling3D";ft(JW);class QW extends Kn{constructor(e){super(e),this.inputSpec=[new Qs({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Fn}}class eG extends QW{constructor(e){super(e||{})}call(e,t){return ze(()=>{const r=wn(e);return Fs(r,1)})}}eG.className="GlobalAveragePooling1D";ft(eG);class tG extends QW{constructor(e){super(e||{})}call(e,t){return ze(()=>{const r=wn(e);return fu(r,1)})}}tG.className="GlobalMaxPooling1D";ft(tG);class nG extends Kn{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ks(this.dataFormat),this.inputSpec=[new Qs({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Fn}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class rG extends nG{call(e,t){return ze(()=>{const r=wn(e);return this.dataFormat==="channelsLast"?Fs(r,[1,2]):Fs(r,[2,3])})}}rG.className="GlobalAveragePooling2D";ft(rG);class sG extends nG{call(e,t){return ze(()=>{const r=wn(e);return this.dataFormat==="channelsLast"?fu(r,[1,2]):fu(r,[2,3])})}}sG.className="GlobalMaxPooling2D";ft(sG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class iG extends Kn{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,r={}){const s=t.layer,i=oh(s,r);delete t.layer;const o={layer:i};return Object.assign(o,t),new e(o)}}class oG extends iG{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=fr(e),e.length<3)throw new Ce(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=fr(e);const t=[e[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(t),s=e[1];return[r[0],s].concat(r.slice(1))}call(e,t){return ze(()=>(e=wn(e),mW((o,a)=>[wn(this.layer.call(o,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}oG.className="TimeDistributed";ft(oG);function bhe(n){dm(Vue,"BidirectionalMergeMode",n)}const She="concat";class aG extends iG{constructor(e){super(e);const t=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=t,this.forwardLayer=oh(r),t.goBackwards=t.goBackwards!==!0;const s={};if(s.className=e.layer.getClassName(),s.config=t,this.backwardLayer=oh(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?She:e.mergeMode,bhe(this.mergeMode),e.weights)throw new Fn("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,r=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let r,s,i;return this.returnState&&(i=t.slice(1)),r=t[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,s=[r]):this.mergeMode==null?s=[r,r.slice()]:s=[r],this.returnState?this.mergeMode==null?s.concat(i).concat(i.slice()):[r].concat(i).concat(i.slice()):Vo(s)}apply(e,t){let r=t==null?null:t.initialState,s=t==null?null:t.constants;t==null&&(t={});const i=pW(e,r,s,this.numConstants);if(e=i.inputs,r=i.initialState,s=i.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(r==null||r.length===0)&&s==null)return super.apply(e,t);const o=[],a=[];if(r!=null){const u=r.length;if(u%2>0)throw new Ce("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=r,o.push(...r);const c=r.map(h=>new Qs({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),a.push(...c)}if(s!=null)throw new Fn("Support for constants in Bidirectional layers is not implemented yet.");const l=o[0]instanceof ic;for(const u of o)if(u instanceof ic!==l)throw new Ce("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[e].concat(o),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const d=super.apply(u,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return ze(()=>{const r=t.initialState;let s,i;if(r==null)s=this.forwardLayer.call(e,t),i=this.backwardLayer.call(e,t);else{const l=r.slice(0,r.length/2),u=r.slice(r.length/2);s=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),i=this.backwardLayer.call(e,Object.assign(t,{initialState:u}))}let o;this.returnState&&(Array.isArray(s)&&(o=s.slice(1).concat(i.slice(1))),s=s[0],i=i[0]),this.returnSequences&&(i=jp(i,1));let a;return this.mergeMode==="concat"?a=yR([s,i]):this.mergeMode==="sum"?a=xt(s,i):this.mergeMode==="ave"?a=Ae(.5,xt(s,i)):this.mergeMode==="mul"?a=Ae(s,i):this.mergeMode==null&&(a=[s,i]),this.returnState?this.mergeMode==null?a.concat(o):[a].concat(o):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Rp(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Rp(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[t,t]:r=t:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(r)?r.concat(i).concat(i):[r].concat(i).concat(i)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const r=oh(t.layer);if(delete t.layer,t.numConstants!=null)throw new Fn("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=t;return s.layer=r,new e(s)}}aG.className="Bidirectional";ft(aG);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class lG extends Kn{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ze(()=>(e=wn(e),e.dtype!=="float32"&&(e=Yu(e,"float32")),xt(Ae(e,this.scale),this.offset)))}}lG.className="Rescaling";ft(lG);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:_he,cropAndResize:The}=nh;class uG extends Kn{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,r,s,i,o,a,l){return ze(()=>{let u,c=!1;const h=t/o,d=r/a,p=(s+t)/o,g=(i+r)/a,w=[h,d,p,g],y=[];e.rank===3?(c=!0,u=uh([e])):u=e;for(let N=0;N<u.shape[0];N++)y.push(w);const x=CU(y,[y.length,4]),_=Sx(0,y.length,1,"int32"),E=The(u,x,_,[s,i],"nearest");return Yu(c?wn(Xp(E)):E,l)})}upsize(e,t,r,s){return ze(()=>{const i=_he(e,[t,r]);return Yu(i,s)})}call(e,t){return ze(()=>{const r=wn(e),s=r.dtype,i=r.shape,o=i[i.length-3],a=i[i.length-2];let l=0;o!==this.height&&(l=Math.floor((o-this.height)/2));let u=0;return a!==this.width&&(u=Math.floor((a-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(r,l,u,this.height,this.width,o,a,s):this.upsize(e,this.height,this.width,s)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=fr(e);const t=e.length-3,r=e.length-2;return e[t]=this.height,e[r]=this.width,e}}uG.className="CenterCrop";ft(uG);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Ehe(n,e,t,r){let s=wn(n);if(s.dtype!=="int32"&&(s=Yu(s,"int32")),e==="int")return s;const i=s.shape;if(s.rank===0&&(s=Uo(s,-1)),e==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=Uo(s,-1)),s.rank>2)throw new Ce(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${i} which would result in output rank ${s.rank}.`);const o=["multiHot","oneHot"].includes(e),a=s;let l;if(typeof r<"u"&&e==="count"?l=OP(a,r,t,o):l=OP(a,[],t,o),e!=="tfIdf")return l;if(r)return Ae(l,r);throw new Ce("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class cG extends Kn{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=fr(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return ze(()=>{e=wn(e),e.dtype!=="int32"&&(e=Yu(e,"int32"));let r;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new Ce(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);r=wn(t.countWeights)}const s=fu(e),i=i_(e),o=Ya(this.numTokens,s).bufferSync().get(0),a=um(i,0).bufferSync().get(0);if(!(o&&a))throw new Ce(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Ehe(e,this.outputMode,this.numTokens,r)})}}cG.className="CategoryEncoding";ft(cG);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Che=["bilinear","nearest"],TL=new Set(Che);class hG extends Kn{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(TL.has(e.interpolation))this.interpolation=e.interpolation;else throw new Ce(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=fr(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ze(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return nh.resizeBilinear(e,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return nh.resizeNearestNeighbor(e,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...TL]} are supported`)})}}hG.className="Resizing";ft(hG);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class dG{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}dG.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class fG extends Kn{constructor(e){super(e),this.randomGenerator=new dG(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}fG.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Ihe=["bilinear","nearest"],EL=new Set(Ihe);class pG extends fG{constructor(e){super(e);const{factor:t,interpolation:r="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new Ce(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new Ce(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Ce(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(EL.has(r))this.interpolation=r;else throw new Ce(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=fr(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return ze(()=>{const r=wn(e);this.imgHeight=r.shape[r.shape.length-3];const s=r.shape[r.shape.length-2];this.widthFactor=ew([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*s;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return nh.resizeBilinear(e,o);case"nearest":return nh.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...EL]} are supported`)}})}}pG.className="RandomWidth";ft(pG);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nhe=je();Nhe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var CL;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(CL||(CL={}));var IL;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(IL||(IL={}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var NL;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(NL||(NL={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xt(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&ie(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ahe=c4;class OE extends yM{nextDataId(){return OE.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new $B(this,Ou())}write(e,t,r){this.firstUse&&(this.firstUse=!1,je().get("IS_NODE")&&Wa(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:r,refCount:1}),s}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&t1(r[0])){const i=r.map(o=>_d(o));s=this.write(i,e,t)}else s=this.write(r,e,t);return{dataId:s,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,r,s,i){this.data.set(e,{values:t,dtype:s,refCount:i})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:r}=this.data.get(e);if(t==="complex64"){const s=this.readSync(r.real.dataId),i=this.readSync(r.imag.dataId);return ch(s,i)}return Zee(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>Rd(s));return Xn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Xn(e.shape,e.dtype,t)}makeOutput(e,t,r){return Ou().makeTensorFromTensorInfo(this.makeTensorInfo(t,r,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Bo();return e(),{kernelMs:Bo()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Xt([e],"where");const t=this.readSync(e.dataId);return Ahe(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}OE.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mG(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const Mhe=n=>{const{x:e}=n.inputs,t=n.backend;Xt(e,"abs");let r=new Float32Array(Qe(e.shape));const s=t.data.get(e.dataId).values;return r=mG(s),t.makeOutput(r,e.shape,e.dtype)},khe={kernelName:pT,backendName:"cpu",kernelFunc:Mhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rs(n){return(e,t,r,s,i)=>{const o=$n(e,t),a=o.length,l=nn(o),u=Qe(o),c=Yi(i,u),h=e.length,d=t.length,p=nn(e),g=nn(t),w=Ty(e,o),y=Ty(t,o);if(w.length+y.length===0)for(let x=0;x<c.length;++x)c[x]=n(r[x%r.length],s[x%s.length]);else for(let x=0;x<c.length;++x){const _=Xy(x,a,l),T=_.slice(-h);w.forEach($=>T[$]=0);const E=Xu(T,h,p),N=_.slice(-d);y.forEach($=>N[$]=0);const M=Xu(N,d,g);c[x]=n(r[E],s[M])}return[c,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wa(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values,a=t.makeTensorInfo(r.shape,"complex64"),l=t.data.get(a.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(r.shape,"float32",i),imag:t.makeTensorInfo(s.shape,"float32",o)},a}const Rhe={kernelName:MM,backendName:"cpu",kernelFunc:wa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x_(n,e,t="float32"){if(t==="complex64"){const s=x_(n,e,"float32"),i=x_(n,e,"float32");return wa({inputs:{real:s,imag:i},backend:n})}const r=Zi(Qe(e),t);return n.makeTensorInfo(e,t,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oc(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Dhe={kernelName:S1,backendName:"cpu",kernelFunc:oc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kp(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.data.get(r.dataId).complexTensorInfos.real,i=t.data.get(s.dataId).values;return t.makeTensorInfo(s.shape,s.dtype,i)}const $he={kernelName:ek,backendName:"cpu",kernelFunc:Kp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gG(n,e,t,r){if(r==="int32"){const s=Int32Array.from(n);return[e,"int32",s]}if(r==="bool"){const s=lm([0],t),[i,o]=Rs((a,l)=>a!==l?1:0)(e,[],n,s,"bool");return[o,"bool",i]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}function Od(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return oc({inputs:{x:s},backend:t});const c=x_(t,s.shape,s.dtype),h=Od({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),d=wa({inputs:{real:h,imag:c},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),d}if(s.dtype==="complex64"){const c=Kp({inputs:{input:s},backend:t}),h=Od({inputs:{x:c},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(c),h}if(!OB(s.dtype,i)){const c=oc({inputs:{x:s},backend:t});return{dataId:c.dataId,shape:c.shape,dtype:i}}const o=t.data.get(s.dataId).values,[a,l,u]=gG(o,s.shape,s.dtype,i);return t.makeTensorInfo(a,l,u)}const Phe={kernelName:u1,backendName:"cpu",kernelFunc:Od};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function si(n,e,t,r){return t==null?({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;Xt([o,a],n);const u=l.data.get(o.dataId).values,c=l.data.get(a.dataId).values,h=o.dtype==="string"?hh(u):u,d=o.dtype==="string"?hh(c):c,p=r||o.dtype,[g,w]=e(o.shape,a.shape,h,d,p);return l.makeTensorInfo(w,p,g)}:({inputs:s,backend:i})=>{const{a:o,b:a}=s,l=i;if(o.dtype==="complex64"||a.dtype==="complex64"){const u=Od({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,p=l.data.get(h.dataId).values,g=l.data.get(d.dataId).values,w=Od({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),y=l.data.get(w.dataId),x=y.complexTensorInfos.real,_=y.complexTensorInfos.imag,T=l.data.get(x.dataId).values,E=l.data.get(_.dataId).values,[N,M,$]=t(o.shape,a.shape,p,g,T,E),L=l.makeTensorInfo($,"float32",N),k=l.makeTensorInfo($,"float32",M),R=wa({inputs:{real:L,imag:k},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(w),l.disposeIntermediateTensorInfo(L),l.disposeIntermediateTensorInfo(k),R}else{const u=l.data.get(o.dataId).values,c=l.data.get(a.dataId).values,h=r||o.dtype,[d,p]=e(o.shape,a.shape,u,c,h);return l.makeTensorInfo(p,h,d)}}}function FR(n){return(e,t,r,s,i,o)=>{const a=$n(e,t),l=Qe(a),u=a.length,c=nn(a),h=Yi("float32",l),d=Yi("float32",l),p=Ty(e,a),g=Ty(t,a),w=ch(r,s),y=ch(i,o),x=e.length,_=nn(e),T=t.length,E=nn(t);if(p.length+g.length===0)for(let N=0;N<h.length;N++){const M=N%w.length,$=N%y.length,L=n(w[M*2],w[M*2+1],y[$*2],y[$*2+1]);h[N]=L.real,d[N]=L.imag}else for(let N=0;N<h.length;N++){const M=Xy(N,u,c),$=M.slice(-x);p.forEach(B=>$[B]=0);const L=Xu($,x,_),k=M.slice(-T);g.forEach(B=>k[B]=0);const R=Xu(k,T,E),P=n(w[L*2],w[L*2+1],y[R*2],y[R*2+1]);h[N]=P.real,d[N]=P.imag}return[h,d,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yG=Rs(((n,e)=>n+e)),Lhe=FR(((n,e,t,r)=>({real:n+t,imag:e+r}))),Ny=si(qy,yG,Lhe),Ohe={kernelName:qy,backendName:"cpu",kernelFunc:Ny};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zR(n,e,t,r,s){const i=Qe(r),o=Zi(s,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(i>0?o[l]+=e[a]:o[l]+=1)}return o}function vG(n,e,t,r=!1){const s=n.shape[0],i=n.shape[1],o=Xn([s,t],e.dtype);for(let a=0;a<s;a++)for(let l=0;l<i;l++){const u=n.get(a,l);if(u<0)throw new Error("Input x must be non-negative!");u>=t||(r?o.set(1,a,u):e.size>0?o.set(o.get(a,u)+e.get(a,l),a,u):o.set(o.get(a,u)+1,a,u))}return o}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xG=Rs(((n,e)=>n&e)),Fhe=si(AM,xG),zhe={kernelName:AM,backendName:"cpu",kernelFunc:Fhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lc(n){return(e,t,r)=>{const s=Cs(t,e.length);for(let i=0;i<e.length;++i)s[i]=n(e[i],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mr(n,e,t){const r=lc(e);return rf(n,r,t)}function rf(n,e,t){return({inputs:r,attrs:s,backend:i})=>{const{x:o}=r;Xt(o,n);const a=i,l=a.data.get(o.dataId).values;let u;if(o.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=hh(l)}else u=l;const c=t||o.dtype,h=e(u,c,s);return a.makeTensorInfo(o.shape,c,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wG=lc(n=>Math.ceil(n)),Bhe=rf(c1,wG),Uhe={kernelName:c1,backendName:"cpu",kernelFunc:Bhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bG(n,e,t,r){const s=Cs(t,Qe(e));if(r&&t!=="string"){let i=0;n.forEach(o=>{const a=Qe(o.shape);s.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a=t==="string"?hh(o.vals):o.vals;let l=0;for(let u=0;u<o.shape[0];++u){const c=u*e[1]+i;for(let h=0;h<o.shape[1];++h)s[c+h]=a[l++]}i+=o.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG=Rs((n,e)=>n===e?1:0),_G=si(AT,SG,null,"bool"),Vhe={kernelName:AT,backendName:"cpu",kernelFunc:_G};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TG=lc(n=>Math.exp(n)),EG=rf(y1,TG,"float32"),Whe={kernelName:y1,backendName:"cpu",kernelFunc:EG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CG=lc(n=>Math.expm1(n)),Ghe=rf(v1,CG),Hhe={kernelName:v1,backendName:"cpu",kernelFunc:Ghe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IG=lc(n=>Math.floor(n)),jhe=rf(x1,IG),Xhe={kernelName:x1,backendName:"cpu",kernelFunc:jhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NG=Rs((n,e)=>Math.floor(n/e)),qhe=si(w1,NG,null,"int32"),Khe={kernelName:w1,backendName:"cpu",kernelFunc:qhe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AG(n,e,t,r,s,i,o,a,l){const u=Xn([r,i],t);for(let c=0;c<r;c++){const h=[];let d=0;for(let p=0;p<s;p++){const g=n[c*s+p];d+=g*o[p],h.push(g)}if(d<0||d>=l/i)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let p=0;p<i;p++)u.values[c*i+p]=e.get(...e.indexToLoc(d*i+p))}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MG(n,e,t){const r=Xn(t,n.dtype);for(let s=0;s<r.size;++s){const o=r.indexToLoc(s).slice(),a=o[0],l=o[2],u=e.locToIndex([a,l]);o[2]=e.values[u];const c=n.locToIndex(o);0<=c&&c<n.values.length&&(r.values[s]=n.values[c])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kG=Rs((n,e)=>n>e?1:0),Yhe=si(DT,kG,null,"bool"),Zhe={kernelName:DT,backendName:"cpu",kernelFunc:Yhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RG=Rs((n,e)=>n>=e?1:0),Jhe=si(b1,RG,null,"bool"),Qhe={kernelName:b1,backendName:"cpu",kernelFunc:Jhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DG=Rs((n,e)=>n<e?1:0),ede=si(PT,DG,null,"bool"),tde={kernelName:PT,backendName:"cpu",kernelFunc:ede};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $G=Rs((n,e)=>n<=e?1:0),nde=si(LT,$G,null,"bool"),rde={kernelName:LT,backendName:"cpu",kernelFunc:nde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PG(n,e,t){const r=(e-n)/(t-1),s=Zi(t,"float32");s[0]=n;for(let i=1;i<s.length;i++)s[i]=s[i-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LG=lc(n=>Math.log(n)),sde=rf(C1,LG),ide={kernelName:C1,backendName:"cpu",kernelFunc:sde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OG(n,e,t,r){const s=Yi(r,Qe(t));for(let i=0;i<s.length;++i){const o=i*e;let a=n[o];for(let l=0;l<e;++l){const u=n[o+l];(Number.isNaN(u)||u>a)&&(a=u)}s[i]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FG=Rs(((n,e)=>Math.max(n,e))),ode=si(N1,FG),ade={kernelName:N1,backendName:"cpu",kernelFunc:ode};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zG=Rs(((n,e)=>Math.min(n,e))),lde=si(A1,zG),ude={kernelName:A1,backendName:"cpu",kernelFunc:lde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BR=Rs(((n,e)=>n*e)),cde=FR(((n,e,t,r)=>({real:n*t-e*r,imag:n*r+e*t}))),FE=si(k1,BR,cde),hde={kernelName:k1,backendName:"cpu",kernelFunc:FE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BG(n,e,t){const r=Yd(-1,t);return BR([],e,r,n,t)}function dde(n){const{inputs:e,backend:t}=n,{x:r}=e;Xt(r,"neg");const s=t.data.get(r.dataId).values,[i,o]=BG(s,r.shape,r.dtype);return t.makeTensorInfo(o,r.dtype,i)}const fde={kernelName:XT,backendName:"cpu",kernelFunc:dde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UG=Rs(((n,e)=>n!==e?1:0)),pde=si(qT,UG,null,"bool"),mde={kernelName:qT,backendName:"cpu",kernelFunc:pde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UR(n,e,t,r,s){const i=e.length,o=Qe(e),a=nn(e),l=nn(s),u=Yi(t,Qe(s));for(let c=0;c<o;++c){const h=Xy(c,i,a),d=new Array(h.length);for(let g=0;g<d.length;g++)d[g]=h[r[g]];const p=Xu(d,i,l);u[p]=n[c]}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yo(n){const{inputs:e,attrs:t,backend:r}=n,{x:s}=e,{perm:i}=t;Xt(s,"transpose");const o=s.shape.length,a=new Array(o);for(let h=0;h<a.length;h++)a[h]=s.shape[i[h]];const l=r.data.get(s.dataId).values,u=UR(l,s.shape,s.dtype,i,a);return{dataId:r.write(u,a,s.dtype),shape:a,dtype:s.dtype}}const gde={kernelName:ly,backendName:"cpu",kernelFunc:Yo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VG(n,e,t,r){const[s,i]=_i(n,r),o=_a(e,"int32"),a=Zi(Qe(s),o),l=Qe(i);for(let u=0;u<a.length;++u){const c=u*l;let h=1;for(let d=0;d<l;++d)h*=t[c+d];a[u]=h}return{outVals:a,outShape:s,outDtype:o}}function yde(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Xt(s,"prod");const a=s.shape.length,l=qn(i,s.shape),u=ps(l,a);let c=l,h=s;const d=[];u!=null&&(h=Yo({inputs:{x:s},backend:t,attrs:{perm:u}}),d.push(h),c=Ms(c.length,a));const p=t.data.get(h.dataId).values,{outVals:g,outShape:w,outDtype:y}=VG(h.shape,h.dtype,p,c);let x=w;return o&&(x=Vs(w,l)),d.forEach(_=>t.disposeIntermediateTensorInfo(_)),t.makeTensorInfo(x,y,g)}const vde={kernelName:eE,backendName:"cpu",kernelFunc:yde};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xde(n,e,t){n.forEach((r,s)=>{if(r<0||r>=t){const i=Xy(s,e.length,nn(e)).join(",");throw new Error(`indices[${i}] = ${r} is not in [0, ${t})`)}})}function wde(n,e){for(let t=0;t<n.length;++t){const r=n[t],s=t===n.length-1?e:n[t+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let i=1;i<r.length;++i)if(r[i-1]>r[i])throw new Error("Ragged splits must be sorted in ascending order")}}function bde(n,e,t,r){const s=[];let i=0;const o=e.length-1+t.length,a=new Array(o).fill(null).map(()=>[0]);wde(t,r);let l=1;for(let u=0;u<e.length-1;++u){l*=e[u];const c=e[u+1];for(let h=1;h<l+1;++h)a[u].push(h*c)}for(let u=0;u<n.length;++u){let c=n[u],h=n[u]+1;for(let d=0;d<t.length;++d){const p=t[d],g=d+e.length-1;if(g>=0){const w=a[g],y=w[w.length-1]-p[c];for(let x=c;x<h;++x)a[g].push(p[x+1]+y)}c=p[c],h=p[h]}h!==c&&(s.push([c,h]),i+=h-c)}return{outSplits:a,valueSlices:s,numValues:i}}function Sde(n){const e=[];for(let t=0;t<n.length;++t){const r=n[t].length,s=Cs("int32",r);e.push(s),n[t].forEach((i,o)=>s[o]=i)}return e}function AL(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let r=e;r<n.length;r++)t[e-1]*=n[r];return t}function _de(n,e,t,r,s,i){const o=AL(e,2)[1],a=AL(i,2)[1];let l=0;for(const u of t)for(let c=u[0];c<u[1];++c){for(let h=0;h<r;++h)s[l*a+h]=n[c*o+h];++l}}function Tde(n,e,t,r,s){const i=e.slice();i[0]=s;const o=Cs(t,Qe(i)),a=n.length,l=a===0?0:a/e[0];return _de(n,e,r,l,o,i),[o,i]}function WG(n,e,t,r,s,i,o,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(xde(i,o,l),r.length===0)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:c,valueSlices:h,numValues:d}=bde(i,o,n,u),p=Sde(c),g=Tde(t,r,s,h,d);return[p,g[0],g[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ML=2147483647;function GG(n,e,t,r,s,i,o){if(e.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,l=s.length===0,u=o.length===0,c=[];a||c.push(e[0]),l||c.push(s[0]),u||c.push(o[0]);for(let y=1;y<c.length;++y)if(c[y]!==c[y-1])throw new Error("starts, limits, and deltas must have the same shape");const h=c.length===0?1:c[0],d=Cs("int32",h+1);d[0]=0;for(let y=0;y<h;++y){const x=a?n[0]:n[y],_=l?r[0]:r[y],T=u?i[0]:i[y];if(T===0)throw new Error("Requires delta != 0");let E;if(T>0&&_<x||T<0&&_>x)E=0;else if(E=Math.ceil(Math.abs((_-x)/T)),E>ML)throw new Error(`Requires ((limit - start) / delta) <= ${ML}`);d[y+1]=d[y]+E}const p=d[h],g=Cs(t,p);let w=0;for(let y=0;y<h;++y){const x=d[y+1]-d[y];let _=a?n[0]:n[y];const T=u?i[0]:i[y];for(let E=0;E<x;++E)g[w++]=_,_+=T}return[d,g]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var fl=lu;class w_{constructor(e,t,r,s,i,o,a,l,u,c){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=s,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=A4(c),this.raggedRank=M4(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===fl.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===fl.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case fl.VALUE_ROWIDS:return w_.getMaxWidthValueRowID(t);case fl.ROW_SPLITS:return w_.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${fl[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let r=0;for(let s=0;s<t-1;++s){const i=e[s+1]-e[s];i>r&&(r=i)}return r}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let r=0,s=e[0],i=0;for(let o=1;o<t;++o){const a=e[o];a!==s&&(s=a,i=Math.max(o-r,i),r=o)}return Math.max(t-r,i)}tensorShapeFromTensor(e,t,r=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return RL(e,r)}calculateOutputSize(e){const t=this.valuesShape,r=this.defaultValueShape;k4(r,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=N4(this.raggedRank,s,t);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,t,r){const s=Math.min(e,r),i=[];let o=0;for(let a=0;a<s;++a,o+=t)i.push(o);for(let a=s;a<e;++a)i.push(-1);return ie(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,r,s){const i=e.length,o=[];for(let a=0;a<i-1;++a){const l=e[a+1]-e[a];let u=Math.min(s,l),c=t[a];c===-1&&(u=0);for(let h=0;h<u;++h)o.push(c),c+=r;for(let h=0;h<l-u;++h)o.push(-1)}if(i>0&&o.length!==e[i-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,t,r,s){const i=e.length,o=[];if(i===0)return[];let a=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let u=t[l];o.push(u);for(let c=1;c<i;++c){const h=e[c];if(h===l)u>=0&&(++a,a<s?u+=r:u=-1);else{if(a=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);u=t[h]}o.push(u)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,t,r,s){const i=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case fl.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,r,s);case fl.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,r,s);default:throw new Error(`Unsupported partition type: ${fl[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case fl.FIRST_DIM_SIZE:return e[0];case fl.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case fl.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${fl[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const i=RL(r,!1),o=Cs(this.valuesDType,Qe(i));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(t,s[0],r[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,s[u],r[u]);this.setOutput(this.raggedRank,l,o,i)}return[i,o]}setOutput(e,t,r,s){if(r.length===0)return;const i=this.values,o=r;let a=s.slice();a=a.slice(e+1);const l=Qe(a),u=t.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const g=this.defaultValueShape;ze(()=>{const w=$e(c,g);c=Xv(w,a).dataSync()})}let h=0,d=0,p=0;for(let g=0;g<=u;++g){let w=g<u?t[g]:-1;if(w===p){++p;continue}if(d<p){const y=i.subarray(h*l),x=o.subarray(d*l),_=(p-d)*l;kL(x,y,_)}if(g>=u){const y=r.length;w=Math.floor(y/l)}if(w>p)if(this.defaultValue.length===1)o.subarray(p*l,w*l).fill(this.defaultValue[0]),p=w;else for(;w>p;){const y=o.slice(p*l);kL(y,c,l),++p}w<0?(h=g+1,d=p):(h=g,d=p,p=d+1)}}}function kL(n,e,t){for(let r=0;r<t;r++)n[r]=e[r]}function RL(n,e){const t=[];for(let r of n){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function HG(n,e,t,r,s,i,o,a,l,u){return new w_(n,e,t,r,s,i,o,a,l,u).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jG(n,e,t,r){const s=n===e,i=n<e&&t<0,o=e<n&&t>1;if(s||i||o)return Zi(0,r);const a=Math.abs(Math.ceil((e-n)/t)),l=Zi(a,r);e<n&&t===1&&(t=-1),l[0]=n;for(let u=1;u<l.length;u++)l[u]=l[u-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XG=lc(n=>1/Math.sqrt(n)),Ede=rf(O1,XG),Cde={kernelName:O1,backendName:"cpu",kernelFunc:Ede};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _p(n,e,t,r,s,i,o,a,l,u){const c=[r/s,s],h=n.values,d=e.values;if(r===0)return Xn(t,e.dtype);const p=l instanceof $i?l:Xn(c,e.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let g=0;g<i;g++){const w=[];let y=0;for(let x=0;x<o;x++){const _=h[g*o+x];w.push(_),y+=_*a[x]}if(y<0||y>=r/s)throw new Error(`Invalid indices: ${w} does not index into ${t}`);for(let x=0;x<s;x++)u?p.values[y*s+x]+=d[g*s+x]:p.values[y*s+x]=e.rank===0?d[0]:d[g*s+x]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ide=lc(n=>1/(1+Math.exp(-n))),qG=Mr(V1,n=>1/(1+Math.exp(-n))),Nde={kernelName:V1,backendName:"cpu",kernelFunc:qG};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KG(n,e,t,r,s){const i=jk(r,e,t),o=Qe(t),a=nn(r);if(i){const h=Xk(e,a);return s==="string"?n.slice(h,h+o):n.subarray(h,h+o)}const l=s==="string"?hh(n):n,u=Xn(r,s,l),c=Xn(t,s);for(let h=0;h<c.size;++h){const d=c.indexToLoc(h),p=d.map((g,w)=>g+e[w]);c.set(u.get(...p),...d)}return s==="string"?Z4(c.values):c.values}function Yp(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,size:o}=r;Xt(s,"slice");const[a,l]=_E(s,i,o);Gk(s,a,l);const u=t.data.get(s.dataId).values,c=KG(u,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,c)}const Ade={kernelName:oE,backendName:"cpu",kernelFunc:Yp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YG(n,e,t,r,s,i,o){const a=e[0],l=i[0],u=new Array(l),c=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error(F4(a));const y=Cs(t,0),x=Cs(s,0);return[y,[0,h],x,u,c]}let d=!0,p=0;const g=new Array(l).fill(0);for(let y=0;y<a;++y){const x=n[y*h];if(x<0)throw new Error(z4(y,x));if(x>=l)throw new Error(B4(y,x,l));++g[x],d=d&&x>=p,p=x}let w=!0;for(let y=0;y<l;++y){const x=g[y]===0;u[y]=x,w=w&&!x,g[y]=Math.max(g[y],1),y>0&&(g[y]+=g[y-1])}if(w&&d){const y=n,x=r;for(let _=0;_<a;++_)c[_]=_;return[y,[a,h],x,u,c]}else{const y=g[l-1],x=Cs(t,y*h),_=Cs(s,y),T=new Array(l).fill(0);for(let E=0;E<a;++E){const N=n[E*h],M=T[N],$=(N===0?0:g[N-1])+M;T[N]++;for(let L=0;L<h;++L)x[$*h+L]=n[E*h+L];_[$]=r[E],c[E]=$}for(let E=0;E<l;++E)if(T[E]===0){const M=E===0?0:g[E-1];x[M*h+0]=E;for(let $=1;$<h;++$)x[M*h+$]=0;_[M]=o}return[x,[y,h],_,u,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZG(n,e,t,r,s){const i=Qe(r),o=e[0],a=s.length,l=[];let u=1,c=-1;for(let y=0;y<a;++y){const x=s[y];if(x===-1){if(c!==-1)throw new Error(U4(c,y));c=y,l.push(1)}else{if(x<0)throw new Error(V4(y,x));u*=x,l.push(x)}}if(c!==-1){if(u<=0)throw new Error(W4());const y=Math.trunc(i/u);if(u*y!==i)throw new Error(G4(r,l));l[c]=y}if(Qe(l)!==i)throw new Error(H4(r,l));const d=r.length,p=[];if(d>0){p[d-1]=1;for(let y=d-2;y>=0;--y)p[y]=p[y+1]*r[y+1]}const g=[];if(a>0){g[a-1]=1;for(let y=a-2;y>=0;--y)g[y]=g[y+1]*l[y+1]}const w=Cs(t,o*a);for(let y=0;y<o;++y){let x=0;for(let _=0;_<d;++_)x+=n[y*d+_]*p[_];for(let _=0;_<a;++_)w[y*a+_]=Math.trunc(x/g[_]),x%=g[_]}return[w,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VR(n,e,t,r,s,i=!1,o=0){const a=r.length,l=[e[0],n.length/e[0]],u=l[1],h=a>0?s[a-1]+1:0;if(h<0)throw new Error(TN());const d=e.slice();d[0]=h;const p=d.reduce((T,E)=>T*E,1),g=Cs(t,p);if(a===0)return h>0&&g.fill(o),[g,d];if(h<=0)throw new Error(TN());let w=0,y=1,x=0,_=s[w];for(;;){let T=0;if(y<a){if(T=s[y],_===T){++y;continue}if(_>=T)throw new Error(j4())}if(_<0||_>=h)throw new Error(X4(_,h));_>x&&g.fill(o,x*u,_*u);for(let E=w;E<y;++E){const N=r[E];if(N<0||N>=l[0])throw new Error(q4(E,r[E],l[0]));for(let M=0;M<u;M++)g[_*u+M]+=n[N*u+M]}if(i)for(let E=0;E<u;E++)g[_*u+E]/=y-w;if(w=y,++y,x=_+1,_=T,y>a)break}return x<h&&g.fill(o,x*u,h*u),[g,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mde=lc(n=>Math.sqrt(n)),kde=Mr(G1,n=>Math.sqrt(n)),Rde={kernelName:G1,backendName:"cpu",kernelFunc:kde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JG=Rs(((n,e)=>{const t=n-e;return t*t})),Dde=si(H1,JG),$de={kernelName:H1,backendName:"cpu",kernelFunc:Dde};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QG=lc((n,e)=>{const{pattern:t,replaceGlobal:r,rewrite:s}=e;return n.replace(new RegExp(t,r?"g":""),s)}),Pde=rf(sk,QG),Lde={kernelName:sk,backendName:"cpu",kernelFunc:Pde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eH(n,e,t,r){const s=Xn(n,e.dtype);for(let i=0;i<s.size;i++){const o=s.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+r[l];s.set(e.get(...a),...o)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ode{constructor(e,t,r,s,i,o){this.separator=_d(e),this.nGramWidths=t,this.leftPad=_d(r),this.rightPad=_d(s),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,s,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),u=Math.max(0,l-a),c=Math.max(0,l-(i-(a+1))),h=o-(u+c),d=t+(u>0?0:a-l);let p=0;p+=u*this.leftPad.length;for(let _=0;_<h;++_)p+=e[d+_].length;p+=c*this.rightPad.length;const g=u+c+h-1;p+=g*this.separator.length,r[s+a]=new Uint8Array(p);const w=r[s+a];let y=0;const x=_=>_.forEach(T=>w[y++]=T);for(let _=0;_<u;++_)x(this.leftPad),x(this.separator);for(let _=0;_<h-1;++_)x(e[d+_]),x(this.separator);if(h>0){x(e[d+h-1]);for(let _=0;_<c;++_)x(this.separator),x(this.rightPad)}else{for(let _=0;_<c-1;++_)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(e,t){const r=e.length,s=t.length;if(s>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<s;++u){let c=t[u]>=l;if(c=c&&t[u]<=r,!c)throw new Error(`Invalid split value ${t[u]}, must be in [${l}, ${r}]`);l=t[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const i=s-1,o=Cs("int32",s);if(r===0||s===0){const l=new Array(r);for(let u=0;u<=i;++u)o[u]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const u=t[l]-t[l-1];let c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(u,h)}),this.preserveShort&&u>0&&c===0&&(c=1),o[l]=o[l-1]+c}const a=new Array(o[i]);for(let l=0;l<i;++l){const u=t[l];let c=o[l];if(this.nGramWidths.forEach(h=>{const d=t[l+1]-t[l],p=this.getNumNGrams(d,h);this.createNGrams(e,u,a,c,p,h),c+=p}),this.preserveShort&&c===o[l]){const h=t[l+1]-t[l];if(h===0)continue;const d=h+2*this.padWidth;this.createNGrams(e,u,a,c,1,d)}}return[a,o]}}function tH(n,e,t,r,s,i,o,a){return new Ode(t,r,s,i,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fde(n,e,t,r){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)r.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let o=n.indexOf(i);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&r.push(a),n=n.subarray(o+1),o=n.indexOf(i)}(!t||n.length!==0)&&r.push(n);return}let s=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const o=n.subarray(s,i);(!t||o.length!==0)&&r.push(o),s=i+1}}function nH(n,e,t){const r=n.length,s=[];let i=0,o=0;const a=new Array(r);for(let d=0;d<r;++d){const p=s.length;Fde(n[d],e,t,s);const g=s.length-p;a[d]=g,i+=g,o=Math.max(o,g)}const l=Cs("int32",i*2),u=new Array(i),c=[r,o];let h=0;for(let d=0;d<r;++d)for(let p=0;p<a[d];++p)l[h*2]=d,l[h*2+1]=p,u[h]=s[h],++h;return[l,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rH(n,e){const t=Cs("int32",n.length);for(let r=0;r<n.length;++r)t[r]=gte(n[r]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sH=Rs(((n,e)=>n-e)),zde=FR(((n,e,t,r)=>({real:n-t,imag:e-r}))),WR=si(j1,sH,zde),Bde={kernelName:j1,backendName:"cpu",kernelFunc:WR};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iH(n,e){const t=new Array(n.rank);for(let s=0;s<t.length;s++)t[s]=n.shape[s]*e[s];const r=Xn(t,n.dtype);for(let s=0;s<r.values.length;++s){const i=r.indexToLoc(s),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);r.values[s]=n.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pv=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function oH(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){const a=r-t+1,l=e-t+1,u=Math.log(a),c=.5*Math.exp(2*u/3),h=.5*Math.sqrt(u*c*(a-c)/a)*Math.sign(l-a/2),d=Math.max(t,Math.floor(e-l*c/a+h)),p=Math.min(r,Math.floor(e+(a-l)*c/a+h));oH(n,e,d,p)}const s=n[e];let i=t,o=r;for(Xg(n,t,e),Pv(n[r],s)>0&&Xg(n,t,r);i<o;){for(Xg(n,i,o),i++,o--;Pv(n[i],s)<0;)i=i+1;for(;Pv(n[o],s)>0;)o=o-1}Pv(n[t],s)===0?Xg(n,t,o):(o=o+1,Xg(n,o,r)),o<=e&&(t=o+1),e<=o&&(r=o-1)}}function aH(n,e,t,r,s){const i=e[e.length-1],[o,a]=[n.length/i,i],l=Yi(t,o*r),u=Yi("int32",o*r);for(let h=0;h<o;h++){const d=h*a,p=n.subarray(d,d+a);let g=new Array(p.length);p.forEach((_,T)=>g[T]={value:_,index:T}),r<g.length&&(oH(g,r),g=g.slice(0,r)),s&&g.sort(Pv);const w=h*r,y=l.subarray(w,w+r),x=u.subarray(w,w+r);for(let _=0;_<r;_++)y[_]=g[_].value,x[_]=g[_].index}const c=e.slice();return c[c.length-1]=r,[Xn(c,t,l),Xn(c,"int32",u)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lH(n,e,t,r){const s=qn(e,t)[0],i=[1,t[0],1];for(let g=0;g<s;g++)i[0]*=t[g];i[1]=t[s];for(let g=s+1;g<t.length;g++)i[2]*=t[g];const o=new Map,a=new Int32Array(t[s]),l=new $i(i,r,n),u=[],c=i[0]===1&&i[2]===1;for(let g=0;g<t[s];g++){let w;if(c)w=n[g].toString();else{const x=[];for(let _=0;_<i[0];_++)for(let T=0;T<i[2];T++)x.push(l.get(_,g,T));w=x.join(",")}const y=o.get(w);if(y!=null)a[g]=y;else{const x=o.size;o.set(w,x),a[g]=x,u.push(g)}}const h=i.slice();h[1]=o.size;const d=new $i(h,r);u.forEach((g,w)=>{for(let y=0;y<i[0];y++)for(let x=0;x<i[2];x++)d.set(l.get(y,g,x),y,w,x)});const p=t.slice();return p[s]=h[1],{outputValues:d.values,outputShape:p,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ude=Object.freeze(Object.defineProperty({__proto__:null,addImpl:yG,bincountImpl:zR,bincountReduceImpl:vG,bitwiseAndImpl:xG,castImpl:gG,ceilImpl:wG,concatImpl:bG,equalImpl:SG,expImpl:TG,expm1Impl:CG,floorDivImpl:NG,floorImpl:IG,gatherNdImpl:AG,gatherV2Impl:MG,greaterEqualImpl:RG,greaterImpl:kG,lessEqualImpl:$G,lessImpl:DG,linSpaceImpl:PG,logImpl:LG,maxImpl:OG,maximumImpl:FG,minimumImpl:zG,multiplyImpl:BR,negImpl:BG,notEqualImpl:UG,prodImpl:VG,raggedGatherImpl:WG,raggedRangeImpl:GG,raggedTensorToTensorImpl:HG,rangeImpl:jG,rsqrtImpl:XG,scatterImpl:_p,sigmoidImpl:Ide,simpleAbsImpl:mG,sliceImpl:KG,sparseFillEmptyRowsImpl:YG,sparseReshapeImpl:ZG,sparseSegmentReductionImpl:VR,sqrtImpl:Mde,squaredDifferenceImpl:JG,staticRegexReplaceImpl:QG,stridedSliceImpl:eH,stringNGramsImpl:tH,stringSplitImpl:nH,stringToHashBucketFastImpl:rH,subImpl:sH,tileImpl:iH,topKImpl:aH,transposeImpl:UR,uniqueImpl:lH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */NU("cpu",()=>new OE,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uH=Mr(m1,n=>n>=0?n:Math.exp(n)-1),Vde={kernelName:m1,backendName:"cpu",kernelFunc:uH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cH(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:i}=r;Xt([s],"leakyRelu");const o=Qe(s.shape),a=t.data.get(s.dataId).values,l=Yi("float32",o);for(let u=0;u<a.length;u++)l[u]=a[u]<0?i*a[u]:a[u];return t.makeTensorInfo(s.shape,"float32",l)}const Wde={kernelName:$T,backendName:"cpu",kernelFunc:cH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gde=Rs((n,e)=>n<0?e*n:n);function hH(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e;Xt([r,s],"prelu");const i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values,[a,l]=Gde(r.shape,s.shape,i,o,"float32");return t.makeTensorInfo(l,"float32",a)}const Hde={kernelName:QT,backendName:"cpu",kernelFunc:hH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dH=Mr($1,n=>Math.max(0,n)),jde={kernelName:$1,backendName:"cpu",kernelFunc:dH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fH=Mr(P1,n=>Math.min(Math.max(0,n),6)),Xde={kernelName:P1,backendName:"cpu",kernelFunc:fH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b_(n,e,t,r,s){if(t==="linear")return oc({inputs:{x:e},backend:n});if(t==="relu")return dH({inputs:{x:e},backend:n});if(t==="elu")return uH({inputs:{x:e},backend:n});if(t==="relu6")return fH({inputs:{x:e},backend:n});if(t==="prelu")return hH({inputs:{x:e,alpha:r},backend:n});if(t==="leakyrelu")return cH({inputs:{x:e},backend:n,attrs:{alpha:s}});if(t==="sigmoid")return qG({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qr(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:i}=r,o=Qe(s.shape),a=LB(i,o),l=Qe(a);ie(o===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(s.dataId);const u=t.data.get(s.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,h=u.complexTensorInfos.imag;c.shape=a,h.shape=a}return{dataId:s.dataId,shape:a,dtype:s.dtype}}const qde={kernelName:tE,backendName:"cpu",kernelFunc:qr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pH(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;Xt([s,i],"matMul");const l=s.shape.length,u=i.shape.length,c=o?s.shape[l-2]:s.shape[l-1],h=a?i.shape[u-1]:i.shape[u-2],d=o?s.shape[l-1]:s.shape[l-2],p=a?i.shape[u-2]:i.shape[u-1],g=s.shape.slice(0,-2),w=i.shape.slice(0,-2),y=Qe(g),x=Qe(w),T=$n(s.shape.slice(0,-2),i.shape.slice(0,-2)).concat([d,p]);ie(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${o} and transposeB=${a} must match.`);const E=o?[y,c,d]:[y,d,c],N=a?[x,p,h]:[x,h,p],M=qr({inputs:{x:s},backend:t,attrs:{shape:E}}),$=qr({inputs:{x:i},backend:t,attrs:{shape:N}}),L=o?M.shape[1]:M.shape[2],k=o?M.shape[2]:M.shape[1],R=a?$.shape[1]:$.shape[2],P=Math.max(y,x),B=t.data.get(M.dataId).values,Z=t.data.get($.dataId).values,V=nn(M.shape),X=nn($.shape),[q,se,W]=o?[V[0],1,V[1]]:[V[0],V[1],1],[J,K,G]=a?[1,X[1],X[0]]:[X[1],1,X[0]],Q=k*R,ne=Xn([P,k,R],M.dtype),ce=ne.values,ye=t.blockSize;for(let Se=0;Se<P;Se++){const Re=Se%y,Oe=Se%x;for(let Ke=0;Ke<k;Ke+=ye){const st=Math.min(Ke+ye,k);for(let ct=0;ct<R;ct+=ye){const fe=Math.min(ct+ye,R);for(let nt=0;nt<L;nt+=ye){const Xe=Math.min(nt+ye,L);for(let it=Ke;it<st;it++)for(let He=ct;He<fe;He++){let _t=0;for(let mt=nt;mt<Xe;mt++){const oe=B[Re*q+it*se+mt*W],ee=Z[mt*J+He*K+Oe*G];_t+=oe*ee}ce[Se*Q+(it*R+He)]+=_t}}}}}return t.disposeIntermediateTensorInfo(M),t.disposeIntermediateTensorInfo($),t.makeTensorInfo(T,ne.dtype,ne.values)}const Kde={kernelName:xT,backendName:"cpu",kernelFunc:pH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yde(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;let d,p,g;const w=[];d=pH({inputs:{a:s,b:i},attrs:{transposeA:l,transposeB:u},backend:t}),o&&(p=Ny({inputs:{a:d,b:o},backend:t}),w.push(d),d=p),c&&(g=b_(t,d,c,a,h),w.push(d),d=g);for(const x of w)t.disposeIntermediateTensorInfo(x);return d}const Zde={kernelName:t_,backendName:"cpu",kernelFunc:Yde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jde=Mr(n1,n=>Math.acos(n)),Qde={kernelName:n1,backendName:"cpu",kernelFunc:Jde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const efe=Mr(r1,n=>Math.acosh(n)),tfe={kernelName:r1,backendName:"cpu",kernelFunc:efe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nfe(n){const{inputs:e,backend:t}=n,r=e;Xt(e,"addN");const s=r.map(a=>t.data.get(a.dataId).values),i=Xn(r[0].shape,r[0].dtype),o=i.values;for(let a=0;a<r.length;a++){const l=s[a];for(let u=0;u<o.length;u++)o[u]+=l[u]}return t.makeTensorInfo(i.shape,i.dtype,i.values)}const rfe={kernelName:_M,backendName:"cpu",kernelFunc:nfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sfe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Xt(s,"all");const a=qn(i,s.shape);let l=a;const u=ps(l,s.shape.length);let c=s;u!=null&&(c=Yo({inputs:{x:s},backend:t,attrs:{perm:u}}),l=Ms(l.length,s.shape.length)),Li("all",l,c.shape.length);const[h,d]=_i(c.shape,l),p=Qe(d),g=Zi(Qe(h),c.dtype),w=t.data.get(c.dataId).values;for(let x=0;x<g.length;++x){const _=x*p;let T=w[_];for(let E=0;E<p;++E){const N=w[_+E];T=T&&N}g[x]=T}u!=null&&t.disposeIntermediateTensorInfo(c);const y=t.makeTensorInfo(h,c.dtype,g);if(o){const x=Vs(h,a),_=qr({inputs:{x:y},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(y),_}return y}const ife={kernelName:TM,backendName:"cpu",kernelFunc:sfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ofe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Xt(s,"any");const a=qn(i,s.shape);let l=a;const u=ps(l,s.shape.length);let c=s;u!=null&&(c=Yo({inputs:{x:s},backend:t,attrs:{perm:u}}),l=Ms(l.length,s.shape.length)),Li("any",l,c.shape.length);const[h,d]=_i(c.shape,l),p=Qe(d),g=Zi(Qe(h),c.dtype),w=t.data.get(c.dataId).values;for(let x=0;x<g.length;++x){const _=x*p;let T=w[_];for(let E=0;E<p;++E){const N=w[_+E];T=T||N}g[x]=T}u!=null&&t.disposeIntermediateTensorInfo(c);const y=t.makeTensorInfo(h,c.dtype,g);if(o){const x=Vs(h,a),_=qr({inputs:{x:y},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(y),_}return y}const afe={kernelName:EM,backendName:"cpu",kernelFunc:ofe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lfe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;Xt(s,"argMax");let o=qn(i,s.shape);const a=ps(o,s.shape.length);let l=s;const u=[];a!=null&&(l=Yo({inputs:{x:s},backend:t,attrs:{perm:a}}),u.push(l),o=Ms(o.length,l.shape.length)),o=[o[0]],Li("argMax",o,l.shape.length);const[c,h]=_i(l.shape,o),d=Qe(c),p=Zi(d,"int32"),g=Qe(h),w=t.data.get(l.dataId).values;for(let y=0;y<p.length;++y){const x=y*g;let _=w[x],T=0;for(let E=0;E<g;++E){const N=w[x+E];N>_&&(_=N,T=E)}p[y]=T}return u.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(c,"int32",p)}const ufe={kernelName:mT,backendName:"cpu",kernelFunc:lfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cfe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;Xt(s,"argMin");let o=qn(i,s.shape);const a=ps(o,s.shape.length);let l=s;const u=[];a!=null&&(l=Yo({inputs:{x:s},backend:t,attrs:{perm:a}}),u.push(l),o=Ms(o.length,l.shape.length)),o=[o[0]],Li("argMin",o,l.shape.length);const[c,h]=_i(l.shape,o),d=Qe(c),p=Zi(d,"int32"),g=Qe(h),w=t.data.get(l.dataId).values;for(let y=0;y<p.length;++y){const x=y*g;let _=w[x],T=0;for(let E=0;E<g;++E){const N=w[x+E];N<_&&(_=N,T=E)}p[y]=T}return u.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(c,"int32",p)}const hfe={kernelName:gT,backendName:"cpu",kernelFunc:cfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dfe=Mr(s1,n=>Math.asin(n)),ffe={kernelName:s1,backendName:"cpu",kernelFunc:dfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pfe=Mr(i1,n=>Math.asinh(n)),mfe={kernelName:i1,backendName:"cpu",kernelFunc:pfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gfe=Mr(o1,n=>Math.atan(n)),yfe={kernelName:o1,backendName:"cpu",kernelFunc:gfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vfe=Rs((n,e)=>Math.atan2(n,e)),xfe=si(l1,vfe),wfe={kernelName:l1,backendName:"cpu",kernelFunc:xfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bfe=Mr(a1,n=>Math.atanh(n)),Sfe={kernelName:a1,backendName:"cpu",kernelFunc:bfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GR(n,e,t,r,s,i){const o=s.strideHeight,a=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,h=s.effectiveFilterWidth,d=s.padInfo.top,p=s.padInfo.left,g=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=Xn(s.outShape,t),y=w.values,x=s.outShape[1]*s.outShape[2]*s.outShape[3],_=s.outShape[2]*s.outShape[3],T=s.outShape[3];for(let E=0;E<s.batchSize;++E){const N=E*x,M=E*r[0];for(let $=0;$<s.inChannels;++$)for(let L=0;L<s.outHeight;++L){const k=L*o-d,R=Math.max(0,k),P=Math.min(s.inHeight,c+k),B=N+L*_;for(let Z=0;Z<s.outWidth;++Z){const V=Z*a-p,X=Math.max(0,V),q=Math.min(s.inWidth,h+V);let se=g,W=0,J=0;for(let G=R;G<P;G+=l){const Q=M+G*r[1];for(let ne=X;ne<q;ne+=u){const ce=Q+ne*r[2],ye=n[ce+$];i==="max"&&ye>se?se=ye:i==="avg"&&(W+=ye,J++)}if(isNaN(se))break}const K=B+Z*T+$;y[K]=i==="avg"?W/J:se}}}return w}function mH(n,e,t,r,s=!1,i=!1){const o=Xn(r.outShape,"int32"),a=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,h=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,g=r.padInfo.left,w=Xn(e,t,n);for(let y=0;y<r.batchSize;++y)for(let x=0;x<r.inChannels;++x)for(let _=0;_<r.outHeight;++_){const T=_*a-p;let E=T;for(;E<0;)E+=u;const N=Math.min(r.inHeight,h+T);for(let M=0;M<r.outWidth;++M){const $=M*l-g;let L=$;for(;L<0;)L+=c;const k=Math.min(r.inWidth,d+$);let R=Number.NEGATIVE_INFINITY,P=-1;for(let B=E;B<N;B+=u){const Z=B-T;for(let V=L;V<k;V+=c){const X=V-$,q=w.get(y,B,V,x);q>R&&(R=q,s?P=i?((y*r.inHeight+B)*r.inWidth+V)*r.inChannels+x:(B*r.inWidth+V)*r.inChannels+x:P=Z*d+X)}}o.set(P,y,_,M,x)}}return o}function gH(n,e,t,r,s,i){const o=s.strideDepth,a=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterDepth,p=s.effectiveFilterHeight,g=s.effectiveFilterWidth,w=s.padInfo.front,y=s.padInfo.top,x=s.padInfo.left,_=i==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,T=Xn(s.outShape,t),E=T.values,N=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],M=s.outShape[2]*s.outShape[3]*s.outShape[4],$=s.outShape[3]*s.outShape[4],L=s.outShape[4];for(let k=0;k<s.batchSize;++k){const R=k*N,P=k*r[0];for(let B=0;B<s.inChannels;++B)for(let Z=0;Z<s.outDepth;++Z){const V=Z*o-w;let X=V;for(;X<0;)X+=u;const q=Math.min(s.inDepth,d+V),se=R+Z*M;for(let W=0;W<s.outHeight;++W){const J=W*a-y;let K=J;for(;K<0;)K+=c;const G=Math.min(s.inHeight,p+J),Q=se+W*$;for(let ne=0;ne<s.outWidth;++ne){const ce=ne*l-x;let ye=ce;for(;ye<0;)ye+=h;const Se=Math.min(s.inWidth,g+ce),Re=Q+ne*L;let Oe=_,Ke=0,st=0;for(let fe=X;fe<q;fe+=u){const nt=P+fe*r[1];for(let Xe=K;Xe<G;Xe+=c){const it=nt+Xe*r[2];for(let He=ye;He<Se;He+=h){const _t=it+He*r[3],mt=n[_t+B];if(i==="max"&&mt>Oe?Oe=mt:i==="avg"&&(Ke+=mt,st++),isNaN(Oe))break}if(isNaN(Oe))break}if(isNaN(Oe))break}const ct=Re+B;E[ct]=i==="avg"?Ke/Math.max(st,1):Oe}}}}return T}function _fe(n,e){const t=Xn(e.outShape,"int32"),r=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,a=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,g=e.padInfo.left;for(let w=0;w<e.batchSize;++w)for(let y=0;y<e.inChannels;++y)for(let x=0;x<e.outDepth;++x){const _=x*r-d;let T=_;for(;T<0;)T+=o;const E=Math.min(e.inDepth,u+_);for(let N=0;N<e.outHeight;++N){const M=N*s-p;let $=M;for(;$<0;)$+=a;const L=Math.min(e.inHeight,c+M);for(let k=0;k<e.outWidth;++k){const R=k*i-g;let P=R;for(;P<0;)P+=l;const B=Math.min(e.inWidth,h+R);let Z=Number.NEGATIVE_INFINITY,V=-1;for(let X=T;X<E;X+=o){const q=X-_;for(let se=$;se<L;se+=a){const W=se-M;for(let J=P;J<B;J+=l){const K=J-R,G=n.get(w,X,se,J,y);G>=Z&&(Z=G,V=q*c*h+W*c+K)}}}t.set(V,w,x,N,k,y)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tfe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Xt(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,u=1;ie(Ji(o,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=El(s.shape,i,o,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&_r(c.inShape,c.outShape))h=oc({inputs:{x:s},backend:t});else{const d=t.data.get(s.dataId).values,p=nn(s.shape),g=GR(d,s.shape,s.dtype,p,c,"avg");h=t.makeTensorInfo(c.outShape,s.dtype,g.values)}return h}const Efe={kernelName:yT,backendName:"cpu",kernelFunc:Tfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cfe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=r;Xt(s,"avgPool3d");const c=vh(s.shape,i,o,1,a,l,u),h=t.data.get(s.dataId).values,d=gH(h,s.shape,s.dtype,nn(s.shape),c,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}const Ife={kernelName:vT,backendName:"cpu",kernelFunc:Cfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nfe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=r;Xt([s,i],"avgPool3DGrad");const c=vh(i.shape,o,a,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,g=c.filterDepth,w=c.filterHeight,y=c.filterWidth,x=c.dilationDepth,_=c.dilationHeight,T=c.dilationWidth,E=c.effectiveFilterDepth,N=c.effectiveFilterHeight,M=c.effectiveFilterWidth,$=E-1-c.padInfo.front,L=M-1-c.padInfo.left,k=N-1-c.padInfo.top,R=Xn(i.shape,"float32"),P=1/(g*w*y),B=t.bufferSync(s);for(let Z=0;Z<c.batchSize;++Z)for(let V=0;V<c.inChannels;++V)for(let X=0;X<c.inDepth;++X)for(let q=0;q<c.inHeight;++q)for(let se=0;se<c.inWidth;++se){const W=X-$,J=q-k,K=se-L;let G=0;for(let Q=0;Q<E;Q+=x){const ne=(W+Q)/h;if(!(ne<0||ne>=c.outDepth||Math.floor(ne)!==ne))for(let ce=0;ce<N;ce+=_){const ye=(J+ce)/d;if(!(ye<0||ye>=c.outHeight||Math.floor(ye)!==ye))for(let Se=0;Se<M;Se+=T){const Re=(K+Se)/p;if(Re<0||Re>=c.outWidth||Math.floor(Re)!==Re)continue;const Oe=B.get(Z,ne,ye,Re,V);G+=Oe}}}R.set(G*P,Z,X,q,se,V)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const Afe={kernelName:IM,backendName:"cpu",kernelFunc:Nfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mfe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i;Xt([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=El(o.shape,a,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,g=c.filterWidth,w=c.dilationHeight,y=c.dilationWidth,x=c.effectiveFilterHeight,_=c.effectiveFilterWidth,T=_-1-c.padInfo.left,E=x-1-c.padInfo.top,N=Xn(o.shape,"float32"),M=1/(p*g),$=t.data.get(s.dataId).values,L=Xn(s.shape,"float32",$);for(let k=0;k<c.batchSize;++k)for(let R=0;R<c.inChannels;++R)for(let P=0;P<c.inHeight;++P)for(let B=0;B<c.inWidth;++B){const Z=P-E,V=B-T;let X=0;for(let q=0;q<x;q+=w){const se=(Z+q)/h;if(!(se<0||se>=c.outHeight||Math.floor(se)!==se))for(let W=0;W<_;W+=y){const J=(V+W)/d;if(J<0||J>=c.outWidth||Math.floor(J)!==J)continue;const K=L.get(k,se,J,R);X+=K}}N.set(X*M,k,P,B,R)}return t.makeTensorInfo(N.shape,N.dtype,N.values)}const kfe={kernelName:CM,backendName:"cpu",kernelFunc:Mfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rfe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,scale:i,offset:o,mean:a,variance:l}=e;ie(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ie(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ie(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Xt([s,a,l,i,o],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);const c=t.data.get(s.dataId).values,h=t.data.get(a.dataId).values,d=t.data.get(l.dataId).values,p=i?t.data.get(i.dataId).values:new Float32Array([1]),g=o?t.data.get(o.dataId).values:new Float32Array([0]),w=new Float32Array(c.length),y=g.length,x=p.length,_=d.length,T=h.length;let E=0,N=0,M=0,$=0;for(let L=0;L<c.length;++L)w[L]=g[E++]+(c[L]-h[N++])*p[M++]/Math.sqrt(d[$++]+u),E>=y&&(E=0),N>=T&&(N=0),M>=x&&(M=0),$>=_&&($=0);return t.makeTensorInfo(s.shape,s.dtype,w)}const Dfe={kernelName:kT,backendName:"cpu",kernelFunc:Rfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $fe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,crops:o}=r;Xt([s],"batchToSpaceND");const a=i.reduce((x,_)=>x*_),l=rw(s.shape,i,a),u=sw(l.length,i.length),c=iw(s.shape,i,a),h=Jk(o,i.length),d=Qk(c,o,i.length),p=qr({inputs:{x:s},backend:t,attrs:{shape:l}}),g=Yo({inputs:{x:p},backend:t,attrs:{perm:u}}),w=qr({inputs:{x:g},backend:t,attrs:{shape:c}}),y=Yp({inputs:{x:w},backend:t,attrs:{begin:h,size:d}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(w),y}const Pfe={kernelName:wT,backendName:"cpu",kernelFunc:$fe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lfe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o}=r,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,u=zR(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,u)}const Ofe={kernelName:NM,backendName:"cpu",kernelFunc:Lfe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ffe(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,i=t.data.get(r.dataId).values,o=t.data.get(s.dataId).values,a=$n(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const zfe={kernelName:VB,backendName:"cpu",kernelFunc:Ffe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bfe=Mr(h1,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),Ufe={kernelName:h1,backendName:"cpu",kernelFunc:Bfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vfe=n=>{const{x:e}=n.inputs,t=n.backend,r=new Float32Array(Qe(e.shape)),s=t.data.get(e.dataId),i=s.complexTensorInfos.real,o=s.complexTensorInfos.imag,a=t.data.get(i.dataId).values,l=t.data.get(o.dataId).values;for(let u=0;u<a.length;u++){const c=a[u],h=l[u];r[u]=Math.hypot(c,h)}return t.makeOutput(r,e.shape,"float32")},Wfe={kernelName:bT,backendName:"cpu",kernelFunc:Vfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ay(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.data.get(r.dataId).complexTensorInfos.imag,i=t.data.get(s.dataId).values;return t.makeTensorInfo(s.shape,s.dtype,i)}const Gfe={kernelName:jM,backendName:"cpu",kernelFunc:Ay};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function My(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,i=qn(s,e[0].shape)[0],o=e.map(w=>w.shape);Kk(o,i);let a=Ku(e.map(w=>w.shape),i);if(Qe(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(w=>Qe(w.shape)>0);if(l.length===1)return oc({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const w=l.map(E=>Kp({inputs:{input:E},backend:t})),y=l.map(E=>Ay({inputs:{input:E},backend:t})),x=My({inputs:w,backend:t,attrs:{axis:i}}),_=My({inputs:y,backend:t,attrs:{axis:i}}),T=wa({inputs:{real:x,imag:_},backend:t});return w.forEach(E=>t.disposeIntermediateTensorInfo(E)),y.forEach(E=>t.disposeIntermediateTensorInfo(E)),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(_),T}const u=l.map(w=>{const x=[-1,Qe(w.shape.slice(i))];return qr({inputs:{x:w},backend:t,attrs:{shape:x}})}),c=u.map(w=>({vals:t.data.get(w.dataId).values,shape:w.shape}));a=Ku(u.map(w=>w.shape),1);const h=u[0].shape[0]===1,d=bG(c,a,e[0].dtype,h),p=Ku(l.map(w=>w.shape),i),g=t.makeTensorInfo(p,e[0].dtype,d);return u.forEach(w=>t.disposeIntermediateTensorInfo(w)),g}const Hfe={kernelName:ST,backendName:"cpu",kernelFunc:My};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yH(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r;Xt([s,i],"conv2d");const h=xh(l),d=Pi(s.shape,i.shape,o,u,a,c,!1,h),p=d.filterHeight,g=d.filterWidth,w=d.dilationHeight,y=d.dilationWidth,x=d.padInfo.left,_=d.padInfo.top,T=d.dataFormat==="channelsLast",E=new $i(d.outShape,s.dtype),N=nn(s.shape),M=nn(i.shape),$=N[0],L=T?N[1]:N[2],k=T?N[2]:1,R=T?1:N[1],P=E.strides[0],B=T?E.strides[1]:E.strides[2],Z=T?E.strides[2]:1,V=T?1:E.strides[1],X=t.data.get(s.dataId).values,q=t.data.get(i.dataId).values,se=E.values;for(let W=0;W<d.batchSize;++W){const J=W*$,K=W*P;for(let G=0;G<d.outHeight;++G){const Q=K+G*B,ne=G*d.strideHeight-_;for(let ce=0;ce<p;++ce){const ye=ne+ce*w;if(ye<0||ye>=d.inHeight)continue;const Se=ce*M[0],Re=J+ye*L;for(let Oe=0;Oe<d.outWidth;++Oe){const Ke=Q+Oe*Z,st=Oe*d.strideWidth-x;for(let ct=0;ct<g;++ct){const fe=st+ct*y;if(fe<0||fe>=d.inWidth)continue;const nt=Se+ct*M[1],Xe=Re+fe*k;let it=nt;for(let He=0;He<d.inChannels;++He){const _t=X[Xe+He*R];for(let mt=0;mt<d.outChannels;++mt)se[Ke+mt*V]+=_t*q[it+mt];it+=d.outChannels}}}}}}return t.makeTensorInfo(E.shape,E.dtype,se)}const jfe={kernelName:_T,backendName:"cpu",kernelFunc:yH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xfe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;Xt([s,i],"conv2dBackpropFilter");const h=xh(l),d=Pi(s.shape,c,o,1,a,u,!1,h),{strideHeight:p,strideWidth:g,filterHeight:w,filterWidth:y}=d,x=d.dataFormat==="channelsLast",_=new $i(d.filterShape,"float32"),T=d.padInfo.left,E=d.padInfo.top,N=t.data.get(s.dataId).values,M=t.data.get(i.dataId).values,$=new $i(s.shape,s.dtype,N),L=new $i(i.shape,i.dtype,M);for(let k=0;k<w;++k){const R=Math.max(0,Math.ceil((E-k)/p)),P=Math.min(d.outHeight,(d.inHeight+E-k)/p);for(let B=0;B<y;++B){const Z=Math.max(0,Math.ceil((T-B)/g)),V=Math.min(d.outWidth,(d.inWidth+T-B)/g);for(let X=0;X<d.inChannels;++X)for(let q=0;q<d.outChannels;++q){let se=0;for(let W=0;W<d.batchSize;++W)for(let J=R;J<P;++J){const K=k+J*p-E;for(let G=Z;G<V;++G){const Q=B+G*g-T;x?se+=$.get(W,K,Q,X)*L.get(W,J,G,q):se+=$.get(W,X,K,Q)*L.get(W,q,J,G)}}_.set(se,k,B,X,q)}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const qfe={kernelName:kM,backendName:"cpu",kernelFunc:Xfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kfe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r;Xt([s,i],"conv2dBackpropInput");const h=nn(i.shape),d=nn(s.shape);let p=xh(u);const g=Pi(o,i.shape,a,1,l,c,!1,p),w=new $i(g.inShape,"float32"),y=w.values,x=t.data.get(s.dataId).values,_=t.data.get(i.dataId).values,[T,E,N]=h,{batchSize:M,filterHeight:$,filterWidth:L,inChannels:k,inHeight:R,inWidth:P,outChannels:B,outHeight:Z,outWidth:V,strideHeight:X,strideWidth:q}=g;p=g.dataFormat;const se=$-1-g.padInfo.top,W=L-1-g.padInfo.left,J=p==="channelsLast",K=w.strides[0],G=J?w.strides[1]:w.strides[2],Q=J?w.strides[2]:1,ne=J?1:w.strides[1],ce=d[0],ye=J?d[1]:d[2],Se=J?d[2]:1,Re=J?1:d[1];for(let Oe=0;Oe<M;++Oe)for(let Ke=0;Ke<k;++Ke)for(let st=0;st<R;++st){const ct=st-se,fe=Math.max(0,Math.ceil(ct/X)),nt=Math.min(Z,($+ct)/X);for(let Xe=0;Xe<P;++Xe){const it=Xe-W,He=Math.max(0,Math.ceil(it/q)),_t=Math.min(V,(L+it)/q);let mt=0;for(let ee=fe;ee<nt;++ee){const Le=ee*X-ct;for(let at=He;at<_t;++at){const ut=at*q-it,ot=ce*Oe+ye*ee+Se*at,$t=T*($-1-Le)+E*(L-1-ut)+N*Ke;for(let bt=0;bt<B;++bt){const It=x[ot+Re*bt],Gt=_[$t+bt];mt+=It*Gt}}}const oe=K*Oe+G*st+Q*Xe+ne*Ke;y[oe]=mt}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const Yfe={kernelName:TT,backendName:"cpu",kernelFunc:Kfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zfe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r;Xt([s,i],"conv3d");const u=Zd(s.shape,i.shape,o,l,a),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:g,dilationWidth:w,padInfo:y}=u,x=y.front,_=y.left,T=y.top,E=new $i(u.outShape,s.dtype),N=t.data.get(s.dataId).values,M=t.data.get(i.dataId).values,$=E.values,L=nn(s.shape),k=nn(i.shape);for(let R=0;R<u.batchSize;++R){const P=R*L[0],B=R*E.strides[0];for(let Z=0;Z<u.outDepth;++Z){const V=B+Z*E.strides[1],X=Z*u.strideDepth-x;for(let q=0;q<c;++q){const se=X+q*p;if(se<0||se>=u.inDepth)continue;const W=q*k[0],J=P+se*L[1];for(let K=0;K<u.outHeight;++K){const G=V+K*E.strides[2],Q=K*u.strideHeight-T;for(let ne=0;ne<h;++ne){const ce=Q+ne*g;if(ce<0||ce>=u.inHeight)continue;const ye=W+ne*k[1],Se=J+ce*L[2];for(let Re=0;Re<u.outWidth;++Re){const Oe=G+Re*u.outChannels,Ke=Re*u.strideWidth-_;for(let st=0;st<d;++st){const ct=Ke+st*w;if(ct<0||ct>=u.inWidth)continue;const fe=ye+st*k[2],nt=Se+ct*u.inChannels;let Xe=fe;for(let it=0;it<u.inChannels;++it){const He=N[nt+it];for(let _t=0;_t<u.outChannels;++_t)$[Oe+_t]+=He*M[Xe+_t];Xe+=u.outChannels}}}}}}}}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const Jfe={kernelName:ET,backendName:"cpu",kernelFunc:Zfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qfe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r;Xt([s,i],"conv3dBackpropFilterV2");const u=nn(s.shape),c=nn(i.shape),h=Zd(s.shape,l,o,1,a),d=h.strideDepth,p=h.strideHeight,g=h.strideWidth,w=h.filterDepth,y=h.filterHeight,x=h.filterWidth,_=new $i(h.filterShape,"float32"),T=_.values,[E,N,M,$]=_.strides,L=t.data.get(i.dataId).values,[k,R,P,B]=c,Z=t.data.get(s.dataId).values,[V,X,q,se]=u,W=h.padInfo.front,J=h.padInfo.left,K=h.padInfo.top;for(let G=0;G<w;++G){const Q=Math.max(0,Math.ceil((W-G)/d)),ne=Math.min(h.outDepth,(h.inDepth+W-G)/d),ce=G*E;for(let ye=0;ye<y;++ye){const Se=Math.max(0,Math.ceil((K-ye)/p)),Re=Math.min(h.outHeight,(h.inHeight+K-ye)/p),Oe=ye*N+ce;for(let Ke=0;Ke<x;++Ke){const st=Math.max(0,Math.ceil((J-Ke)/g)),ct=Math.min(h.outWidth,(h.inWidth+J-Ke)/g),fe=Ke*M+Oe;for(let nt=0;nt<h.inChannels;++nt){const Xe=nt*$+fe;for(let it=0;it<h.outChannels;++it){let He=0;for(let _t=0;_t<h.batchSize;++_t){const mt=_t*V,oe=_t*k;for(let ee=Q;ee<ne;++ee){const at=(G+ee*d-W)*X+mt,ut=ee*R+oe;for(let ot=Se;ot<Re;++ot){const bt=(ye+ot*p-K)*q+at,It=ot*P+ut;for(let Gt=st;Gt<ct;++Gt){const ht=(Ke+Gt*g-J)*se+bt,Nn=Gt*B+It;He+=Z[ht+nt]*L[Nn+it]}}}}T[Xe+it]=He}}}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const epe={kernelName:RM,backendName:"cpu",kernelFunc:Qfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tpe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{pad:o,strides:a,inputShape:l}=r;Xt([s],"conv3dBackpropInputV2");const u=nn(s.shape),c=nn(i.shape),h=Zd(l,i.shape,a,1,o),d=new $i(h.inShape,"float32"),p=d.values,[g,w,y,x]=d.strides,_=t.data.get(s.dataId).values,[T,E,N,M]=u,$=t.data.get(i.dataId).values,[L,k,R,P]=c,{batchSize:B,filterDepth:Z,filterHeight:V,filterWidth:X,inChannels:q,inDepth:se,inHeight:W,inWidth:J,outChannels:K,outDepth:G,outHeight:Q,outWidth:ne,strideDepth:ce,strideHeight:ye,strideWidth:Se}=h,Re=Z-1-h.padInfo.front,Oe=V-1-h.padInfo.top,Ke=X-1-h.padInfo.left;for(let st=0;st<B;++st)for(let ct=0;ct<q;++ct)for(let fe=0;fe<se;++fe){const nt=fe-Re,Xe=Math.max(0,Math.ceil(nt/ce)),it=Math.min(G,(Z+nt)/ce);for(let He=0;He<W;++He){const _t=He-Oe,mt=Math.max(0,Math.ceil(_t/ye)),oe=Math.min(Q,(V+_t)/ye);for(let ee=0;ee<J;++ee){const Le=ee-Ke,at=Math.max(0,Math.ceil(Le/Se)),ut=Math.min(ne,(X+Le)/Se);let ot=0;for(let $t=Xe;$t<it;++$t){const bt=$t*ce-nt;for(let It=mt;It<oe;++It){const Gt=It*ye-_t;for(let rn=at;rn<ut;++rn){const ht=rn*Se-Le,Nn=T*st+E*$t+N*It+M*rn,An=L*(Z-1-bt)+k*(V-1-Gt)+R*(X-1-ht)+P*ct;for(let en=0;en<K;++en){const Ft=_[Nn+en],Vt=$[An+en];ot+=Ft*Vt}}}}p[g*st+w*fe+y*He+x*ee+ct]=ot}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}const npe={kernelName:DM,backendName:"cpu",kernelFunc:tpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rpe=Mr(d1,n=>Math.cos(n)),spe={kernelName:d1,backendName:"cpu",kernelFunc:rpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ipe=Mr(f1,n=>Math.cosh(n)),ope={kernelName:f1,backendName:"cpu",kernelFunc:ipe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ape(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=r,[c,h,d,p]=s.shape,g=i.shape[0],[w,y]=a,x=Xn([g,w,y,p],"float32"),_=t.data.get(i.dataId).values,T=t.data.get(o.dataId).values,E=t.data.get(s.dataId).values,N=nn(s.shape),M=nn(x.shape);for(let $=0;$<g;$++){const L=$*4,k=_[L],R=_[L+1],P=_[L+2],B=_[L+3],Z=T[$];if(Z>=c)continue;const V=w>1?(P-k)*(h-1)/(w-1):0,X=y>1?(B-R)*(d-1)/(y-1):0;for(let q=0;q<w;q++){const se=w>1?k*(h-1)+q*V:.5*(k+P)*(h-1);if(se<0||se>h-1){for(let W=0;W<y;W++)for(let J=0;J<p;J++){const K=J+W*M[2]+q*M[1]+$*M[0];x.values[K]=u}continue}if(l==="bilinear"){const W=Math.floor(se),J=Math.ceil(se),K=se-W;for(let G=0;G<y;G++){const Q=y>1?R*(d-1)+G*X:.5*(R+B)*(d-1);if(Q<0||Q>d-1){for(let Se=0;Se<p;Se++){const Re=Se+G*M[2]+q*M[1]+$*M[0];x.values[Re]=u}continue}const ne=Math.floor(Q),ce=Math.ceil(Q),ye=Q-ne;for(let Se=0;Se<p;Se++){let Re=Se+ne*N[2]+W*N[1]+Z*N[0];const Oe=E[Re];Re=Se+ce*N[2]+W*N[1]+Z*N[0];const Ke=E[Re];Re=Se+ne*N[2]+J*N[1]+Z*N[0];const st=E[Re];Re=Se+ce*N[2]+J*N[1]+Z*N[0];const ct=E[Re],fe=Oe+(Ke-Oe)*ye,nt=st+(ct-st)*ye;Re=Se+G*M[2]+q*M[1]+$*M[0],x.values[Re]=fe+(nt-fe)*K}}}else for(let W=0;W<y;++W){const J=y>1?R*(d-1)+W*X:.5*(R+B)*(d-1);if(J<0||J>d-1){for(let Q=0;Q<p;Q++){const ne=Q+W*M[2]+q*M[1]+$*M[0];x.values[ne]=u}continue}const K=Math.round(J),G=Math.round(se);for(let Q=0;Q<p;Q++){const ne=Q+K*N[2]+G*N[1]+Z*N[0],ce=Q+W*M[2]+q*M[1]+$*M[0];x.values[ce]=E[ne]}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const lpe={kernelName:PM,backendName:"cpu",kernelFunc:ape};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function upe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;Xt(s,"cumprod");const l=ps([i],s.shape.length);let u=s;l!=null&&(u=Yo({inputs:{x:s},backend:t,attrs:{perm:l}}));const c=Ms(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=_a(u.dtype,"int32"),d=wM(Qe(u.shape),h),p=t.data.get(u.dataId).values,g=u.shape[u.shape.length-1],w=a?(x,_)=>x+g-_-1:(x,_)=>x+_;for(let x=0;x<p.length;x+=g)for(let _=0;_<g;_++){const T=w(x,_);if(_===0)d[T]=o?1:p[T];else{const E=w(x,_-1);d[T]=o?p[E]*d[E]:p[T]*d[E]}}const y=t.makeTensorInfo(u.shape,h,d);if(l!=null){const x=Jd(l),_=Yo({inputs:{x:y},backend:t,attrs:{perm:x}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(u),_}return y}const cpe={kernelName:$M,backendName:"cpu",kernelFunc:upe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hpe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;Xt(s,"cumsum");const l=ps([i],s.shape.length);let u=s;l!=null&&(u=Yo({inputs:{x:s},backend:t,attrs:{perm:l}}));const c=Ms(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=_a(u.dtype,"int32"),d=Zi(Qe(u.shape),h),p=t.data.get(u.dataId).values,g=u.shape[u.shape.length-1],w=a?(x,_)=>x+g-_-1:(x,_)=>x+_;for(let x=0;x<p.length;x+=g)for(let _=0;_<g;_++){const T=w(x,_);if(_===0)d[T]=o?0:p[T];else{const E=w(x,_-1);d[T]=o?p[E]+d[E]:p[T]+d[E]}}const y=t.makeTensorInfo(u.shape,h,d);if(l!=null){const x=Jd(l),_=Yo({inputs:{x:y},backend:t,attrs:{perm:x}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(u),_}return y}const dpe={kernelName:CT,backendName:"cpu",kernelFunc:hpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fpe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r;if(s.shape.length===1){const l=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values,c=zR(l,u,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}else if(s.shape.length===2){const l=t.bufferSync(s),u=t.bufferSync(i),c=vG(l,u,o,a);return t.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const ppe={kernelName:LM,backendName:"cpu",kernelFunc:fpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mpe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:i,dataFormat:o}=r;ie(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const a=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],h=l*i,d=u*i,p=c/(i*i),g=t.data.get(s.dataId).values,w=new Float32Array(a*h*d*p);let y=0;for(let x=0;x<a;++x)for(let _=0;_<h;++_){const T=Math.floor(_/i),E=_%i;for(let N=0;N<d;++N){const M=Math.floor(N/i),$=N%i,L=(E*i+$)*p;for(let k=0;k<p;++k){const P=k+L+c*(M+u*(T+l*x));w[y++]=g[P]}}}return t.makeTensorInfo([a,h,d,p],s.dtype,w)}const gpe={kernelName:OM,backendName:"cpu",kernelFunc:mpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vH(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=r;Xt([s,i],"depthwiseConv2DNative");const c=nn(s.shape),h=nn(i.shape);let d=l;d==null&&(d=[1,1]),ie(Ji(o,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${d}'`);const p=Pi(s.shape,i.shape,o,d,a,u,!0),{filterHeight:g,filterWidth:w,dilationHeight:y,dilationWidth:x,padInfo:_}=p,T=_.left,E=_.top,N=p.outChannels/p.inChannels,M=new $i(p.outShape,s.dtype),$=t.data.get(s.dataId).values,L=t.data.get(i.dataId).values,k=M.values;for(let R=0;R<p.batchSize;++R){const P=R*c[0],B=R*M.strides[0];for(let Z=0;Z<p.outHeight;++Z){const V=B+Z*M.strides[1],X=Z*p.strideHeight-E;for(let q=0;q<g;++q){const se=X+q*y;if(se<0||se>=p.inHeight)continue;const W=q*h[0],J=P+se*c[1];for(let K=0;K<p.outWidth;++K){const G=V+K*M.strides[2],Q=K*p.strideWidth-T;for(let ne=0;ne<w;++ne){const ce=Q+ne*x;if(ce<0||ce>=p.inWidth)continue;const ye=W+ne*h[1],Se=J+ce*p.inChannels;let Re=G,Oe=ye;for(let Ke=0;Ke<p.inChannels;++Ke){const st=$[Se+Ke];for(let ct=0;ct<N;++ct)k[Re+ct]+=st*L[Oe+ct];Re+=N,Oe+=N}}}}}}return t.makeTensorInfo(M.shape,M.dtype,M.values)}const ype={kernelName:IT,backendName:"cpu",kernelFunc:vH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vpe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r;Xt([s,i],"depthwiseConv2dNativeBackpropFilter");const h=Pi(s.shape,c,o,a,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:g,filterWidth:w}=h,y=new $i(h.filterShape,"float32"),x=h.padInfo.left,_=h.padInfo.top,T=h.outChannels/h.inChannels,E=t.data.get(s.dataId).values,N=new $i(s.shape,s.dtype,E),M=t.data.get(i.dataId).values,$=new $i(i.shape,i.dtype,M);for(let L=0;L<g;++L){const k=Math.max(0,Math.ceil((_-L)/d)),R=Math.min(h.outHeight,(h.inHeight+_-L)/d);for(let P=0;P<w;++P){const B=Math.max(0,Math.ceil((x-P)/p)),Z=Math.min(h.outWidth,(h.inWidth+x-P)/p);for(let V=0;V<h.outChannels;++V){const X=Math.trunc(V/T),q=V%T;let se=0;for(let W=0;W<h.batchSize;++W)for(let J=k;J<R;++J){const K=L+J*d-_;for(let G=B;G<Z;++G){const Q=P+G*p-x;se+=N.get(W,K,Q,X)*$.get(W,J,G,V)}}y.set(se,L,P,X,q)}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const xpe={kernelName:FM,backendName:"cpu",kernelFunc:vpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wpe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r;Xt([s,i],"depthwiseConv2DNativeBackpropInput");const h=nn(s.shape),d=nn(i.shape),p=Pi(c,i.shape,o,a,l,u,!0),g=new $i(p.inShape,"float32"),w=g.values,[y,x,_]=g.strides,T=t.data.get(s.dataId).values,[E,N,M]=h,$=t.data.get(i.dataId).values,[L,k,R]=d,{batchSize:P,filterHeight:B,filterWidth:Z,inChannels:V,inHeight:X,inWidth:q,outChannels:se,outHeight:W,outWidth:J,strideHeight:K,strideWidth:G}=p,Q=B-1-p.padInfo.top,ne=Z-1-p.padInfo.left,ce=se/V;for(let ye=0;ye<P;++ye)for(let Se=0;Se<V;++Se)for(let Re=0;Re<X;++Re){const Oe=Re-Q,Ke=Math.max(0,Math.ceil(Oe/K)),st=Math.min(W,(B+Oe)/K);for(let ct=0;ct<q;++ct){const fe=ct-ne,nt=Math.max(0,Math.ceil(fe/G)),Xe=Math.min(J,(Z+fe)/G);let it=0;for(let He=Ke;He<st;++He){const _t=He*K-Oe;for(let mt=nt;mt<Xe;++mt){const oe=mt*G-fe,ee=E*ye+N*He+M*mt,Le=L*(B-1-_t)+k*(Z-1-oe)+R*Se;for(let at=0;at<ce;++at){const ut=Se*ce+at,ot=T[ee+ut],$t=$[Le+at];it+=ot*$t}}}w[y*ye+x*Re+_*ct+Se]=it}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const bpe={kernelName:zM,backendName:"cpu",kernelFunc:wpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Spe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=Qe(r.shape),i=t.data.get(r.dataId).values,o=Xn([s,s],r.dtype),a=o.values;for(let u=0;u<i.length;u++)a[u*s+u]=i[u];const l=[...r.shape,...r.shape];return t.makeTensorInfo(l,o.dtype,o.values)}const _pe={kernelName:WB,backendName:"cpu",kernelFunc:Spe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tpe={kernelName:NT,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s}=n,{strides:i,pad:o,dilations:a}=t,l=e,u=l.data.get(r.dataId).values,c=r.shape.length,h=l.data.get(s.dataId).values,d=s.shape.length,{batchSize:p,inHeight:g,inWidth:w,inChannels:y,outHeight:x,outWidth:_,padInfo:T,strideHeight:E,strideWidth:N,filterHeight:M,filterWidth:$,dilationHeight:L,dilationWidth:k,outShape:R}=J1(r.shape,s.shape,i,o,"NHWC",a),P=Qe(R),B=R.length,Z=Cs(r.dtype,P);for(let X=0;X<p;++X)for(let q=0;q<x;++q){const se=q*E-T.top;for(let W=0;W<_;++W){const J=W*N-T.left;for(let K=0;K<y;++K){let G=Number.MIN_SAFE_INTEGER;for(let ne=0;ne<M;++ne){const ce=se+ne*L;if(ce>=0&&ce<g)for(let ye=0;ye<$;++ye){const Se=J+ye*k;if(Se>=0&&Se<w){const Re=Xu([X,ce,Se,K],c,nn(r.shape)),Oe=Xu([ne,ye,K],d,nn(s.shape)),Ke=u[Re]+h[Oe];Ke>G&&(G=Ke)}}}const Q=Xu([X,q,W,K],B,nn(R));Z[Q]=G}}}return{dataId:l.write(lm(Z,r.dtype),R,r.dtype),shape:R,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Epe={kernelName:lN,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=t,u=e,c=du(r.shape,u.data.get(r.dataId).values),h=du(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:g,inChannels:w,outHeight:y,outWidth:x,padInfo:_,strideHeight:T,strideWidth:E,filterHeight:N,filterWidth:M,dilationHeight:$,dilationWidth:L,outShape:k}=J1(r.shape,s.shape,o,a,"NHWC",l);ie(i.rank===k.length,()=>`Error in ${lN}, dy must have the same rank as output ${k.length}, but got ${i.rank}`);const R=du(k,u.data.get(i.dataId).values),P=zB(s.shape,s.dtype);for(let Z=0;Z<d;++Z)for(let V=0;V<y;++V){const X=V*T-_.top;for(let q=0;q<x;++q){const se=q*E-_.left;for(let W=0;W<w;++W){let J=Number.MIN_SAFE_INTEGER,K=0,G=0;for(let Q=0;Q<N;++Q){const ne=X+Q*$;if(ne>=0&&ne<p)for(let ce=0;ce<M;++ce){const ye=se+ce*L;if(ye>=0&&ye<g){const Se=c[Z][ne][ye][W]+h[Q][ce][W];Se>J&&(J=Se,K=Q,G=ce)}}}P[K][G][W]+=R[Z][V][q][W]}}}return{dataId:u.write(lm(P,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cpe={kernelName:aN,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:s,dy:i}=n,{strides:o,pad:a,dilations:l}=t,u=e,c=du(r.shape,u.data.get(r.dataId).values),h=du(s.shape,u.data.get(s.dataId).values),{batchSize:d,inHeight:p,inWidth:g,inChannels:w,outHeight:y,outWidth:x,padInfo:_,strideHeight:T,strideWidth:E,filterHeight:N,filterWidth:M,dilationHeight:$,dilationWidth:L,outShape:k}=J1(r.shape,s.shape,o,a,"NHWC",l);ie(i.rank===k.length,()=>`Error in ${aN}, dy must have the same rank as output ${k.length}, but got ${i.rank}`);const R=du(k,u.data.get(i.dataId).values),P=zB(r.shape,r.dtype);for(let Z=0;Z<d;++Z)for(let V=0;V<y;++V){const X=V*T-_.top;for(let q=0;q<x;++q){const se=q*E-_.left;for(let W=0;W<w;++W){let J=Number.MIN_SAFE_INTEGER,K=X<0?0:X,G=se<0?0:se;for(let Q=0;Q<N;++Q){const ne=X+Q*$;if(ne>=0&&ne<p)for(let ce=0;ce<M;++ce){const ye=se+ce*L;if(ye>=0&&ye<g){const Se=c[Z][ne][ye][W]+h[Q][ce][W];Se>J&&(J=Se,K=ne,G=ye)}}}P[Z][K][G][W]+=R[Z][V][q][W]}}}return{dataId:u.write(lm(P,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ipe(n){const{inputs:e,backend:t,attrs:r}=n,{image:s}=e,{canvas:i,options:o}=r,{contextOptions:a,imageOptions:l}=o||{},u=(l==null?void 0:l.alpha)||1,c=(a==null?void 0:a.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=i.getContext(c,(a==null?void 0:a.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);const[d,p]=s.shape.slice(0,2),g=s.shape.length===2?1:s.shape[2],w=t.data.get(s.dataId).values,y=s.dtype==="float32"?255:1,x=new Uint8ClampedArray(p*d*4);for(let T=0;T<d*p;++T){const E=[0,0,0,255*u];for(let M=0;M<g;M++){const $=w[T*g+M];if(s.dtype==="float32"){if($<0||$>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${$}.`)}else if(s.dtype==="int32"&&($<0||$>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${$}.`);g===1?(E[0]=$*y,E[1]=$*y,E[2]=$*y):E[M]=$*y}const N=T*4;x[N+0]=Math.round(E[0]),x[N+1]=Math.round(E[1]),x[N+2]=Math.round(E[2]),x[N+3]=Math.round(E[3])}i.width=p,i.height=d;const _=new ImageData(x,p,d);return h.putImageData(_,0,0),s}const Npe={kernelName:ite,backendName:"cpu",kernelFunc:Ipe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dw(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Xt(s,"sum");let a;s.dtype==="bool"?a=Od({inputs:{x:s},backend:t,attrs:{dtype:"int32"}}):a=oc({inputs:{x:s},backend:t});const l=a.shape.length,u=qn(i,a.shape),c=ps(u,l);let h=u,d=a;c!=null&&(d=Yo({inputs:{x:a},backend:t,attrs:{perm:c}}),h=Ms(h.length,l)),Li("sum",h,d.shape.length);const[p,g]=_i(d.shape,h),w=_a(d.dtype,"int32");let y=x_(t,p,w);const x=Qe(g),_=t.data.get(y.dataId).values,T=t.data.get(d.dataId).values;for(let E=0;E<_.length;++E){const N=E*x;let M=0;for(let $=0;$<x;++$)M+=T[N+$];_[E]=M}if(o){const E=Vs(y.shape,u),N=y;y=qr({inputs:{x:y},backend:t,attrs:{shape:E}}),t.disposeIntermediateTensorInfo(N)}return t.disposeIntermediateTensorInfo(a),c!=null&&t.disposeIntermediateTensorInfo(d),y}const Ape={kernelName:aE,backendName:"cpu",kernelFunc:dw};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mpe(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=aR(s,i.length);uR(o.length,l,i);const{path:u,steps:c}=cR(a,l),h=c.length;let d=null,p=o.length;const g=[];for(let w=0;w<h;++w){for(const y of c[w]){const{permutationIndices:x,expandDims:_}=lR(p,l[y]);let T;hR(x)?T=i[y]:(T=Yo({inputs:{x:i[y]},backend:t,attrs:{perm:x}}),g.push(T));const E=T.shape.slice();for(let N=0;N<_.length;++N)E.splice(_[N],0,1);_r(T.shape,E)||(T=qr({inputs:{x:T},backend:t,attrs:{shape:E}}),g.push(T)),d===null?d=T:(d=FE({inputs:{a:T,b:d},backend:t}),g.push(d))}w<h-1&&(u[w]>=0&&(d=dw({inputs:{x:d},backend:t,attrs:{axis:u[w]-(o.length-p),keepDims:!1}}),g.push(d)),p--)}for(const w of g)w!==d&&t.disposeIntermediateTensorInfo(w);return d}const kpe={kernelName:BM,backendName:"cpu",kernelFunc:Mpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rpe(n){const{inputs:e,backend:t}=n,{dy:r,y:s}=e;Xt([r,s],"eluGrad");const i=new Float32Array(Qe(s.shape)),o=t.data.get(s.dataId).values,a=t.data.get(r.dataId).values;for(let l=0;l<o.length;++l){const u=o[l];u>=0?i[l]=a[l]:i[l]=a[l]*(u+1)}return t.makeTensorInfo(s.shape,"float32",i)}const Dpe={kernelName:UM,backendName:"cpu",kernelFunc:Rpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $pe=eR,Ppe=tR,Lpe=nR,Ope=rR,Fpe=sR,zpe=iR,Bpe=Mr(g1,n=>{const e=Math.sign(n),t=Math.abs(n),r=1/(1+$pe*t);return e*(1-((((zpe*r+Fpe)*r+Ope)*r+Lpe)*r+Ppe)*r*Math.exp(-t*t))}),Upe={kernelName:g1,backendName:"cpu",kernelFunc:Bpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S_(n){const{inputs:e,backend:t,attrs:r}=n,{input:s}=e,{dim:i}=r,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(ie(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),qr({inputs:{x:s},backend:t,attrs:{shape:a}})}const Vpe={kernelName:MT,backendName:"cpu",kernelFunc:S_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wpe=Rs((n,e)=>n/e),HR=si(p1,Wpe),PN={kernelName:p1,backendName:"cpu",kernelFunc:HR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xH(n,e,t){const r=n.shape,s=r[0],i=r[1],o=t.data.get(n.dataId),a=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=[s,i],c=Qe(u),h=Yi("float32",c),d=Yi("float32",c);for(let y=0;y<s;y++){const x=Yp({inputs:{x:a},backend:t,attrs:{begin:[y,0],size:[1,i]}}),_=Yp({inputs:{x:l},backend:t,attrs:{begin:[y,0],size:[1,i]}}),T=wa({inputs:{real:x,imag:_},backend:t}),{real:E,imag:N}=Gpe(T,e,t),M=ch(E,N);for(let $=0;$<i;$++){const L=oR(M,$);h[y*i+$]=L.real,d[y*i+$]=L.imag}t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(T)}const p=t.makeTensorInfo(u,"float32",h),g=t.makeTensorInfo(u,"float32",d),w=wa({inputs:{real:p,imag:g},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),w}function Gpe(n,e,t){const r=Qe(n.shape),s=t.data.get(n.dataId),i=t.data.get(s.complexTensorInfos.real.dataId).values,o=t.data.get(s.complexTensorInfos.imag.dataId).values;if(Hpe(r)){const a=LN(i,o,r,e,t),l=[n.shape[0],n.shape[1]];if(e){const u=t.makeTensorInfo(l,"float32",a.real),c=t.makeTensorInfo(l,"float32",a.imag),h=t.makeTensorInfo([],"float32",Yd(r,"float32")),d=oc({inputs:{x:h},backend:t}),p=PN.kernelFunc({inputs:{a:u,b:h},backend:t}),g=PN.kernelFunc({inputs:{a:c,b:d},backend:t}),w=t.data.get(p.dataId).values,y=t.data.get(g.dataId).values;return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),{real:w,imag:y}}return a}else{const a=ch(i,o),l=jpe(a,r,e);return R4(l)}}function Hpe(n){return(n&n-1)===0}function LN(n,e,t,r,s){if(t===1)return{real:n,imag:e};const i=ch(n,e),o=t/2,a=D4(i),l=a.real,u=a.imag,c=[l.length],h=s.makeTensorInfo(c,"float32",l),d=s.makeTensorInfo(c,"float32",u),p=wa({inputs:{real:h,imag:d},backend:s}),g=$4(i),w=g.real,y=g.imag,x=[w.length],_=s.makeTensorInfo(x,"float32",w),T=s.makeTensorInfo(x,"float32",y),E=wa({inputs:{real:_,imag:T},backend:s}),N=LN(l,u,o,r,s),M=N.real,$=N.imag,L=[M.length],k=s.makeTensorInfo(L,"float32",M),R=s.makeTensorInfo(L,"float32",$),P=wa({inputs:{real:k,imag:R},backend:s}),B=LN(w,y,o,r,s),Z=B.real,V=B.imag,X=[Z.length],q=s.makeTensorInfo(X,"float32",Z),se=s.makeTensorInfo(X,"float32",V),W=wa({inputs:{real:q,imag:se},backend:s}),J=L4(t,r),K=[J.real.length],G=s.makeTensorInfo(K,"float32",J.real),Q=s.makeTensorInfo(K,"float32",J.imag),ne=wa({inputs:{real:G,imag:Q},backend:s}),ce=FE({inputs:{a:ne,b:W},backend:s}),ye=Ny({inputs:{a:P,b:ce},backend:s}),Se=WR({inputs:{a:P,b:ce},backend:s}),Re=Kp({inputs:{input:ye},backend:s}),Oe=Kp({inputs:{input:Se},backend:s}),Ke=Ay({inputs:{input:ye},backend:s}),st=Ay({inputs:{input:Se},backend:s}),ct=My({inputs:[Re,Oe],backend:s,attrs:{axis:0}}),fe=My({inputs:[Ke,st],backend:s,attrs:{axis:0}}),nt=s.data.get(ct.dataId).values,Xe=s.data.get(fe.dataId).values;return s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(E),s.disposeIntermediateTensorInfo(k),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(se),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(Q),s.disposeIntermediateTensorInfo(ne),s.disposeIntermediateTensorInfo(ce),s.disposeIntermediateTensorInfo(ye),s.disposeIntermediateTensorInfo(Se),s.disposeIntermediateTensorInfo(Re),s.disposeIntermediateTensorInfo(Ke),s.disposeIntermediateTensorInfo(Oe),s.disposeIntermediateTensorInfo(st),s.disposeIntermediateTensorInfo(ct),s.disposeIntermediateTensorInfo(fe),{real:nt,imag:Xe}}function jpe(n,e,t){const r=new Float32Array(e*2);for(let s=0;s<e;s++){let i=0,o=0;for(let a=0;a<e;a++){const l=O4(s*a,e,t),u=oR(n,a);i+=u.real*l.real-u.imag*l.imag,o+=u.real*l.imag+u.imag*l.real}t&&(i/=e,o/=e),P4(r,i,o,s)}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xpe(n){const{inputs:e,backend:t}=n,{input:r}=e,s=Qe(r.shape),i=r.shape[r.shape.length-1],o=s/i,a=qr({inputs:{x:r},backend:t,attrs:{shape:[o,i]}}),l=xH(a,!1,t),u=qr({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}const qpe={kernelName:VM,backendName:"cpu",kernelFunc:Xpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jR(n){const{backend:e,attrs:t}=n,{shape:r,value:s,dtype:i}=t,o=i||jy(s),a=Cs(o,Qe(r));return Ype(a,s,o),e.makeTensorInfo(r,o,a)}const Kpe={kernelName:WM,backendName:"cpu",kernelFunc:jR};function Ype(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zpe={kernelName:GM,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,s=t,i=Yi(r.dtype,Qe(r.shape)),[o,a,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let d=0;d<o;d++){const p=d*l*a*u;for(let g=0;g<a;g++){const w=g*(l*u);for(let y=0;y<l;y++){const x=y*u;for(let _=0;_<u;_++){const T=Math.round(l-y-1),E=p+w+x+_;let N=c[E];if(T>=0&&T<l){const M=T*u,$=p+w+M+_;N=c[$]}i[E]=N}}}}return{dataId:s.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jpe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:g}=r;let w=yH({inputs:{x:s,filter:i},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(o){const y=w;if(c==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const x=qr({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});w=Ny({inputs:{a:w,b:x},backend:t}),t.disposeIntermediateTensorInfo(x)}else w=Ny({inputs:{a:w,b:o},backend:t});t.disposeIntermediateTensorInfo(y)}if(p){const y=w;if(c==="NCHW"&&p==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const x=qr({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});w=b_(t,w,p,x,g),t.disposeIntermediateTensorInfo(x)}else w=b_(t,w,p,a,g);t.disposeIntermediateTensorInfo(y)}return w}const Qpe={kernelName:n_,backendName:"cpu",kernelFunc:Jpe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eme(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:g}=r;let w=vH({inputs:{x:s,filter:i},backend:t,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(o){const y=w;w=Ny({inputs:{a:w,b:o},backend:t}),t.disposeIntermediateTensorInfo(y)}if(p){const y=w;w=b_(t,w,p,a,g),t.disposeIntermediateTensorInfo(y)}return w}const tme={kernelName:lU,backendName:"cpu",kernelFunc:eme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nme(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,i=Qe(r.shape),o=s.shape,a=o[o.length-1],[l,u,c,h]=Wk(r,s);if(u===0)return t.makeTensorInfo(l,r.dtype,[]);const d=t.data.get(s.dataId).values,p=t.bufferSync(r),g=AG(d,p,r.dtype,u,a,c,h,r.shape,i);return t.makeTensorInfo(l,r.dtype,g.values)}const rme={kernelName:GB,backendName:"cpu",kernelFunc:nme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sme(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:i}=e,{axis:o,batchDims:a}=r;Xt([s,i],"gatherV2");const l=qn(o,s.shape)[0],u=t.data.get(i.dataId).values,c=s.shape[l];for(let E=0;E<u.length;++E){const N=u[E];ie(N<=c-1&&N>=0,()=>`GatherV2: the index value ${N} is not in [0, ${c-1}]`)}let h=a;a==null&&(h=0);const d=Qe(i.shape),p=fR(s,i,l,h),g=qr({inputs:{x:s},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),w=qr({inputs:{x:i},backend:t,attrs:{shape:[p.batchSize,d/p.batchSize]}}),y=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],x=t.bufferSync(w),_=t.bufferSync(g),T=MG(_,x,y);return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(w),t.makeTensorInfo(p.outputShape,T.dtype,T.values)}const ime={kernelName:RT,backendName:"cpu",kernelFunc:sme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ome(n){const{inputs:e,backend:t}=n,{input:r}=e,s=Qe(r.shape),i=r.shape[r.shape.length-1],o=s/i,a=qr({inputs:{x:r},backend:t,attrs:{shape:[o,i]}}),l=xH(a,!0,t),u=qr({inputs:{x:l},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),u}const ame={kernelName:HM,backendName:"cpu",kernelFunc:ome};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lme=Mr(_1,n=>Number.isFinite(n)?1:0,"bool"),ume={kernelName:_1,backendName:"cpu",kernelFunc:lme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cme=Mr(T1,n=>Math.abs(n)===1/0?1:0,"bool"),hme={kernelName:T1,backendName:"cpu",kernelFunc:cme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dme=Mr(E1,n=>Number.isNaN(n)?1:0,"bool"),fme={kernelName:E1,backendName:"cpu",kernelFunc:dme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pme(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:i}=t,o=PG(r,s,i);return e.makeTensorInfo([o.length],"float32",o)}const mme={kernelName:HB,backendName:"cpu",kernelFunc:pme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gme=Mr(I1,n=>Math.log1p(n)),yme={kernelName:I1,backendName:"cpu",kernelFunc:gme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vme=Rs((n,e)=>n&&e),xme=si(OT,vme,null,"bool"),wme={kernelName:OT,backendName:"cpu",kernelFunc:xme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bme=Mr(FT,n=>n?0:1,"bool"),Sme={kernelName:FT,backendName:"cpu",kernelFunc:bme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _me=Rs((n,e)=>n||e),Tme=si(zT,_me,null,"bool"),Eme={kernelName:zT,backendName:"cpu",kernelFunc:Tme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cme(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r;Xt(s,"LRN");const u=s.shape[3],c=u-1,h=t.data.get(s.dataId).values,d=Qe(s.shape),p=new Float32Array(d);function g(w){const y=w%u;let x=w-y+Math.max(0,y-i);const _=w-y+Math.min(y+i,c);let T=0;for(;x<=_;x++){const E=h[x];T+=E*E}return T}for(let w=0;w<d;w++){const y=g(w),x=h[w]*Math.pow(o+a*y,-l);p[w]=x}return t.makeTensorInfo(s.shape,s.dtype,p)}const Ime={kernelName:BT,backendName:"cpu",kernelFunc:Cme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nme(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=r;Xt(o,"LRNGrad");const h=Qe(o.shape),d=o.shape[3],p=t.data.get(o.dataId).values,g=t.data.get(s.dataId).values,w=t.data.get(i.dataId).values,y=new Float32Array(h),x=h;for(let _=0;_<x;_++){const T=_%d,E=_-T+Math.max(0,T-a),N=_-T+Math.min(d,T+a+1);let M=0;for(let $=E;$<N;$++)M+=Math.pow(g[$],2);M=u*M+l;for(let $=E;$<N;$++){let L=-2*u*c*g[$]*w[_]/M;_===$&&(L+=Math.pow(M,-c)),L*=p[_],y[$]+=L}}return t.makeTensorInfo(o.shape,s.dtype,y)}const Ame={kernelName:XM,backendName:"cpu",kernelFunc:Nme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wH(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:i,keepDims:o}=r,a=t;let l=s.shape;const u=l.length,c=qn(i,l);let h=c;const d=ps(h,u);let p=a.data.get(s.dataId).values;if(d!=null){const E=new Array(u);for(let N=0;N<E.length;N++)E[N]=l[d[N]];p=UR(p,l,s.dtype,d,E),h=Ms(h.length,u),l=E}Xt(s,"max"),Li("max",h,u);const[g,w]=_i(l,h),y=Qe(w),x=OG(p,y,g,s.dtype),_=a.write(x,g,s.dtype);let T=g;return o&&(T=Vs(g,c)),{dataId:_,shape:T,dtype:s.dtype}}const Mme={kernelName:UT,backendName:"cpu",kernelFunc:wH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kme(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;Xt(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,u=1;ie(Ji(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=El(s.shape,i,o,u,a,l);let h;if(c.filterWidth===1&&c.filterHeight===1&&_r(c.inShape,c.outShape))h=oc({inputs:{x:s},backend:t});else{const d=t.data.get(s.dataId).values,p=nn(s.shape),g=GR(d,s.shape,s.dtype,p,c,"max");h=t.makeTensorInfo(c.outShape,s.dtype,g.values)}return h}const Rme={kernelName:VT,backendName:"cpu",kernelFunc:kme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dme(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=r;Xt(s,"maxPool3d");const c=vh(s.shape,i,o,1,a,l,u),h=t.data.get(s.dataId).values,d=gH(h,s.shape,s.dtype,nn(s.shape),c,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}const $me={kernelName:WT,backendName:"cpu",kernelFunc:Dme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pme(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=r;Xt([s,i],"maxPool3DGrad");const c=vh(i.shape,o,a,1,l,u),h=t.bufferSync(i),d=_fe(h,c),p=c.strideDepth,g=c.strideHeight,w=c.strideWidth,y=c.dilationDepth,x=c.dilationHeight,_=c.dilationWidth,T=c.effectiveFilterDepth,E=c.effectiveFilterHeight,N=c.effectiveFilterWidth,M=T-1-c.padInfo.front,$=N-1-c.padInfo.left,L=E-1-c.padInfo.top,k=Xn(i.shape,"float32"),R=t.bufferSync(s);for(let P=0;P<c.batchSize;++P)for(let B=0;B<c.inChannels;++B)for(let Z=0;Z<c.inDepth;++Z)for(let V=0;V<c.inHeight;++V)for(let X=0;X<c.inWidth;++X){const q=Z-M,se=V-L,W=X-$;let J=0;for(let K=0;K<T;K+=y){const G=(q+K)/p;if(!(G<0||G>=c.outDepth||Math.floor(G)!==G))for(let Q=0;Q<E;Q+=x){const ne=(se+Q)/g;if(!(ne<0||ne>=c.outHeight||Math.floor(ne)!==ne))for(let ce=0;ce<N;ce+=_){const ye=(W+ce)/w;if(ye<0||ye>=c.outWidth||Math.floor(ye)!==ye)continue;const Se=T*E*N-1-d.get(P,G,ne,ye,B),Re=K*E*N+Q*N+ce,Oe=Se===Re?1:0;if(Oe===0)continue;const Ke=R.get(P,G,ne,ye,B);J+=Ke*Oe}}}k.set(J,P,Z,V,X,B)}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const Lme={kernelName:KM,backendName:"cpu",kernelFunc:Pme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ome(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i,output:o}=e,a=i;Xt([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=El(a.shape,l,u,1,c,h),p=t.data.get(a.dataId).values,g=Xn(d.outShape,a.dtype,mH(p,a.shape,a.dtype,d).values),w=d.strideHeight,y=d.strideWidth,x=d.dilationHeight,_=d.dilationWidth,T=d.effectiveFilterHeight,E=d.effectiveFilterWidth,N=E-1-d.padInfo.left,M=T-1-d.padInfo.top,$=Xn(a.shape,"float32"),L=t.data.get(s.dataId).values,k=Xn(s.shape,"float32",L);for(let R=0;R<d.batchSize;++R)for(let P=0;P<d.inChannels;++P)for(let B=0;B<d.inHeight;++B)for(let Z=0;Z<d.inWidth;++Z){const V=B-M,X=Z-N;let q=0;for(let se=0;se<T;se+=x){const W=(V+se)/w;if(!(W<0||W>=d.outHeight||Math.floor(W)!==W))for(let J=0;J<E;J+=_){const K=(X+J)/y;if(K<0||K>=d.outWidth||Math.floor(K)!==K)continue;const G=T*E-1-g.get(R,W,K,P),Q=se*E+J,ne=G===Q?1:0;if(ne===0)continue;const ce=k.get(R,W,K,P);q+=ce*ne}}$.set(q,R,B,Z,P)}return t.makeTensorInfo($.shape,$.dtype,$.values)}const Fme={kernelName:qM,backendName:"cpu",kernelFunc:Ome};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zme(n,e,t,r,s){const i=nn(e),o=GR(n,e,t,i,s,"max"),a=mH(n,e,t,s,!0,r);return[o.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bme={kernelName:jB,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;Xt(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=El(r.shape,s,i,[1,1],o),[h,d]=zme(u,r.shape,r.dtype,a,c),p=l.write(h,c.outShape,r.dtype),g=l.write(d,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:g,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ume(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=qn(i,s.shape),u=_i(s.shape,a)[1],c=Qe(u),h=[],d=t.makeTensorInfo([],"float32",new Float32Array([c]));h.push(d);const p=Od({inputs:{x:s},backend:t,attrs:{dtype:"float32"}});h.push(p);const g=HR({inputs:{a:p,b:d},backend:t});h.push(g);const w=dw({inputs:{x:g},backend:t,attrs:{axis:i,keepDims:o}});return h.forEach(y=>t.disposeIntermediateTensorInfo(y)),w}const Vme={kernelName:GT,backendName:"cpu",kernelFunc:Ume};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wme(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;Xt(s,"min");const a=qn(i,s.shape);let l=a;const u=ps(l,s.shape.length);let c=s;u!=null&&(c=Yo({inputs:{x:s},backend:t,attrs:{perm:u}}),l=Ms(l.length,s.shape.length)),Li("min",l,c.shape.length);const[h,d]=_i(c.shape,l),p=Qe(d),g=Zi(Qe(h),c.dtype),w=t.data.get(c.dataId).values;for(let x=0;x<g.length;++x){const _=x*p;let T=w[_];for(let E=0;E<p;++E){const N=w[_+E];(Number.isNaN(N)||N<T)&&(T=N)}g[x]=T}u!=null&&t.disposeIntermediateTensorInfo(c);const y=t.makeTensorInfo(h,c.dtype,g);if(o){const x=Vs(h,a),_=qr({inputs:{x:y},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(y),_}return y}const Gme={kernelName:HT,backendName:"cpu",kernelFunc:Wme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hme(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,mode:o}=r;Xt(s,"mirrorPad");const a=i.map((T,E)=>T[0]+s.shape[E]+T[1]),l=i.map(T=>T[0]),u=i.map((T,E)=>T[0]+s.shape[E]),c=o==="reflect"?0:1,h=t.data.get(s.dataId).values,d=s.shape.length,p=nn(s.shape),g=Qe(a),w=a.length,y=nn(a),x=Yi(s.dtype,g);for(let T=0;T<g;T++){let E=Xy(T,w,y);for(let M=0;M<w;M++)E[M]<l[M]?E[M]=l[M]*2-E[M]-c:E[M]>=u[M]&&(E[M]=(u[M]-1)*2-E[M]+c);E=E.map((M,$)=>M-l[$]);const N=Xu(E,d,p);x[T]=h[N]}return{dataId:t.write(x,a,s.dtype),shape:a,dtype:s.dtype}}const jme={kernelName:jT,backendName:"cpu",kernelFunc:Hme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xme=Rs(((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e})),qme=si(M1,Xme),Kme={kernelName:M1,backendName:"cpu",kernelFunc:qme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bH(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:i}=r,o=s.shape.length;let a=i;if(a===-1&&(a=o-1),a!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${a}`);const l=qn([a],s.shape),u=wH({inputs:{x:s},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),c=Vs(u.shape,l),h=qr({inputs:{x:u},backend:t,attrs:{shape:c}}),d=WR({inputs:{a:s,b:h},backend:t}),p=EG({inputs:{x:d},backend:t}),g=dw({inputs:{x:p},backend:t,attrs:{axis:l,keepDims:!1}}),w=qr({inputs:{x:g},backend:t,attrs:{shape:c}}),y=HR({inputs:{a:p,b:w},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(w),y}const Yme={kernelName:cE,backendName:"cpu",kernelFunc:bH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zme(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r;Xt(s,"multinomial");const l=a?s:bH({inputs:{logits:s},backend:t,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=t.data.get(l.dataId).values,d=[u,i],p=Zi(Qe(d),"int32");for(let g=0;g<u;++g){const w=g*c,y=new Float32Array(c-1);y[0]=h[w];for(let T=1;T<y.length;++T)y[T]=y[T-1]+h[w+T];const x=Zy.alea(o.toString()),_=g*i;for(let T=0;T<i;++T){const E=x();p[_+T]=y.length;for(let N=0;N<y.length;N++)if(E<y[N]){p[_+T]=N;break}}}return a||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(d,"int32",p)}const Jme={kernelName:XB,backendName:"cpu",kernelFunc:Zme};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qme=Fk;function ege(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r;Xt(s,"NonMaxSuppression");const u=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values,{selectedIndices:h}=Qme(u,c,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const tge={kernelName:YM,backendName:"cpu",kernelFunc:ege};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nge=zk;function rge(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r;Xt(s,"NonMaxSuppressionPadded");const c=t.data.get(s.dataId).values,h=t.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=nge(c,h,o,a,l,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const sge={kernelName:ZM,backendName:"cpu",kernelFunc:rge};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ige=Bk;function oge(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r;Xt(s,"NonMaxSuppressionWithScore");const c=t.data.get(s.dataId).values,h=t.data.get(i.dataId).values,d=o,p=a,g=l,w=u,{selectedIndices:y,selectedScores:x}=ige(c,h,d,p,g,w);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}const age={kernelName:JM,backendName:"cpu",kernelFunc:oge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lge(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r;Xt(s,"oneHot");const u=Qe(s.shape),c=new Float32Array(u*o);c.fill(l);const h=t.data.get(s.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<o&&(c[d*o+h[d]]=a);return t.makeTensorInfo([...s.shape,o],i,c)}const uge={kernelName:YT,backendName:"cpu",kernelFunc:lge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function __(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const s=Kp({inputs:{input:r},backend:t}),i=__({inputs:{x:s},backend:t}),o=Ay({inputs:{input:r},backend:t}),a=__({inputs:{x:o},backend:t}),l=wa({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return jR({backend:t,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const cge={kernelName:fE,backendName:"cpu",kernelFunc:__};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SH(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const s=Kp({inputs:{input:r},backend:t}),i=SH({inputs:{x:s},backend:t}),o=Ay({inputs:{input:r},backend:t}),a=__({inputs:{x:o},backend:t}),l=wa({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return jR({backend:t,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const hge={kernelName:KT,backendName:"cpu",kernelFunc:SH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _H(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return S_({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(c=>{xM(i,c.shape,"All tensors passed to stack must have matching shapes"),ie(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=S_({inputs:{input:c},backend:t,attrs:{dim:s}});return a.push(h),h}),u=My({inputs:l,backend:t,attrs:{axis:s}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const dge={kernelName:ZT,backendName:"cpu",kernelFunc:_H};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fge(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,constantValue:o}=r;Xt(s,"pad");const a=i.map((_,T)=>_[0]+s.shape[T]+_[1]),l=i.map(_=>_[0]),u=t.data.get(s.dataId).values,c=Qe(s.shape),h=s.shape.length,d=nn(s.shape),p=Qe(a),g=a.length,w=nn(a),y=Yi(s.dtype,p);o!==0&&y.fill(o);for(let _=0;_<c;_++){const E=Xy(_,h,d).map((M,$)=>M+l[$]),N=Xu(E,g,w);y[N]=u[_]}return{dataId:t.write(y,a,s.dtype),shape:a,dtype:s.dtype}}const TH={kernelName:JT,backendName:"cpu",kernelFunc:fge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pge=Rs((n,e)=>Math.pow(n,e)),mge=si(R1,pge),gge={kernelName:R1,backendName:"cpu",kernelFunc:mge};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yge(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=r,l=s.map(x=>t.data.get(x.dataId).values),u=s.map(x=>x.shape),c=t.data.get(i.dataId).values,h=t.data.get(o.dataId).values,[d,p,g]=WG(l,u,c,i.shape,i.dtype,h,o.shape),w=d.map(x=>t.makeTensorInfo([x.length],"int32",x)),y=t.makeTensorInfo(g,i.dtype,p);return w.concat([y])}const vge={kernelName:qB,backendName:"cpu",kernelFunc:yge};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xge(n){const{inputs:e,backend:t}=n,{starts:r,limits:s,deltas:i}=e,o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,[u,c]=GG(o,r.shape,r.dtype,a,s.shape,l,i.shape),h=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([c.length],r.dtype,c);return[h,d]}const wge={kernelName:KB,backendName:"cpu",kernelFunc:xge};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bge(n){const{inputs:e,backend:t,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,u=t.data.get(s.dataId).values,c=t.data.get(i.dataId).values,h=t.data.get(o.dataId).values,d=a.map(y=>t.data.get(y.dataId).values),p=a.map(y=>y.shape),[g,w]=HG(u,s.shape,c,i.shape,i.dtype,h,o.shape,d,p,l);return t.makeTensorInfo(g,i.dtype,w)}const Sge={kernelName:YB,backendName:"cpu",kernelFunc:bge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ge(n){const{backend:e,attrs:t}=n,{start:r,stop:s,dtype:i,step:o}=t,a=jG(r,s,o,i);return e.makeTensorInfo([a.length],i,a)}const Tge={kernelName:QM,backendName:"cpu",kernelFunc:_ge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ege=Mr(D1,n=>1/n),Cge={kernelName:D1,backendName:"cpu",kernelFunc:Ege};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ige(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r;Xt(s,"resizeBilinear");const l=nn(s.shape),[u,c]=a,[h,d,p,g]=s.shape,w=t.data.get(s.dataId).values,y=new Float32Array(Qe([h,u,c,g])),x=[i&&u>1?d-1:d,i&&c>1?p-1:p],_=[i&&u>1?u-1:u,i&&c>1?c-1:c];let T=0;const E=x[0]/_[0],N=x[1]/_[1];for(let M=0;M<h;M++)for(let $=0;$<u;$++){let L;o?L=E*($+.5)-.5:L=E*$;const k=Math.max(0,Math.floor(L)),R=L-k,P=Math.min(d-1,Math.ceil(L)),B=M*l[0]+k*l[1],Z=M*l[0]+P*l[1];for(let V=0;V<c;V++){let X;o?X=N*(V+.5)-.5:X=N*V;const q=Math.max(0,Math.floor(X)),se=X-q,W=Math.min(p-1,Math.ceil(X)),J=B+q*l[2],K=Z+q*l[2],G=B+W*l[2],Q=Z+W*l[2];for(let ne=0;ne<g;ne++){const ce=w[J+ne],ye=w[K+ne],Se=w[G+ne],Re=w[Q+ne],Oe=ce+(Se-ce)*se,Ke=ye+(Re-ye)*se,st=Oe+(Ke-Oe)*R;y[T++]=st}}}return t.makeTensorInfo([h,u,c,g],"float32",y)}const Nge={kernelName:rE,backendName:"cpu",kernelFunc:Ige};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Age(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r;Xt([i,s],"resizeBilinearGrad");const a=nn(s.shape),[l,u,c,h]=s.shape,[,d,p]=i.shape,g=new Float32Array(l*u*c*h),w=[o&&d>1?u-1:u,o&&p>1?c-1:c],y=[o&&d>1?d-1:d,o&&p>1?p-1:p],x=w[0]/y[0],_=w[1]/y[1],T=t.data.get(i.dataId).values;let E=0;for(let N=0;N<l;N++){const M=N*a[0];for(let $=0;$<d;$++){const L=$*x,k=Math.floor(L),R=Math.min(Math.ceil(L),u-1),P=M+k*a[1],B=M+R*a[1],Z=L-k,V=1-Z;for(let X=0;X<p;X++){const q=X*_,se=Math.floor(q),W=Math.min(Math.ceil(q),c-1),J=q-se,K=1-J,G=P+se*a[2],Q=P+W*a[2],ne=B+se*a[2],ce=B+W*a[2],ye=V*K,Se=V*J,Re=Z*K,Oe=Z*J;for(let Ke=0;Ke<h;Ke++){const st=T[E++];g[G+Ke]+=st*ye,g[Q+Ke]+=st*Se,g[ne+Ke]+=st*Re,g[ce+Ke]+=st*Oe}}}}return t.makeTensorInfo([l,c,u,h],"float32",g)}const Mge={kernelName:nk,backendName:"cpu",kernelFunc:Age};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kge(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r;Xt(s,"resizeNearestNeighbor");const l=nn(s.shape),[u,c]=a,[h,d,p,g]=s.shape,w=t.data.get(s.dataId).values,y=new Float32Array(h*u*c*g),x=[i&&u>1?d-1:d,i&&c>1?p-1:p],_=[i&&u>1?u-1:u,i&&c>1?c-1:c],T=x[0]/_[0],E=x[1]/_[1];let N=0;for(let M=0;M<h;M++){const $=M*l[0];for(let L=0;L<u;L++){const k=o?T*(L+.5):T*L;let R=Math.min(d-1,i?Math.round(k):Math.floor(k));o&&(R=Math.max(0,R));const P=$+R*l[1];for(let B=0;B<c;B++){const Z=o?E*(B+.5):E*B;let V=Math.min(p-1,i?Math.round(Z):Math.floor(Z));o&&(V=Math.max(0,V));const X=P+V*l[2];for(let q=0;q<g;q++){const se=w[X+q];y[N++]=se}}}}return t.makeTensorInfo([h,u,c,g],s.dtype,y)}const Rge={kernelName:nE,backendName:"cpu",kernelFunc:kge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dge(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r;Xt([i,s],"resizeNearestNeighborGrad");const a=nn(s.shape),l=nn(i.shape),[u,c,h,d]=s.shape,[,p,g]=i.shape,w=new Float32Array(u*c*h*d),y=t.data.get(i.dataId).values,x=[o&&p>1?c-1:c,o&&g>1?h-1:h],_=[o&&p>1?p-1:p,o&&g>1?g-1:g],T=x[0]/_[0],E=x[1]/_[1],N=1/T,M=1/E,$=Math.ceil(N)*2+2,L=Math.ceil(M)*2+2;for(let k=0;k<u;k++){const R=k*a[0];for(let P=0;P<c;P++){const B=R+P*a[1],Z=Math.floor(P*N),V=Math.floor(Z-$/2);for(let X=0;X<h;X++){const q=B+X*a[2],se=Math.floor(X*M),W=Math.floor(se-L/2);for(let J=0;J<d;J++){let K=0;for(let G=0;G<$;G++){const Q=G+V;if(Q<0||Q>=p)continue;const ne=R+Q*l[1],ce=Q*T,ye=Math.min(c-1,o?Math.round(ce):Math.floor(ce));if(P===ye)for(let Se=0;Se<L;Se++){const Re=Se+W;if(Re<0||Re>=g)continue;const Oe=ne+Re*l[2],Ke=Re*E,st=Math.min(h-1,o?Math.round(Ke):Math.floor(Ke));X===st&&(K+=y[Oe+J])}}w[q+J]=K}}}}return t.makeTensorInfo(s.shape,s.dtype,w)}const $ge={kernelName:tk,backendName:"cpu",kernelFunc:Dge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pge(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:i}=r;Xt(s,"reverse");const o=s.shape.length,a=qn(i,s.shape);if(o===0)return oc({inputs:{x:s},backend:t});const l=new $i(s.shape,s.dtype),u=t.bufferSync(s);for(let c=0;c<l.size;c++){const h=l.indexToLoc(c),d=h.slice();a.forEach(p=>d[p]=s.shape[p]-1-d[p]),l.set(u.get(...d),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const Lge={kernelName:sE,backendName:"cpu",kernelFunc:Pge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oge={kernelName:uk,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=e,a=t,l=Yi(r.dtype,Qe(r.shape)),[u,c,h,d]=r.shape,[p,g]=Zk(o,c,h),w=255,y=Math.sin(s),x=Math.cos(s),_=a.data.get(r.dataId).values;for(let E=0;E<u;E++){const N=E*h*c*d;for(let M=0;M<c;M++){const $=M*(h*d);for(let L=0;L<h;L++){const k=L*d;for(let R=0;R<d;R++){const P=[u,M,L,R],B=P[2],Z=P[1];let V=(B-p)*x-(Z-g)*y,X=(B-p)*y+(Z-g)*x;V=Math.round(V+p),X=Math.round(X+g);let q=i;if(typeof i!="number"&&(R===3?q=w:q=i[R]),V>=0&&V<h&&X>=0&&X<c){const W=X*(h*d),J=V*d,K=N+W+J+R;q=_[K]}const se=N+$+k+R;l[se]=q}}}}return{dataId:a.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fge=Mr(L1,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),zge={kernelName:L1,backendName:"cpu",kernelFunc:Fge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bge(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=hm(i,s,o),d=!0,p=t.bufferSync(s),g=t.bufferSync(i),w=_p(p,g,o,h,u,l,a,c,0,d);return t.makeTensorInfo(o,w.dtype,w.values)}const Uge={kernelName:ZB,backendName:"cpu",kernelFunc:Bge};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vge(n,e){let t=0,r=n.length,s=0;for(;t<r;)s=Math.floor((t+r)/2),n[s]<e?t=s+1:r=s;return r}function Wge(n,e){let t=0,r=n.length,s=0;for(;t<r;)s=Math.floor((t+r)/2),n[s]<=e?t=s+1:r=s;return r}function Gge(n,e,t,r,s,i){const o=Cs("int32",t*s);for(let a=0;a<t;++a){const l=n.slice(a*r,(a+1)*r),u=a*s;for(let c=0;c<s;++c)o[u+c]=i==="left"?Vge(l,e[c+u]):Wge(l,e[c+u])}return o}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hge(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:i}=e,{side:o}=r,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,u=Gge(a,l,s.shape[0],s.shape[1],i.shape[1],o);return t.makeTensorInfo(i.shape,"int32",u)}const jge={kernelName:QB,backendName:"cpu",kernelFunc:Hge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xge(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:i}=e;Xt([r,s,i],"select");const o=r.shape.length,a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values,c=_a(s.dtype,i.dtype),h=Zi(Qe(s.shape),c);let d=0;const p=o===0||o>1||s.shape.length===1?1:Qe(s.shape.slice(1));for(let g=0;g<a.length;g++)for(let w=0;w<p;w++)a[g]===1?h[d++]=l[g]:h[d++]=u[g];return t.makeTensorInfo(s.shape,c,h)}const qge={kernelName:iE,backendName:"cpu",kernelFunc:Xge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kge=EE,Yge=CE,Zge=Mr(F1,n=>n>=0?Yge*n:Kge*(Math.exp(n)-1)),Jge={kernelName:F1,backendName:"cpu",kernelFunc:Zge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qge=Mr(U1,n=>n<0?-1:n>0?1:0),eye={kernelName:U1,backendName:"cpu",kernelFunc:Qge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tye=Mr(z1,n=>Math.sin(n)),nye={kernelName:z1,backendName:"cpu",kernelFunc:tye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rye=Mr(B1,n=>Math.sinh(n)),sye={kernelName:B1,backendName:"cpu",kernelFunc:rye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iye=11920928955078125e-23,DL=Math.log(iye)+2,oye=Mr(W1,n=>{const e=n>-DL,t=n<DL,r=Math.exp(n);let s;return t?s=r:e?s=n:s=Math.log(1+r),s}),aye={kernelName:W1,backendName:"cpu",kernelFunc:oye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lye(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,paddings:o}=r;Xt([s],"spaceToBatchND");const a=Qe(i),l=[[0,0]];l.push(...o);for(let M=1+i.length;M<s.shape.length;++M)l.push([0,0]);const u=TH.kernelFunc({inputs:{x:s},backend:t,attrs:{paddings:l,constantValue:0}}),c=rw(u.shape,i,a,!1),h=sw(c.length,i.length,!1),d=iw(u.shape,i,a,!1),w=qr({inputs:{x:u},backend:t,attrs:{shape:c}}),_=Yo({inputs:{x:w},backend:t,attrs:{perm:h}}),N=qr({inputs:{x:_},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(_),N}const uye={kernelName:lE,backendName:"cpu",kernelFunc:lye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cye(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${i.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.data.get(r.dataId).values,l=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values,c=t.data.get(o.dataId).values[0],[h,d,p,g,w]=YG(a,r.shape,r.dtype,l,s.dtype,u,c);return[t.makeTensorInfo(d,r.dtype,h),t.makeTensorInfo([d[0]],s.dtype,p),t.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(y=>Number(y)))),t.makeTensorInfo([w.length],r.dtype,new Int32Array(w))]}const hye={kernelName:eU,backendName:"cpu",kernelFunc:cye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dye(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:i}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.data.get(s.dataId).values),a=t.data.get(r.dataId).values,l=Array.from(t.data.get(i.dataId).values),[u,c,h]=ZG(a,r.shape,r.dtype,o,l);return[t.makeTensorInfo(c,r.dtype,u),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const fye={kernelName:tU,backendName:"cpu",kernelFunc:dye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pye(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,[u,c]=VR(o,r.shape,r.dtype,a,l,!0);return t.makeTensorInfo(c,r.dtype,u)}const mye={kernelName:nU,backendName:"cpu",kernelFunc:pye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gye(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${i.shape}`);if(s.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const o=t.data.get(r.dataId).values,a=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,[u,c]=VR(o,r.shape,r.dtype,a,l);return t.makeTensorInfo(c,r.dtype,u)}const yye={kernelName:rU,backendName:"cpu",kernelFunc:gye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vye(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=hm(i,s,a),p=!1,g=t.bufferSync(s);let w;switch(i.dtype){case"bool":{const y=t.bufferSync(i),x=!!t.data.get(o.dataId).values[0];w=_p(g,y,a,d,c,u,l,h,x,p);break}case"float32":{const y=t.bufferSync(i),x=t.data.get(o.dataId).values[0];w=_p(g,y,a,d,c,u,l,h,x,p);break}case"int32":{const y=t.bufferSync(i),x=t.data.get(o.dataId).values[0];w=_p(g,y,a,d,c,u,l,h,x,p);break}case"string":{const y=t.bufferSync(i),x=Rd(t.data.get(o.dataId).values[0]);w=_p(g,y,a,d,c,u,l,h,x,p);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return t.makeTensorInfo(a,w.dtype,w.values)}const xye={kernelName:sU,backendName:"cpu",kernelFunc:vye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wye(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=qn(o,s.shape)[0],l=dR(s,i,a),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(h=>{const d=[...c];d[a]=h;const p=Yp({inputs:{x:s},backend:t,attrs:{begin:u,size:d}});return u[a]+=h,p})}const bye={kernelName:uE,backendName:"cpu",kernelFunc:wye};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sye={kernelName:rk,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,r=e;Xt(t,"square");const s=r.data.get(t.dataId).values,i=new Float32Array(s.length);for(let a=0;a<s.length;++a){const l=s[a];i[a]=l*l}return{dataId:r.write(i,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ye=Mr(Y1,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),Tye={kernelName:Y1,backendName:"cpu",kernelFunc:_ye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eye(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r;Xt(s,"stridedSlice");const{finalShapeSparse:p,finalShape:g,isIdentity:w,sliceDim0:y,isSimpleSlice:x,begin:_,end:T,strides:E}=qk(s.shape,i,o,a,l,u,c,h,d);let N;if(w)N=qr({inputs:{x:s},backend:t,attrs:{shape:g}});else if(y||x){ie(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const M=Hk(_,T,E),$=Yp({inputs:{x:s},backend:t,attrs:{begin:_,size:M}});N=qr({inputs:{x:$},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo($)}else{const M=t.bufferSync(s),$=eH(p,M,E,_);N=t.makeTensorInfo(g,$.dtype,$.values)}return N}const Cye={kernelName:ik,backendName:"cpu",kernelFunc:Eye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iye(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=e,d=t.data.get(c.dataId).values,p=t.data.get(h.dataId).values,[g,w]=tH(d,p,s,i,o,a,l,u);return[t.makeTensorInfo([g.length],"string",g),t.makeTensorInfo(h.shape,"int32",w)]}const Nye={kernelName:iU,backendName:"cpu",kernelFunc:Iye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aye(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.data.get(i.dataId).values,l=t.data.get(o.dataId).values[0],[u,c,h]=nH(a,l,s),d=c.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const Mye={kernelName:oU,backendName:"cpu",kernelFunc:Aye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kye(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(i.dataId).values,a=rH(o,s);return t.makeTensorInfo(i.shape,"int32",a)}const Rye={kernelName:aU,backendName:"cpu",kernelFunc:kye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dye=Mr(X1,n=>Math.tan(n)),$ye={kernelName:X1,backendName:"cpu",kernelFunc:Dye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pye=Mr(q1,n=>Math.tanh(n)),Lye={kernelName:q1,backendName:"cpu",kernelFunc:Pye};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oye(n){const{inputs:e,backend:t}=n,{tensor:r,indices:s,updates:i}=e,{sliceRank:o,numUpdates:a,sliceSize:l,strides:u,outputSize:c}=hm(i,s,r.shape),h=!1,d=t.bufferSync(s),p=t.bufferSync(i),g=t.bufferSync(r),w=_p(d,p,r.shape,c,l,a,o,u,g,h);return t.makeTensorInfo(r.shape,w.dtype,w.values)}const Fye={kernelName:JB,backendName:"cpu",kernelFunc:Oye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zye(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:i}=r;Xt(s,"tile");const o=iH(t.bufferSync(s),i);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const Bye={kernelName:K1,backendName:"cpu",kernelFunc:zye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uye(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:i,sorted:o}=r;Xt(s,"topk");const a=t.data.get(s.dataId).values,[l,u]=aH(a,s.shape,s.dtype,i,o);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(u.shape,u.dtype,u.values)]}const Vye={kernelName:ok,backendName:"cpu",kernelFunc:Uye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wye(n){const{inputs:e,attrs:t,backend:r}=n,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=t,[c,h,d,p]=s.shape,[g,w]=u??[h,d],y=[c,g,w,p],x=nn(s.shape),_=x[0],T=x[1],E=x[2],N=nn(y),M=N[0],$=N[1],L=N[2],k=Yi(s.dtype,Qe(y));k.fill(l);const R=r.data.get(s.dataId).values,P=r.data.get(i.dataId).values;for(let Z=0;Z<c;++Z){const V=i.shape[0]===1?P:P.subarray(Z*8,Z*8+8);for(let X=0;X<g;++X)for(let q=0;q<w;++q)for(let se=0;se<p;++se){let W;const J=V[6]*q+V[7]*X+1;if(J===0)continue;const K=(V[0]*q+V[1]*X+V[2])/J,G=(V[3]*q+V[4]*X+V[5])/J,Q=$L(K,d,a),ne=$L(G,h,a);switch(o){case"nearest":W=Kye(R,h,d,_,T,E,Z,ne,Q,se,l);break;case"bilinear":W=Yye(R,h,d,_,T,E,Z,ne,Q,se,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const ce=Z*M+X*$+q*L+se;k[ce]=W}return r.makeTensorInfo(y,s.dtype,k)}return{dataId:r.write(k,y,s.dtype),shape:s.shape,dtype:s.dtype}}const Gye={kernelName:ak,backendName:"cpu",kernelFunc:Wye};function $L(n,e,t){switch(t){case"reflect":return Hye(n,e);case"wrap":return jye(n,e);case"nearest":return qye(n,e);case"constant":default:return Xye(n)}}function Hye(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const r=2*e;t<r&&(t=r*Math.trunc(-t/r)+t),t=t<-e?t+r:-t-1}else if(t>e-1)if(e<=1)t=0;else{const r=2*e;t-=r*Math.trunc(t/r),t>=e&&(t=r-t-1)}return zp(0,t,e-1)}function jye(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const r=e-1;t+=e*(Math.trunc(-t/r)+1)}else if(t>e-1)if(e<=1)t=0;else{const r=e-1;t-=e*Math.trunc(t/r)}return zp(0,t,e-1)}function Xye(n,e){return n}function qye(n,e){return zp(0,n,e-1)}function Lv(n,e,t,r,s,i,o,a,l,u,c){const h=o*r+a*s+l*i+u;return 0<=a&&a<e&&0<=l&&l<t?n[h]:c}function Kye(n,e,t,r,s,i,o,a,l,u,c){const h=Math.round(a),d=Math.round(l);return Lv(n,e,t,r,s,i,o,h,d,u,c)}function Yye(n,e,t,r,s,i,o,a,l,u,c){const h=Math.floor(a),d=Math.floor(l),p=h+1,g=d+1,w=(g-l)*Lv(n,e,t,r,s,i,o,h,d,u,c)+(l-d)*Lv(n,e,t,r,s,i,o,h,g,u,c),y=(g-l)*Lv(n,e,t,r,s,i,o,p,d,u,c)+(l-d)*Lv(n,e,t,r,s,i,o,p,g,u,c);return(p-a)*w+(a-h)*y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zye(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:i}=e;Xt(i,"unique");const o=r.data.get(i.dataId).values,{outputValues:a,outputShape:l,indices:u}=lH(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}const Jye={kernelName:lk,backendName:"cpu",kernelFunc:Zye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qye(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s.shape.length,a=s.shape[i],l=new Array(o-1);let u=0;for(let p=0;p<o;p++)p!==i&&(l[u++]=s.shape[p]);const c=new Array(o).fill(0),h=s.shape.slice();h[i]=1;const d=new Array(a);for(let p=0;p<d.length;p++){c[i]=p;const g=Yp({inputs:{x:s},backend:t,attrs:{begin:c,size:h}});d[p]=qr({inputs:{x:g},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(g)}return d}const e0e={kernelName:hE,backendName:"cpu",kernelFunc:Qye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t0e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:i}=e,{numSegments:o}=r;Xt(s,"unsortedSegmentSum");const a=s.shape.length,l=i.shape.length,u=[],c=[],h=a-l;let d=i;for(let g=0;g<h;++g){const w=S_({inputs:{input:d},backend:t,attrs:{dim:g+1}});d=w,c.push(w)}for(let g=0;g<o;++g){const w=Yd(g,"int32"),y=t.makeTensorInfo([],"int32",w),x=_G({inputs:{a:y,b:d},backend:t}),_=Od({inputs:{x},backend:t,attrs:{dtype:"float32"}}),T=FE({inputs:{a:_,b:s},backend:t}),E=dw({inputs:{x:T},backend:t,attrs:{axis:0,keepDims:!1}});u.push(E),c.push(y),c.push(x),c.push(_),c.push(T),c.push(E)}const p=_H({inputs:u,backend:t,attrs:{axis:0}});return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),p}const n0e={kernelName:dE,backendName:"cpu",kernelFunc:t0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r0e=[Zde,khe,Qde,tfe,Ohe,rfe,ife,afe,ufe,hfe,ffe,mfe,yfe,wfe,Sfe,Efe,Ife,Afe,kfe,Kde,Dfe,Pfe,Ofe,zhe,zfe,Phe,Uhe,Ufe,Rhe,Wfe,Hfe,jfe,qfe,Yfe,Jfe,epe,npe,spe,ope,lpe,cpe,dpe,ppe,gpe,ype,xpe,bpe,_pe,Tpe,Epe,Cpe,Npe,kpe,Vde,Dpe,Vhe,Upe,Whe,Vpe,Hhe,qpe,Kpe,Zpe,Xhe,Khe,Qpe,tme,rme,ime,Zhe,Qhe,Dhe,ame,Gfe,ume,hme,fme,Wde,tde,rde,mme,ide,yme,wme,Sme,Eme,Ime,Ame,Mme,ade,Rme,$me,Lme,Fme,Bme,Vme,Gme,ude,jme,Kme,Jme,hde,fde,tge,sge,age,mde,uge,hge,dge,TH,gge,Hde,vde,vge,wge,Sge,Tge,$he,PN,Cge,jde,Xde,qde,Nge,Mge,Rge,$ge,Lge,Oge,zge,Cde,Uge,jge,qge,Jge,Nde,eye,nye,sye,Ade,Yme,aye,uye,hye,fye,mye,yye,xye,bye,Rde,Sye,$de,Lde,Tye,Cye,Nye,Mye,Rye,Bde,Ape,$ye,Lye,Fye,Bye,Vye,Gye,gde,Jye,e0e,n0e,cge];for(const n of r0e)uU(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fp={},pS={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function s0e(n,e){fp[n]=e}function vu(n,e){if(!(n in fp)||e!=null){const r=o0e(n,e);if(r!==null)fp[n]=r;else return console.log("Could not get context for WebGL version",n),null}const t=fp[n];return t==null||t.isContextLost()?(delete fp[n],vu(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),fp[n])}function i0e(n){if(!je().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function o0e(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??i0e(n);return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete fp[n]},!1),je().getBool("SOFTWARE_WEBGL_ENABLED")&&(pS.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",pS)||t.getContext("experimental-webgl",pS):t.getContext("webgl2",pS)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ix;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Ix||(Ix={}));var Ga;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Ga||(Ga={}));var ki;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(ki||(ki={}));function fw(n,e){return[e,n]}function a0e(n,e){return n*e}function mS(n){const e=Qe(n),t=Math.ceil(e/4);return rN(t)}function n0(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function l0e(n,e){const[t,r]=n0(n,e);return t*r*4}function XR(n,e){const t=n;let r,s,i,o,a,l,u,c,h,d;return je().getNumber("WEBGL_VERSION")===2?(r=t.R32F,s=t.R16F,i=t.RGBA16F,o=t.RGBA32F,a=t.RED,u=4,c=1,h=t.HALF_FLOAT,d=t.FLOAT,l=t.RGBA8):(r=n.RGBA,s=n.RGBA,i=n.RGBA,o=t.RGBA,a=n.RGBA,u=4,c=4,h=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,l=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lt(n,e){const t=e();return je().getBool("DEBUG")&&u0e(n),t}function u0e(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+f0e(n,e))}const c0e=596e-10,h0e=65504;function d0e(n){return!!(je().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||c0e<Math.abs(n)&&Math.abs(n)<h0e)}function f0e(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function gS(n,e){return wh(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function p0e(n,e){const t=wh(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Lt(n,()=>n.shaderSource(t,e)),Lt(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function m0e(n,e){const t=wh(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Lt(n,()=>n.shaderSource(t,e)),Lt(n,()=>n.compileShader(t)),je().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw EH(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const g0e=/ERROR: [0-9]+:([0-9]+):/g;function EH(n,e){const t=g0e.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const r=+t[1],s=n.split(`
`),i=s.length.toString().length+2,o=s.map((h,d)=>ay((d+1).toString(),i)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,r-1),u=o.slice(r-1,r),c=o.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${ay(u[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function y0e(n){return wh(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function v0e(n,e){if(Lt(n,()=>n.linkProgram(e)),!je().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function K2(n,e){if(Lt(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function x0e(n,e){const t=wh(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Lt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Lt(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function w0e(n,e){const t=wh(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Lt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Lt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function b0e(n){return wh(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function S0e(n,e){const t=je().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const r=`[${n}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>t||e>t){const r=`[${n}x${e}]`,s=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function _0e(n){return wh(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function PL(n,e,t,r,s,i,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(Lt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),Lt(n,()=>n.vertexAttribPointer(a,s,n.FLOAT,!1,i,o)),Lt(n,()=>n.enableVertexAttribArray(a)),!0)}function T0e(n,e,t){A0e(n,t),Lt(n,()=>n.activeTexture(n.TEXTURE0+t)),Lt(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function E0e(n,e,t){return wh(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function C0e(n,e,t){return n.getUniformLocation(e,t)}function I0e(n,e,t,r){Lt(n,()=>T0e(n,e,r)),Lt(n,()=>n.uniform1i(t,r))}function Y2(n,e,t){Lt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Lt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function LL(n,e){Lt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Lt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function yS(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+N0e(n,e))}function N0e(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function wh(n,e,t){const r=Lt(n,()=>e());if(r==null)throw new Error(t);return r}function A0e(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){const s=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${s}.`)}}function ky(n,e=2){return Qe(n.slice(0,n.length-e))}function Ry(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function vS(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[ky(n),...Ry(n)]),e}function M0e(n,e=!1){let t=je().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=je().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&je().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),e&&(t=t*2,r=r*2,n=n.map((a,l)=>l>=n.length-2?vM(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Kd(n).newShape);let s=Qe(n),i=null;n.length<=1&&s<=t?i=[1,s]:n.length===2&&n[0]<=t&&n[1]<=t?i=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?i=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?i=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?i=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(i=[n[0],n[1]*n[2]*n[3]]);const o=i!=null&&Math.max(...i)>r&&Math.min(...i)<=(e?2:1)&&Math.min(...i)>0;if(i==null||o)if(e){const a=ky(n);let l=2,u=2;n.length&&([l,u]=Ry(n)),s=a*(l/2)*(u/2),i=rN(s).map(c=>c*2)}else i=rN(s);return i}function xS(n){return n%2===0}function T_(n,e){if(n=n.slice(-2),e=e.slice(-2),_r(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],r=e[e.length-1];if(t===r||xS(t)&&xS(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&xS(n[0])&&xS(e[0])}let Z2,J2;function k0e(n){if(Z2==null){const e=vu(n);Z2=e.getParameter(e.MAX_TEXTURE_SIZE)}return Z2}function R0e(n){if(J2==null){const e=vu(n);J2=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,J2)}function D0e(n){if(n===0)return 0;let e;const t=vu(n);return vl(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:vl(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function vl(n,e){return n.getExtension(e)!=null}function OL(n){try{if(vu(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function $0e(n){if(n===0)return!1;const e=vu(n);if(n===1){if(!vl(e,"OES_texture_float"))return!1}else if(!vl(e,"EXT_color_buffer_float"))return!1;return ON(e)}function P0e(n){if(n===0)return!1;const e=vu(n);if(n===1){if(!vl(e,"OES_texture_float")||!vl(e,"WEBGL_color_buffer_float"))return!1}else{if(vl(e,"EXT_color_buffer_float"))return ON(e);const r="EXT_color_buffer_half_float";if(vl(e,r)){const s=e.getExtension(r);return L0e(e,s)}return!1}return ON(e)}function ON(n){const e=XR(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),o}function L0e(n,e){const t=XR(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),a}function O0e(n){return n!==2?!1:vu(n).fenceSync!=null}function pw(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&ie(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kt=je();Kt.registerFlag("HAS_WEBGL",()=>Kt.getNumber("WEBGL_VERSION")>0);Kt.registerFlag("WEBGL_VERSION",()=>OL(2)?2:OL(1)?1:0);Kt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Kt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Kt.get("WEBGL_VERSION")===2);Kt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Kt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Kt.registerFlag("WEBGL_PACK",()=>Kt.getBool("HAS_WEBGL"));Kt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Kt.getBool("WEBGL_PACK"));Kt.registerFlag("WEBGL_PACK_CLIP",()=>Kt.getBool("WEBGL_PACK"));Kt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Kt.getBool("WEBGL_PACK"));Kt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Kt.getBool("WEBGL_PACK"));Kt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Kt.getBool("WEBGL_PACK"));Kt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Kt.getBool("WEBGL_PACK"));Kt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Kt.getBool("WEBGL_PACK"));Kt.registerFlag("WEBGL_PACK_REDUCE",()=>Kt.getBool("WEBGL_PACK"));Kt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Kt.getBool("WEBGL_PACK"));Kt.registerFlag("WEBGL_CONV_IM2COL",()=>Kt.getBool("WEBGL_PACK"));Kt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Kt.getBool("WEBGL_PACK"));Kt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>k0e(Kt.getNumber("WEBGL_VERSION")));Kt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>R0e(Kt.getNumber("WEBGL_VERSION")));Kt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Kt.getNumber("WEBGL_VERSION");return n===0?0:D0e(n)});Kt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Kt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!SU());Kt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>$0e(Kt.getNumber("WEBGL_VERSION")));Kt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Kt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Kt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Kt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>P0e(Kt.getNumber("WEBGL_VERSION")));Kt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>O0e(Kt.getNumber("WEBGL_VERSION")));Kt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Kt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Kt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Kt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>SU()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Kt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Kt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Kt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Kt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Kt.registerFlag("WEBGL_EXP_CONV",()=>!1);Kt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Kt.getBool("IS_TEST"));Kt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Kt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Kt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Kt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Io(){let n,e,t,r,s,i,o,a,l,u;return je().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",s="texture",i="outputColor",o="out vec4 outputColor;",a=je().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",s="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:s,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pm(n,e,t="index"){const r=nn(e);return r.map((s,i)=>{const o=`int ${n[i]} = ${t} / ${s}`,a=i===r.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${s}`:`index -= ${n[i]} * ${s}`;return`${o}; ${a};`}).join("")}function zE(n,e,t="index"){const r=nn(e);return r.map((s,i)=>{const o=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,a=i===r.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function F0e(n,e){const t=n.length,r=n.map(i=>`${e}[${i}]`),s=new Array(t-1);s[t-2]=r[t-1];for(let i=t-3;i>=0;--i)s[i]=`(${s[i+1]} * ${r[i+1]})`;return s}function z0e(n,e,t="index"){const r=n.map((i,o)=>o),s=F0e(r,e);return s.map((i,o)=>{const a=`int ${n[o]} = ${t} / ${s[o]}`,l=o===s.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${s[o]}`:`index -= ${n[o]} * ${s[o]}`;return`${a}; ${l};`}).join("")}function qR(n){const e=nn(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function KR(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const CH=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:IH}=Aae;function B0e(n,e,t){const r=[];if(n.forEach(p=>{const g=Qe(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?r.push(`uniform float ${p.name}${g>1?`[${g}]`:""};`):(r.push(`uniform sampler2D ${p.name};`),r.push(`uniform int offset${p.name};`)),t.enableShapeUniforms){const{uniformShape:w}=YR(t.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(w.length){case 1:r.push(`uniform int ${p.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${p.name}Shape;`);break}r.push(`uniform ivec2 ${p.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(p=>{r.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const s=r.join(`
`),i=n.map(p=>U0e(p,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=Io(),l=G0e(a);let u,c,h=X0e(a);return e.isPacked?(u=V0e(e.logicalShape,o,t.enableShapeUniforms),c=j0e(a)):(u=W0e(e.logicalShape,o,t.enableShapeUniforms),c=H0e(a)),t.packedInputs&&(h+=Z0e),[h,l,c,s,u,i,t.userCode].join(`
`)}function r0(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return uve(n,e);case 1:return hve(n,e);case 2:return fve(n,e);case 3:return mve(n,e);case 4:return yve(n,e);case 5:return vve(n);case 6:return xve(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function NH(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return lve(n);case 1:return cve(n,e);case 2:return dve(n,e);case 3:return pve(n,e);default:return gve(n,e)}}function U0e(n,e,t=!1,r){let s="";t?s+=NH(n,r):s+=r0(n,r);const i=n.shapeInfo.logicalShape,o=e.logicalShape;return i.length<=o.length&&(t?s+=wve(n,e):s+=bve(n,e)),s}function V0e(n,e,t){switch(n.length){case 0:return AH();case 1:return J0e(n,e,t);case 2:return ove(n,e,t);case 3:return eve(n,e,t);default:return nve(n,e,t)}}function W0e(n,e,t){switch(n.length){case 0:return AH();case 1:return Q0e(n,e,t);case 2:return ave(n,e,t);case 3:return tve(n,e,t);case 4:return rve(n,e,t);case 5:return sve(n,e);case 6:return ive(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function G0e(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function H0e(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function j0e(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function X0e(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${q0e}
    ${K0e}
    ${Y0e}
  `}const q0e=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,K0e=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Y0e=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Z0e=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function AH(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function J0e(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function Q0e(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function eve(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[2]/2),i=s*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function tve(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${zE(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const r=pm(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function nve(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],s=Math.ceil(n[n.length-1]/2),i=s*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let u=2;u<n.length-1;u++)o*=n[n.length-u-1],a=`
      int b${u} = index / ${o};
      index -= b${u} * ${o};
    `+a,l=`b${u}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${n.length}(${l});
    }
  `}function rve(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${zE(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const r=pm(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function sve(n,e){const t=pm(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function ive(n,e){const t=pm(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function ove(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(_r(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function ave(n,e,t){return _r(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function mm(n){return`offset${n}`}function lve(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=Io();return`
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function uve(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[s,i]=n.shapeInfo.texShape;if(s===1&&i===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=mm(t);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function cve(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=n.shapeInfo.texShape,i=Io();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function hve(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${s0(n)}
      }
    `;const s=n.shapeInfo.texShape,i=s[0],o=s[1];if(o===1&&i===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=mm(t);return o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function dve(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=Io();if(i!=null&&_r(t,i))return e?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=Math.ceil(t[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function fve(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape;if(i!=null&&_r(t,i)){if(e)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const d=i[0],p=i[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:o,keptDims:a}=Kd(t),l=o;if(l.length<t.length){const d=i0(n,l),p=["row","col"];return`
      ${r0(d,e)}
      float ${s}(int row, int col) {
        return ${s}(${o0(p,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${s0(n)}
      }
    `;const u=i[0],c=i[1],h=mm(r);return c===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?e?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function pve(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const d=t.slice(1),p=[1,2],g=i0(n,d),w=["b","row","col"];return`
        ${NH(g,e)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${o0(w,p)});
        }
      `}const a=Io();if(e)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const l=o[0],u=o[1],c=Math.ceil(t[2]/2),h=c*Math.ceil(t[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${h}, ${c}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function mve(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=Kd(t),u=a;if(u.length<t.length){const w=i0(n,u),y=["row","col","depth"];return`
        ${r0(w,e)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${o0(y,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${s0(n)}
      }
    `;const c=n.shapeInfo.texShape,h=c[0],d=c[1],p=n.shapeInfo.flatOffset;if(d===i&&p==null)return e?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===o&&p==null)return e?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `;const g=mm(r);return e?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${g};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${g};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function gve(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=Io();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=l[0],c=l[1],h=Math.ceil(i[o-1]/2);let d=h*Math.ceil(i[o-2]/2),p="int b, int row, int col",g=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let w=2;w<o-1;w++)p=`int b${w}, `+p,d*=i[o-w-1],g=`b${w} * ${d} + `+g;return`
    vec4 ${r}(${p}) {
      int index = ${g};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${s.texture2D}(${t}, uv);
    }
  `}function yve(n,e){const t=n.shapeInfo.logicalShape,r=n.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),i=t[3],o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:u}=Kd(t);if(l.length<t.length){const _=i0(n,l),T=["row","col","depth","depth2"];return`
      ${r0(_,e)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${o0(T,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${s0(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1],g=`int stride2 = ${r}Shape[3];`,w=`int stride1 = ${r}Shape[2] * stride2;`,y=`int stride0 = ${r}Shape[1] * stride1;`;if(p===a&&c==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${g}
        ${w}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(p===i&&c==null)return e?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;const x=mm(r);return e?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${g}
      ${w}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${x});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${x});
      return sampleTexture(${r}, uv);
    }
  `}function vve(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),s=e[4],i=e[3]*s,o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:u}=Kd(e);if(l.length<e.length){const w=i0(n,l),y=["row","col","depth","depth2","depth3"];return`
      ${r0(w)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${o0(y,u)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${s})) +
          depth3;
        ${s0(n)}
      }
    `;const c=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1];if(p===a&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=mm(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${s} + depth3 + ${g};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function xve(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:s,keptDims:i}=Kd(e);if(s.length<e.length){const y=i0(n,s),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${r0(y)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${o0(x,i)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,u=e[2]*l,c=e[1]*u;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${s0(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],g=d[1];if(g===c&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${g}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(g===o&&h==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${g}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const w=mm(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${w};
      vec2 uv = uvFromFlat(${p}, ${g}, index);
      return sampleTexture(${t}, uv);
    }
  `}function s0(n){const e=n.name,t=Qe(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function wve(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=IH(n.shapeInfo.logicalShape,e.logicalShape),l=Or(o),u=o-i;let c;const h=["x","y","z","w","u","v"];i===0?c="":o<2&&a.length>=1?c="coords = 0;":c=a.map(_=>`coords.${h[_+u]} = 0;`).join(`
`);let d="";o<2&&i>0?d="coords":d=n.shapeInfo.logicalShape.map((_,T)=>`coords.${h[T+u]}`).join(", ");let p="return outputValue;";const w=Qe(n.shapeInfo.logicalShape)===1,x=Qe(e.logicalShape)===1;if(i===1&&!w&&!x)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(w&&!x)o===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(a.length){const _=i-2,T=i-1;a.indexOf(_)>-1&&a.indexOf(T)>-1?p="return vec4(outputValue.x);":a.indexOf(_)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(T)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${d});
      ${p}
    }
  `}function bve(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),s="get"+r+"AtOutCoords",i=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&_r(o,i))return`
      float ${s}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const u=Or(l),c=IH(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let d;const p=["x","y","z","w","u","v"];a===0?d="":l<2&&c.length>=1?d="coords = 0;":d=c.map(w=>`coords.${p[w+h]} = 0;`).join(`
`);let g="";return l<2&&a>0?g="coords":g=n.shapeInfo.logicalShape.map((w,y)=>`coords.${p[y+h]}`).join(", "),`
    float ${s}() {
      ${u} coords = getOutputCoords();
      ${d}
      return get${r}(${g});
    }
  `}function Or(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function YR(n,e,t){const{newShape:r,keptDims:s}=Kd(e),i=e.length,o=n&&i===3&&e[0]===1,a=o?e.slice(1):r,l=!n&&i>1&&!_r(e,t)&&r.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:s}}function i0(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function o0(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sve(n,e,t,r){const s=t.map((c,h)=>{const d={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(d.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:d}}),i=s.map(c=>c.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=B0e(s,o,e),l=m0e(n.gl,a),u=n.createProgram(l);return je().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:i,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(u),Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:u,inShapeInfos:i,outShapeInfo:o},MH(n,e,u)))}function MH(n,e,t){const r=[],s=[];let i,o,a,l=null,u=null;u=n.getUniformLocation(t,"NAN",!1),je().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(t,"INFINITY",!1));const c=!1;for(const h of e.variableNames){const d={name:h,uniform:n.getUniformLocation(t,h,c),offset:n.getUniformLocation(t,`offset${h}`,c)};e.enableShapeUniforms&&(d.shape=n.getUniformLocation(t,`${h}Shape`,c),d.texShape=n.getUniformLocation(t,`${h}TexShape`,c)),r.push(d)}if(e.enableShapeUniforms&&(i=n.getUniformLocation(t,"outShape",c),a=n.getUniformLocation(t,"outShapeStrides",c),o=n.getUniformLocation(t,"outTexShape",c)),e.customUniforms)for(const h of e.customUniforms)s.push(n.getUniformLocation(t,h.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}}function FL(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{const s=t.logicalShape,i=e[r],o=i.shape;if(!_r(s,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${o} must match`);if(t.isUniform&&i.isUniform)return;const a=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!_r(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function _ve(n,e,t,r,s){e.program.enableShapeUniforms||(FL(e.inShapeInfos,t),FL([e.outShapeInfo],[r]));const i=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(i.texture,o[0],o[1]):n.setOutputMatrixTexture(i.texture,o[0],o[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),je().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const u=t[l],{uniform:c,offset:h,shape:d,texShape:p}=e.variablesLocations[l];if(d){const{uniformShape:g}=YR(e.program.packedInputs,u.shape,u.texData.texShape);switch(g.length){case 1:n.gl.uniform1iv(d,new Int32Array(g));break;case 2:n.gl.uniform2iv(d,new Int32Array(g));break;case 3:n.gl.uniform3iv(d,new Int32Array(g));break;case 4:n.gl.uniform4iv(d,new Int32Array(g));break}}if(p&&n.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(Qe(u.shape)<2)n.gl.uniform1f(c,u.uniformValues[0]);else{let g=u.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),n.gl.uniform1fv(c,g)}continue}u.texData.slice!=null&&h!=null&&n.gl.uniform1i(h,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=nn(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&s)for(let l=0;l<e.program.customUniforms.length;++l){const u=e.program.customUniforms[l],c=e.customUniformLocations[l],h=s[l];if(u.type==="float")n.gl.uniform1fv(c,h);else if(u.type==="vec2")n.gl.uniform2fv(c,h);else if(u.type==="vec3")n.gl.uniform3fv(c,h);else if(u.type==="vec4")n.gl.uniform4fv(c,h);else if(u.type==="int")n.gl.uniform1iv(c,h);else if(u.type==="ivec2")n.gl.uniform2iv(c,h);else if(u.type==="ivec3")n.gl.uniform3iv(c,h);else if(u.type==="ivec4")n.gl.uniform4iv(c,h);else throw Error(`uniform type ${u.type} is not supported yet.`)}n.executeProgram()}function Tve(n,e,t){let r="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:h}=YR(n.packedInputs,o.shape,l);let d="",p="",g="";if(c.length===1&&n.packedInputs){const N=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${N[0]>1}_${N[1]>1}`}else if(c.length===2&&!n.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!n.packedInputs){const N=nn(c);g=`${N[0]===l[1]}_${N[N.length-1]===l[1]}`}const w=o.shape.length,y=c.length===2&&_r(o.shape,l),x=Qe(o.shape)===1,_=Ty(o.shape,t.shape),T=!n.packedInputs&&w===t.shape.length&&_r(l,t.texData.texShape),E=n.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${w}_${T}_${u?h:""}_${c.length}_${x}_${_}_${y}_${d}_${p}_${g}_${E}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;r+=`${o.shape}_${l}_${a}`}});const s=n.userCode;let i=n.constructor.name;return i+="_"+r+"_"+s+`${je().getNumber("WEBGL_VERSION")}`,i}function Qi(n){return je().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eve{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ix.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Io();this.outputShape=e,this.enableShapeUniforms=Qi(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?zE(["r","c","d"],e):pm(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cve{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ix.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Io();this.outputShape=e,this.enableShapeUniforms=Qi(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?zE(["r","c","d"],e):pm(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ive{constructor(e){this.variableNames=["A"],this.outTexUsage=Ga.DOWNLOAD;const t=Io();this.outputShape=e,this.userCode=`
      ${CH}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nve{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Ga.DOWNLOAD;const t=Io();this.outputShape=e,this.userCode=`
      ${CH}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ave={R:0,G:1,B:2,A:3};class zL{constructor(e,t=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Io();this.outputShape=e,this.enableShapeUniforms=Qi(this.outputShape.length);let i="result";t&&(i="floor(result * 255. + 0.5)");let o="";for(let a=0;a<r.length;a++){const l=r[a];o+=`
          if(offset == ${a}) {
            result = values[${Ave[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?KR():qR(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${o}
        }
        ${s.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mve{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Io();this.outputShape=e,this.enableShapeUniforms=Qi(this.outputShape.length);let s="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;s+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?KR():qR(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kve(n){const e=Io(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return p0e(n,t)}function Rve(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return x0e(n,e)}function Dve(n){const e=new Uint16Array([0,1,2,2,1,3]);return w0e(n,e)}function mw(n,e,t,r,s,i){S0e(e,t);const o=b0e(n),a=n.TEXTURE_2D;return Lt(n,()=>n.bindTexture(a,o)),Lt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Lt(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Lt(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),Lt(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),je().getNumber("WEBGL_VERSION")===1?Lt(n,()=>n.texImage2D(a,0,r,e,t,0,s,i,null)):Lt(n,()=>n.texStorage2D(a,1,r,e,t)),Lt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[t,e]}}function kH(n){return n.internalFormatFloat}function $ve(n,e,t,r){const[s,i]=fw(e,t);return mw(n,s,i,kH(r),r.textureFormatFloat,n.FLOAT)}function RH(n){return n.internalFormatHalfFloat}function Pve(n,e,t,r){const[s,i]=fw(e,t);return mw(n,s,i,RH(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function DH(n){return n.downloadTextureFormat}function Lve(n,e,t,r){const[s,i]=fw(e,t);return mw(n,s,i,DH(r),n.RGBA,n.UNSIGNED_BYTE)}function $H(n){return n.internalFormatPackedFloat}function Ove(n,e,t,r){const[s,i]=n0(e,t);return mw(n,s,i,$H(r),n.RGBA,n.FLOAT)}function PH(n){return n.internalFormatPackedHalfFloat}function Fve(n,e,t,r){const[s,i]=n0(e,t);return mw(n,s,i,PH(r),n.RGBA,r.textureTypeHalfFloat)}function zve(n,e,t){return Lt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),PL(n,e,"clipSpacePos",t,3,20,0)&&PL(n,e,"uv",t,2,20,12)}function Bve(n,e,t,r,s,i){Lt(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;s instanceof Uint8Array?(o=new Uint8Array(t*r*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*r*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(s),je().getNumber("WEBGL_VERSION")===2?Lt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,r,n.RGBA,a,o)):Lt(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,r,0,n.RGBA,a,o)),Lt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Uve(n,e,t){Lt(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?je().getNumber("WEBGL_VERSION")===2?Lt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Lt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):je().getNumber("WEBGL_VERSION")===2?Lt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Lt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Lt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Vve(n,e,t,r){const s=n.createBuffer();Lt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,s));const a=4*4*e*t;return Lt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),Lt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Lt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),s}function Wve(n,e,t){const r=n,s=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function Gve(n,e,t,r){const[s,i]=fw(e,t),o=4,a=new Uint8Array(a0e(e*t,o));return Lt(n,()=>n.readPixels(0,0,s,i,r.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function Hve(n,e,t,r,s,i,o,a){const l=n,u=new Float32Array(l0e(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function jve(n,e,t){const r=new Float32Array(e*t*4);return Lt(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q2{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=je().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,s0e(t,e)):this.gl=vu(t),e=this.gl,je().getNumber("WEBGL_VERSION")===2){const i=e;this.createVertexArray=()=>Lt(i,()=>i.createVertexArray()),this.bindVertexArray=o=>Lt(i,()=>i.bindVertexArray(o)),this.deleteVertexArray=o=>Lt(i,()=>i.deleteVertexArray(o)),this.getVertexArray=()=>Lt(i,()=>i.getParameter(i.VERTEX_ARRAY_BINDING))}else if(e!=null){const i=e.getExtension("OES_vertex_array_object");if(i==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Lt(e,()=>i.createVertexArrayOES()),this.bindVertexArray=o=>Lt(e,()=>i.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Lt(e,()=>i.deleteVertexArrayOES(o)),this.getVertexArray=()=>Lt(e,()=>e.getParameter(i.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),je().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=gS(this.gl,i),vl(this.gl,o))this.textureHalfFloatExtension=gS(this.gl,o);else if(je().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),vl(this.gl,s))this.colorBufferHalfFloatExtension=gS(this.gl,s);else if(je().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",vl(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(vl(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Rve(this.gl),this.indexBuffer=Dve(this.gl),this.framebuffer=_0e(this.gl),this.textureConfig=XR(this.gl,this.textureHalfFloatExtension)}get debug(){return je().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Lt(e,()=>e.finish()),Lt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Lt(e,()=>e.deleteFramebuffer(this.framebuffer)),Lt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Lt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Lt(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),$ve(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Pve(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Lve(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Uve(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,s){this.throwIfDisposed(),Bve(this.gl,e,t,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Fve(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Ove(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(LL(this.gl,this.framebuffer),this.outputTexture=null),Lt(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>Gve(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,s,i,o){return Hve(this.gl,e,t,r,s,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Wve(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);const s=Vve(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(je().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,i=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const o=s.clientWaitSync(i,0,0);return o===s.ALREADY_SIGNALED||o===s.CONDITION_SATISFIED},t=i}else je().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,je().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>jve(this.gl,t,r))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=kve(t));const r=y0e(t);Lt(t,()=>t.attachShader(r,this.vertexShader)),Lt(t,()=>t.attachShader(r,e)),v0e(t,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&K2(t,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Lt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),zve(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Lt(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&K2(this.gl,this.program),Lt(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?E0e(this.gl,e,t):C0e(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Lt(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),I0e(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();const[s,i]=n0(t,r);this.setOutputMatrixTextureDriver(e,s,i)}setOutputMatrixWriteRegion(e,t,r,s){this.setOutputMatrixWriteRegionDriver(r,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&K2(this.gl,this.program),yS(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Lt(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Lt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=gS(this.gl,je().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(je().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(je().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await wP(()=>this.disposed||this.isQueryAvailable(e,je().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,je().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),i=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=Xve(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in je().platform&&(r=je().platform.setTimeoutCustom.bind(je().platform)),wP(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Y2(this.gl,e,this.framebuffer),this.debug&&yS(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Y2(this.gl,this.outputTexture,this.framebuffer),this.debug&&yS(this.gl)):LL(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();const s=this.gl;Y2(s,e,this.framebuffer),this.debug&&yS(s),this.outputTexture=e,Lt(s,()=>s.viewport(0,0,t,r)),Lt(s,()=>s.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,s){this.throwIfDisposed(),Lt(this.gl,()=>this.gl.scissor(e,t,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function Xve(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:qve,bincountImpl:LH,bincountReduceImpl:Kve,bitwiseAndImpl:Yve,castImpl:Zve,ceilImpl:Jve,concatImpl:Qve,equalImpl:exe,expImpl:txe,expm1Impl:nxe,floorImpl:rxe,gatherNdImpl:sxe,gatherV2Impl:ixe,greaterImpl:oxe,greaterEqualImpl:axe,lessImpl:lxe,lessEqualImpl:uxe,linSpaceImpl:cxe,logImpl:hxe,maxImpl:dxe,maximumImpl:fxe,minimumImpl:pxe,multiplyImpl:mxe,negImpl:gxe,notEqualImpl:yxe,prodImpl:vxe,raggedGatherImpl:xxe,raggedRangeImpl:wxe,raggedTensorToTensorImpl:bxe,rangeImpl:Sxe,rsqrtImpl:_xe,scatterImpl:Txe,sigmoidImpl:Exe,simpleAbsImpl:OH,sliceImpl:Cxe,sparseFillEmptyRowsImpl:Ixe,sparseReshapeImpl:Nxe,sparseSegmentReductionImpl:FH,sqrtImpl:Axe,staticRegexReplaceImpl:Mxe,stridedSliceImpl:kxe,stringNGramsImpl:Rxe,stringSplitImpl:Dxe,stringToHashBucketFastImpl:$xe,subImpl:Pxe,tileImpl:Lxe,topKImpl:Oxe,transposeImpl:ZR,uniqueImpl:Fxe}=Ude;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zH(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function yo(n,e){return e===1?[n]:zH(n,e)}function zxe(n,e){if(n===1)return"rc";let t="";for(let r=0;r<n;r++)t+=e[r],r<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bxe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Qi(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=yo("rc",this.rank),r=Or(this.rank),s=this.getOutOfBoundsCondition(t),i=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let i=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${e[e.length-1-o]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BH{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Qi(this.outputShape.length);let r="";for(let s=0;s<4;s++){let i="thisRC = rc;";s%2===1&&(i+="thisRC.z += 1;"),s>1&&(i+="thisRC.y += 1;"),r+=`
        ${i}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${Uxe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?KR():qR(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function Uxe(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?z0e(["r","c","d"],"inputShape"):pm(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vxe{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,r){const s=UL(t,r),i=VL(e,s,r);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=BL(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].pop();return this.usedTextures[i].push(l),l}let a;return s===ki.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===ki.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===ki.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===ki.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===ki.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,r,s){if(this.freeTextures==null)return;const i=UL(r,s),o=VL(t,i,s);o in this.freeTextures||(this.freeTextures[o]=[]);const a=BL(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=je().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const u=this.usedTextures[o],c=u&&u.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Wxe(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function BL(n,e,t,r,s){const i=Gxe(e,r);let o;if(s){const[l,u]=n0(n[0],n[1]);o=l*u}else{const[l,u]=fw(n[0],n[1]);o=l*u}const a=Wxe(t,i);return o*a}function Gxe(n,e){switch(n){case ki.PACKED_2X2_FLOAT32:return $H(e);case ki.PACKED_2X2_FLOAT16:return PH(e);case ki.UNPACKED_FLOAT32:return kH(e);case ki.UNPACKED_FLOAT16:return RH(e);case ki.PACKED_4X1_UNSIGNED_BYTE:return DH(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function Hxe(n){return je().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?ki.PACKED_2X2_FLOAT32:ki.UNPACKED_FLOAT32:n?ki.PACKED_2X2_FLOAT16:ki.UNPACKED_FLOAT16}function UL(n,e){if(n===Ga.UPLOAD)return ki.PACKED_2X2_FLOAT32;if(n===Ga.RENDER||n==null)return Hxe(e);if(n===Ga.DOWNLOAD||n===Ga.PIXELS)return ki.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function VL(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wu{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Qi(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Il="if (isnan(x)) return x;",jxe="return x;",WL="return abs(x);",Xxe="return (x >= 0.0) ? x : (exp(x) - 1.0);",qxe=Il+`
  return (x < 0.0) ? 0.0 : x;
`,Kxe=Il+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,fd="return x;",Yxe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zxe="return x;",Jxe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Qxe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,e1e=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,t1e="return 1.0 / (1.0 + exp(-1.0 * x));";class vd{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Qi(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n1e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Qi(this.outputShape.length);const t=e.length,r=yo("rc",t),s=Or(t),i=zxe(t,r),o=r.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r1e=c4,s1e=1e-7,i1e=1e-4,wS={};function o1e(n){return n in wS||(wS[n]={}),wS[n]}const a1e=je().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),l1e=600;function u1e(){return je().global.screen==null?1024:je().global.screen.height*je().global.screen.width*window.devicePixelRatio*l1e/1024/1024}class BE extends yM{nextDataId(){return BE.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!je().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Q2)t=e;else{const r=vu(je().getNumber("WEBGL_VERSION"),e);t=new Q2(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=vu(je().getNumber("WEBGL_VERSION"));t=new Q2(r),this.binaryCache=o1e(je().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Vxe(this.gpgpu),this.numMBBeforeWarning=u1e(),this.texData=new $B(this,Ou())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,r,s,i,o){const a=this.makeTensorInfo(t,r),l=this.texData.get(a.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[s,i]},l.texShape=[s,i];const u=vS(t),c=new zL(u,!1,o),h=this.runWebGLProgram(c,[a],r,[[s,i]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,t,r){if((je().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||je().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:r,values:e,usage:Ga.UPLOAD,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,r,s,i){if(je().getBool("DEBUG")&&this.checkNumericalProblems(t),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:s,values:t,usage:Ga.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:r,dtype:s,complexTensorInfos:i,slice:o,shape:a,isPacked:l}=t;if(o!=null){let d;l?d=new vd(a,fd):d=new Wu(a,fd);const p=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:s}],s),g=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),g}if(r!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return r;const u=this.activeTimers!=null;let c;u&&(c=Bo());let h;if(s==="complex64"){const d=this.readSync(i.real.dataId),p=this.readSync(i.imag.dataId);h=ch(d,p)}else h=this.getValuesFromTexture(e);return u&&(this.downloadWaitMs+=Bo()-c),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const g=this.pendingRead.get(e);return new Promise(w=>g.push(w))}const t=this.texData.get(e),{values:r,shape:s,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(i!=null){let g;l?g=new vd(s,fd):g=new Wu(s,fd);const w=this.runWebGLProgram(g,[{dataId:e,shape:s,dtype:o}],o),y=this.read(w.dataId);return this.disposeIntermediateTensorInfo(w),y}if(r!=null)return this.convertAndCacheOnCPU(e);if(je().getBool("DEBUG")&&!je().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&je().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(o!=="complex64"&&je().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const g=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(g.texture.texture,...mS(s))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const g=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),w=g[0],y=g[1];h=ch(w,y)}else if(u==null)h=this.getValuesFromTexture(e);else{const g=Qe(s);h=this.gpgpu.downloadFloat32MatrixFromBuffer(u,g)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const g=this.gpgpu.gl;Lt(g,()=>g.deleteBuffer(u))}const d=this.convertAndCacheOnCPU(e,h),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(g=>g(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ou().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const r=this.texData.get(e),{values:s,shape:i,slice:o,dtype:a,isPacked:l,texture:u}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let p;l?p=new vd(i,fd):p=new Wu(i,fd);const g=this.runWebGLProgram(p,[{dataId:e,shape:i,dtype:a}],a),w=this.readToGPU(g,t);return this.disposeIntermediateTensorInfo(g),w}if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,t.customTexShape),h=Ou().makeTensorFromTensorInfo(c),d=this.texData.get(c.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>Rd(s));return Xn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Xn(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const r=e[t];if(!d0e(r))throw je().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:r,isPacked:s}=this.texData.get(e),i=Qe(t);if(je().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),p=this.texData.get(d.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...mS(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(d),g}const o=je().getBool("WEBGL_PACK")&&s===!0,a=o?vS(t):t,l=o?new Nve(a):new Ive(a),u=this.runWebGLProgram(l,[{shape:a,dtype:r,dataId:e}],"float32"),c=this.texData.get(u.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(u),h}timerAvailable(){return je().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const i=Bp(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=Bp(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(je().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);a.kernelMs=jee(l),a.getExtraProfileInfo=()=>l.map((u,c)=>({name:o[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return je().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Bo(),endMs:null}}endTimer(e){return je().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Bo(),e)}async getQueryTime(e){if(je().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:r,texShape:s,usage:i,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(t,s,i,o)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=a1e){return je().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&Qe(r.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Wa("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return r1e(e.shape,t)}packedUnaryOp(e,t,r){const s=new vd(e.shape,t),i=this.compileAndRun(s,[e],r);return Ou().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const s=OH(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(je().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,WL,e.dtype);const t=new Wu(e.shape,WL),r=this.compileAndRun(t,[e]);return Ou().makeTensorFromTensorInfo(r)}makeTensorInfo(e,t,r){let s;if(t==="string"&&r!=null&&r.length>0&&t1(r[0])){const i=r.map(o=>_d(o));s=this.write(i,e,t)}else s=this.write(r,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,r){return Ou().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,r),this)}unpackTensor(e){const t=new n1e(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new Bxe(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const r=[ky(e.shape),...Ry(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},i=[ky(t),...Ry(t)],o=new BH(i,r),a=!0,l=[r],u=this.runWebGLProgram(o,[s],e.dtype,l,a);return{dataId:u.dataId,shape:t,dtype:u.dtype}}decode(e,t){const r=this.texData.get(e),{isPacked:s,shape:i,dtype:o}=r;if(t!=null){const d=Qe(i),p=t[0]*t[1]*4;ie(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=vS(i);let l;s?l=new Cve(a):l=new Eve(a);const u=!0,c=[t??mS(a)],h=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,c,u,t);return{dtype:o,shape:i,dataId:h.dataId}}runWebGLProgram(e,t,r,s,i=!1,o){const a=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Ix.DENSE){const x=o??mS(e.outputShape);l.texShape=x.map(_=>_*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Qe(a.shape)===0)return l.values=Yi(a.dtype,0),a;const u=[],c=t.map(x=>{if(x.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let _=this.texData.get(x.dataId);if(_.texture==null){if(!e.packedInputs&&Qe(x.shape)<=je().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:x.shape,texData:null,isUniform:!0,uniformValues:_.values};e.packedInputs&&(_.isPacked=!0,_.shape=x.shape)}if(this.uploadToGPU(x.dataId),!!_.isPacked!=!!e.packedInputs)x=_.isPacked?this.unpackTensor(x):this.packTensor(x),u.push(x),_=this.texData.get(x.dataId);else if(_.isPacked&&!T_(_.shape,x.shape)){const T=x,E=x.shape;x.shape=_.shape,x=this.packedReshape(x,E),u.push(x),_=this.texData.get(x.dataId),T.shape=E}return{shape:x.shape,texData:_,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:l,isUniform:!1},d=Tve(e,c,h),p=this.getAndSaveBinary(d,()=>Sve(this.gpgpu,e,c,h)),g=this.activeTimers!=null;let w;g&&(w=this.startTimer()),je().get("ENGINE_COMPILE_ONLY")||_ve(this.gpgpu,p,c,h,s),u.forEach(x=>this.disposeIntermediateTensorInfo(x)),g&&(w=this.endTimer(w),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(w)}));const y=je().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const x=Bo();x-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=x)}if(!je().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&i===!1){const x=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),x}return a}compileAndRun(e,t,r,s,i=!1){return r=r||t[0].dtype,this.runWebGLProgram(e,t,r,s,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(je().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ze(()=>{if(!je().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=je().getBool("DEBUG");je().set("DEBUG",!1);const t=this.abs(Sr(1e-8)).dataSync()[0];if(je().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?s1e:i1e}uploadToGPU(e){const t=this.texData.get(e),{shape:r,dtype:s,values:i,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const u=this.activeTimers!=null;let c;u&&(c=Bo());let h=t.texShape;if(h==null&&(h=M0e(r,l),t.texShape=h),i!=null){const d=vS(r);let p,g=h[1],w=h[0];const y=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!y)&&([g,w]=n0(h[0],h[1])),l?p=new Mve(d,y):p=new zL(d,y);const x=y?[w,g]:h,_=this.makeTensorInfo(x,s),T=this.texData.get(_.dataId);y?T.usage=Ga.PIXELS:T.usage=Ga.UPLOAD,T.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(_.dataId),g,w,i);const E=[[w,g]],M=this.runWebGLProgram(p,[_],s,E,!0),$=this.texData.get(M.dataId);t.texShape=$.texShape,t.isPacked=$.isPacked,t.usage=$.usage,je().get("ENGINE_COMPILE_ONLY")?this.disposeData(M.dataId):(t.texture=$.texture,t.values=null,this.texData.delete(M.dataId)),this.disposeIntermediateTensorInfo(_),u&&(this.uploadWaitMs+=Bo()-c)}else{const d=this.acquireTexture(h,a,s,l);t.texture=d}}convertAndCacheOnCPU(e,t){const r=this.texData.get(e),{dtype:s}=r;return t!=null&&(r.values=c1e(t,s)),r.values}acquireTexture(e,t,r,s){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,s)}computeBytes(e,t){return e[0]*e[1]*e_(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(t),s(!0)}catch(i){throw i}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await I4(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(EH(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:r,infLoc:s,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:l}=MH(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=r,e.infLoc=s,e.nanLoc=i,e.outShapeLocation=o,e.outShapeStridesLocation=a,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,r){e.channels=e.channels||"RGBA";const{texture:s,height:i,width:o,channels:a}=e,l=Ou().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(s,t,r,i,o,a);return Ou().makeTensorFromDataId(u,t,r,l)}}BE.nextDataId=0;function c1e(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<t.length;++r)t[r]=Math.round(n[r]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_U()&&NU("webgl",()=>new BE,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JR=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Zp{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=$n(t,r),this.enableShapeUniforms=Qi(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gm=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class a0{constructor(e,t,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=$n(t,r);const i=this.outputShape.length;this.enableShapeUniforms=Qi(i);let o="";if(s)if(i===0||Qe(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Or(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=yo("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ea(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const h1e={kernelName:S1,backendName:"webgl",kernelFunc:Ea};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sf(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,i=t.makeTensorInfo(r.shape,"complex64"),o=t.texData.get(i.dataId),a=Ea({inputs:{x:r},backend:t}),l=Ea({inputs:{x:s},backend:t});return o.complexTensorInfos={real:a,imag:l},i}const d1e={kernelName:MM,backendName:"webgl",kernelFunc:sf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UH="return (a < 0.) ? b * a : a;",VH=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function f1e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:i}=r,o=t.makeTensorInfo([],"float32",Yd(i,"float32")),a=je().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new a0(VH,s.shape,o.shape):new Zp(UH,s.shape,o.shape),l=t.runWebGLProgram(a,[s,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const p1e={kernelName:$T,backendName:"webgl",kernelFunc:f1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WH="return (a < 0.) ? b * a : a;",GH=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function m1e(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,i=je().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new a0(GH,r.shape,s.shape):new Zp(WH,r.shape,s.shape);return t.runWebGLProgram(i,[r,s],"float32")}const g1e={kernelName:QT,backendName:"webgl",kernelFunc:m1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l0="if (isnan(x)) return x;";function lr({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:s,backend:i})=>{const{x:o}=s,a=i,l=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const h=a.texData.get(o.dataId),d=t(h.values,l);return a.makeTensorInfo(o.shape,l,d)}const u=je().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return u?c=new vd(o.shape,e):c=new Wu(o.shape,n),a.runWebGLProgram(c,[o],l)}}function Oi({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:u}=o,c=a;if(r&&l.dtype==="complex64"){const g=c.texData.get(l.dataId),w=c.texData.get(u.dataId),[y,x]=[[g.complexTensorInfos.real,w.complexTensorInfos.real],[g.complexTensorInfos.imag,w.complexTensorInfos.imag]].map(T=>{const[E,N]=T,M={dataId:E.dataId,dtype:E.dtype,shape:l.shape},$={dataId:N.dataId,dtype:N.dtype,shape:u.shape},L=new Zp(n,l.shape,u.shape);return c.runWebGLProgram(L,[M,$],_a(E.dtype,N.dtype))}),_=sf({inputs:{real:y,imag:x},backend:c});return c.disposeIntermediateTensorInfo(y),c.disposeIntermediateTensorInfo(x),_}const h=i||_a(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&s!=null){const g=c.texData.get(l.dataId).values,w=c.texData.get(u.dataId).values,y=l.dtype==="string"?hh(g):g,x=l.dtype==="string"?hh(w):w,[_,T]=s(l.shape,u.shape,y,x,h),E=c.makeTensorInfo(T,h),N=c.texData.get(E.dataId);return N.values=_,E}const d=je().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return d?p=new a0(e,l.shape,u.shape,t):p=new Zp(n,l.shape,u.shape),c.runWebGLProgram(p,[l,u],h)}}function Nx(n,e=!1){if(n==="linear")return e?Zxe:jxe;if(n==="relu")return e?Qxe:qxe;if(n==="elu")return e?Jxe:Xxe;if(n==="relu6")return e?e1e:Kxe;if(n==="prelu")return e?GH:WH;if(n==="leakyrelu")return e?VH:UH;if(n==="sigmoid")return e?t1e:Yxe;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HH{constructor(e,t,r,s=!1,i=!1,o=!1,a=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Qi(this.outputShape.length);const c=s?e[1]:e[2],h=Math.ceil(c/2),d=s?"i * 2, rc.y":"rc.y, i * 2",p=i?"rc.z, i * 2":"i * 2, rc.z",g=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],w=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",x="";a&&(l?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:u?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:y=`vec4 activation(vec4 x) {
          ${a}
        }`,x="result = activation(result);");const _=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let T="rc.x",E="rc.x";e[0]<t[0]?T=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(E=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${T};
        int batchB = ${E};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${g[0]} * ${w[0]});
          result += (${g[1]} * ${w[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${_}

        ${x}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GL={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class HL{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=$n(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jL="return a * b;";function QR(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,i=_a(r.dtype,s.dtype);if(r.dtype==="complex64"){const a=t.texData.get(r.dataId),l=t.texData.get(s.dataId),u=new HL(GL.REAL,r.shape,s.shape),c=new HL(GL.IMAG,r.shape,s.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],d=t.runWebGLProgram(u,h,"float32"),p=t.runWebGLProgram(c,h,"float32"),g=sf({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),g}if(t.shouldExecuteOnCPU([r,s])){const a=t.texData.get(r.dataId),l=t.texData.get(s.dataId),[u,c]=mxe(r.shape,s.shape,a.values,l.values,i),h=t.makeTensorInfo(c,i),d=t.texData.get(h.dataId);return d.values=u,h}let o;return je().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new a0(jL,r.shape,s.shape):o=new Zp(jL,r.shape,s.shape),t.runWebGLProgram(o,[r,s],i)}const y1e={kernelName:k1,backendName:"webgl",kernelFunc:QR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v1e(n,e,t){const r=[ky(n.shape),...Ry(n.shape)],s={dtype:n.dtype,shape:r,dataId:n.dataId},i=[ky(e),...Ry(e)],o=new BH(i,r),a=!0,l=[r],u=t.runWebGLProgram(o,[s],n.dtype,l,a);return{dataId:u.dataId,shape:e,dtype:u.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function At(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{shape:i}=r,o=t,a=Qe(s.shape),l=LB(i,a),u=Qe(l);ie(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=o.texData.get(s.dataId);return c.isPacked&&!T_(s.shape,l)&&!(c.texture!==null&&T_(c.shape,l))?v1e(s,l,o):(o.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const x1e={kernelName:tE,backendName:"webgl",kernelFunc:At};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XL{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=e;this.outputShape=[s,o];const a=Math.floor(r/4)*4,l=r%4;let u="sumValue += dot(values, ones);";if(t!=null){const h=1/t;u=`sumValue += dot(values * ${Sy(h)?h.toPrecision(2):h}, ones);`}let c="";i%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w1e{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:i,outSize:o}=e;this.outputShape=[s,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");const c=Math.floor(r/4)*4,h=r%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let g="";i%r>0&&(g=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${g}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b1e(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],r=TE(t);e.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return e}function ym(n,e,t,r){const s=b1e(n.shape);let i=n;for(let o=0;o<s.length;o++){const{inSize:a,windowSize:l,outSize:u}=s[o];let c,h;t==="mean"?c=o===0?new XL({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},a):new XL({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u}):c=new w1e({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:u},t),h=i,i=r.runWebGLProgram(c,[i],e),h.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(h)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S1e{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[t[o]];this.outputShape=r,this.rank=r.length;const s=Or(this.rank),i=_1e(t);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function _1e(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let s=0;s<n.length;s++)r[n[s]]=t[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class T1e{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let c=0;c<r.length;c++)r[c]=e[t[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Or(this.rank),i=zH("rc",this.rank),o=new Array(this.rank);for(let c=0;c<t.length;c++)o[t[c]]=i[c];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UE(n,e,t){const r=je().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new T1e(n.shape,e):new S1e(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E1e(n,e,t,r){const s=e,i=n.shape.length,o=qn(s,n.shape);let a=o;const l=ps(a,i),u=l!=null;let c=n;u&&(c=UE(n,l,r),a=Ms(a.length,i)),Li("sum",a,i);const[h,d]=_i(c.shape,a);let p=h;t&&(p=Vs(h,o));const g=Qe(d),y=Qe(n.shape)/g,x=At({inputs:{x:c},attrs:{shape:[y,g]},backend:r}),_=ck(n.dtype),T=ym(x,_,"sum",r),E=At({inputs:{x:T},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(T),u&&r.disposeIntermediateTensorInfo(c),E}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r;return E1e(s,i,o,t)}const C1e={kernelName:aE,backendName:"webgl",kernelFunc:VE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Co(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:i}=r,o=t,a=s.shape.length,l=new Array(a);for(let c=0;c<l.length;c++)l[c]=s.shape[i[c]];let u;if(o.shouldExecuteOnCPU([s])){const h=o.texData.get(s.dataId).values,d=ZR(h,s.shape,s.dtype,i,l);u=o.makeTensorInfo(l,s.dtype);const p=o.texData.get(u.dataId);p.values=d}else u=UE(s,i,o);return u}const I1e={kernelName:ly,backendName:"webgl",kernelFunc:Co};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jH=1e3;function E_({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const u=n.shape.length,c=e.shape.length,h=t?n.shape[u-2]:n.shape[u-1],d=r?e.shape[c-1]:e.shape[c-2],p=t?n.shape[u-1]:n.shape[u-2],g=r?e.shape[c-2]:e.shape[c-1],w=n.shape.slice(0,-2),y=e.shape.slice(0,-2),x=Qe(w),_=Qe(y),E=$n(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,g]);ie(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const N=t?[x,h,p]:[x,p,h],M=r?[_,g,d]:[_,d,g],$=At({inputs:{x:n},backend:s,attrs:{shape:N}}),L=At({inputs:{x:e},backend:s,attrs:{shape:M}}),k=[$,L],R=Math.max(x,_),P=t?$.shape[1]:$.shape[2],B=i!=null,Z=o!=null,V=l==="leakyrelu",X=l!=null?Nx(l,!0):null,q=B||Z||V||X!=null;let se;if((p===1||g===1)&&P>jH&&q===!1){let J=$,K=L;t&&(J=Co({inputs:{x:$},backend:s,attrs:{perm:[0,2,1]}}),k.push(J)),r&&(K=Co({inputs:{x:L},backend:s,attrs:{perm:[0,2,1]}}),k.push(K));const G=g!==1,Q=g===1;let ne=J;G&&(ne=At({inputs:{x:J},backend:s,attrs:{shape:[R,P,1]}}),k.push(ne));const ce=g===1?2:1;let ye=K;Q&&(ye=At({inputs:{x:K},backend:s,attrs:{shape:[R,1,P]}}),k.push(ye));const Se=QR({inputs:{a:ne,b:ye},backend:s});se=VE({inputs:{x:Se},backend:s,attrs:{axis:ce,keepDims:!0}}),k.push(Se)}else{const J=_a(n.dtype,e.dtype),K=new HH(N,M,[R,p,g],t,r,B,X,Z,V),G=[$,L];if(i!=null&&G.push(i),Z&&G.push(o),V){const Q=s.makeTensorInfo([],"float32",Yd(a,"float32"));G.push(Q),k.push(Q)}se=s.runWebGLProgram(K,G,J)}const W=At({inputs:{x:se},backend:s,attrs:{shape:E}});k.push(se);for(const J of k)s.disposeIntermediateTensorInfo(J);return W}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N1e(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=r;return E_({a:s,b:i,transposeA:l,transposeB:u,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}const A1e={kernelName:t_,backendName:"webgl",kernelFunc:N1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qL="return abs(x);";function M1e(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const i=t.texData.get(r.dataId),o=OH(i.values);return t.makeTensorInfo(r.shape,r.dtype,o)}let s;return je().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new vd(r.shape,qL):s=new Wu(r.shape,qL),t.runWebGLProgram(s,[r],r.dtype)}const k1e={kernelName:pT,backendName:"webgl",kernelFunc:M1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R1e=Il+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,D1e=lr({opSnippet:R1e}),$1e={kernelName:n1,backendName:"webgl",kernelFunc:D1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P1e=Il+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,L1e=lr({opSnippet:P1e}),O1e={kernelName:r1,backendName:"webgl",kernelFunc:L1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KL="return a + b;",F1e=Oi({opSnippet:KL,packedOpSnippet:KL,supportsComplex:!0,cpuKernelImpl:qve}),z1e={kernelName:qy,backendName:"webgl",kernelFunc:F1e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B1e{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`float v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class U1e{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const r=[];this.variableNames.forEach(i=>{r.push(`vec4 v${i} = get${i}AtOutCoords();`)});const s=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function US(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return Ea({inputs:{x:r[0]},backend:t});if(r.length>je().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),u=US({inputs:r.slice(0,l),backend:t}),c=US({inputs:r.slice(l),backend:t});return US({inputs:[u,c],backend:t})}const s=r.map(l=>l.dtype).reduce((l,u)=>_a(l,u)),i=r.map(l=>l.shape),a=je().getBool("WEBGL_PACK")?new U1e(r[0].shape,i):new B1e(r[0].shape,i);return t.runWebGLProgram(a,r,s)}const V1e={kernelName:_M,backendName:"webgl",kernelFunc:US};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W1e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=qn(i,s.shape);let u=l;const c=ps(u,a);let h=s;c!=null&&(h=Co({inputs:{x:s},backend:t,attrs:{perm:c}}),u=Ms(u.length,a)),Li("all",u,a);const[d,p]=_i(h.shape,u),g=Qe(p),w=At({inputs:{x:h},backend:t,attrs:{shape:[-1,g]}}),y=ym(w,w.dtype,"all",t);let x;if(o){const _=Vs(d,l);x=At({inputs:{x:y},backend:t,attrs:{shape:_}})}else x=At({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(h),x}const G1e={kernelName:TM,backendName:"webgl",kernelFunc:W1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H1e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=qn(i,s.shape);let u=l;const c=ps(u,a);let h=s;c!=null&&(h=Co({inputs:{x:s},backend:t,attrs:{perm:c}}),u=Ms(u.length,a)),Li("any",u,a);const[d,p]=_i(h.shape,u),g=Qe(p),w=At({inputs:{x:h},backend:t,attrs:{shape:[-1,g]}}),y=ym(w,w.dtype,"any",t);let x;if(o){const _=Vs(d,l);x=At({inputs:{x:y},backend:t,attrs:{shape:_}})}else x=At({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(h),x}const j1e={kernelName:EM,backendName:"webgl",kernelFunc:H1e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X1e{constructor(e,t,r){this.variableNames=["A"];const{windowSize:s,batchSize:i,outSize:o}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=t==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q1e{constructor(e,t,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,ie(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],o=Math.ceil(i/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,u=Or(l),c=yo("coords",l);let h,d;if(o===1){d=l+1;const L=Or(d);h=`
        ${L} sourceLocR = ${L}(${c.join()}, 0);
        ++${c[l-1]};
        ${L} sourceLocG = ${L}(${c.join()}, 0);
        ++${c[l-2]};
        ${L} sourceLocA = ${L}(${c.join()}, 0);
        --${c[l-1]};
        ${L} sourceLocB = ${L}(${c.join()}, 0);
        --${c[l-2]};`}else d=l,h=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),g="."+p[d-1],w=p.map(L=>"int "+L),y=yo("sourceLocR",d-1).concat("inIdx.r"),x=yo("sourceLocG",d-1).concat("inIdx.g"),_=yo("sourceLocB",d-1).concat("inIdx.b"),T=yo("sourceLocA",d-1).concat("inIdx.a"),E=r==="max"?"greaterThan":"lessThan",N=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${_.join()}),
                             getBestIndicesAChannel(${T.join()})));`,M=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${_.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${T.join()}) : 0.)`,$=s?"":`
      float getBestIndicesAChannel(${w.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${w.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${$}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},
          sourceLocB${g}, sourceLocA${g}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${M};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${N}
          vec4 candidate = ${M};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${E}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XH(n,e,t,r=null){let s=e.shape[0],i=e.shape[1];r!=null&&(s=r.shape[0],i=r.shape[1]);const o=TE(i),a={windowSize:o,inSize:i,batchSize:s,outSize:Math.ceil(i/o)},l=new X1e(a,t,r==null),u=[e];r!=null&&u.push(r);const c=n.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const h=XH(n,e,t,c);return n.disposeIntermediateTensorInfo(c),h}function qH(n,e,t,r=null){const s=r!=null?r.shape:e.shape,i=s[s.length-1],o=TE(i),a=new q1e(s,o,t,r==null),l=r==null?[e]:[e,r],u=n.runWebGLProgram(a,l,"int32");if(u.shape.length===e.shape.length){const c=qH(n,e,t,u);return n.disposeIntermediateTensorInfo(u),c}return u}function KH(n,e,t,r){const s=[t];if(Li("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,e.shape.length),!je().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),i.push(l));const[u,c]=_i(l.shape,s),h=Qe(c),d=At({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});i.push(d);const p=XH(n,d,r);i.push(p);const g=At({inputs:{x:p},backend:n,attrs:{shape:u}});return i.forEach(w=>n.disposeIntermediateTensorInfo(w)),g}return qH(n,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K1e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=qn(i,s.shape);const a=ps(o,s.shape.length);let l=s;const u=[];a!=null&&(l=Co({inputs:{x:s},backend:t,attrs:{perm:a}}),u.push(l),o=Ms(o.length,l.shape.length)),Li("argMax",[o[0]],l.shape.length);const c=KH(t,l,o[0],"max");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const Y1e={kernelName:mT,backendName:"webgl",kernelFunc:K1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z1e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i}=r;let o=qn(i,s.shape);const a=ps(o,s.shape.length);let l=s;const u=[];a!=null&&(l=Co({inputs:{x:s},backend:t,attrs:{perm:a}}),u.push(l),o=Ms(o.length,l.shape.length)),Li("argMin",[o[0]],l.shape.length);const c=KH(t,l,o[0],"min");return u.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const J1e={kernelName:gT,backendName:"webgl",kernelFunc:Z1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q1e=Il+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,ewe=lr({opSnippet:Q1e}),twe={kernelName:s1,backendName:"webgl",kernelFunc:ewe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nwe=Il+"return log(x + sqrt(x * x + 1.0));",rwe=lr({opSnippet:nwe}),swe={kernelName:i1,backendName:"webgl",kernelFunc:rwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iwe=Il+`
  return atan(x);
`,owe=lr({opSnippet:iwe}),awe={kernelName:o1,backendName:"webgl",kernelFunc:owe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lwe=JR+`
  return atan(a, b);
`,uwe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+gm+`
  return result;
`,cwe=Oi({opSnippet:lwe,packedOpSnippet:uwe}),hwe={kernelName:l1,backendName:"webgl",kernelFunc:cwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dwe=Il+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,fwe=lr({opSnippet:dwe}),pwe={kernelName:a1,backendName:"webgl",kernelFunc:fwe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ax{constructor(e,t,r,s=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;const w=t==="avg",y=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,x=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let _="0.0";if(w||(_="-1.0 / 1e-20"),r){this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${p}, ${g});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?i?y:x:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const T="max";let E=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(E="avgValue / max(count, 1.0)");const N=Math.floor(o/4)*4,M=o%4,$=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${T}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${p}, ${g});
      const float initializationValue = ${_};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${_});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${N}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${$}
          }

          int xC = xCCorner + ${N};
          if (${M===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${M===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${$}
          } else if (${M===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${$}
          }
        }
        setOutput(${E});
      }
    `}}class eD{constructor(e,t,r,s=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,u=e.strideWidth,c=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,g=e.effectiveFilterHeight,w=e.effectiveFilterWidth,y=e.padInfo.front,x=e.padInfo.top,_=e.padInfo.left;this.outputShape=e.outShape;const T=t==="avg";let E="0.0";if(T||(E="-1.0 / 1e-20"),r){this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${u});
        const ivec3 pads = ivec3(${y}, ${x}, ${_});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${g};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${w};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${g} * ${w} +
                      wR * ${w} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const N="max";let M=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(M="avgValue / max(count, 1.0)");const $=Math.floor(o/4)*4,L=o%4,k=`
      if (${T}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${u});
      const ivec3 pads = ivec3(${y}, ${x}, ${_});
      const float initializationValue = ${E};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${E});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${g};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${$}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${k}
            }

            int xC = xCCorner + ${$};
            if (${L===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${k}
            } else if (${L===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${k}
            } else if (${L===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${k}
            }
          }
        }
        setOutput(${M});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mwe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;pw(s,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,u=1;ie(Ji(o,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=El(s.shape,i,o,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&_r(c.inShape,c.outShape))return Ea({inputs:{x:s},backend:t});const h=new Ax(c,"avg",!1);return t.runWebGLProgram(h,[s],"float32")}const gwe={kernelName:yT,backendName:"webgl",kernelFunc:mwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ywe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],h=vh(s.shape,i,o,c,a,l,u),d=new eD(h,"avg",!1);return t.runWebGLProgram(d,[s],"float32")}const vwe={kernelName:vT,backendName:"webgl",kernelFunc:ywe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xwe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=l-1-e.padInfo.top,h=u-1-e.padInfo.left,d=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class wwe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,g=h-1-e.padInfo.front,w=d-1-e.padInfo.top,y=p-1-e.padInfo.left,x=1/(t*r*s);this.userCode=`
      const ivec3 pads = ivec3(${g}, ${w}, ${y});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bwe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=[1,1,1],d=vh(o.shape,a,l,h,u,c),p=new wwe(d);return t.runWebGLProgram(p,[s],o.dtype)}const Swe={kernelName:IM,backendName:"webgl",kernelFunc:bwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _we(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i;pw([s,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:u}=r,c=El(o.shape,a,l,1,u),h=new xwe(c);return t.runWebGLProgram(h,[s],o.dtype)}const Twe={kernelName:CM,backendName:"webgl",kernelFunc:_we};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ewe(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:i}=e,{transposeA:o,transposeB:a}=r;return E_({a:s,b:i,transposeA:o,transposeB:a,backend:t})}const Cwe={kernelName:xT,backendName:"webgl",kernelFunc:Ewe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Iwe{constructor(e,t,r,s,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],$n(e,t),$n(e,r);let a="0.0";s!=null&&($n(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";i!=null&&($n(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nwe{constructor(e,t,r,s,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],$n(e,t),$n(e,r);let a="vec4(0.0)";s!=null&&($n(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&($n(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Awe=({inputs:n,backend:e,attrs:t})=>{const{x:r,mean:s,variance:i,offset:o,scale:a}=n;ie(s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),ie(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),ie(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const u=[r,s,i];let c=null;o!=null&&(c=o.shape,u.push(o));let h=null;a!=null&&(h=a.shape,u.push(a));const d=je().getBool("WEBGL_PACK_NORMALIZATION")?new Nwe(r.shape,s.shape,i.shape,c,h,l):new Iwe(r.shape,s.shape,i.shape,c,h,l);return e.runWebGLProgram(d,u,u[0].dtype)},Mwe={kernelName:kT,backendName:"webgl",kernelFunc:Awe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kwe{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Or(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=Rwe(this.rank);let s;const i=e.map((o,a)=>`sourceLoc.${FN[a]} = start[${a}] + coords.${FN[a]};`);s=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const FN=["x","y","z","w","u","v"];function Rwe(n){if(n===1)return"sourceLoc";if(n<=6)return FN.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dwe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Or(this.rank),r=yo("coords",this.rank),s=yo("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,o=`getChannel(getSource(${s.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${o};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${o};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${o};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((c,h)=>`start[${h}]`).join()});`:e.map((c,h)=>`${s[h]} = ${r[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $we(n,e,t,r){const s=r.texData.get(n.dataId),i=r.makeTensorInfo(t,n.dtype),o=r.texData.get(i.dataId);Object.assign(o,s),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=Xk(e,nn(n.shape));s.slice&&(a+=s.slice.flatOffset),o.slice={flatOffset:a,origDataId:s.slice&&s.slice.origDataId||n.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),i}function u0(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,size:o}=r,[a,l]=_E(s,i,o);if(Gk(s,a,l),Qe(l)===0)return t.makeTensorInfo(l,s.dtype,[]);if(t.shouldExecuteOnCPU([s])||s.dtype==="string"){const h=t.texData.get(s.dataId),d=Cxe(h.values,a,l,s.shape,s.dtype);return t.makeTensorInfo(l,s.dtype,d)}const{isPacked:u}=t.texData.get(s.dataId),c=jk(s.shape,a,l);if(u||!c){const h=je().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Dwe(l):new kwe(l),d=[a];return t.runWebGLProgram(h,[s],s.dtype,d)}return t.uploadToGPU(s.dataId),$we(s,a,l,t)}const Pwe={kernelName:oE,backendName:"webgl",kernelFunc:u0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lwe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,crops:o}=r;ie(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((_,T)=>_*T),l=rw(s.shape,i,a),u=sw(l.length,i.length),c=iw(s.shape,i,a),h=Jk(o,i.length),d=Qk(c,o,i.length),p=[],g=At({inputs:{x:s},backend:t,attrs:{shape:l}}),w=Co({inputs:{x:g},backend:t,attrs:{perm:u}}),y=At({inputs:{x:w},backend:t,attrs:{shape:c}}),x=u0({inputs:{x:y},backend:t,attrs:{begin:h,size:d}});return p.push(g),p.push(w),p.push(y),p.forEach(_=>t.disposeIntermediateTensorInfo(_)),x},Owe={kernelName:wT,backendName:"webgl",kernelFunc:Lwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fwe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o}=r,a=t.readSync(s.dataId),l=t.readSync(i.dataId),u=LH(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,u)}const zwe={kernelName:NM,backendName:"webgl",kernelFunc:Fwe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bwe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,Uwe=`
  return float(int(a.r) & int(b.r));
`;function Vwe(n){const{inputs:e,backend:t}=n,{a:r,b:s}=e,i=je().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=je().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([r,s])||o===1){const l=t.texData.get(r.dataId).values,u=t.texData.get(s.dataId).values,[c,h]=Yve(r.shape,s.shape,l,u,r.dtype),d=t.makeTensorInfo(h,r.dtype),p=t.texData.get(d.dataId);return p.values=c,d}let a;return i?a=new a0(Bwe,r.shape,s.shape,!1):a=new Zp(Uwe,r.shape,s.shape),t.runWebGLProgram(a,[r,s],r.dtype)}const Wwe={kernelName:AM,backendName:"webgl",kernelFunc:Vwe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gwe(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e,i=t.readSync(r.dataId),o=t.readSync(s.dataId),a=$n(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const Hwe={kernelName:VB,backendName:"webgl",kernelFunc:Gwe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jwe="return float(a != b);",YH=Oi({opSnippet:jwe,cpuKernelImpl:yxe,dtype:"bool"}),Xwe={kernelName:qT,backendName:"webgl",kernelFunc:YH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gw(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return Ea({inputs:{x:s.complexTensorInfos.real},backend:t})}const qwe={kernelName:ek,backendName:"webgl",kernelFunc:gw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kwe="return float(int(x));";function Ywe(n,e){const t=new Wu(n.shape,Kwe),r=e.runWebGLProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zN(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:i}=r;if(i==="complex64"){if(s.dtype==="complex64")return Ea({inputs:{x:s},backend:t});const o=gi(s.shape),a=zN({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),l=sf({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(s.dtype==="complex64"){const o=gw({inputs:{input:s},backend:t}),a=zN({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(o),a}if(!OB(s.dtype,i)){const o=Ea({inputs:{x:s},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(t.shouldExecuteOnCPU([s])){const o=t.texData.get(s.dataId).values,[a,l,u]=Zve(o,s.shape,s.dtype,i);return t.makeTensorInfo(a,l,u)}if(i==="int32")return Ywe(s,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",Yi("bool",1)),l=YH({inputs:{a:s,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${i}`)}const Zwe={kernelName:u1,backendName:"webgl",kernelFunc:zN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YL="return ceil(x);",Jwe=lr({opSnippet:YL,packedOpSnippet:YL,cpuKernelImpl:Jve}),Qwe={kernelName:c1,backendName:"webgl",kernelFunc:Jwe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ebe{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tbe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nbe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:i,clipValueMax:o}=r;let a;je().getBool("WEBGL_PACK_CLIP")?a=new tbe(s.shape):a=new ebe(s.shape);const l=[[i],[o]];return t.runWebGLProgram(a,[s],s.dtype,l)}const rbe={kernelName:h1,backendName:"webgl",kernelFunc:nbe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sbe{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZL(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function ibe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.texData.get(r.dataId),i=new sbe(r.shape),o=[ZL(r,s.complexTensorInfos.real),ZL(r,s.complexTensorInfos.imag)];return t.runWebGLProgram(i,o,o[0].dtype)}const obe={kernelName:bT,backendName:"webgl",kernelFunc:ibe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class abe{constructor(e){this.outputShape=[],this.outputShape=Ku(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];r.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const s=t.length,i=t[t.length-1];r.push(`else setOutput(getT${s}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lbe{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Ku(e,t);const r=this.outputShape,s=r.length,i=Or(s),o=yo("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map((w,y)=>`T${y}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let w=1;w<l.length;w++)l[w]=l[w-1]+e[w][t];const u=a[t],c=a.slice(-2),h=a.join();let d=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;for(let w=1;w<l.length;w++){const y=l[w-1];d+=`
        if (${u} < ${l[w]}  && ${u} >= ${l[w-1]}) {
          return getChannel(
            getT${w}(${bS(a,u,y)}),
            vec2(${bS(c,u,y)}));
        }`}const p=l.length,g=l[l.length-1];d+=`
        return getChannel(
          getT${p}(${bS(a,u,g)}),
          vec2(${bS(c,u,g)}));`,this.userCode=`
      float getValue(${a.map(w=>"int "+w)}) {
        ${d}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[s-1]} = ${o[s-1]} + 1;
        if (${o[s-1]} < ${r[s-1]}) {
          result.g = getValue(${o});
        }

        ${o[s-2]} = ${o[s-2]} + 1;
        if (${o[s-2]} < ${r[s-2]}) {
          result.a = getValue(${o});
        }

        ${o[s-1]} = ${o[s-1]} - 1;
        if (${o[s-2]} < ${r[s-2]} &&
            ${o[s-1]} < ${r[s-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function bS(n,e,t){const r=n.indexOf(e);return n.map((i,o)=>o===r?`${i} - ${t}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WE(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.texData.get(r.dataId);return Ea({inputs:{x:s.complexTensorInfos.imag},backend:t})}const ube={kernelName:jM,backendName:"webgl",kernelFunc:WE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ov(n,e,t){const r=n[0].dtype;if(r==="complex64"){const p=n.map(_=>gw({inputs:{input:_},backend:t})),g=n.map(_=>WE({inputs:{input:_},backend:t})),w=Ov(p,e,t),y=Ov(g,e,t),x=sf({inputs:{real:w,imag:y},backend:t});return p.forEach(_=>t.disposeIntermediateTensorInfo(_)),g.forEach(_=>t.disposeIntermediateTensorInfo(_)),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(y),x}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const p=n.map(E=>{const M=[-1,Qe(E.shape.slice(e))];return At({inputs:{x:E},backend:t,attrs:{shape:M}})}),g=p.map(E=>({vals:t.readSync(E.dataId),shape:E.shape})),w=Ku(p.map(E=>E.shape),1),y=p[0].shape[0]===1,x=Qve(g,w,r,y),_=Ku(n.map(E=>E.shape),e),T=t.makeTensorInfo(_,r,x);return p.forEach(E=>t.disposeIntermediateTensorInfo(E)),T}const i=n.filter(p=>Qe(p.shape)>0),o=je().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(i.length===1){const p=o?new Wu(n[0].shape,fd):new vd(n[0].shape,fd);return t.runWebGLProgram(p,n,r)}const a=je().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>a){const p=[];for(let w=0;w<i.length;w+=a){const y=i.slice(w,w+a);p.push(Ov(y,e,t))}const g=Ov(p,e,t);for(const w of p)t.disposeIntermediateTensorInfo(w);return g}if(o){const p=new lbe(i.map(g=>g.shape),e);return t.runWebGLProgram(p,i,r)}const{tensors2D:l,outShape:u}=cbe(i,e,t),c=new abe(l.map(p=>p.shape)),h=t.runWebGLProgram(c,l,r);l.forEach(p=>t.disposeIntermediateTensorInfo(p));const d=At({inputs:{x:h},attrs:{shape:u},backend:t});return t.disposeIntermediateTensorInfo(h),d}function cbe(n,e,t){const r=Ku(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>At({inputs:{x:i},attrs:{shape:[-1,Qe(i.shape.slice(e))]},backend:t})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZH(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,i=qn(s,e[0].shape)[0],o=e.map(u=>u.shape);Kk(o,i);const a=Ku(e.map(u=>u.shape),i);if(Qe(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(u=>Qe(u.shape)>0);return l.length===1?Ea({inputs:{x:l[0]},backend:t}):Ov(l,i,t)}const hbe={kernelName:ST,backendName:"webgl",kernelFunc:ZH};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JH{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,u=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,g=Math.floor(e.inChannels/4)*4,w=e.inChannels%4,y=e.dataFormat==="channelsLast",x=y?1:2,_=y?2:3,T=y?3:1;let E="",N="";r&&(s?E=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?E=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:E=`
          float activation(float x) {
            ${r}
          }
        `,N="result = activation(result);");const M=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${E}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${T}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${_}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${g}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${w===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${g}) *
                    getW(wR, wC, ${g}, d2);
              } else {
                dotProd +=
                    getX(batch, ${g}, xR, xC) *
                    getW(wR, wC, ${g}, d2);
              }

            } else if (${w===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${w===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${g}, d2),
                getW(wR, wC, ${g} + 1, d2),
                getW(wR, wC, ${g} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${g}),
                  getX(batch, xR, xC, ${g} + 1),
                  getX(batch, xR, xC, ${g} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${g}, xR, xC),
                  getX(batch, ${g} + 1, xR, xC),
                  getX(batch, ${g} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${M}
        ${N}
        setOutput(result);
      }
    `}}class dbe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,r=e.padInfo.top,s=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,p=e.filterWidth,g=Math.floor(e.inChannels/4)*4,w=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${g}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${w===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${g}) *
                  getW(wF, wR, wC, ${g}, d2);
              } else if (${w===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${w===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${g}),
                  getX(batch, xF, xR, xC, ${g} + 1),
                  getX(batch, xF, xR, xC, ${g} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${g}, d2),
                  getW(wF, wR, wC, ${g} + 1, d2),
                  getW(wF, wR, wC, ${g} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QH{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Qi(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<c;y++)d+=`
           vec4 xTexelC${y*2};
           int xTexelC${y*2}Ready;
           vec4 xTexelC${y*2+1};
           int xTexelC${y*2+1}Ready;
           vec4 xC${y};`;d+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let y=0;y<c;y++)d+=`
           xTexelC${y*2} = vec4(0.0);
           xTexelC${y*2}Ready = 0;
           xTexelC${y*2+1} = vec4(0.0);
           xTexelC${y*2+1}Ready = 0;
           xC${y} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let y=0;y<(h+1)/2;y++){const x=y*2;if(d+=`
           xC = xCCorner + ${x*l};
           `,a===1){if(x<c&&(o%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }
               `,l===1&&x>0?d+=`
                 xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                   } else {
                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xC${x} = xTexelC${x};
                 `,x+1<c)){const _=o%2===0?vM(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${_};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                     xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${x+1}.zw = vec2(0.0);
                     }
                     xTexelC${x+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                     } else {
                      xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                     }
                     `:d+=`
                     xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                     `):_===1?d+=`
                     xC${x+1} = xTexelC${x};
                     `:d+=`
                     xCOffset = xC + ${_};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                       xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${x+1}.zw = vec2(0.0);
                       }
                       xTexelC${x+1}Ready = 1;
                     }

                     xC${x+1} = xTexelC${x+1};
                     `}}else x<c&&(o%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.0);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
               `,x+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                   xTexelC${x} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${x}.zw = vec2(0.0);
                   }
                   xTexelC${x}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                   xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${x+1}.zw = vec2(0.);
                   }
                   xTexelC${x+1}Ready = 1;
                 }

                 xC${x} = vec4(
                   xTexelC${x}.xy, xTexelC${x+1}.xy);
               `,x+1<c&&(d+=`
                   xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                 `)));x<c&&(d+=`
             wTexel = getW(r, ${x}, d1, d2);
             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,x+1<c&&(d+=`
               wTexel = getW(r, ${x+1}, d1, d2);
               dotProd += xC${x+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${x+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",g="";r&&(s?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:i?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:p=`vec4 activation(vec4 x) {
           ${r}
         }`,g="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${w}
         ${g}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fbe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Qi(this.outputShape.length);const{dataFormat:r}=t,s=Io(),i=r==="channelsLast",o=i?1:2,a=i?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)u+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C_(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function e5({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,u=r.texData.get(n.dataId),c=t.inChannels,h=l[0]*l[1]*l[2],d=t.outChannels,p=t.dataFormat==="channelsLast",g=!1,w=!1;let y;const x=[];if(i!=null){const E=C_(i.shape,p);E!=null&&(i=At({inputs:{x:i},backend:r,attrs:{shape:E}}),x.push(i))}if(s!=null){const E=C_(s.shape,p);E!=null&&(s=At({inputs:{x:s},backend:r,attrs:{shape:E}}),x.push(s))}if(!((h===1||d===1)&&c>jH)&&u.isPacked&&p&&u.texture!=null&&l[2]%2!==0&&_r(u.shape.slice(-3),l.slice(-3))){const E=l[0]*l[1]*(l[2]+1),N={dataId:n.dataId,shape:[1,E,t.inChannels],dtype:n.dtype},M=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,ie(T_(u.shape,N.shape),()=>`packed reshape ${u.shape} to ${N.shape} isn't free`);const $=At({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});x.push($);const L=E_({a:N,b:$,backend:r,transposeA:g,transposeB:w,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),k=r.texData.get(L.dataId);ie(k.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=M,k.shape=t.outShape,y=Ea({inputs:{x:L},backend:r}),y.shape=t.outShape,x.push(L)}else{const E=t.outHeight*t.outWidth,N=At({inputs:{x:n},backend:r,attrs:{shape:p?[t.batchSize,E,t.inChannels]:[t.batchSize,t.inChannels,E]}}),M=At({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),$=E_({a:p?N:M,b:p?M:N,transposeA:!p,transposeB:w,backend:r,bias:s,activation:a,preluActivationWeights:i,leakyreluAlpha:o});y=At({inputs:{x:$},backend:r,attrs:{shape:t.outShape}}),x.push(N),x.push(M),x.push($)}for(const E of x)r.disposeIntermediateTensorInfo(E);return y}function t5({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:h,outHeight:d,dataFormat:p}=t,g=p==="channelsLast",w=l*u*c,y=d*h,x=[t.batchSize,w,y],_=!0,T=!1,E=[];if(i!=null){const W=C_(i.shape,g);W!=null&&(i=At({inputs:{x:i},backend:r,attrs:{shape:W}}),E.push(i))}if(s!=null){const W=C_(s.shape,g);W!=null&&(s=At({inputs:{x:s},backend:r,attrs:{shape:W}}),E.push(s))}const N=At({inputs:{x:e},backend:r,attrs:{shape:[1,w,Qe(e.shape)/w]}});E.push(N);const M=new fbe(x,t),$=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],L=r.runWebGLProgram(M,[n],"float32",$),k=At({inputs:{x:L},backend:r,attrs:{shape:x}});E.push(L),E.push(k);const R=s!=null,P=i!=null,B=a==="leakyrelu",Z=a?Nx(a,!0):null,V=new HH(g?k.shape:N.shape,g?N.shape:k.shape,g?[t.batchSize,y,t.outChannels]:[t.batchSize,t.outChannels,y],_,T,R,Z,P,B),X=g?[k,N]:[N,k];if(s&&X.push(s),P&&X.push(i),B){const W=r.makeTensorInfo([],"float32",Yd(o,"float32"));X.push(W),E.push(W)}const q=r.runWebGLProgram(V,X,"float32"),se=At({inputs:{x:q},backend:r,attrs:{shape:t.outShape}});E.push(q);for(const W of E)r.disposeIntermediateTensorInfo(W);return se}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pbe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:u,dimRoundingMode:c}=r,h=xh(l),d=Pi(s.shape,i.shape,o,u,a,c,!1,h);let p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=e5({x:s,filter:i,convInfo:d,backend:t});else if(d.strideWidth<=2&&h==="channelsLast"&&je().getBool("WEBGL_EXP_CONV")){const w=new QH(d),y=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=t.runWebGLProgram(w,[s,i],"float32",y)}else if(je().getBool("WEBGL_CONV_IM2COL"))p=t5({x:s,filter:i,convInfo:d,backend:t});else{const w=new JH(d);p=t.runWebGLProgram(w,[s,i],"float32")}const g=At({inputs:{x:p},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(p),g}const mbe={kernelName:_T,backendName:"webgl",kernelFunc:pbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gbe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,i=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class ybe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=r-1-e.padInfo.left,u=o?1:2,c=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class vbe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class xbe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,u=r-1-e.padInfo.top,c=s-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wbe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,h=xh(l),d=Pi(s.shape,c,o,1,a,u,!1,h),p=new gbe(d);return t.runWebGLProgram(p,[s,i],"float32")}const bbe={kernelName:kM,backendName:"webgl",kernelFunc:wbe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sbe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=Qi(this.outputShape.length);const t=e.filterHeight,r=e.filterWidth,s=t-1-e.padInfo.top,i=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _be(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:c}=r,h=xh(u),d=Pi(o,i.shape,a,1,l,c,!1,h);if(je().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const p=[[d.strideHeight,d.strideWidth]],g=new Sbe(d);return t.runWebGLProgram(g,[s,i],"float32",p)}else{const p=new ybe(d);return t.runWebGLProgram(p,[s,i],"float32")}}const Tbe={kernelName:TT,backendName:"webgl",kernelFunc:_be};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ebe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,u=Zd(s.shape,i.shape,o,l,a),c=new dbe(u);return t.runWebGLProgram(c,[s,i],"float32")}const Cbe={kernelName:ET,backendName:"webgl",kernelFunc:Ebe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ibe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,pad:a,filterShape:l}=r,u=Zd(s.shape,l,o,1,a),c=new vbe(u);return t.runWebGLProgram(c,[s,i],"float32")}const Nbe={kernelName:RM,backendName:"webgl",kernelFunc:Ibe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Abe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{pad:o,strides:a,inputShape:l}=r,u=Zd(l,i.shape,a,1,o),c=new xbe(u);return t.runWebGLProgram(c,[s,i],"float32")}const Mbe={kernelName:DM,backendName:"webgl",kernelFunc:Abe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kbe=l0+`
  return cos(x);
`,Rbe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${gm}
  return result;
`,Dbe=lr({opSnippet:kbe,packedOpSnippet:Rbe}),$be={kernelName:d1,backendName:"webgl",kernelFunc:Dbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pbe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Lbe=lr({opSnippet:Pbe}),Obe={kernelName:f1,backendName:"webgl",kernelFunc:Lbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fbe{constructor(e,t,r,s,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,u]=e,[c]=t,[h,d]=r;this.outputShape=[c,h,d,u];const p=s==="bilinear"?1:0,[g,w]=[`${a-1}.0`,`${l-1}.0`],[y,x,_]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${g} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${g}`],[T,E,N]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${w} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${w}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${T});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${E};

        float in_y = ${_};
        if( in_y < 0.0 || in_y > ${g} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${N};
        if( in_x < 0.0 || in_x > ${w} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zbe=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:u}=r,c=new Fbe(s.shape,i.shape,a,l,u);return t.runWebGLProgram(c,[s,i,o],"float32")},Bbe={kernelName:PM,backendName:"webgl",kernelFunc:zbe};var Mx;(function(n){n.Prod="*",n.Sum="+"})(Mx||(Mx={}));class JL{constructor(e,t,r,s){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const i=this.outputShape.length,o=this.op===Mx.Prod?"1.0":"0.0",a=r?o:`getX(${QL(i,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";r?(u=s?`end != ${l-1}`:"end != 0",c=s?"end + 1":"end - 1"):(u=s?`end + pow2 < ${l}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Or(i)} coords = getOutputCoords();
        int end = ${eO(i,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${eO(i,"coords",this.op)} = idx;
          val ${this.op}= getX(${QL(i,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function QL(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function eO(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n5(n,e,t,r,s,i){const o=e.shape.length,a=ps([r],o);let l=e;a!=null&&(l=Co({inputs:{x:e},backend:t,attrs:{perm:a}}));const u=Ms(1,o)[0];if(u!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const c=l.shape[u];let h=Ea({inputs:{x:l},backend:t});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const p=new JL(n,l.shape,!1,i),g=[[d]],w=h;h=t.runWebGLProgram(p,[h],h.dtype,g),t.disposeIntermediateTensorInfo(w)}if(s){const d=new JL(n,l.shape,s,i),p=h;h=t.runWebGLProgram(d,[h],h.dtype),t.disposeIntermediateTensorInfo(p)}if(a!=null){const d=Jd(a),p=Co({inputs:{x:h},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),p}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ube(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return n5(Mx.Prod,s,t,i,o,a)}const Vbe={kernelName:$M,backendName:"webgl",kernelFunc:Ube};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wbe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,exclusive:o,reverse:a}=r;return n5(Mx.Sum,s,t,i,o,a)}const Gbe={kernelName:CT,backendName:"webgl",kernelFunc:Wbe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hbe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:i}=e,{size:o,binaryOutput:a}=r;if(s.shape.length===1){const l=t.readSync(s.dataId),u=t.readSync(i.dataId),c=LH(l,u,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}else if(s.shape.length===2){const l=t.bufferSync(s),u=t.bufferSync(i),c=Kve(l,u,o,a);return t.makeTensorInfo(c.shape,i.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const jbe={kernelName:LM,backendName:"webgl",kernelFunc:Hbe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xbe{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qbe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:i,dataFormat:o}=r,a=s.shape[0],l=o==="NHWC"?s.shape[1]:s.shape[2],u=o==="NHWC"?s.shape[2]:s.shape[3],c=o==="NHWC"?s.shape[3]:s.shape[1],h=l*i,d=u*i,p=c/(i*i),g=o==="NHWC"?[a,h,d,p]:[a,p,h,d],w=new Xbe(g,i,o);return t.runWebGLProgram(w,[s],s.dtype)}const Kbe={kernelName:OM,backendName:"webgl",kernelFunc:qbe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r5{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Qi(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let u="",c="";r&&(s?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:u=`
          float activation(float x) {
            ${r}
          }
        `,c="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s5{constructor(e,t=!1,r=null,s=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Qi(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,u=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,d=h;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<h;x++)p+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;p+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let x=0;x<h;x++)p+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(d+1)/2;x++){const _=x*2;if(p+=`
          xC = xCCorner + ${_*u};
          `,l===1){if(_<h&&(a%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_}Ready == 0) {
                  xTexelC${_} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${_}.zw = vec2(0.0);
                  }
                  xTexelC${_}Ready = 1;
                }
              `,u===1&&_>0?p+=`
                xC${_} = vec4(xTexelC${_-2}.zw, xTexelC${_}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${_} = vec4(previous.zw, xTexelC${_}.xy);
                  } else {
                    xC${_} = vec4(0.0, 0.0, xTexelC${_}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${_}Ready == 0) {
                  xTexelC${_} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${_}.zw = vec2(0.0);
                  }
                  xTexelC${_}Ready = 1;
                }

                xC${_} = xTexelC${_};
                `,_+1<h)){const T=a%2===0?vM(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${T};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {
                    xTexelC${_+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${_+1}.zw = vec2(0.0);
                    }
                    xTexelC${_+1}Ready = 1;
                  }
                  `,u>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${_+1} = vec4(previous.zw, xTexelC${_+1}.xy);
                    } else {
                     xC${_+1} = vec4(0.0, 0.0, xTexelC${_+1}.xy);
                    }
                    `:p+=`
                    xC${_+1} = vec4(xTexelC${_}.zw, xTexelC${_+1}.xy);
                    `):T===1?p+=`
                    xC${_+1} = xTexelC${_};
                    `:p+=`
                    xCOffset = xC + ${T};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {
                      xTexelC${_+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${_+1}.zw = vec2(0.0);
                      }
                      xTexelC${_+1}Ready = 1;
                    }

                    xC${_+1} = xTexelC${_+1};
                    `}}else _<h&&(a%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_}Ready == 0) {
                  xTexelC${_} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${_}.zw = vec2(0.0);
                  }
                  xTexelC${_}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${_+1}Ready == 0) {
                  xTexelC${_+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${_+1}.zw = vec2(0.0);
                  }
                  xTexelC${_+1}Ready = 1;
                }

                xC${_} = vec4(xTexelC${_}.zw, xTexelC${_+1}.zw);
              `,_+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${_+1} = vec4(xTexelC${_+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${_}Ready == 0) {
                  xTexelC${_} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${_}.zw = vec2(0.0);
                  }
                  xTexelC${_}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${_+1}Ready == 0) {
                  xTexelC${_+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${_+1}.zw = vec2(0.);
                  }
                  xTexelC${_+1}Ready = 1;
                }

                xC${_} = vec4(
                  xTexelC${_}.xy, xTexelC${_+1}.xy);
              `,_+1<h&&(p+=`
                  xC${_+1} = vec4(xTexelC${_}.zw, xTexelC${_+1}.zw);
                `)));_<h&&(p+=`
            wTexel = getW(r, ${_}, d1, q);
            dotProd += xC${_} * vec4(wTexel.xz, wTexel.xz);
          `,_+1<h&&(p+=`
              wTexel = getW(r, ${_+1}, d1, q);
              dotProd += xC${_+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let g="",w="";r&&(s?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:i?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:g=`vec4 activation(vec4 x) {
          ${r}
        }`,w="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${g}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${w}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ybe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:u}=r;let c=l;c==null&&(c=[1,1]),ie(Ji(o,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const h=Pi(s.shape,i.shape,o,c,a,u,!0);let d;je().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new s5(h):d=new r5(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(d,[s,i],"float32",p)}const Zbe={kernelName:IT,backendName:"webgl",kernelFunc:Ybe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jbe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,s=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${s};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Qbe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.top,a=r-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eSe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,filterShape:c}=r,h=Pi(s.shape,c,o,a,l,u,!0),d=new Jbe(h);return t.runWebGLProgram(d,[s,i],"float32")}const tSe={kernelName:FM,backendName:"webgl",kernelFunc:eSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nSe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:u,inputShape:c}=r,h=Pi(c,i.shape,o,a,l,u,!0),d=new Qbe(h);return t.runWebGLProgram(d,[s,i],"float32")}const rSe={kernelName:zM,backendName:"webgl",kernelFunc:nSe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sSe{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iSe(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],i=Qe(r.shape),o=At({inputs:{x:r},backend:t,attrs:{shape:[i]}}),a=new sSe(i),l=t.runWebGLProgram(a,[o],o.dtype),u=At({inputs:{x:l},backend:t,attrs:{shape:s}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),u}const oSe={kernelName:WB,backendName:"webgl",kernelFunc:iSe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aSe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:r,padInfo:s,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:u,dilationWidth:c}=e,{top:h,left:d}=s;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lSe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i}=e,{strides:o,pad:a,dilations:l}=r,u=J1(s.shape,i.shape,o,a,"NHWC",l);let c;const h=new aSe(u);c=t.runWebGLProgram(h,[s,i],"float32");const d=At({inputs:{x:c},backend:t,attrs:{shape:u.outShape}});return t.disposeIntermediateTensorInfo(c),d}const uSe={kernelName:NT,backendName:"webgl",kernelFunc:lSe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cSe(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,i=e,{allDims:o,summedDims:a,idDims:l}=aR(s,i.length);uR(o.length,l,i);const{path:u,steps:c}=cR(a,l),h=c.length;let d=null,p=o.length;const g=[];for(let w=0;w<h;++w){for(const y of c[w]){const{permutationIndices:x,expandDims:_}=lR(p,l[y]);let T;hR(x)?T=i[y]:(T=Co({inputs:{x:i[y]},backend:t,attrs:{perm:x}}),g.push(T));const E=T.shape.slice();for(let N=0;N<_.length;++N)E.splice(_[N],0,1);_r(T.shape,E)||(T=At({inputs:{x:T},backend:t,attrs:{shape:E}}),g.push(T)),d===null?d=T:(d=QR({inputs:{a:T,b:d},backend:t}),g.push(d))}w<h-1&&(u[w]>=0&&(d=VE({inputs:{x:d},backend:t,attrs:{axis:u[w]-(o.length-p),keepDims:!1}}),g.push(d)),p--)}for(const w of g)w!==d&&t.disposeIntermediateTensorInfo(w);return d}const hSe={kernelName:BM,backendName:"webgl",kernelFunc:cSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dSe="return (x >= 0.0) ? x : (exp(x) - 1.0);",fSe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,pSe=lr({opSnippet:dSe,packedOpSnippet:fSe}),mSe={kernelName:m1,backendName:"webgl",kernelFunc:pSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gSe="return (b >= 0.0) ? a : a * (b + 1.0);",ySe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,vSe=n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,i=je().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new a0(ySe,r.shape,s.shape):new Zp(gSe,r.shape,s.shape);return t.runWebGLProgram(i,[r,s],r.dtype)},xSe={kernelName:UM,backendName:"webgl",kernelFunc:vSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wSe=`
  return vec4(equal(a, b));
`,bSe="return float(a == b);",SSe=Oi({opSnippet:bSe,packedOpSnippet:wSe,dtype:"bool",cpuKernelImpl:exe}),_Se={kernelName:AT,backendName:"webgl",kernelFunc:SSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TSe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${eR};
  float a1 = ${tR};
  float a2 = ${nR};
  float a3 = ${rR};
  float a4 = ${sR};
  float a5 = ${iR};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,ESe=lr({opSnippet:TSe}),CSe={kernelName:g1,backendName:"webgl",kernelFunc:ESe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ISe=l0+`
  return exp(x);
`,NSe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,i5=lr({opSnippet:ISe,packedOpSnippet:NSe,cpuKernelImpl:txe,dtype:"float32"}),ASe={kernelName:y1,backendName:"webgl",kernelFunc:i5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BN(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=s;return s<0&&(ie(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+s+1),a.splice(l,0,1),At({inputs:{x:i},backend:r,attrs:{shape:a}})}const MSe={kernelName:MT,backendName:"webgl",kernelFunc:BN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tO="return exp(x) - 1.0;",kSe=lr({opSnippet:tO,packedOpSnippet:tO,cpuKernelImpl:nxe}),RSe={kernelName:v1,backendName:"webgl",kernelFunc:kSe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nO{constructor(e,t,r){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const i=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${s}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o5(n,e,t){const r=t.texData.get(n.dataId),s=Qe(n.shape),i=n.shape[n.shape.length-1],o=s/i,a=At({inputs:{x:n},backend:t,attrs:{shape:[o,i]}}),l=a.shape,u=new nO("real",l,e),c=new nO("imag",l,e),h=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=t.runWebGLProgram(u,h,"float32"),p=t.runWebGLProgram(c,h,"float32"),g=sf({inputs:{real:d,imag:p},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p);const w=At({inputs:{x:g},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(g),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DSe(n){const{inputs:e,backend:t}=n,{input:r}=e;return o5(r,!1,t)}const $Se={kernelName:VM,backendName:"webgl",kernelFunc:DSe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PSe{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yw(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:i}=t;if(i=i||jy(s),i==="string"){const o=Cs(i,Qe(r));return o.fill(s),e.makeTensorInfo(r,i,o)}else{const o=new PSe(r,s),a=[[s]];return e.runWebGLProgram(o,[],i,a)}}const LSe={kernelName:WM,backendName:"webgl",kernelFunc:yw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OSe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FSe={kernelName:GM,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new OSe(t.shape);return r.runWebGLProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rO="return floor(x);",zSe=lr({opSnippet:rO,packedOpSnippet:rO,cpuKernelImpl:rxe}),BSe={kernelName:x1,backendName:"webgl",kernelFunc:zSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const USe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,VSe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,WSe=Oi({opSnippet:USe,packedOpSnippet:VSe,dtype:"int32"}),GSe={kernelName:w1,backendName:"webgl",kernelFunc:WSe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HSe{constructor(e){this.variableNames=["A"];const t=Io(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jSe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Io(),[r,s]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XSe={kernelName:ate,backendName:"webgl",kernelFunc:qSe};let Wg,eI=je().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function qSe(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:i}=r,o=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=o?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],h=[u,l,i];if(a||o){const w=je().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Wg==null||w!==eI)&&(eI=w,Wg=document.createElement("canvas").getContext("2d",{willReadFrequently:eI})),Wg.canvas.width=l,Wg.canvas.height=u,Wg.drawImage(s,0,0,l,u),s=Wg.canvas}const d=t.makeTensorInfo(c,"int32");t.texData.get(d.dataId).usage=Ga.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),s);const p=je().getBool("WEBGL_PACK")?new jSe(h):new HSe(h),g=t.runWebGLProgram(p,[d],"int32");return t.disposeData(d.dataId),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KSe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:g}=r,w=xh(c),y=Pi(s.shape,i.shape,l,h,u,d,!1,w);let x;const _=[],T=o!=null,E=a!=null,N=p==="leakyrelu",M=()=>{const L=[s,i],k=(R,P)=>{if(P==="NCHW"&&R.shape.length===1&&R.shape[0]!==1){const B=At({inputs:{x:R},backend:t,attrs:{shape:[R.shape[0],1,1]}});return _.push(B),B}return R};if(T&&L.push(k(o,c)),E&&L.push(k(a,c)),N){const R=t.makeTensorInfo([],"float32",Yd(g,"float32"));L.push(R),_.push(R)}return L};if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))x=e5({x:s,filter:i,convInfo:y,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:g});else if(y.strideWidth<=2&&w==="channelsLast"&&je().getBool("WEBGL_EXP_CONV")){const L=p?Nx(p,!0):null,k=new QH(y,T,L,E,N),R=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],P=M();x=t.runWebGLProgram(k,P,"float32",R)}else if(je().getBool("WEBGL_CONV_IM2COL"))x=t5({x:s,filter:i,convInfo:y,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:g});else{const L=p?Nx(p,!1):null,k=new JH(y,T,L,E,N),R=M();x=t.runWebGLProgram(k,R,"float32")}const $=At({inputs:{x},backend:t,attrs:{shape:y.outShape}});return _.push(x),_.forEach(L=>t.disposeIntermediateTensorInfo(L)),$}const YSe={kernelName:n_,backendName:"webgl",kernelFunc:KSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZSe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=r,g=[];let w=c;w==null&&(w=[1,1]),ie(Ji(l,w),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${w}'`);const y=Pi(s.shape,i.shape,l,w,u,h,!0),x=je().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,_=d?Nx(d,x):null,T=[s,i],E=o!=null,N=a!=null,M=d==="leakyrelu";if(E&&T.push(o),N&&T.push(a),M){const R=t.makeTensorInfo([],"float32",Yd(p,"float32"));T.push(R),g.push(R)}let $;x?$=new s5(y,E,_,N,M):$=new r5(y,E,_,N,M);const L=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],k=t.runWebGLProgram($,T,"float32",L);return g.forEach(R=>t.disposeIntermediateTensorInfo(R)),k}const JSe={kernelName:lU,backendName:"webgl",kernelFunc:ZSe};class QSe{constructor(e,t,r,s){this.sliceDim=e,this.strides=t,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const i=Or(r.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e_e(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,i=s.shape,o=i[i.length-1],a=Qe(r.shape),[l,u,c,h]=Wk(r,s),d=At({inputs:{x:s},backend:t,attrs:{shape:[u,o]}}),p=At({inputs:{x:r},backend:t,attrs:{shape:[Qe(r.shape)/c,c]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const x=t.readSync(s.dataId),_=t.bufferSync(r),T=sxe(x,_,r.dtype,u,o,c,h,r.shape,a);return t.makeTensorInfo(l,r.dtype,T.values)}const g=new QSe(o,h,[u,c],r.shape),w=t.runWebGLProgram(g,[p,d],p.dtype),y=At({inputs:{x:w},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(w),y}const t_e={kernelName:GB,backendName:"webgl",kernelFunc:e_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n_e{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=Or(this.rank),s=r_e(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}}function r_e(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n.length;s++)s===2?r.push("index"):r.push(`${t[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a5(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:i}=e,{axis:o,batchDims:a}=r,l=qn(o,s.shape)[0];if(je().get("DEBUG")){const _=t.readSync(i.dataId),T=s.shape[l];for(let E=0;E<_.length;++E){const N=_[E];ie(N<=T-1&&N>=0,()=>`GatherV2: the index value ${N} is not in [0, ${T-1}]`)}}const u=fR(s,i,l,a),c=Qe(i.shape),h=[],d=At({inputs:{x:s},backend:t,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=At({inputs:{x:i},backend:t,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const g=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(t.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const _=t.bufferSync(p),T=t.bufferSync(d),E=ixe(T,_,g);return h.forEach(N=>t.disposeIntermediateTensorInfo(N)),t.makeTensorInfo(u.outputShape,E.dtype,E.values)}const w=new n_e(d.shape,g),y=t.runWebGLProgram(w,[d,p],d.dtype);h.push(y);const x=At({inputs:{x:y},backend:t,attrs:{shape:u.outputShape}});return h.forEach(_=>t.disposeIntermediateTensorInfo(_)),x}const s_e={kernelName:RT,backendName:"webgl",kernelFunc:a5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i_e="return float(a > b);",o_e=`
  return vec4(greaterThan(a, b));
`,a_e=Oi({opSnippet:i_e,packedOpSnippet:o_e,cpuKernelImpl:oxe,dtype:"bool"}),l_e={kernelName:DT,backendName:"webgl",kernelFunc:a_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u_e="return float(a >= b);",c_e=`
  return vec4(greaterThanEqual(a, b));
`,h_e=Oi({opSnippet:u_e,packedOpSnippet:c_e,dtype:"bool",cpuKernelImpl:axe}),d_e={kernelName:b1,backendName:"webgl",kernelFunc:h_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f_e(n){const{inputs:e,backend:t}=n,{input:r}=e;return o5(r,!0,t)}const p_e={kernelName:HM,backendName:"webgl",kernelFunc:f_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m_e="return float(!isnan(x) && !isinf(x));",g_e=lr({opSnippet:m_e,dtype:"bool"}),y_e={kernelName:_1,backendName:"webgl",kernelFunc:g_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v_e="return float(isinf(x));",x_e=lr({opSnippet:v_e,dtype:"bool"}),w_e={kernelName:T1,backendName:"webgl",kernelFunc:x_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b_e="return float(isnan(x));",S_e=lr({opSnippet:b_e,dtype:"bool"}),__e={kernelName:E1,backendName:"webgl",kernelFunc:S_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T_e="return float(a < b);",E_e=`
  return vec4(lessThan(a, b));
`,C_e=Oi({opSnippet:T_e,packedOpSnippet:E_e,cpuKernelImpl:lxe,dtype:"bool"}),I_e={kernelName:PT,backendName:"webgl",kernelFunc:C_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N_e="return float(a <= b);",A_e=`
  return vec4(lessThanEqual(a, b));
`,M_e=Oi({opSnippet:N_e,packedOpSnippet:A_e,cpuKernelImpl:uxe,dtype:"bool"}),k_e={kernelName:LT,backendName:"webgl",kernelFunc:M_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R_e(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:i}=t,o=cxe(r,s,i);return e.makeTensorInfo([o.length],"float32",o)}const D_e={kernelName:HB,backendName:"webgl",kernelFunc:R_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $_e=l0+`
  return x < 0.0 ? 0./0. : log(x);
`,P_e=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,L_e=lr({opSnippet:$_e,packedOpSnippet:P_e,cpuKernelImpl:hxe}),O_e={kernelName:C1,backendName:"webgl",kernelFunc:L_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F_e=l0+`
  return log(1.0 + x);
`,z_e=lr({opSnippet:F_e}),B_e={kernelName:I1,backendName:"webgl",kernelFunc:z_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U_e="return float(a >= 1.0 && b >= 1.0);",V_e=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,W_e=Oi({opSnippet:U_e,packedOpSnippet:V_e,dtype:"bool"}),G_e={kernelName:OT,backendName:"webgl",kernelFunc:W_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H_e="return float(!(x >= 1.0));",j_e=lr({opSnippet:H_e}),X_e={kernelName:FT,backendName:"webgl",kernelFunc:j_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q_e="return float(a >= 1.0 || b >= 1.0);",K_e=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Y_e=Oi({opSnippet:q_e,packedOpSnippet:K_e,dtype:"bool"}),Z_e={kernelName:zT,backendName:"webgl",kernelFunc:Y_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class J_e{constructor(e,t,r,s,i){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const u=`float(${r}) + float(${s}) * sum`;i===.5?l=`inversesqrt(${u})`:i===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q_e{constructor(e,t,r,s,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const u=`float(${r}) + float(${s}) * sum`;i===.5?l=`inversesqrt(${u})`:i===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eTe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=r,u=je().getBool("WEBGL_PACK_NORMALIZATION")?new Q_e(s.shape,i,o,a,l):new J_e(s.shape,i,o,a,l);return t.runWebGLProgram(u,[s],s.dtype)},tTe={kernelName:BT,backendName:"webgl",kernelFunc:eTe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nTe{constructor(e,t,r,s,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=s,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${i})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rTe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:u,beta:c}=r,h=new nTe(s.shape,a,l,u,c);return t.runWebGLProgram(h,[s,i,o],s.dtype)},sTe={kernelName:XM,backendName:"webgl",kernelFunc:rTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iTe(n,e,t,r){const s=Qe(e),o=Qe(n.shape)/s,a=At({inputs:{x:n},attrs:{shape:[o,s]},backend:r}),l=ym(a,n.dtype,"max",r),u=At({inputs:{x:l},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l5(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:i,keepDims:o}=r,a=s.shape.length,l=qn(i,s.shape);let u=l;const c=ps(u,a),h=c!=null,d=t.shouldExecuteOnCPU([s]);let p=s;if(h){if(d){const T=t.texData.get(p.dataId).values,E=new Array(a);for(let $=0;$<E.length;$++)E[$]=s.shape[c[$]];const N=ZR(T,s.shape,s.dtype,c,E);p=t.makeTensorInfo(E,s.dtype);const M=t.texData.get(p.dataId);M.values=N}else p=UE(s,c,t);u=Ms(u.length,a)}Li("max",u,a);const[g,w]=_i(p.shape,u);let y=g;o&&(y=Vs(g,l));let x;if(d){const T=t.texData.get(p.dataId).values,E=dxe(T,Qe(w),y,s.dtype);x=t.makeTensorInfo(y,s.dtype);const N=t.texData.get(x.dataId);N.values=E}else x=iTe(p,w,y,t);return h&&t.disposeIntermediateTensorInfo(p),x}const oTe={kernelName:UT,backendName:"webgl",kernelFunc:l5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aTe=JR+`
  return max(a, b);
`,lTe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+gm+`
  return result;
`,uTe=Oi({opSnippet:aTe,packedOpSnippet:lTe,cpuKernelImpl:fxe}),cTe={kernelName:N1,backendName:"webgl",kernelFunc:uTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;pw(s,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=r,u=1;ie(Ji(o,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const c=El(s.shape,i,o,u,a,l);if(c.filterWidth===1&&c.filterHeight===1&&_r(c.inShape,c.outShape))return Ea({inputs:{x:s},backend:t});const h=new Ax(c,"max",!1);return t.runWebGLProgram(h,[s],s.dtype)}const dTe={kernelName:VT,backendName:"webgl",kernelFunc:hTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fTe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],h=vh(s.shape,i,o,c,a,u,l),d=new eD(h,"max",!1);return t.runWebGLProgram(d,[s],s.dtype)}const pTe={kernelName:WT,backendName:"webgl",kernelFunc:fTe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mTe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=i-1-e.padInfo.top,l=o-1-e.padInfo.left,u=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class gTe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,r=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=l-1-e.padInfo.front,d=u-1-e.padInfo.top,p=c-1-e.padInfo.left,g=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${g} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yTe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i}=e,o=i,{filterSize:a,strides:l,pad:u,dimRoundingMode:c}=r,h=[1,1,1],d=vh(o.shape,a,l,h,u,c),p=new eD(d,"max",!0),g=t.runWebGLProgram(p,[o],o.dtype),w=new gTe(d),y=t.runWebGLProgram(w,[s,g],o.dtype);return t.disposeIntermediateTensorInfo(g),y}const vTe={kernelName:KM,backendName:"webgl",kernelFunc:yTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xTe(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:i,output:o}=e,a=i;pw([i,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=r,d=El(a.shape,l,u,1,c,h),p=!0,g=new Ax(d,"max",p),w=t.runWebGLProgram(g,[a],a.dtype),y=new mTe(d),x=t.runWebGLProgram(y,[s,w],a.dtype);return t.disposeIntermediateTensorInfo(w),x}const wTe={kernelName:qM,backendName:"webgl",kernelFunc:xTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bTe(n,e,t,r){let s=new Ax(t,"max",!1);const i=r.runWebGLProgram(s,[n],"float32");s=new Ax(t,"max",!0,!0,e);const o=r.runWebGLProgram(s,[n],"float32");return[i,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const STe={kernelName:jB,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:s,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;ie(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];ie(Ji(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=El(r.shape,s,i,u,o),[h,d]=bTe(r,a,c,l);return[h,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Te(n,e,t,r){const s=Qe(e),o=Qe(n.shape)/s,a=At({inputs:{x:n},attrs:{shape:[o,s]},backend:r}),l=ym(a,"float32","mean",r),u=At({inputs:{x:l},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TTe={kernelName:GT,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{keepDims:s,axis:i}=e,o=t,a=r.shape.length,l=qn(i,r.shape);let u=l;const c=ps(u,a),h=c!=null,d=o.shouldExecuteOnCPU([r]),p=[];let g=r;if(h){if(d){const E=o.texData.get(g.dataId).values,N=new Array(a);for(let L=0;L<N.length;L++)N[L]=r.shape[c[L]];const M=ZR(E,r.shape,r.dtype,c,N);g=o.makeTensorInfo(N,r.dtype);const $=o.texData.get(g.dataId);$.values=M}else g=UE(r,c,o);p.push(g),u=Ms(u.length,a)}Li("sum",u,a);const[w,y]=_i(g.shape,u);let x=w;s&&(x=Vs(w,l));const _=_Te(g,y,x,o);for(const T of p)o.disposeIntermediateTensorInfo(T);return _}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ETe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=qn(i,s.shape);let u=l;const c=ps(u,a);let h=s;c!=null&&(h=Co({inputs:{x:s},backend:t,attrs:{perm:c}}),u=Ms(u.length,s.shape.length)),Li("min",u,a);const[d,p]=_i(h.shape,u),g=Qe(p),w=At({inputs:{x:h},backend:t,attrs:{shape:[-1,g]}}),y=ym(w,w.dtype,"min",t);let x;if(o){const _=Vs(d,l);x=At({inputs:{x:y},backend:t,attrs:{shape:_}})}else x=At({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(y),c!=null&&t.disposeIntermediateTensorInfo(h),x}const CTe={kernelName:HT,backendName:"webgl",kernelFunc:ETe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ITe=JR+`
  return min(a, b);
`,NTe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+gm+`
  return result;
`,ATe=Oi({opSnippet:ITe,packedOpSnippet:NTe,cpuKernelImpl:pxe}),MTe={kernelName:A1,backendName:"webgl",kernelFunc:ATe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kTe{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((c,h)=>c[0]+e[h]+c[1]);const s=e.length,i=Or(s),o=t.map(c=>c[0]).join(","),a=t.map((c,h)=>c[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RTe{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((g,w)=>g[0]+e[w]+g[1]);const s=e.length,i=Or(s),o=t.map(g=>g[0]).join(","),a=t.map((g,w)=>g[0]+e[w]).join(","),l=yo("rc",s),u=yo("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${u.slice(-2).join()})`,d=r==="reflect"?0:1;let p="";if(s===1){const g=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[s-1]} += 1;
        if(${c}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
      `}else{const g=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${g}
        result[0] = getChannel(getX(${u.join()}), ${h});
        ${l[s-1]} += 1;
        if(${c}) {
          ${g}
          result[1] = getChannel(getX(${u.join()}), ${h});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${g}
          result[2] = getChannel(getX(${u.join()}), ${h});
          ${l[s-1]} += 1;
          if(${c}) {
            ${g}
            result[3] = getChannel(getX(${u.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DTe=({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{paddings:s,mode:i}=t,o=je().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new RTe(r.shape,s,i):new kTe(r.shape,s,i);return e.runWebGLProgram(o,[r],r.dtype)},$Te={kernelName:jT,backendName:"webgl",kernelFunc:DTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PTe=`if (b == 0.0) return NAN;
  return mod(a, b);`,LTe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+gm+`
  return result;
`,OTe=Oi({opSnippet:PTe,packedOpSnippet:LTe}),FTe={kernelName:M1,backendName:"webgl",kernelFunc:OTe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zTe{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BTe=`
if (a == b) {
  return 1.0;
};
return a / b;`,UTe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,u5=Oi({opSnippet:BTe,packedOpSnippet:UTe,checkOutOfBounds:!0}),VTe={kernelName:p1,backendName:"webgl",kernelFunc:u5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sO="return a - b;",c5=Oi({opSnippet:sO,packedOpSnippet:sO,supportsComplex:!0,cpuKernelImpl:Pxe}),WTe={kernelName:j1,backendName:"webgl",kernelFunc:c5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h5(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:i}=r,o=qn([i],s.shape),a=l5({inputs:{x:s},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=Vs(a.shape,o),u=At({inputs:{x:a},backend:t,attrs:{shape:l}}),c=c5({inputs:{a:s,b:u},backend:t}),h=i5({inputs:{x:c},backend:t}),d=VE({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),p=At({inputs:{x:d},backend:t,attrs:{shape:l}}),g=u5({inputs:{a:h,b:p},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),g}const GTe={kernelName:cE,backendName:"webgl",kernelFunc:h5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HTe(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:i,seed:o,normalized:a}=r,l=a?s:h5({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new zTe(u,c,i),d=[[o]],p=t.runWebGLProgram(h,[l],"int32",d);return a||t.disposeIntermediateTensorInfo(l),p}const jTe={kernelName:XB,backendName:"webgl",kernelFunc:HTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XTe=Il+`
  return -x;
`,qTe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function KTe(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const i=t.texData.get(r.dataId),[o,a]=gxe(i.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,o)}let s;return je().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new vd(r.shape,qTe):s=new Wu(r.shape,XTe),t.runWebGLProgram(s,[r],r.dtype)}const YTe={kernelName:XT,backendName:"webgl",kernelFunc:KTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZTe=Fk;function JTe(n){Wa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,u=t.readSync(s.dataId),c=t.readSync(i.dataId),{selectedIndices:h}=ZTe(u,c,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const QTe={kernelName:YM,backendName:"webgl",kernelFunc:JTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eEe=zk;function tEe(n){Wa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:u}=r,c=t.readSync(s.dataId),h=t.readSync(i.dataId),{selectedIndices:d,validOutputs:p}=eEe(c,h,o,a,l,u);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const nEe={kernelName:ZM,backendName:"webgl",kernelFunc:tEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rEe=Bk;function sEe(n){Wa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:u}=r,c=t.readSync(s.dataId),h=t.readSync(i.dataId),d=o,p=a,g=l,w=u,{selectedIndices:y,selectedScores:x}=rEe(c,h,d,p,g,w);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}const iEe={kernelName:JM,backendName:"webgl",kernelFunc:sEe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oEe{constructor(e,t,r,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aEe=n=>{const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:i,depth:o,onValue:a,offValue:l}=r,u=Qe(s.shape),c=new oEe(u,o,a,l),h=At({inputs:{x:s},backend:t,attrs:{shape:[u]}}),d=t.runWebGLProgram(c,[h],i);t.disposeIntermediateTensorInfo(h);const p=[...s.shape,o],g=At({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(d),g},lEe={kernelName:YT,backendName:"webgl",kernelFunc:aEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I_(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=gw({inputs:{input:r},backend:t}),i=I_({inputs:{x:s},backend:t}),o=WE({inputs:{input:r},backend:t}),a=I_({inputs:{x:o},backend:t}),l=sf({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return yw({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const uEe={kernelName:fE,backendName:"webgl",kernelFunc:I_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d5(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=gw({inputs:{input:r},backend:t}),i=d5({inputs:{x:s},backend:t}),o=WE({inputs:{input:r},backend:t}),a=I_({inputs:{x:o},backend:t}),l=sf({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return yw({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const cEe={kernelName:KT,backendName:"webgl",kernelFunc:d5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hEe(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return BN({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const i=e[0].shape,o=e[0].dtype;e.forEach(c=>{xM(i,c.shape,"All tensors passed to stack must have matching shapes"),ie(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(c=>{const h=BN({inputs:{input:c},backend:t,attrs:{dim:s}});return a.push(h),h}),u=ZH({inputs:l,backend:t,attrs:{axis:s}});return a.forEach(c=>t.disposeIntermediateTensorInfo(c)),u}const dEe={kernelName:ZT,backendName:"webgl",kernelFunc:hEe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fEe{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);const s=e.length,i=Or(s),o=t.map(u=>u[0]).join(","),a=t.map((u,c)=>u[0]+e[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pEe{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((w,y)=>w[0]+e[y]+w[1]);const s=e.length,i=Or(s),o=t.map(w=>w[0]).join(","),a=t.map((w,y)=>w[0]+e[y]).join(","),l=yo("rc",s),u=yo("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,h=s===1?"source":`vec2(${u.slice(-2).join()})`,d=[`${i} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${c}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${c}) {`],p=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let g="";for(let w=0,y=s===1?2:4;w<y;w++)g+=`
        ${d[w]}
        if (${p}) {
          result[${w}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${w}] = getChannel(getX(${u.join()}), ${h});
        }
      `;g+=s===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f5=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:i,constantValue:o}=r;if(Qe(s.shape)===0){const u=i.map((c,h)=>c[0]+s.shape[h]+c[1]);return yw({backend:t,attrs:{shape:u,value:o,dtype:s.dtype}})}const a=je().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new pEe(s.shape,i,o):new fEe(s.shape,i,o),l=[[o]];return t.runWebGLProgram(a,[s],s.dtype,l)},mEe={kernelName:JT,backendName:"webgl",kernelFunc:f5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gEe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,yEe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+gm+`
  return result;
`,vEe=Oi({opSnippet:gEe,packedOpSnippet:yEe}),xEe={kernelName:R1,backendName:"webgl",kernelFunc:vEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wEe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:i,keepDims:o}=r,a=s.shape.length,l=[],u=qn(i,s.shape);let c=u;const h=ps(c,a);let d=s;h!=null&&(d=Co({inputs:{x:s},backend:t,attrs:{perm:h}}),c=Ms(c.length,a),l.push(d)),Li("prod",c,a);let p;if(t.shouldExecuteOnCPU([d])){const g=t.texData.get(d.dataId).values,{outVals:w,outShape:y,outDtype:x}=vxe(d.shape,d.dtype,g,c);p=t.makeTensorInfo(y,x,w)}else{const[g,w]=_i(d.shape,c),y=Qe(w),x=At({inputs:{x:d},backend:t,attrs:{shape:[-1,y]}}),_=ck(s.dtype),T=ym(x,_,"prod",t);p=At({inputs:{x:T},backend:t,attrs:{shape:g}}),l.push(x),l.push(T)}if(o){l.push(p);const g=Vs(p.shape,u);p=At({inputs:{x:p},backend:t,attrs:{shape:g}})}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),p}const bEe={kernelName:eE,backendName:"webgl",kernelFunc:wEe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SEe(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:s,paramsDenseValues:i,indices:o}=e,{outputRaggedRank:a}=r,l=s.map(x=>t.readSync(x.dataId)),u=s.map(x=>x.shape),c=t.readSync(i.dataId),h=t.readSync(o.dataId),[d,p,g]=xxe(l,u,c,i.shape,i.dtype,h,o.shape,a),w=d.map(x=>t.makeTensorInfo([x.length],"int32",x)),y=t.makeTensorInfo(g,i.dtype,p);return w.concat([y])}const _Ee={kernelName:qB,backendName:"webgl",kernelFunc:SEe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TEe(n){const{inputs:e,backend:t}=n,{starts:r,limits:s,deltas:i}=e,o=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(i.dataId),[u,c]=wxe(o,r.shape,r.dtype,a,s.shape,l,i.shape),h=t.makeTensorInfo([u.length],"int32",u),d=t.makeTensorInfo([c.length],r.dtype,c);return[h,d]}const EEe={kernelName:KB,backendName:"webgl",kernelFunc:TEe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CEe(n){const{inputs:e,backend:t,attrs:r}=n,{shape:s,values:i,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,u=t.readSync(s.dataId),c=t.readSync(i.dataId),h=t.readSync(o.dataId),d=a.map(y=>t.readSync(y.dataId)),p=a.map(y=>y.shape),[g,w]=bxe(u,s.shape,c,i.shape,i.dtype,h,o.shape,d,p,l);return t.makeTensorInfo(g,i.dtype,w)}const IEe={kernelName:YB,backendName:"webgl",kernelFunc:CEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p5=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:i,dtype:o}=t,a=Sxe(r,s,i,o);return e.makeTensorInfo([a.length],o,a)},NEe={kernelName:QM,backendName:"webgl",kernelFunc:p5};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AEe="return 1.0 / x;",MEe=lr({opSnippet:AEe}),kEe={kernelName:D1,backendName:"webgl",kernelFunc:MEe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const REe=Il+`
  return (x < 0.0) ? 0.0 : x;
`,DEe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,$Ee=lr({opSnippet:REe,packedOpSnippet:DEe}),PEe={kernelName:$1,backendName:"webgl",kernelFunc:$Ee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LEe=Il+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,OEe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,FEe=lr({opSnippet:LEe,packedOpSnippet:OEe}),zEe={kernelName:P1,backendName:"webgl",kernelFunc:FEe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BEe{constructor(e,t,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,t,r,u];const c=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r];let d;i?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UEe{constructor(e,t,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,t,r,u];const c=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r];let d;i?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VEe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,u]=a,c=je().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new UEe(s.shape,l,u,i,o):new BEe(s.shape,l,u,i,o);return t.runWebGLProgram(c,[s],"float32")}const WEe={kernelName:rE,backendName:"webgl",kernelFunc:VEe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GEe{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,i]=t,[,o,a]=e,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],u=[r&&o>1?o-1:o,r&&a>1?a-1:a],c=l[0]/u[0],h=l[1]/u[1],d=1/c,p=1/h,g=Math.ceil(d)*2+2,w=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${g});
        const int winWidth = int(${w});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HEe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,a=new GEe(i.shape,s.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const jEe={kernelName:nk,backendName:"webgl",kernelFunc:HEe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XEe{constructor(e,t,r,s,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,t,r,u];const c=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r],d=s?"0.5":"0.0";let p;i?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qEe{constructor(e,t,r,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,u]=e;this.outputShape=[o,t,r,u];const c=[s&&t>1?a-1:a,s&&r>1?l-1:l],h=[s&&t>1?t-1:t,s&&r>1?r-1:r],d=s?"0.5":"0.0";let p;i?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KEe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:i,halfPixelCenters:o,size:a}=r,[l,u]=a,c=je().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new qEe(s.shape,l,u,i,o):new XEe(s.shape,l,u,i,o);return t.runWebGLProgram(c,[s],s.dtype)}const YEe={kernelName:nE,backendName:"webgl",kernelFunc:KEe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZEe{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,i]=t,[,o,a]=e,l=[r&&o>1?s-1:s,r&&a>1?i-1:i],u=[r&&o>1?o-1:o,r&&a>1?a-1:a],c=l[0]/u[0],h=l[1]/u[1],d=1/c,p=1/h,g=Math.ceil(d)*2+2,w=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${g});
        const int winWidth = int(${w});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JEe(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:i}=e,{alignCorners:o}=r,a=new ZEe(i.shape,s.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const QEe={kernelName:tk,backendName:"webgl",kernelFunc:JEe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eCe{constructor(e,t){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const s=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,i=e.map((a,l)=>s(l)).join(","),o=Or(r);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tCe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const s=yo("rc",r),i=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,a=Or(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${i}){
            result.g = ${u(s.slice())};
          }
          if(${o}) {
            result.b = ${c(s.slice())};
            if(${i}) {
              result.a = ${h(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(g){return d(g)}function u(g){return g[r-1]="("+g[r-1]+" + 1)",d(g)}function c(g){return g[r-2]="("+g[r-2]+" + 1)",d(g)}function h(g){return g[r-1]="("+g[r-1]+" + 1)",g[r-2]="("+g[r-2]+" + 1)",d(g)}function d(g){const w=e.map((_,T)=>p(T,g)),y=w.join(","),x=w.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${x}))`}function p(g,w){return t.indexOf(g)!==-1&&e[g]!==1?`${e[g]} - ${w[g]} - 1`:`${w[g]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:i}=r,o=s.shape.length,a=qn(i,s.shape);if(o===0)return Ea({inputs:{x:s},backend:t});const l=je().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tCe(s.shape,a):new eCe(s.shape,a);return t.runWebGLProgram(l,[s],s.dtype)}const rCe={kernelName:sE,backendName:"webgl",kernelFunc:nCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sCe{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],s=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iCe={kernelName:uk,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:i,center:o}=e,a=t,l=new sCe(r.shape,i),[u,c]=Zk(o,r.shape[1],r.shape[2]),h=[[u,c,Math.sin(s),Math.cos(s)]];return a.runWebGLProgram(l,[r],r.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oCe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,aCe=lr({opSnippet:oCe}),lCe={kernelName:L1,backendName:"webgl",kernelFunc:aCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uCe="return inversesqrt(x);",cCe=lr({opSnippet:uCe,cpuKernelImpl:_xe}),hCe={kernelName:O1,backendName:"webgl",kernelFunc:cCe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tD{constructor(e,t,r,s,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const u=Or(i.length),c=Or(o.length);let h="";r===1?h="i":r===2&&(h="i, j");const d=`getIndices(${h})`;let p="";s===1?p="i":s===2&&(p="i, coords[1]");const g=`getUpdates(${p})`;let w="";l&&(w="coords[0], coords[1]");const y=`getDefaultValue(${w})`,x=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${x};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${g};
              found = true;
            }
          }
          setOutput(mix(${y}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dCe{constructor(e,t,r,s,i,o,a=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const u=Or(i.length),c=Or(o.length);let h="";r===1?h="i":r===2&&(h="i, j");const d=`getIndices(${h})`;let p="";s===1?p="i":s===2&&(p="i, coords[1]");const g=`getUpdates(${p})`;let w="";l&&(w="coords[0], coords[1]");const y=`getDefaultValue(${w})`,x=t>1?"strides[j]":"strides",_=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${x};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${_};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${g};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${y}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fCe(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:i}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=hm(i,s,o),d=[h/u,u];if(h===0)return t.makeTensorInfo(o,s.dtype);const p=At({inputs:{x:s},backend:t,attrs:{shape:[l,a]}}),g=At({inputs:{x:i},backend:t,attrs:{shape:[l,u]}}),w=t.makeTensorInfo([],"float32",new Float32Array([0]));let y;je().getBool("WEBGL_PACK")?y=new dCe(l,a,p.shape.length,g.shape.length,c,d):y=new tD(l,a,p.shape.length,g.shape.length,c,d);const x=t.runWebGLProgram(y,[g,p,w],g.dtype),_=At({inputs:{x},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w),_}const pCe={kernelName:ZB,backendName:"webgl",kernelFunc:fCe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mCe{constructor(e,t,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const i="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=je().getNumber("WEBGL_VERSION")===2?i:o,l=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gCe(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:i}=e,{side:o}=r,a=new mCe(s.shape[0],s.shape[1],i.shape[1],o),l=[[s.shape[1]]];return t.runWebGLProgram(a,[s,i],"int32",l)}const yCe={kernelName:QB,backendName:"webgl",kernelFunc:gCe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vCe{constructor(e,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let s,i;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)i="resRC",s="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<t.length;c++)u.push(`${a[c]}`),c<e&&l.push(`${a[c]}`);s=l.join(),i=u.join()}const o=Or(r);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xCe(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:i}=e,o=new vCe(r.shape.length,s.shape,s.shape.length);return t.runWebGLProgram(o,[r,s,i],_a(s.dtype,i.dtype))}const wCe={kernelName:iE,backendName:"webgl",kernelFunc:xCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bCe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${EE};
  float scale = ${CE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,SCe=lr({opSnippet:bCe}),_Ce={kernelName:F1,backendName:"webgl",kernelFunc:SCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TCe=l0+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,ECe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,CCe=lr({opSnippet:TCe,packedOpSnippet:ECe,cpuKernelImpl:Exe}),ICe={kernelName:V1,backendName:"webgl",kernelFunc:CCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NCe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,ACe=lr({opSnippet:NCe}),MCe={kernelName:U1,backendName:"webgl",kernelFunc:ACe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kCe=l0+`
  return sin(x);
`,RCe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${gm}
  return result;
`,DCe=lr({opSnippet:kCe,packedOpSnippet:RCe}),$Ce={kernelName:z1,backendName:"webgl",kernelFunc:DCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PCe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,LCe=lr({opSnippet:PCe}),OCe={kernelName:B1,backendName:"webgl",kernelFunc:LCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FCe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,zCe=lr({opSnippet:FCe}),BCe={kernelName:W1,backendName:"webgl",kernelFunc:zCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UCe=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:i,paddings:o}=r;ie(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((x,_)=>x*_),l=[[0,0]];l.push(...o);for(let x=1+i.length;x<s.shape.length;++x)l.push([0,0]);const u=[],c=f5({inputs:{x:s},backend:t,attrs:{paddings:l,constantValue:0}}),h=rw(c.shape,i,a,!1),d=sw(h.length,i.length,!1),p=iw(c.shape,i,a,!1),g=At({inputs:{x:c},backend:t,attrs:{shape:h}}),w=Co({inputs:{x:g},backend:t,attrs:{perm:d}}),y=At({inputs:{x:w},backend:t,attrs:{shape:p}});return u.push(c),u.push(g),u.push(w),u.forEach(x=>t.disposeIntermediateTensorInfo(x)),y},VCe={kernelName:lE,backendName:"webgl",kernelFunc:UCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WCe(n){const{inputs:e,backend:t}=n,{indices:r,values:s,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(r.dataId),l=t.readSync(s.dataId),u=t.readSync(i.dataId),c=t.readSync(o.dataId)[0],[h,d,p,g,w]=Ixe(a,r.shape,r.dtype,l,s.dtype,u,c);return[t.makeTensorInfo(d,r.dtype,h),t.makeTensorInfo([d[0]],s.dtype,p),t.makeTensorInfo([g.length],"bool",new Uint8Array(g.map(y=>Number(y)))),t.makeTensorInfo([w.length],r.dtype,new Int32Array(w))]}const GCe={kernelName:eU,backendName:"webgl",kernelFunc:WCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HCe(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:s,newShape:i}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.readSync(s.dataId)),a=t.readSync(r.dataId),l=Array.from(t.readSync(i.dataId)),[u,c,h]=Nxe(a,r.shape,r.dtype,o,l);return[t.makeTensorInfo(c,r.dtype,u),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const jCe={kernelName:tU,backendName:"webgl",kernelFunc:HCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XCe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(i.dataId),[u,c]=FH(o,r.shape,r.dtype,a,l,!0);return t.makeTensorInfo(c,r.dtype,u)}const qCe={kernelName:nU,backendName:"webgl",kernelFunc:XCe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KCe(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:i}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=t.readSync(r.dataId),a=t.readSync(s.dataId),l=t.readSync(i.dataId),[u,c]=FH(o,r.shape,r.dtype,a,l);return t.makeTensorInfo(c,r.dtype,u)}const YCe={kernelName:rU,backendName:"webgl",kernelFunc:KCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZCe(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:i,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=hm(i,s,a),p=!1;if(i.dtype==="string"){const x=t.bufferSync(s),_=t.bufferSync(i),T=Rd(t.readSync(o.dataId)[0]),E=Txe(x,_,a,d,c,u,l,h,T,p);return t.makeTensorInfo(a,E.dtype,E.values)}const g=new tD(u,l,s.shape.length,i.shape.length,h,[d,1],p),w=t.runWebGLProgram(g,[i,s,o],i.dtype),y=At({inputs:{x:w},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(w),y}const JCe={kernelName:sU,backendName:"webgl",kernelFunc:ZCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QCe(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:i,axis:o}=r,a=qn(o,s.shape)[0],l=dR(s,i,a),u=s.shape.length,c=new Array(u).fill(0),h=s.shape.slice();return l.map(d=>{const p=[...h];p[a]=d;const g=u0({inputs:{x:s},backend:t,attrs:{begin:c,size:p}});return c[a]+=d,g})}const e2e={kernelName:uE,backendName:"webgl",kernelFunc:QCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iO="return sqrt(x);",t2e=lr({opSnippet:iO,packedOpSnippet:iO,cpuKernelImpl:Axe}),n2e={kernelName:G1,backendName:"webgl",kernelFunc:t2e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r2e="return x * x;",s2e=lr({opSnippet:r2e}),i2e={kernelName:rk,backendName:"webgl",kernelFunc:s2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oO="return (a - b) * (a - b);",o2e=Oi({opSnippet:oO,packedOpSnippet:oO}),a2e={kernelName:H1,backendName:"webgl",kernelFunc:o2e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const i=t.readSync(s.dataId),o=hh(i),a=Mxe(o,"string",r);return t.makeTensorInfo(s.shape,"string",a)}const u2e={kernelName:sk,backendName:"webgl",kernelFunc:l2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c2e({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=Il+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new Wu(r.shape,s);return t.runWebGLProgram(i,[r],r.dtype)}const h2e={kernelName:Y1,backendName:"webgl",kernelFunc:c2e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d2e{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,i=Or(r.length),o=Or(r.length);let a="";if(s===1)a="coords * strides + begin";else{let l=0;a=r.map((u,c)=>(l++,r.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:g,isIdentity:w,sliceDim0:y,isSimpleSlice:x,begin:_,end:T,strides:E}=qk(s.shape,i,o,a,l,u,c,h,d);let N;if(w)N=At({inputs:{x:s},backend:t,attrs:{shape:g}});else if(y||x){ie(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const $=Hk(_,T,E),L=u0({inputs:{x:s},backend:t,attrs:{begin:_,size:$}});N=At({inputs:{x:L},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo(L)}else if(t.shouldExecuteOnCPU([s])){const L=t.readSync(s.dataId),k=Xn(s.shape,s.dtype,L),R=kxe(p,k,E,_);N=t.makeTensorInfo(g,s.dtype,R.values)}else{const L=new d2e(_,E,p);N=t.runWebGLProgram(L,[s],s.dtype)}const M=At({inputs:{x:N},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(N),M}const p2e={kernelName:ik,backendName:"webgl",kernelFunc:f2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m2e(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:h}=e,d=t.readSync(c.dataId),p=t.readSync(h.dataId),[g,w]=Rxe(d,p,s,i,o,a,l,u);return[t.makeTensorInfo([g.length],"string",g),t.makeTensorInfo(h.shape,"int32",w)]}const g2e={kernelName:iU,backendName:"webgl",kernelFunc:m2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y2e(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:s}=r,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(i.dataId),l=t.readSync(o.dataId)[0],[u,c,h]=Dxe(a,l,s),d=c.length;return[t.makeTensorInfo([d,2],"int32",u),t.makeTensorInfo([d],"string",c),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const v2e={kernelName:oU,backendName:"webgl",kernelFunc:y2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2e(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:s}=r,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(i.dataId),a=$xe(o,s);return t.makeTensorInfo(i.shape,"int32",a)}const w2e={kernelName:aU,backendName:"webgl",kernelFunc:x2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b2e="return tan(x);",S2e=lr({opSnippet:b2e}),_2e={kernelName:X1,backendName:"webgl",kernelFunc:S2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T2e=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,E2e=lr({opSnippet:T2e}),C2e={kernelName:q1,backendName:"webgl",kernelFunc:E2e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I2e(n){const{inputs:e,backend:t,attrs:r}=n,{tensor:s,indices:i,updates:o}=e,{sliceRank:a,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=hm(o,i,s.shape),d=[h/u,u];if(h===0)return t.makeTensorInfo(s.shape,i.dtype);const p=At({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),g=At({inputs:{x:o},backend:t,attrs:{shape:[l,u]}}),w=At({inputs:{x:s},backend:t,attrs:{shape:d}}),y=new tD(l,a,p.shape.length,g.shape.length,c,d,!1,!0),x=t.runWebGLProgram(y,[g,p,w],w.dtype),_=At({inputs:{x},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(x),_}const N2e={kernelName:JB,backendName:"webgl",kernelFunc:I2e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class A2e{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[o]*t[o];this.outputShape=r,this.rank=r.length;const s=Or(this.rank),i=M2e(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function M2e(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<n.length;s++)r.push(`imod(${t[s]}, ${n[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m5(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:i}=r;if(s.dtype==="string"||s.shape.length>5){const l=t.readSync(s.dataId),u=s.dtype==="string"?l.map(d=>Rd(d)):l,c=Xn(s.shape,s.dtype,u),h=Lxe(c,i);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new A2e(s.shape,i);return t.runWebGLProgram(o,[s],s.dtype)}const k2e={kernelName:K1,backendName:"webgl",kernelFunc:m5};class R2e{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class D2e{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ip(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function aO(n){let e=1;for(;e<n;)e*=2;return e}function $2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:i,sorted:o}=r,a=je().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=je().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(t.shouldExecuteOnCPU([s])||c<a||i>l){const R=t.readSync(s.dataId),[P,B]=Oxe(R,u,s.dtype,i,o);return[t.makeTensorInfo(P.shape,P.dtype,P.values),t.makeTensorInfo(B.shape,B.dtype,B.values)]}if(i===0)return u[u.length-1]=0,[t.makeTensorInfo(u,s.dtype,[]),t.makeTensorInfo(u,"int32",[])];if(c===1)return[s,yw({attrs:{shape:u,dtype:"int32",value:0},backend:t})];const h=t.texData.get(s.dataId),d=h!==null&&h.isPacked,p=d?t.unpackTensor(s):s,w=Qe(u)/c,y=At({inputs:{x:p},attrs:{shape:[w,c]},backend:t});d&&ip(t,p);const x=aO(i),_=aO(c);let T=null;const E=()=>T===null?[y,y]:[y,T],N=(R,P,B)=>{const Z=E(),V=new R2e(B),q=[[c],[T===null?1:0],[Number.NEGATIVE_INFINITY],[R],[P]],se=T;T=t.runWebGLProgram(V,Z,"int32",q),ip(t,se)};for(let R=1;R<x;R*=2){const P=R*2;for(let B=R;B>=1;B/=2)N(P,B,[w,_])}for(let R=_;R>x;R/=2){const P=E(),B=new D2e([w,R/2]),V=[[c],[T===null?1:0],[x]],X=T;T=t.runWebGLProgram(B,P,"int32",V),ip(t,X);const q=x/2,se=q*2;for(let W=q;W>=1;W/=2)N(se,W,T.shape)}let M=T;T=u0({inputs:{x:T},backend:t,attrs:{begin:0,size:[w,i]}}),ip(t,M);let $=a5({inputs:{x:y,indices:T},backend:t,attrs:{axis:1,batchDims:1}});ip(t,y);const L=u.slice(0,-1);L.push(i),M=T,T=At({inputs:{x:T},attrs:{shape:L},backend:t}),ip(t,M);const k=$;return $=At({inputs:{x:$},attrs:{shape:L},backend:t}),ip(t,k),[$,T]}const P2e={kernelName:ok,backendName:"webgl",kernelFunc:$2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class L2e{constructor(e,t,r,s,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=r==="nearest"?1:2;let l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O2e(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:u}=r,[c,h,d,p]=s.shape,[g,w]=u??[h,d],y=[c,g,w,p],x=new L2e(h,d,o,a,l,y);return t.runWebGLProgram(x,[s,i],"float32")}const F2e={kernelName:ak,backendName:"webgl",kernelFunc:O2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2e(n){const{inputs:e,attrs:t,backend:r}=n,{axis:s}=t,{x:i}=e;pw(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(i.dataId),{outputValues:a,outputShape:l,indices:u}=Fxe(o,s,i.shape,i.dtype);return[r.makeTensorInfo(l,i.dtype,a),r.makeTensorInfo([u.length],"int32",u)]}const B2e={kernelName:lk,backendName:"webgl",kernelFunc:z2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U2e(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:i}=r;i<0&&(i+=s.shape.length);const o=s,a=o.shape.length,l=s.shape[i],u=new Array(a-1);let c=0;for(let w=0;w<a;w++)w!==i&&(u[c++]=o.shape[w]);const h=[],d=new Array(a).fill(0),p=o.shape.slice();p[i]=1;const g=new Array(l);for(let w=0;w<g.length;w++){d[i]=w;const y=u0({inputs:{x:o},backend:t,attrs:{begin:d,size:p}}),x=At({inputs:{x:y},backend:t,attrs:{shape:u}});g[w]=x,h.push(y)}return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),g}const V2e={kernelName:hE,backendName:"webgl",kernelFunc:U2e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W2e{constructor(e,t){this.variableNames=["x","segmentIds"];const r=e.windowSize,s=e.batchSize,i=e.inSize,o=e.numSegments,a=o*Math.ceil(i/r);this.outputShape=[s,a];const l="0.0",u="sumValue",c=Math.floor(r/4)*4,h=r%4,d=`
        sumValue += dot(values, segFilter);
    `;let p="";i%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let g="";i%r>0&&(g=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${g}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G2e(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:i}=e,{numSegments:o}=r,a=s.shape.length,l=[];let u=0;const c=ps([u],a);let h=s;c!=null&&(h=Co({inputs:{x:s},backend:t,attrs:{perm:c}}),l.push(h),u=Ms(1,a)[0]);const d=Y4(h.shape,u,o),p=Qe([h.shape[u]]),g=At({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}});l.push(g);const w=ck(s.dtype),y=(E,N,M,$,L)=>{const k=E.shape[0],R=E.shape[1],P=K4(R,L),B={windowSize:P,inSize:R,batchSize:k,numSegments:L},Z=new W2e(B,N),V=t.compileAndRun(Z,[E,M],$);if(l.push(V),V.shape[1]===L)return V;const X=p5({backend:t,attrs:{start:0,stop:L,step:1,dtype:"float32"}}),q=m5({inputs:{x:X},backend:t,attrs:{reps:[R/P]}});return l.push(X),l.push(q),y(V,N,q,$,L)},x=y(g,"unsortedSegmentSum",i,w,o),_=At({inputs:{x},backend:t,attrs:{shape:d}});let T=_;if(c!=null){l.push(_);const E=Jd(c);T=Co({inputs:{x:T},backend:t,attrs:{perm:E}})}return l.forEach(E=>t.disposeIntermediateTensorInfo(E)),T}const H2e={kernelName:dE,backendName:"webgl",kernelFunc:G2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j2e=[A1e,k1e,$1e,O1e,z1e,V1e,G1e,j1e,Y1e,J1e,twe,swe,awe,hwe,pwe,gwe,vwe,Swe,Twe,Cwe,Mwe,Owe,zwe,Wwe,Hwe,Zwe,Qwe,rbe,d1e,obe,hbe,mbe,bbe,Tbe,Cbe,Nbe,Mbe,$be,Obe,Bbe,Vbe,Gbe,jbe,Kbe,Zbe,tSe,rSe,oSe,uSe,hSe,mSe,xSe,_Se,CSe,ASe,MSe,RSe,$Se,LSe,FSe,BSe,GSe,XSe,YSe,JSe,t_e,s_e,l_e,d_e,h1e,p_e,ube,y_e,w_e,__e,p1e,I_e,k_e,D_e,O_e,B_e,G_e,X_e,Z_e,tTe,sTe,oTe,cTe,dTe,pTe,vTe,wTe,STe,TTe,CTe,MTe,$Te,FTe,jTe,y1e,YTe,QTe,nEe,iEe,Xwe,lEe,cEe,dEe,mEe,xEe,g1e,bEe,_Ee,EEe,IEe,NEe,qwe,VTe,kEe,PEe,zEe,x1e,WEe,jEe,YEe,QEe,rCe,iCe,lCe,hCe,pCe,yCe,wCe,_Ce,ICe,MCe,$Ce,OCe,Pwe,GTe,BCe,VCe,GCe,jCe,qCe,YCe,JCe,e2e,n2e,i2e,a2e,u2e,h2e,p2e,g2e,v2e,w2e,WTe,C1e,_2e,C2e,N2e,k2e,P2e,F2e,I1e,B2e,V2e,H2e,uEe];for(const n of j2e)uU(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X2e=1e-7,q2e=1e-4;class K2e{refCount(e){return pa("refCount")}incRef(e){return pa("incRef")}timerAvailable(){return!0}time(e){return pa("time")}read(e){return pa("read")}readSync(e){return pa("readSync")}readToGPU(e,t){return pa("readToGPU")}numDataIds(){return pa("numDataIds")}disposeData(e,t){return pa("disposeData")}write(e,t,r){return pa("write")}move(e,t,r,s,i){return pa("move")}createTensorFromGPUData(e,t,r){return pa("createTensorFromGPUData")}memory(){return pa("memory")}floatPrecision(){return pa("floatPrecision")}epsilon(){return this.floatPrecision()===32?X2e:q2e}dispose(){return pa("dispose")}}function pa(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function de(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Nl(n,e,t=""){de(dh(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function c0(n){de(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Bs(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function Y2e(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function dh(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function kx(n){return n%1===0}function VS(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function GE(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),de(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),de(n.every(r=>kx(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function Z2e(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||s?null:GE(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),i[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function J2e(n,e){return g5(n,e)}function g5(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function Q2e(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function eIe(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function UN(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function tIe(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function nD(n){return typeof n=="string"||n instanceof String}function nIe(n){return typeof n=="boolean"}function rIe(n){return typeof n=="number"}function HE(n){return Array.isArray(n)?HE(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":rIe(n)?"float32":nD(n)?"string":nIe(n)?"bool":"float32"}function VN(n){return!!(n&&n.constructor&&n.call&&n.apply)}function rD(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function y5(n,e,t,r=!1){const s=new Array;if(e.length===1){const i=e[0]*(r?2:1);for(let o=0;o<i;o++)s[o]=t[n+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<i;l++)s[l]=y5(n+l*a,o,t,r)}return s}function WN(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,i)=>s*i)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return y5(0,n,e,t)}function v5(n,e){const t=sD(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function sD(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function Ja(n){n.forEach(e=>{de(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Jp(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lO="tfjsflags";class sIe{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=iIe,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(kn().getBool("IS_TEST")||kn().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];kn().getBool("IS_TEST")||kn().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Jp(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);lO in e&&e[lO].split(",").forEach(r=>{const[s,i]=r.split(":");this.urlFlags[s]=aIe(s,i)})}}function iIe(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(oIe(e,r[0],r[1]),r.join("="))),e}function oIe(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function aIe(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function kn(){return x5}let x5=null;function lIe(n){x5=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tI;function w5(){if(tI==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");tI=n}return tI}function uIe(){const n=w5();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function iD(n,e){const t=uIe();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const cIe="Abs",hIe="Acos",dIe="Acosh",b5="Add",fIe="AddN",pIe="All",mIe="Any",gIe="ArgMax",yIe="ArgMin",vIe="Asin",xIe="Asinh",wIe="Atan",bIe="Atanh",SIe="Atan2",_Ie="AvgPool",TIe="AvgPool3D",EIe="BatchMatMul",CIe="BatchToSpaceND",IIe="Bincount",NIe="BitwiseAnd",AIe="BroadcastArgs",S5="Cast",MIe="Ceil",kIe="ClipByValue",RIe="Complex",DIe="ComplexAbs",$Ie="Concat",PIe="Conv2D",LIe="Conv2DBackpropFilter",OIe="Conv2DBackpropInput",FIe="Conv3D",zIe="Conv3DBackpropInputV2",BIe="Cos",UIe="Cosh",VIe="Cumprod",WIe="Cumsum",GIe="CropAndResize",HIe="DenseBincount",jIe="DepthToSpace",XIe="DepthwiseConv2dNative",qIe="DepthwiseConv2dNativeBackpropFilter",KIe="DepthwiseConv2dNativeBackpropInput",YIe="Diag",ZIe="Dilation2D",JIe="RealDiv",QIe="Einsum",eNe="Elu",tNe="Erf",nNe="Equal",rNe="Exp",sNe="ExpandDims",iNe="Expm1",oNe="FFT",aNe="Fill",lNe="FlipLeftRight",uNe="Floor",cNe="FloorDiv",hNe="FusedBatchNorm",dNe="GatherV2",fNe="GatherNd",pNe="Greater",mNe="GreaterEqual",_5="Identity",gNe="IFFT",yNe="Imag",vNe="IsFinite",xNe="IsInf",wNe="IsNan",bNe="LeakyRelu",SNe="Less",_Ne="LessEqual",TNe="LinSpace",ENe="Log",CNe="Log1p",INe="LogicalAnd",NNe="LogicalNot",ANe="LogicalOr",MNe="LRN",kNe="Max",RNe="Maximum",DNe="MaxPool",$Ne="MaxPool3D",PNe="MaxPoolWithArgmax",LNe="Mean",ONe="Min",FNe="Minimum",zNe="MirrorPad",BNe="Mod",UNe="Multinomial",VNe="Multiply",WNe="Neg",GNe="NotEqual",HNe="NonMaxSuppressionV3",jNe="NonMaxSuppressionV4",XNe="NonMaxSuppressionV5",qNe="OnesLike",KNe="OneHot",YNe="Pack",ZNe="PadV2",JNe="Pow",QNe="Prelu",eAe="Prod",tAe="RaggedGather",nAe="RaggedRange",rAe="RaggedTensorToTensor",sAe="Range",iAe="Real",oAe="Reciprocal",aAe="Relu",lAe="Reshape",uAe="ResizeNearestNeighbor",cAe="ResizeBilinear",hAe="Relu6",dAe="Reverse",fAe="Round",pAe="Rsqrt",mAe="ScatterNd",gAe="TensorScatterUpdate",yAe="SearchSorted",vAe="Select",xAe="Selu",wAe="Slice",bAe="Sin",SAe="Sinh",_Ae="Sign",TAe="Sigmoid",EAe="Softplus",CAe="Sqrt",IAe="Sum",NAe="SpaceToBatchND",AAe="SplitV",MAe="Softmax",kAe="SparseFillEmptyRows",RAe="SparseReshape",DAe="SparseSegmentMean",$Ae="SparseSegmentSum",PAe="SparseToDense",LAe="SquaredDifference",OAe="StaticRegexReplace",FAe="StridedSlice",zAe="StringNGrams",BAe="StringSplit",UAe="StringToHashBucketFast",VAe="Sub",WAe="Tan",GAe="Tanh",T5="Tile",HAe="TopK",jAe="Transform",nI="Transpose",XAe="Unique",qAe="Unpack",KAe="UnsortedSegmentSum",YAe="ZerosLike",ZAe="Step",uO="FromPixels",JAe="RotateWithOffset",cO="_FusedMatMul",hO="FusedConv2D",dO="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nv(...n){kn().getBool("IS_TEST")||kn().getBool("PROD")||console.warn(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E5=iD("kernelRegistry",()=>new Map),QAe=iD("gradRegistry",()=>new Map);function GN(n,e){const t=eMe(n,e);return E5.get(t)}function fO(n){return QAe.get(n)}function pO(n){const e=E5.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[i,o]=s,[a]=i.split("_");a===n&&t.push(o)}return t}function eMe(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C5(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tMe(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function I5(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Rx(n)),kn().getBool("DEBUG")&&Q2e(n,e),tMe(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function N_(){return kn().platform.now()}function nMe(n,e){return kn().platform.fetch(n,e)}function rMe(n,e="utf-8"){return e=e||"utf-8",kn().platform.encode(n,e)}function mO(n,e="utf-8"){return e=e||"utf-8",kn().platform.decode(n,e)}function _l(n){return kn().platform.isTypedArray!=null?kn().platform.isTypedArray(n):C5(n)}function Rx(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Jp(n)||n==null||_l(n)&&t)e.push(n);else if(Array.isArray(n)||_l(n))for(let r=0;r<n.length;++r)Rx(n[r],e,t);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Rx(n[s],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sMe{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new oMe)}profileKernel(e,t,r){let s;const i=()=>{s=r()};let o;const a=N_();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const u of s)u.dataSync();o=Promise.resolve({kernelMs:N_()-a})}if(kn().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(h=>{iMe(h,c.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:o.then(u=>u.kernelMs),extraInfo:o.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:i,extraInfo:o}=e;r.forEach(a=>{Promise.all([a.data(),s,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],i,l[2])})})}}function iMe(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class oMe{logKernelProfile(e,t,r,s,i,o){const a=typeof s=="number"?VS(`${s}ms`,9):s.error,l=VS(e,25),u=t.rank,c=t.size,h=VS(t.shape.toString(),14);let d="";for(const p in i){const g=i[p];if(g!=null){const w=g.shape||t.shape,y=w.length;d+=`${p}: ${y}D ${y>0?w:""} `}}console.log(`%c${l}	%c${a}	%c${u}D ${h}	%c${c}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aMe(n,e,t){const r={},s={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<n.length;l++){const u=n[l],c=u.inputs;for(const h in c){const d=c[h];let p=!1;for(let g=0;g<e.length;g++)if(r[d.id]){u.outputs.forEach(w=>r[w.id]=!0),p=!0,s[u.id]=!0;break}if(p)break}}const i={};i[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const u=n[l],c=u.inputs;for(let h=0;h<u.outputs.length;h++)if(i[u.outputs[h].id]){for(const d in c)i[c[d].id]=!0,o[u.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const u=n[l];if(s[u.id]&&o[u.id]){const c={};for(const d in u.inputs){const p=u.inputs[d];r[p.id]&&(c[d]=p)}const h=Object.assign({},u);h.inputs=c,h.outputs=u.outputs,a.push(h)}}return a}function lMe(n,e,t,r){for(let s=e.length-1;s>=0;s--){const i=e[s],o=[];if(i.outputs.forEach(l=>{const u=n[l.id];u!=null?o.push(u):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const u=t(()=>a[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=i.inputs[l];if(!dh(u.shape,c.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(n[c.id]==null)n[c.id]=u;else{const h=n[c.id];n[c.id]=r(h,u),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gO=20,Av=3,rI=7;function uMe(n,e,t,r){const s=rD(e),i=cMe(n,e,t,s),o=e.length,a=WS(n,e,t,s,i),l=["Tensor"];return r&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(u=>"    "+u).join(`
`)),l.join(`
`)}function cMe(n,e,t,r){const s=Bs(e),i=r[r.length-1],o=new Array(i).fill(0),a=e.length,l=t==="complex64"?zv(n):n;if(a>1)for(let u=0;u<s/i;u++){const c=u*i;for(let h=0;h<i;h++)o[h]=Math.max(o[h],Fv(l[c+h],0,t).length)}return o}function Fv(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(rI))} + ${parseFloat(n[1].toFixed(rI))}j`:nD(n)?r=`'${n}'`:t==="bool"?r=N5(n):r=parseFloat(n.toFixed(rI)).toString(),VS(r,e)}function N5(n){return n===0?"false":"true"}function WS(n,e,t,r,s,i=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const w=zv(n);return[Fv(w[0],0,t)]}return t==="bool"?[N5(n[0])]:[n[0].toString()]}if(l===1){if(a>gO){const y=Av*o;let x=Array.from(n.slice(0,y)),_=Array.from(n.slice((a-Av)*o,a*o));return t==="complex64"&&(x=zv(x),_=zv(_)),["["+x.map((T,E)=>Fv(T,s[E],t)).join(", ")+", ..., "+_.map((T,E)=>Fv(T,s[a-Av+E],t)).join(", ")+"]"]}return["["+(t==="complex64"?zv(n):Array.from(n)).map((y,x)=>Fv(y,s[x],t)).join(", ")+"]"]}const u=e.slice(1),c=r.slice(1),h=r[0]*o,d=[];if(a>gO){for(let w=0;w<Av;w++){const y=w*h,x=y+h;d.push(...WS(n.slice(y,x),u,t,c,s,!1))}d.push("...");for(let w=a-Av;w<a;w++){const y=w*h,x=y+h;d.push(...WS(n.slice(y,x),u,t,c,s,w===a-1))}}else for(let w=0;w<a;w++){const y=w*h,x=y+h;d.push(...WS(n.slice(y,x),u,t,c,s,w===a-1))}const p=l===2?",":"";d[0]="["+(a>0?d[0]+p:"");for(let w=1;w<d.length-1;w++)d[w]=" "+d[w]+p;let g=`,
`;for(let w=2;w<l;w++)g+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":g),d}function zv(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HN{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=Bs(e),r!=null){const s=r.length;de(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||g5(t,this.size),this.strides=rD(e)}set(e,...t){t.length===0&&(t=[0]),de(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return uu().makeTensor(this.values,this.shape,this.dtype)}}let uu=null,Zg=null;function hMe(n){uu=n}function dMe(n){Zg=n}class Mi{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Bs(e),this.strides=rD(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Zg.buffer(this.shape,this.dtype,e)}bufferSync(){return Zg.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return WN(this.shape,e,this.dtype==="complex64")}arraySync(){return WN(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=uu().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>mO(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),uu().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=uu().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>mO(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await uu().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),uu().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Zg.print(this,e)}clone(){return this.throwIfDisposed(),Zg.clone(this)}toString(e=!1){const t=this.dataSync();return uMe(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Zg.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),uu().makeVariable(this,e,t,r)}}Object.defineProperty(Mi,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function A5(){return iD("Tensor",()=>Mi)}A5();class A_ extends Mi{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!dh(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);uu().disposeTensor(this),this.dataId=e.dataId,uu().incRef(this,null)}dispose(){uu().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(A_,Symbol.hasInstance,{value:n=>n instanceof Mi&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var yO;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(yO||(yO={}));var jN;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(jN||(jN={}));var XN;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(XN||(XN={}));var qN;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(qN||(qN={}));var KN;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(KN||(KN={}));const fMe={float32:qN,int32:jN,bool:XN,complex64:KN};function pMe(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return fMe[n][e]}function M5(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function k5(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ws(n,e){if(n.dtype===e.dtype)return[n,e];const t=pMe(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function mMe(n,e){de(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function R5(n){const e=[];return D5(n,e,new Set),e}function D5(n,e,t){if(n==null)return;if(n instanceof Mi){e.push(n);return}if(!gMe(n))return;const r=n;for(const s in r){const i=r[s];t.has(i)||(t.add(i),D5(i,e,t))}}function gMe(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sI(n){return n.kernelName!=null}class vO{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Dy{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new vO}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(Nv(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new sMe(this.backendInstance),!0}setupRegisteredKernels(){pO(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){pO(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof K2e)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,i=r.then(o=>s<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Nv(`Initialization of backend ${e} failed`),Nv(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return Nv(`Initialization of backend ${e} failed`),Nv(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:i}=this.initializeBackend(r);if(i||s)return{name:r,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,i=this.readSync(t),o=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,i,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return Dy.nextTensorId++}nextVariableId(){return Dy.nextVariableId++}clone(e){const t=Ee.runKernel(_5,{x:e}),r={x:e},s=o=>({x:()=>{const a="float32",l={x:o},u={dtype:a};return Ee.runKernel(S5,l,u)}}),i=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,i,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(GN(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let i=0;r.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-t-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const u=sI(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(sI(e)){const{kernelName:g,inputs:w,attrs:y}=e;this.backendName==null&&this.backend;const x=GN(g,this.backendName);de(x!=null,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),a=()=>{const _=this.backend.numDataIds();l=x.kernelFunc({inputs:w,attrs:y,backend:this.backend});const T=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,_,T);const E=T.map(N=>N.rank!=null?N:this.makeTensorFromTensorInfo(N));if(s){const N=this.getTensorsForGradient(g,w,E);r=this.saveTensorsForBackwardMode(N)}return E}}else{const{forwardFunc:g}=e,w=y=>{s&&(r=y.map(x=>this.keep(this.clone(x))))};a=()=>{const y=this.backend.numDataIds();l=this.tidy(()=>g(this.backend,w));const x=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,y,x),x}}const{inputs:c,attrs:h}=e,d=sI(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(p=this.profiler.profileKernel(u,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),s&&this.addTapeNode(u,c,t,d,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(g=>c[g]!=null?c[g].shape:null),outputShapes:t.map(g=>g.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=fO(e);if(s!=null){const i=s.inputsToSave||[],o=s.outputsToSave||[];let a;s.saveAllInputs?(de(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(u=>t[u])):a=i.map(u=>t[u]);const l=r.filter((u,c)=>o[c]);return a.concat(l)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let i=e;r==="string"&&nD(e[0])&&(i=e.map(l=>rMe(l)));const o=s.write(i,t,r),a=new Mi(t,r,o,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const l=this.state.tensorInfo.get(o),u=tIe(i);this.state.numBytes+=u-l.bytes,l.bytes=u}return a}makeTensorFromDataId(e,t,r,s){r=r||"float32";const i={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(i,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:i}=e,o=new Mi(s,i,r,this.nextTensorId());return this.trackTensor(o,t),o}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const i=new A_(e,t,r,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*UN(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof A_||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*UN(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:i},l=fO(e);l!=null&&(s=l.gradFunc),s!=null&&(a.gradient=u=>(u=u.map((c,h)=>{if(c==null){const d=r[h],p=sD(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return c}),s(u.length>1?u:u[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=R5(e),r=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!r.has(o.id)&&o.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,t,r,s=!1){if(de(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));de(i instanceof Mi,()=>"The result y returned by f() must be a tensor.");const o=aMe(this.state.activeTape,t,i);if(!s&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=r??yMe(i.shape),lMe(a,o,u=>this.tidy(u),vMe);const l=t.map(u=>a[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return de(VN(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{de(t.every(a=>a instanceof Mi),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((a,l)=>{s[l]=a});const i=(a,l)=>(r=e(...t,l),de(r.value instanceof Mi,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),de(VN(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(a,l)=>{const u=r.gradFunc(a,l),c=Array.isArray(u)?u:[u];de(c.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),de(c.every(d=>d instanceof Mi),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=N_(),r=await this.backend.time(e);return r.wallMs=N_()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new vO;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Dy.nextTensorId=0;Dy.nextVariableId=0;function yMe(n){const e=v5(Bs(n),"float32");return Ee.makeTensor(e,n,"float32")}function $5(){const n=w5();if(n._tfengine==null){const e=new sIe(n);n._tfengine=new Dy(e)}return lIe(n._tfengine.ENV),hMe(()=>n._tfengine),n._tfengine}const Ee=$5();function vMe(n,e){const t={a:n,b:e};return Ee.runKernel(b5,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xMe(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zo=kn();Zo.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Zo.registerFlag("IS_BROWSER",()=>xMe());Zo.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Zo.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Zo.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Zo.registerFlag("PROD",()=>!1);Zo.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Zo.getBool("DEBUG"));Zo.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Zo.registerFlag("IS_TEST",()=>!1);Zo.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Zo.getBool("DEBUG"));Zo.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Zo.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Zo.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function of(n,e){let t=n;if(_l(n))return e==="string"?[]:[n.length];if(M5(n)){const s=n.channels||"RGBA";return[n.height,n.width*s.length]}else if(k5(n))return[n.buffer.size/(e==null?4:UN(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||_l(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&kn().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&P5(n,r,[]),r}function P5(n,e,t){if(t=t||[],!Array.isArray(n)&&!_l(n)){de(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}de(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),de(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)P5(n[s],r,t.concat(s))}function xO(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function te(n,e,t,r="numeric"){if(n instanceof A5())return xO(r,n.dtype,e,t),n;let s=HE(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),xO(r,s,e,t),n==null||!_l(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=of(n,s);!_l(n)&&!Array.isArray(n)&&(n=[n]);const a=s!=="string"?I5(n,s):Rx(n,[],!0);return Ee.makeTensor(a,i,s)}function M_(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>te(i,`${e}[${o}]`,t,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L5="__op";function ve(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+L5;const s=(...i)=>{Ee.startScope(t);try{const o=r(...i);return Jp(o)&&console.error("Cannot return a Promise inside of tidy."),Ee.endScope(o),o}catch(o){throw Ee.endScope(null),o}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wMe(n,e){const t=te(n,"real","complex"),r=te(e,"imag","complex");Nl(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return Ee.runKernel(RIe,s)}const Fd=ve({complex_:wMe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function af(n,e,t,r){if(r==null)r=HE(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(k5(n)||M5(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return Ee.backend.createTensorFromGPUData(n,e||t,r)}if(!_l(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Ja(e);const s=Bs(e),i=Bs(t);de(s===i,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${i}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Bs(e.slice(o)):!0;de(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!_l(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?I5(n,r):Rx(n,[],!0),Ee.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ju(n,e,t){const r=of(n,t);return af(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qp={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Su{static join(e){return new Su(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>_l(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const i=t+s.byteLength;this.shards.push({buffer:s,start:t,end:i}),t=i}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=t-e,i=new ArrayBuffer(s),o=new Uint8Array(i);let a=0;for(let l=r;l<this.shards.length;l++){const u=this.shards[l],h=e+a-u.start,d=a,g=Math.min(t,u.end)-u.start,w=new Uint8Array(u.buffer,h,g-h);if(o.set(w,d),a+=w.length,t<u.end)break}return i}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(s){return e<s.start?-1:e>=s.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=bMe(this.shards,t);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function bMe(n,e){let t=0,r=n.length;for(;t<=r;){const s=Math.floor((r-t)/2)+t,i=e(n[s]);if(i===0)return s;i<0?r=s:t=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qn(n,e){return Ee.tidy(n,e)}function qo(n){R5(n).forEach(t=>t.dispose())}function Gu(n){return Ee.keep(n)}function oD(){return Ee.backendName}function SMe(){return Ee.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zd=4;async function _Me(n,e){const t=[],r=[],s=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<s.length;++o){const a=s[o],l=Array.isArray(n)?n[o].tensor:n[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const u={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async h=>{const d=await l.bytes(),p=d.reduce((y,x)=>y+x.length,0)+zd*d.length,g=new Uint8Array(p);let w=0;for(let y=0;y<d.length;y++){const x=d[y],_=new Uint8Array(new Uint32Array([x.length]).buffer);g.set(_,w),w+=zd,g.set(x,w),w+=x.length}h(g)});r.push(c)}else r.push(l.data());e!=null&&(u.group=e),t.push(u)}const i=await Promise.all(r);return{data:CMe(i),specs:t}}function O5(n,e){const t=new Su(n),r={};let s=0;for(const i of e){const o=TMe(i,(a,l)=>t.slice(s+a,s+l));r[i.name]=F5(i,t.slice(s,s+o)),s+=o}return r}function TMe(n,e){const t=Bs(n.shape);let r;if("quantization"in n){const s=n.quantization;r=Qp[s.dtype]}else if(n.dtype==="string"){let s=0;for(let i=0;i<t;i++)s+=zd+new Uint32Array(e(s,s+zd))[0];return s}else r=Qp[n.dtype];return t*r}async function EMe(n,e){const t=Bs(n.shape);let r;if("quantization"in n){const s=n.quantization;r=Qp[s.dtype]}else if(n.dtype==="string"){let s=0;for(let i=0;i<t;i++)s+=zd+new Uint32Array(await e(s,s+zd))[0];return s}else r=Qp[n.dtype];return t*r}function F5(n,e){const t=n.name,r=n.dtype,s=n.shape,i=Bs(s);let o,a=0;if("quantization"in n){const l=n.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${n.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${n.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const u=Qp[l.dtype],c=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){o=new Float32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];o[h]=d*l.scale+l.min}}else if(l.dtype==="float16")o=DMe()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);o=new Int32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];o[h]=Math.round(d*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${r}`);a+=i*u}else if(r==="string"){const l=Bs(n.shape);o=[];for(let u=0;u<l;u++){const c=new Uint32Array(e.slice(a,a+zd))[0];a+=zd;const h=new Uint8Array(e.slice(a,a+c));o.push(h),a+=c}}else{const l=Qp[r];if(r==="float32")o=new Float32Array(e);else if(r==="int32")o=new Int32Array(e);else if(r==="bool")o=new Uint8Array(e);else if(r==="complex64"){o=new Float32Array(e);const u=new Float32Array(o.length/2),c=new Float32Array(o.length/2);for(let g=0;g<u.length;g++)u[g]=o[g*2],c[g]=o[g*2+1];const h=Ju(u,s,"float32"),d=Ju(c,s,"float32"),p=Fd(h,d);return h.dispose(),d.dispose(),p}else throw new Error(`Unsupported dtype in weight '${t}': ${r}`);a+=i*l}return Ju(o,s,r)}async function wO(n,e,t){let r=new Uint8Array(e);for(;r.byteLength<t;){const{done:s,value:i}=await n.read();if(s&&i==null){const a=t-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const o=new Uint8Array(r.length+i.byteLength);o.set(r,0),o.set(new Uint8Array(i),r.length),r=o}return r.buffer}async function z5(n,e){const t={},r=n.getReader();let s=new ArrayBuffer(0);for(const i of e){const o=await EMe(i,async(u,c)=>(s=await wO(r,s,c),s.slice(u,c)));s=await wO(r,s,o);const a=s.slice(0,o);s=s.slice(o);const l=F5(i,a);if(t[i.name]=l,oD()==="webgpu"){const u=SMe();"uploadToGPU"in u&&Bs(l.shape)>=kn().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return t}function CMe(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(i=>{if(e+=i.byteLength,t.push(i.byteLength===i.buffer.byteLength?i:new i.constructor(i)),!(i instanceof Float32Array||i instanceof Int32Array||i instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${i.constructor.name}`)});const r=new Uint8Array(e);let s=0;return t.forEach(i=>{r.set(new Uint8Array(i.buffer),s),s+=i.byteLength}),r.buffer}const aD=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function bO(n){return aD?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function IMe(n){if(aD)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function NMe(n){if(aD){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function AMe(n){return Su.join(n)}function SO(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const t=n.split("/");return t[t.length-1]}function B5(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function U5(n,e,t){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=t}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(r.initializerSignature=n.initializerSignature),r}async function lD(n,e){let t,r;return n.weightsManifest!=null&&([t,r]=await e(n.weightsManifest)),U5(n,t,r)}function vw(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:bO(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:bO(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Su(n.weightData).byteLength}}function YN(n){const e=[];for(const t of n)e.push(...t.weights);return e}function MMe(){const n=t=>{let r=t<<13,s=0;for(;(r&8388608)===0;)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function kMe(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function RMe(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function DMe(){const n=MMe(),e=kMe(),t=RMe();return r=>{const s=new ArrayBuffer(4*r.length),i=new Uint32Array(s);for(let o=0;o<r.length;o++){const a=r[o],l=n[t[a>>10]+(a&1023)]+e[a>>10];i[o]=l}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hs{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return hs.instance==null&&(hs.instance=new hs),hs.instance}static registerSaveRouter(e){hs.getInstance().saveRouters.push(e)}static registerLoadRouter(e){hs.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return hs.getHandlers(e,"save")}static getLoadHandlers(e,t){return hs.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?hs.getInstance().loadRouters:hs.getInstance().saveRouters).forEach(o=>{const a=o(e,r);a!==null&&s.push(a)}),s}}const $Me=n=>hs.registerSaveRouter(n),PMe=n=>hs.registerLoadRouter(n),LMe=n=>hs.getSaveHandlers(n),OMe=(n,e)=>hs.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZN="tensorflowjs",JN=1,Tp="models_store",xd="model_info_store";function V5(){if(!kn().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function QN(n){const e=n.result;e.createObjectStore(Tp,{keyPath:"modelPath"}),e.createObjectStore(xd,{keyPath:"modelPath"})}class em{constructor(e){if(this.indexedDB=V5(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,s)=>{const i=this.indexedDB.open(ZN,JN);i.onupgradeneeded=()=>QN(i),i.onsuccess=()=>{const o=i.result;if(t==null){const a=o.transaction(Tp,"readonly"),u=a.objectStore(Tp).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return o.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(u.result.modelArtifacts)},u.onerror=c=>(o.close(),s(u.error)),a.oncomplete=()=>o.close()}else{t.weightData=Su.join(t.weightData);const a=vw(t),l=o.transaction(xd,"readwrite");let u=l.objectStore(xd),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(d){return s(d)}let h;c.onsuccess=()=>{h=o.transaction(Tp,"readwrite");const d=h.objectStore(Tp);let p;try{p=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(g){return s(g)}p.onsuccess=()=>r({modelArtifactsInfo:a}),p.onerror=g=>{u=l.objectStore(xd);const w=u.delete(this.modelPath);w.onsuccess=()=>(o.close(),s(p.error)),w.onerror=y=>(o.close(),s(p.error))}},c.onerror=d=>(o.close(),s(c.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},i.onerror=o=>s(i.error)})}}em.URL_SCHEME="indexeddb://";const W5=n=>kn().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(em.URL_SCHEME)?FMe(n.slice(em.URL_SCHEME.length)):null;hs.registerSaveRouter(W5);hs.registerLoadRouter(W5);function FMe(n){return new em(n)}function zMe(n){return n.startsWith(em.URL_SCHEME)?n.slice(em.URL_SCHEME.length):n}class BMe{constructor(){this.indexedDB=V5()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(ZN,JN);r.onupgradeneeded=()=>QN(r),r.onsuccess=()=>{const s=r.result,i=s.transaction(xd,"readonly"),a=i.objectStore(xd).getAll();a.onsuccess=()=>{const l={};for(const u of a.result)l[u.modelPath]=u.modelArtifactsInfo;e(l)},a.onerror=l=>(s.close(),t(a.error)),i.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})}async removeModel(e){return e=zMe(e),new Promise((t,r)=>{const s=this.indexedDB.open(ZN,JN);s.onupgradeneeded=()=>QN(s),s.onsuccess=()=>{const i=s.result,o=i.transaction(xd,"readwrite"),a=o.objectStore(xd),l=a.get(e);let u;l.onsuccess=()=>{if(l.result==null)return i.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=a.delete(e),h=()=>{u=i.transaction(Tp,"readwrite");const p=u.objectStore(Tp).delete(e);p.onsuccess=()=>t(l.result.modelArtifactsInfo),p.onerror=g=>r(l.error)};c.onsuccess=h,c.onerror=d=>(h(),i.close(),r(l.error))}},l.onerror=c=>(i.close(),r(l.error)),o.oncomplete=()=>{u==null?i.close():u.oncomplete=()=>i.close()}},s.onerror=i=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eh="/",Jg="tensorflowjs_models",G5="info",UMe="model_topology",VMe="weight_specs",WMe="weight_data",GMe="model_metadata";function H5(n){return{info:[Jg,n,G5].join(eh),topology:[Jg,n,UMe].join(eh),weightSpecs:[Jg,n,VMe].join(eh),weightData:[Jg,n,WMe].join(eh),modelMetadata:[Jg,n,GMe].join(eh)}}function j5(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function HMe(n){const e=n.split(eh);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(eh)}function jMe(n){return n.startsWith(tm.URL_SCHEME)?n.slice(tm.URL_SCHEME.length):n}class tm{constructor(e){if(!kn().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=H5(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=vw(e),i=Su.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,IMe(i));const o={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch{throw j5(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=NMe(o),t}}tm.URL_SCHEME="localstorage://";const X5=n=>kn().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(tm.URL_SCHEME)?XMe(n.slice(tm.URL_SCHEME.length)):null;hs.registerSaveRouter(X5);hs.registerLoadRouter(X5);function XMe(n){return new tm(n)}class qMe{constructor(){de(kn().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),de(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Jg+eh,r=eh+G5;for(let s=0;s<this.LS.length;++s){const i=this.LS.key(s);if(i.startsWith(t)&&i.endsWith(r)){const o=HMe(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=jMe(e);const t=H5(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return j5(t),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dy="://";class fo{constructor(){this.managers={}}static getInstance(){return fo.instance==null&&(fo.instance=new fo),fo.instance}static registerManager(e,t){de(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(dy)&&(e=e.slice(0,e.indexOf(dy))),de(e.length>0,()=>"scheme must not be an empty string.");const r=fo.getInstance();de(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=fo.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(fo.getInstance().managers)}}function GS(n){if(n.indexOf(dy)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${fo.getSchemes().join(",")}`);return{scheme:n.split(dy)[0],path:n.split(dy)[1]}}async function q5(n,e,t=!1){de(n!==e,()=>`Old path and new path are the same: '${n}'`);const r=hs.getLoadHandlers(n);de(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),de(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],i=hs.getSaveHandlers(e);de(i.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),de(i.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=i[0],a=GS(n).scheme,l=GS(n).path,u=a===GS(n).scheme,c=await s.load();t&&u&&await fo.getManager(a).removeModel(l);const h=await o.save(c);return t&&!u&&await fo.getManager(a).removeModel(l),h.modelArtifactsInfo}async function KMe(){const n=fo.getSchemes(),e={};for(const t of n){const r=await fo.getManager(t).listModels();for(const s in r){const i=t+dy+s;e[i]=r[s]}}return e}async function YMe(n){const e=GS(n);return fo.getManager(e.scheme).removeModel(e.path)}async function ZMe(n,e){return q5(n,e,!1)}async function JMe(n,e){return q5(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QMe{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!kn().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return C5(e)}}if(kn().get("IS_BROWSER")){kn().setPlatform("browser",new QMe);try{fo.registerManager(tm.URL_SCHEME,new qMe)}catch{}try{fo.registerManager(em.URL_SCHEME,new BMe)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eke={importFetch:()=>require("node-fetch")};let iI;class tke{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return kn().global.fetch!=null?kn().global.fetch(e,t):(iI==null&&(iI=eke.importFetch()),iI(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}kn().get("IS_NODE")&&!kn().get("IS_BROWSER")&&kn().setPlatform("node",new tke);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fh(n,e="float32",t){return e=e||"float32",Ja(n),new HN(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nke(n,e){const t=te(n,"x","cast");if(!eIe(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return Ee.runKernel(S5,r,s)}const Ns=ve({cast_:nke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rke(n){const t={x:te(n,"x","clone","string_or_numeric")};return Ee.runKernel(_5,t)}const Cd=ve({clone_:rke});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K5(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */$5();const ske={buffer:fh,cast:Ns,clone:Cd,print:K5};dMe(ske);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ike(n,e){let t=te(n,"a","add"),r=te(e,"b","add");[t,r]=ws(t,r);const s={a:t,b:r};return Ee.runKernel(b5,s)}const gn=ve({add_:ike});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oke(n,e){let t=te(n,"a","floorDiv"),r=te(e,"b","floorDiv");[t,r]=ws(t,r);const s={a:t,b:r};return Ee.runKernel(cNe,s)}const Y5=ve({floorDiv_:oke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ake(n,e){let t=te(n,"a","div"),r=te(e,"b","div");if([t,r]=ws(t,r),t.dtype==="int32"&&r.dtype==="int32")return Y5(t,r);const s={a:t,b:r},i={};return Ee.runKernel(JIe,s,i)}const Er=ve({div_:ake});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lke(n,e){let t=te(n,"a","mul"),r=te(e,"b","mul");[t,r]=ws(t,r);const s={a:t,b:r};return Ee.runKernel(VNe,s)}const Dt=ve({mul_:lke});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uke(n){const e=te(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return Ee.runKernel(DIe,t)}else{const t={x:e};return Ee.runKernel(cIe,t)}}const Va=ve({abs_:uke});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cke(n){const t={x:te(n,"x","acos")};return Ee.runKernel(hIe,t)}const hke=ve({acos_:cke});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dke(n){const t={x:te(n,"x","acosh")};return Ee.runKernel(dIe,t)}const fke=ve({acosh_:dke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pke(n){de(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),de(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((s,i)=>te(s,`tensors${i}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!dh(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return Ee.runKernel(fIe,r)}const mke=ve({addN_:pke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gke(n,e=null,t=!1){const s={x:te(n,"x","all","bool")},i={axis:e,keepDims:t};return Ee.runKernel(pIe,s,i)}const yke=ve({all_:gke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vke(n,e=null,t=!1){const s={x:te(n,"x","any","bool")},i={axis:e,keepDims:t};return Ee.runKernel(mIe,s,i)}const xke=ve({any_:vke});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wke(n,e=0){const r={x:te(n,"x","argMax")},s={axis:e};return Ee.runKernel(gIe,r,s)}const bke=ve({argMax_:wke});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ske(n,e=0){const r={x:te(n,"x","argMin")},s={axis:e};return Ee.runKernel(yIe,r,s)}const _ke=ve({argMin_:Ske});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tke(n){const t={x:te(n,"x","asin")};return Ee.runKernel(vIe,t)}const Eke=ve({asin_:Tke});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cke(n){const t={x:te(n,"x","asinh")};return Ee.runKernel(xIe,t)}const Ike=ve({asinh_:Cke});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nke(n){const t={x:te(n,"x","atan")};return Ee.runKernel(wIe,t)}const Ake=ve({atan_:Nke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mke(n,e){let t=te(n,"a","atan2"),r=te(e,"b","atan2");[t,r]=ws(t,r);const s={a:t,b:r};return Ee.runKernel(SIe,s)}const kke=ve({atan2_:Mke});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rke(n){const t={x:te(n,"x","atanh")};return Ee.runKernel(bIe,t)}const Dke=ve({atanh_:Rke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ke(n,e,t,r,s,i,o="channelsLast"){const[a,l]=Dx(e);let u;if(o==="channelsLast")u=[a,l,n[3],n[3]];else if(o==="channelsFirst")u=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return uD(n,u,t,r,s,i,!1,o)}function uD(n,e,t,r,s,i,o=!1,a="channelsLast"){let[l,u,c,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,u,c,h]=n;else if(a==="channelsFirst")[l,h,u,c]=n;else throw new Error(`Unknown dataFormat ${a}`);const[d,p,,g]=e,[w,y]=Dx(t),[x,_]=Dx(r),T=eA(d,x),E=eA(p,_),{padInfo:N,outHeight:M,outWidth:$}=Oke(s,u,c,w,y,T,E,i,a),L=o?g*h:g;let k;return a==="channelsFirst"?k=[l,L,M,$]:a==="channelsLast"&&(k=[l,M,$,L]),{batchSize:l,dataFormat:a,inHeight:u,inWidth:c,inChannels:h,outHeight:M,outWidth:$,outChannels:L,padInfo:N,strideHeight:w,strideWidth:y,filterHeight:d,filterWidth:p,effectiveFilterHeight:T,effectiveFilterWidth:E,dilationHeight:x,dilationWidth:_,inShape:n,outShape:k,filterShape:e}}function Pke(n,e,t,r,s){r==null&&(r=Lke(n,e,t));const i=n[0],o=n[1],a=k_((i-e+2*r)/t+1,s),l=k_((o-e+2*r)/t+1,s);return[a,l]}function Lke(n,e,t,r=1){const s=eA(e,r);return Math.floor((n[0]*(t-1)-t+s)/2)}function Dx(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function eA(n,e){return e<=1?n:n+(n-1)*(e-1)}function Oke(n,e,t,r,s,i,o,a,l){let u,c,h;if(typeof n=="number"){u={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const p=Pke([e,t],i,r,n,a);c=p[0],h=p[1]}else if(n==="same"){c=Math.ceil(e/r),h=Math.ceil(t/s);const d=Math.max(0,(c-1)*r+i-e),p=Math.max(0,(h-1)*s+o-t),g=Math.floor(d/2),w=d-g,y=Math.floor(p/2),x=p-y;u={top:g,bottom:w,left:y,right:x,type:"SAME"}}else if(n==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-i+1)/r),h=Math.ceil((t-o+1)/s);else if(typeof n=="object"){const d=l==="channelsLast"?n[1][0]:n[2][0],p=l==="channelsLast"?n[1][1]:n[2][1],g=l==="channelsLast"?n[2][0]:n[3][0],w=l==="channelsLast"?n[2][1]:n[3][1];u={top:d,bottom:p,left:g,right:w,type:d===0&&p===0&&g===0&&w===0?"VALID":"EXPLICIT"},c=k_((e-i+d+p)/r+1,a),h=k_((t-o+g+w)/s+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:u,outHeight:c,outWidth:h}}function k_(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function R_(n){const[e,t,r]=Dx(n);return e===1&&t===1&&r===1}function lf(n,e){return R_(n)||R_(e)}function $y(n){return Dx(n).every(e=>e>0)}function _u(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")de(kx(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{de(kx(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fke(n,e){const r={x:te(n,"x","reshape","string_or_numeric")},s={shape:e};return Ee.runKernel(lAe,r,s)}const lt=ve({reshape_:Fke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zke(n,e,t,r,s){const i=te(n,"x","avgPool","float32"),o=1;de(lf(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=lt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),de(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),_u("avgPool",r,s);const u={x:a},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let h=Ee.runKernel(_Ie,u,c);return h=Ns(h,i.dtype),l?lt(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Z5=ve({avgPool_:zke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bke(n,e,t,r,s,i="NDHWC"){const o=te(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=lt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),de(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),de(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),de(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),_u("avgPool3d",r,s);const u={x:a},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:i};let h=Ee.runKernel(TIe,u,c);return h=Ns(h,a.dtype),l?lt(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Uke=ve({avgPool3d_:Bke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vke(n,e=0){de(n.length>=1,()=>"Pass at least one tensor to concat");const t=M_(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return Cd(t[0]);const r=t,s={axis:e};return Ee.runKernel($Ie,r,s)}const To=ve({concat_:Vke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wke(n,e,t=!1,r=!1){let s=te(n,"a","matMul"),i=te(e,"b","matMul");[s,i]=ws(s,i);const o={a:s,b:i},a={transposeA:t,transposeB:r};return Ee.runKernel(EIe,o,a)}const Pr=ve({matMul_:Wke});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gke(n){const t={x:te(n,"x","sigmoid","float32")};return Ee.runKernel(TAe,t)}const $p=ve({sigmoid_:Gke});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hke(n,e,t){const r=te(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},i={begin:e,size:t};return Ee.runKernel(wAe,s,i)}const yr=ve({slice_:Hke});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jke(n){const t={x:te(n,"x","tanh","float32")};return Ee.runKernel(GAe,t)}const tA=ve({tanh_:jke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xke(n,e,t,r,s,i){const o=te(n,"forgetBias","basicLSTMCell"),a=te(e,"lstmKernel","basicLSTMCell"),l=te(t,"lstmBias","basicLSTMCell"),u=te(r,"data","basicLSTMCell"),c=te(s,"c","basicLSTMCell"),h=te(i,"h","basicLSTMCell"),d=To([u,h],1),p=Pr(d,a),g=gn(p,l),w=g.shape[0],y=g.shape[1]/4,x=[w,y],_=yr(g,[0,0],x),T=yr(g,[0,y],x),E=yr(g,[0,y*2],x),N=yr(g,[0,y*3],x),M=gn(Dt($p(_),tA(T)),Dt(c,$p(gn(o,E)))),$=Dt(tA(M),$p(N));return[M,$]}const qke=ve({basicLSTMCell_:Xke});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kke(n,e,t){const r=te(n,"x","batchToSpaceND"),s=e.reduce((a,l)=>a*l);de(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),de(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),de(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const i={x:r},o={blockShape:e,crops:t};return Ee.runKernel(CIe,i,o)}const J5=ve({batchToSpaceND_:Kke});function Yke(n){let e;return n.rank===0||n.rank===1?e=lt(n,[1,1,1,n.size]):n.rank===2?e=lt(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=lt(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zke(n,e,t,r,s,i){i==null&&(i=.001);const o=te(n,"x","batchNorm"),a=te(e,"mean","batchNorm"),l=te(t,"variance","batchNorm");let u;s!=null&&(u=te(s,"scale","batchNorm"));let c;r!=null&&(c=te(r,"offset","batchNorm")),de(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),de(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),de(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:Yke(o),scale:u,offset:c,mean:a,variance:l},p={varianceEpsilon:i},g=Ee.runKernel(hNe,d,p);return lt(g,o.shape)}const jE=ve({batchNorm_:Zke});function Jke(n,e,t,r,s,i){const o=te(n,"x","batchNorm"),a=te(e,"mean","batchNorm"),l=te(t,"variance","batchNorm");let u;s!=null&&(u=te(s,"scale","batchNorm"));let c;return r!=null&&(c=te(r,"offset","batchNorm")),de(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),de(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),de(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&de(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&de(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),jE(o,a,l,c,u,i)}const Qke=ve({batchNorm2d_:Jke});function eRe(n,e,t,r,s,i){const o=te(n,"x","batchNorm"),a=te(e,"mean","batchNorm"),l=te(t,"variance","batchNorm");let u;s!=null&&(u=te(s,"scale","batchNorm"));let c;return r!=null&&(c=te(r,"offset","batchNorm")),de(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),de(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),de(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&de(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&de(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),jE(o,a,l,c,u,i)}const tRe=ve({batchNorm3d_:eRe});function nRe(n,e,t,r,s,i){const o=te(n,"x","batchNorm"),a=te(e,"mean","batchNorm"),l=te(t,"variance","batchNorm");let u;s!=null&&(u=te(s,"scale","batchNorm"));let c;return r!=null&&(c=te(r,"offset","batchNorm")),de(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),de(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),de(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&de(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&de(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),jE(o,a,l,c,u,i)}const rRe=ve({batchNorm4d_:nRe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sRe(n,e,t){const r=te(n,"x","bincount"),s=te(e,"weights","bincount");de(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),de(t>=0,()=>`size must be non-negative, but got ${t}.`),de(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const i={x:r,weights:s},o={size:t};return Ee.runKernel(IIe,i,o)}const Q5=ve({bincount_:sRe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iRe(n,e){const t=te(n,"x","bitwiseAnd"),r=te(e,"y","bitwiseAnd");if(!dh(t.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${r.shape}`);if(t.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${r.dtype}`);const s={a:t,b:r};return Ee.runKernel(NIe,s)}const oRe=ve({bitwiseAnd_:iRe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aRe(n,e){const t=te(n,"s0","broadcastArgs","int32"),r=te(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:t,s1:r};return Ee.runKernel(AIe,s)}const lRe=ve({broadcastArgs_:aRe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uRe(n,e){let t=te(n,"broadcastTo","x");const r=t.shape;if(Ja(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const u=t.shape.slice();for(;u.length<e.length;)u.unshift(1);t=lt(t,u)}const s=t.shape,i=Array.from(e);for(let u=e.length-1;u>=0;u--)if(s[u]===e[u])i[u]=1;else if(t.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(i.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return Cd(t);const a={x:t},l={reps:i};return Ee.runKernel(T5,a,l)}const HS=ve({broadcastTo_:uRe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cRe(n){const t={x:te(n,"x","ceil","float32")};return Ee.runKernel(MIe,t)}const hRe=ve({ceil_:cRe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xw(n,e,t){Ja(n),t=t||HE(e);const r={shape:n,value:e,dtype:t};return Ee.runKernel(aNe,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dRe(n,e,t){const r=te(n,"x","clipByValue");if(de(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return xw(r.shape,e,r.dtype);const s={x:r},i={clipValueMin:e,clipValueMax:t};return Ee.runKernel(kIe,s,i)}const fRe=ve({clipByValue_:dRe});function pRe(n){return To(n,0)}const mRe=ve({concat1d_:pRe});function gRe(n,e){return To(n,e)}const e6=ve({concat2d_:gRe});function yRe(n,e){return To(n,e)}const vRe=ve({concat3d_:yRe});function xRe(n,e){return To(n,e)}const wRe=ve({concat4d_:xRe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bRe(n,e,t,r,s="NHWC",i=[1,1],o){const a=te(n,"x","conv2d","float32"),l=te(e,"filter","conv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=lt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),de(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),de(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),_u("conv2d",r,o);const h=s==="NHWC"?u.shape[3]:u.shape[1];de(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),de(lf(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),de($y(i),()=>"Error in conv2D: Dilated rates should be larger than 0."),de($y(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:u,filter:l},p={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o},g=Ee.runKernel(PIe,d,p);return c?lt(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const XE=ve({conv2d_:bRe});function SRe(n,e,t,r,s="NWC",i=1,o){const a=te(n,"x","conv1d"),l=te(e,"filter","conv1d");let u=a,c=!1;a.rank===2&&(c=!0,u=lt(a,[1,a.shape[0],a.shape[1]])),de(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),de(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),_u("conv1d",r,o),de(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),de(lf(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),de($y(i),()=>"Error in conv1D: Dilated rates should be larger than 0."),de($y(t),()=>"Error in conv1D: Stride should be larger than 0."),de(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=lt(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=lt(u,[u.shape[0],1,u.shape[1],u.shape[2]]),y=XE(d,h,[1,t],r,"NHWC",[1,i],o);return c?lt(y,[y.shape[2],y.shape[3]]):lt(y,[y.shape[0],y.shape[2],y.shape[3]])}const _Re=ve({conv1d_:SRe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TRe(n,e,t,r,s,i="NHWC",o){de(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,u=!1;e.rank===3&&(u=!0,l=lt(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),de(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),de(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),de(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const c=i==="NHWC"?a[3]:a[1],h=i==="NHWC"?l.shape[3]:l.shape[1];de(c===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[2]}.`),de(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),_u("conv2dDerInput",s,o);const d={dy:l,filter:t},p={strides:r,pad:s,dataFormat:i,dimRoundingMode:o,inputShape:a},g=Ee.runKernel(OIe,d,p);return u?lt(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const t6=ve({conv2DBackpropInput_:TRe});function ERe(n,e,t,r,s,i){const o=te(n,"x","conv2dTranspose"),a=te(e,"filter","conv2dTranspose");return t6(t,o,a,r,s,"NHWC",i)}const CRe=ve({conv2dTranspose_:ERe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IRe(n,e,t,r,s="NDHWC",i=[1,1,1]){const o=te(n,"x","conv3d"),a=te(e,"filter","conv3d");let l=o,u=!1;o.rank===4&&(u=!0,l=lt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),de(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),de(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),de(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),de(lf(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),de(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),de($y(i),()=>"Error in conv3D: Dilated rates should be larger than 0."),de($y(t),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:a},h={strides:t,pad:r,dataFormat:s,dilations:i},d=Ee.runKernel(FIe,c,h);return u?lt(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const NRe=ve({conv3d_:IRe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ARe(n,e,t,r,s){de(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,o=e,a=!1;e.rank===4&&(a=!0,o=lt(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),i=[1,n[0],n[1],n[2],n[3]]);const l=i[4],u=o.shape[4];de(i.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`),de(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),de(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),de(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),de(u===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${t.shape[4]}.`);const c={dy:o,filter:t},h={pad:s,strides:r,inputShape:i},d=Ee.runKernel(zIe,c,h);return a?lt(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const MRe=ve({conv3DBackpropInput_:ARe});function kRe(n,e,t,r,s){const i=te(n,"x","conv3dTranspose"),o=te(e,"filter","conv3dTranspose");return MRe(t,i,o,r,s)}const RRe=ve({conv3dTranspose_:kRe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DRe(n){const t={x:te(n,"x","cos","float32")};return Ee.runKernel(BIe,t)}const $Re=ve({cos_:DRe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PRe(n){const t={x:te(n,"x","cosh","float32")};return Ee.runKernel(UIe,t)}const LRe=ve({cosh_:PRe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ORe(n,e=0,t=!1,r=!1){const i={x:te(n,"x","cumprod")},o={axis:e,exclusive:t,reverse:r};return Ee.runKernel(VIe,i,o)}const FRe=ve({cumprod_:ORe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zRe(n,e=0,t=!1,r=!1){const i={x:te(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:r};return Ee.runKernel(WIe,i,o)}const BRe=ve({cumsum_:zRe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function URe(n,e,t,r=!1){const s=te(n,"x","denseBincount"),i=te(e,"weights","denseBincount");de(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),de(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),de(t>=0,()=>`size must be non-negative, but got ${t}.`),de(i.size===s.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${i.shape}.`);const o={x:s,weights:i},a={size:t,binaryOutput:r};return Ee.runKernel(HIe,o,a)}const VRe=ve({denseBincount_:URe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WRe(n,e,t="NHWC"){const r=te(n,"x","depthToSpace","float32"),s=t==="NHWC"?r.shape[1]:r.shape[2],i=t==="NHWC"?r.shape[2]:r.shape[3],o=t==="NHWC"?r.shape[3]:r.shape[1];de(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),de(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),de(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${r.shape}`),de(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const a={x:r},l={blockSize:e,dataFormat:t};return Ee.runKernel(jIe,a,l)}const GRe=ve({depthToSpace_:WRe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HRe(n,e,t,r,s="NHWC",i=[1,1],o){const a=te(n,"x","depthwiseConv2d","float32"),l=te(e,"filter","depthwiseConv2d","float32");let u=a,c=!1;a.rank===3&&(c=!0,u=lt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),de(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),de(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=s==="NHWC"?u.shape[3]:u.shape[1];de(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),_u("depthwiseConv2d",r,o);const d={x:u,filter:l},p={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o},g=Ee.runKernel(XIe,d,p);return c?lt(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const cD=ve({depthwiseConv2d_:HRe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jRe(n){const t={x:te(n,"x","diag")};return Ee.runKernel(YIe,t)}const XRe=ve({diag_:jRe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qRe(n,e,t,r,s=[1,1],i="NHWC"){const o=te(n,"x","dilation2d"),a=te(e,"filter","dilation2d");de(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),de(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),de(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,u=!1;o.rank===3&&(l=lt(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0),de(l.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${a.shape[2]}`);const c={x:l,filter:a},h={strides:t,pad:r,dilations:s},d=Ee.runKernel(ZIe,c,h);return u?lt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const KRe=ve({dilation2d_:qRe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YRe(n,e){const t=[];for(let r=0;r<e.length;r++){const s=n[n.length-r-1],i=e.length-r-1,o=e[i];(s==null||s===1&&o>1)&&t.unshift(i)}return t}function bi(n,e){const t=Math.max(n.length,e.length),r=new Array(t);for(let s=0;s<t;s++){let i=n[n.length-s-1];i==null&&(i=1);let o=e[e.length-s-1];if(o==null&&(o=1),i===1)r[t-s-1]=o;else if(o===1)r[t-s-1]=i;else if(i!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else r[t-s-1]=i}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZRe(n,e){let t=te(n,"a","equal","string_or_numeric"),r=te(e,"b","equal","string_or_numeric");[t,r]=ws(t,r),bi(t.shape,r.shape);const s={a:t,b:r};return Ee.runKernel(nNe,s)}const n6=ve({equal_:ZRe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JRe(n,e,t){const r=te(e,"a","where"),s=te(t,"b","where"),i=te(n,"condition","where","bool"),o=bi(bi(i.shape,r.shape),s.shape),a=HS(i,o),l=HS(r,o),u=HS(s,o),c={condition:a,t:l,e:u};return Ee.runKernel(vAe,c)}const Id=ve({where_:JRe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QRe(n){const t={x:te(n,"x","zerosLike")};return Ee.runKernel(YAe,t)}const Xa=ve({zerosLike_:QRe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eDe(n,e){let t=te(n,"a","div"),r=te(e,"b","div");[t,r]=ws(t,r);const s=Er(t,r),i=Xa(s),o=n6(r,i);return Id(o,i,s)}const tDe=ve({divNoNan_:eDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nDe(n,e){const t=te(n,"t1","dot"),r=te(e,"t2","dot");de((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const s=t.rank===1?t.size:t.shape[1],i=r.rank===1?r.size:r.shape[0];if(de(s===i,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${i}.`),t.rank===1&&r.rank===1){const o=lt(t,[1,-1]),a=lt(r,[-1,1]),l=Pr(o,a);return lt(l,[])}else if(t.rank===1&&r.rank===2){const o=lt(t,[1,-1]),a=lt(r,[r.shape[0],r.shape[1]]),l=Pr(o,a);return lt(l,[l.size])}else if(t.rank===2&&r.rank===1){const o=lt(r,[-1,1]),a=Pr(t,o);return lt(a,[a.size])}else{const o=lt(r,[r.shape[0],r.shape[1]]);return Pr(t,o)}}const rDe=ve({dot_:nDe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sDe(n,...e){const t=e.map((s,i)=>te(s,`tensors${i}`,"einsum")),r={equation:n};return Ee.runKernel(QIe,t,r)}const Qg=ve({einsum_:sDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iDe(n){const t={x:te(n,"x","elu","float32")};return Ee.runKernel(eNe,t)}const r6=ve({elu_:iDe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oDe(n,e){const t=te(n,"x","ensureShape","string_or_numeric");if(!Y2e(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const aDe=ve({ensureShape_:oDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lDe(n){let e=te(n,"x","erf");de(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ns(e,"float32"));const t={x:e};return Ee.runKernel(tNe,t)}const uDe=ve({erf_:lDe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cDe(n,e,t){const r=n.length+e.length,s=[];let i=0,o=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?s.push(n[i++]):s.push(e[o++]);return s}function qE(n,e){const t=e.map(r=>1);return cDe(n,t,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hDe(n,e=null,t=!1){const s={x:te(n,"x","max")},i={reductionIndices:e,keepDims:t};return Ee.runKernel(kNe,s,i)}const fy=ve({max_:hDe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dDe(n,e=null,t=!1){const s={x:te(n,"x","min")},i={axis:e,keepDims:t};return Ee.runKernel(ONe,s,i)}const nA=ve({min_:dDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fDe(n,e){let t=te(n,"base","pow"),r=te(e,"exp","pow");[t,r]=ws(t,r);const s={a:t,b:r};return Ee.runKernel(JNe,s)}const $x=ve({pow_:fDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ar(n,e){if((_l(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&_l(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return af(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pDe(n){const t={x:te(n,"x","sqrt","float32")};return Ee.runKernel(CAe,t)}const ph=ve({sqrt_:pDe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mDe(n){const e=te(n,"x","square"),t={};return Ee.runKernel("Square",{x:e},t)}const mu=ve({square_:mDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gDe(n,e=null,t=!1){let r=te(n,"x","sum");r.dtype==="bool"&&(r=Ns(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return Ee.runKernel(IAe,s,i)}const Jr=ve({sum_:gDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yDe(n,e="euclidean",t=null,r=!1){n=te(n,"x","norm");const s=s6(n,e,t);let i=s.shape;if(r){const o=GE(t,n.shape);i=qE(s.shape,o)}return lt(s,i)}function s6(n,e,t=null){if(n.rank===0)return Va(n);if(n.rank!==1&&t===null)return s6(lt(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Jr(Va(n),t);if(e===1/0)return fy(Va(n),t);if(e===-1/0)return nA(Va(n),t);if(e==="euclidean"||e===2)return ph(Jr($x(Va(n),ar(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return fy(Jr(Va(n),t[0]),t[1]-1);if(e===1/0)return fy(Jr(Va(n),t[1]),t[0]);if(e===-1/0)return nA(Jr(Va(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return ph(Jr(mu(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const KE=ve({norm_:yDe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vDe(n,e=null,t=!1){return KE(n,"euclidean",e,t)}const xDe=ve({euclideanNorm_:vDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wDe(n){const t={x:te(n,"x","exp")};return Ee.runKernel(rNe,t)}const nm=ve({exp_:wDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bDe(n,e=0){const t=te(n,"x","expandDims","string_or_numeric");de(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return Ee.runKernel(sNe,r,s)}const Kc=ve({expandDims_:bDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SDe(n){const t={x:te(n,"x","expm1")};return Ee.runKernel(iNe,t)}const _De=ve({expm1_:SDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TDe(n,e){const t=te(n,"x","tile","string_or_numeric");de(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return Ee.runKernel(T5,r,s)}const Kv=ve({tile_:TDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EDe(n,e,t,r="float32"){e==null&&(e=n);const s=fh([n,e],r),i=n<=e?n:e;for(let a=0;a<i;++a)s.set(1,a,a);const o=lt(s.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return Kv(Kc(o,0),[t[0],1,1]);if(t.length===2)return Kv(Kc(Kc(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Kv(Kc(Kc(Kc(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const i6=ve({eye_:EDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CDe(n){const t={x:te(n,"x","floor","float32")};return Ee.runKernel(uNe,t)}const o6=ve({floor_:CDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IDe(n,e,t=0,r=0){const s=te(n,"x","gather"),i=te(e,"indices","gather","int32"),o={x:s,indices:i},a={axis:t,batchDims:r};return Ee.runKernel(dNe,o,a)}const a6=ve({gather_:IDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NDe(n,e){let t=te(n,"a","greater","string_or_numeric"),r=te(e,"b","greater","string_or_numeric");[t,r]=ws(t,r),bi(t.shape,r.shape);const s={a:t,b:r};return Ee.runKernel(pNe,s)}const YE=ve({greater_:NDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ADe(n,e){let t=te(n,"a","greaterEqual","string_or_numeric"),r=te(e,"b","greaterEqual","string_or_numeric");[t,r]=ws(t,r),bi(t.shape,r.shape);const s={a:t,b:r};return Ee.runKernel(mNe,s)}const l6=ve({greaterEqual_:ADe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MDe(n){const t={input:te(n,"input","imag")};return Ee.runKernel(yNe,t)}const ZE=ve({imag_:MDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kDe(n){const t={x:te(n,"x","isFinite")};return Ee.runKernel(vNe,t)}const RDe=ve({isFinite_:kDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DDe(n){const t={x:te(n,"x","isInf")};return Ee.runKernel(xNe,t)}const $De=ve({isInf_:DDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PDe(n){const t={x:te(n,"x","isNaN")};return Ee.runKernel(wNe,t)}const LDe=ve({isNaN_:PDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ODe(n,e=.2){const r={x:te(n,"x","leakyRelu")},s={alpha:e};return Ee.runKernel(bNe,r,s)}const u6=ve({leakyRelu_:ODe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FDe(n,e){let t=te(n,"a","less","string_or_numeric"),r=te(e,"b","less","string_or_numeric");[t,r]=ws(t,r),bi(t.shape,r.shape);const s={a:t,b:r};return Ee.runKernel(SNe,s)}const rA=ve({less_:FDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zDe(n,e){let t=te(n,"a","lessEqual","string_or_numeric"),r=te(e,"b","lessEqual","string_or_numeric");[t,r]=ws(t,r),bi(t.shape,r.shape);const s={a:t,b:r};return Ee.runKernel(_Ne,s)}const hD=ve({lessEqual_:zDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BDe(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return Ee.runKernel(TNe,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UDe(n,e=5,t=1,r=1,s=.5){const i=te(n,"x","localResponseNormalization");de(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),de(kx(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=lt(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},u={depthRadius:e,bias:t,alpha:r,beta:s},c=Ee.runKernel(MNe,l,u);return a?lt(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const VDe=ve({localResponseNormalization_:UDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WDe(n){const t={x:te(n,"x","log","float32")};return Ee.runKernel(ENe,t)}const Px=ve({log_:WDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GDe(n){const t={x:te(n,"x","log1p")};return Ee.runKernel(CNe,t)}const c6=ve({log1p_:GDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HDe(n,e){de(VN(n),()=>"The f passed in variableGrads(f) must be a function"),de(e==null||Array.isArray(e)&&e.every(u=>u instanceof A_),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const u in Ee.registeredVariables)e.push(Ee.registeredVariables[u])}const r=t?e.filter(u=>!u.trainable):null,s=e.length;e=e.filter(u=>u.trainable),de(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const i=!0,{value:o,grads:a}=Ee.gradients(n,e,null,i);de(a.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),de(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return e.forEach((u,c)=>{a[c]!=null&&(l[u.name]=a[c])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:o,grads:l}}function mh(n){return Ee.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jDe(n){const t={x:te(n,"x","neg")};return Ee.runKernel(WNe,t)}const Qu=ve({neg_:jDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XDe(n){const t={x:te(n,"x","softplus")};return Ee.runKernel(EAe,t)}const h6=ve({softplus_:XDe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qDe(n){const e=te(n,"x","logSigmoid");return mh(r=>({value:Qu(h6(Qu(r))),gradFunc:o=>Dt(o,$p(Qu(r)))}))(e)}const KDe=ve({logSigmoid_:qDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YDe(n,e){let t=te(n,"a","sub"),r=te(e,"b","sub");[t,r]=ws(t,r);const s={a:t,b:r};return Ee.runKernel(VAe,s)}const Wn=ve({sub_:YDe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZDe(n,e=-1){const t=te(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return mh((s,i)=>{const a=fy(s,e,!0),l=Wn(s,a),u=Wn(Ns(l,"float32"),Px(Jr(nm(l),e,!0)));return i([u]),{value:u,gradFunc:(h,d)=>{const[p]=d,g=!0,w=nm(p);return Wn(h,Dt(Jr(h,e,g),w))}}})(t)}const JDe=ve({logSoftmax_:ZDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QDe(n,e=null,t=!1){const r=te(n,"x","logSumExp"),s=GE(e,r.shape),i=fy(r,s,!0),o=Wn(r,i),a=nm(o),l=Jr(a,s),u=Px(l),c=gn(lt(i,u.shape),u);if(t){const h=qE(c.shape,s);return lt(c,h)}return c}const d6=ve({logSumExp_:QDe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$e(n,e){const t=te(n,"a","logicalAnd","bool"),r=te(e,"b","logicalAnd","bool");bi(t.shape,r.shape);const s={a:t,b:r};return Ee.runKernel(INe,s)}const D_=ve({logicalAnd_:e$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t$e(n){const t={x:te(n,"x","logicalNot","bool")};return Ee.runKernel(NNe,t)}const f6=ve({logicalNot_:t$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n$e(n,e){const t=te(n,"a","logicalOr","bool"),r=te(e,"b","logicalOr","bool");bi(t.shape,r.shape);const s={a:t,b:r};return Ee.runKernel(ANe,s)}const p6=ve({logicalOr_:n$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r$e(n,e){const t=te(n,"a","logicalXor","bool"),r=te(e,"b","logicalXor","bool");return bi(t.shape,r.shape),D_(p6(n,e),f6(D_(n,e)))}const s$e=ve({logicalXor_:r$e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SS=2147483648;function i$e(n,e,t="left"){const r=te(n,"sortedSequence","searchSorted"),s=te(e,"values","searchSorted"),i=r.shape[r.shape.length-1],o=s.shape[s.shape.length-1],a=lt(r,[-1,i]),l=lt(s,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Bs(l.shape)>=SS)throw new Error(`values tensor size must less than ${SS}`);if(a.shape[1]>=SS)throw new Error(`trailing dim_size must less than ${SS} for int32 output type, was ${a.shape[1]}`);const u={sortedSequence:a,values:l},c={side:t};return Ee.runKernel(yAe,u,c)}const dD=ve({searchSorted_:i$e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o$e(n,e){return dD(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$e(n,e,t,r,s){const i=te(n,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=lt(i,[1,i.shape[0],i.shape[1],i.shape[2]])),de(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),de(lf(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),_u("maxPool",r,s);const u={x:a},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s},h=Ee.runKernel(DNe,u,c);return l?lt(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const m6=ve({maxPool_:a$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$e(n,e=[1,1,1],t,r,s,i="NDHWC"){const o=te(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=lt(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),de(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),de(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),_u("maxPool3d",r,s);const u={x:a},c={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:i},h=Ee.runKernel($Ne,u,c);return l?lt(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const u$e=ve({maxPool3d_:l$e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c$e(n,e,t,r,s=!1){const o={x:te(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:r,includeBatchInIndex:s},l=Ee.runKernel(PNe,o,a);return{result:l[0],indexes:l[1]}}const h$e=ve({maxPoolWithArgmax_:c$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d$e(n,e){let t=te(n,"a","maximum"),r=te(e,"b","maximum");[t,r]=ws(t,r),t.dtype==="bool"&&(t=Ns(t,"int32"),r=Ns(r,"int32")),bi(t.shape,r.shape);const s={a:t,b:r};return Ee.runKernel(RNe,s)}const g6=ve({maximum_:d$e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$e(n,e=null,t=!1){const s={x:te(n,"x","mean")},i={axis:e,keepDims:t};return Ee.runKernel(LNe,s,i)}const $_=ve({mean_:f$e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Py(n,e="float32"){if(Ja(n),e==="complex64"){const r=Py(n,"float32"),s=Py(n,"float32");return Fd(r,s)}const t=sD(Bs(n),e);return Ee.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ep(n,e="float32"){if(Ja(n),e==="complex64"){const r=Ep(n,"float32"),s=Py(n,"float32");return Fd(r,s)}const t=v5(Bs(n),e);return Ee.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p$e(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=te(n,"x","meshgrid",n instanceof Mi?n.dtype:"float32");if(e===void 0)return[r];let s=te(e,"y","meshgrid",e instanceof Mi?e.dtype:"float32");const i=Bs(r.shape),o=Bs(s.shape);return t==="xy"?(r=lt(r,[1,-1]),s=lt(s,[-1,1]),[Pr(Ep([o,1],r.dtype),r),Pr(s,Ep([1,i],s.dtype))]):(r=lt(r,[-1,1]),s=lt(s,[1,-1]),[Pr(r,Ep([1,o],r.dtype)),Pr(Ep([i,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$e(n,e){let t=te(n,"a","minimum"),r=te(e,"b","minimum");[t,r]=ws(t,r),t.dtype==="bool"&&(t=Ns(t,"int32"),r=Ns(r,"int32")),bi(t.shape,r.shape);const s={a:t,b:r};return Ee.runKernel(FNe,s)}const P_=ve({minimum_:m$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g$e(n,e,t){de(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=te(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");de(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let a=0;a<r.rank;a++)de(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),de(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const i={paddings:e,mode:t},o={x:r};return Ee.runKernel(zNe,o,i)}const y$e=ve({mirrorPad_:g$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v$e(n,e){let t=te(n,"a","mod"),r=te(e,"b","mod");[t,r]=ws(t,r);const s={a:t,b:r};return Ee.runKernel(BNe,s)}const x$e=ve({mod_:v$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w$e(n,e=null,t=!1){n=te(n,"x","moments");const r=GE(e,n.shape),s=$_(n,r,t);let i=s.shape;t||(i=qE(s.shape,r));const o=mu(Wn(Ns(n,"float32"),lt(s,i))),a=$_(o,r,t);return{mean:s,variance:a}}const b$e=ve({moments_:w$e});function S$e(n,e,t,r){const s=te(e,"data","multiRNNCell"),i=M_(t,"c","multiRNNCell"),o=M_(r,"h","multiRNNCell");let a=s;const l=[];for(let h=0;h<n.length;h++){const d=n[h](a,i[h],o[h]);l.push(d[0]),l.push(d[1]),a=d[1]}const u=[],c=[];for(let h=0;h<l.length;h+=2)u.push(l[h]),c.push(l[h+1]);return[u,c]}const _$e=ve({multiRNNCell_:S$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T$e(n,e,t,r=!1){const s=te(n,"logits","multinomial"),i=s.size,o=s.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?lt(s,[1,-1]):s},u={numSamples:e,seed:t,normalized:r},c=Ee.runKernel(UNe,l,u);return o===1?lt(c,[c.size]):c}const E$e=ve({multinomial_:T$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C$e(n,e){let t=te(n,"a","notEqual","string_or_numeric"),r=te(e,"b","notEqual","string_or_numeric");[t,r]=ws(t,r),bi(t.shape,r.shape);const s={a:t,b:r};return Ee.runKernel(GNe,s)}const y6=ve({notEqual_:C$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$e(n,e,t=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:te(n,"indices","oneHot","int32")},a={dtype:s,depth:e,onValue:t,offValue:r};return Ee.runKernel(KNe,o,a)}const N$e=ve({oneHot_:I$e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A$e(n){const t={x:te(n,"x","onesLike")};return Ee.runKernel(qNe,t)}const M$e=ve({onesLike_:A$e});function k$e(n,e){const t=te(n,"v1","outerProduct"),r=te(e,"v2","outerProduct");de(t.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);const s=lt(t,[-1,1]),i=lt(r,[1,-1]);return Pr(s,i)}const R$e=ve({outerProduct_:k$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$e(n,e,t=0){const r=te(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},i={x:r};return Ee.runKernel(ZNe,i,s)}const ww=ve({pad_:D$e});function $$e(n,e,t=0){return de(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),ww(n,[e],t)}const P$e=ve({pad1d_:$$e});function L$e(n,e,t=0){return de(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ww(n,e,t)}const O$e=ve({pad2d_:L$e});function F$e(n,e,t=0){return de(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ww(n,e,t)}const z$e=ve({pad3d_:F$e});function B$e(n,e,t=0){return de(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),ww(n,e,t)}const U$e=ve({pad4d_:B$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$e(n,e,t){const r=te(n,"x","spaceToBatchND");de(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),de(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),de(r.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},i={blockShape:e,paddings:t};return Ee.runKernel(NAe,s,i)}const v6=ve({spaceToBatchND_:V$e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$e(n,e,t,r,s,i,o){s==null&&(s=[1,1]),i==null&&(i=1),r===0&&(r="valid");const a=te(n,"x","maxPool");let l=a,u=!1;a.rank===3&&(u=!0,l=lt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),de(lf(i,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${s}'`);const c=$ke(l.shape,e,i,s,r),h=[c.dilationHeight,c.dilationWidth];let d;r==="same"?d=H$e([c.filterHeight,c.filterWidth],h):d=[[0,0],[0,0]];const p=h[0]===1&&h[1]===1,[g,w]=G$e([c.inHeight,c.inWidth],h,d),y=p?r:"valid",x=p?l:v6(l,h,g),T=(t==="avg"?()=>Z5(x,e,i,y,o):()=>m6(x,e,i,y,o))(),E=p?T:J5(T,h,w);return u?lt(E,[E.shape[1],E.shape[2],E.shape[3]]):E}function G$e(n,e,t){const r=t.map(c=>c[0]),s=t.map(c=>c[1]),i=n.concat(r,s),o=e.map((c,h)=>(c-i[h]%c)%c),a=s.map((c,h)=>c+o[h]),l=e.map((c,h)=>[r[h],a[h]]),u=e.map((c,h)=>[0,o[h]]);return[l,u]}function H$e(n,e){const r=n.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),s=r.map(o=>Math.floor(o/2)),i=r.map((o,a)=>o-s[a]);return r.map((o,a)=>[s[a],i[a]])}const j$e=ve({pool_:W$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$e(n,e){const t=te(n,"x","prelu"),r=te(e,"alpha","prelu"),s={x:t,alpha:r};return Ee.runKernel(QNe,s)}const x6=ve({prelu_:X$e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$e(n,e=null,t=!1){let r=te(n,"x","prod");r.dtype==="bool"&&(r=Ns(r,"int32"));const s={x:r},i={axis:e,keepDims:t};return Ee.runKernel(eAe,s,i)}const K$e=ve({prod_:q$e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$e(n,e,t,r){const s=n.map((c,h)=>te(c,`tensors${h}`,"raggedGather","int32")),i=te(e,"paramsDenseValues","raggedGather"),o=te(t,"indices","raggedGather","int32"),a={paramsNestedSplits:s,paramsDenseValues:i,indices:o},l={outputRaggedRank:r},u=Ee.runKernel(tAe,a,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}const Z$e=ve({raggedGather_:Y$e});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$e(n,e,t){const r=te(n,"starts","raggedRange"),s=te(e,"limits","raggedRange",r.dtype),i=te(t,"deltas","raggedRange",r.dtype),o={starts:r,limits:s,deltas:i},a=Ee.runKernel(nAe,o);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const Q$e=ve({raggedRange_:J$e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e3e(n,e,t,r,s){const i=te(n,"shape","raggedTensorToTensor","int32"),o=te(e,"values","raggedTensorToTensor"),a=te(t,"defaultValue","raggedTensorToTensor",o.dtype),l=r.map((h,d)=>te(h,`tensors${d}`,"raggedTensorToTensor","int32")),u={shape:i,values:o,defaultValue:a,rowPartitionTensors:l},c={rowPartitionTypes:s};return Ee.runKernel(rAe,u,c)}const t3e=ve({raggedTensorToTensor_:e3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n3e(n,e,t){Ja(n);const r=Bs(n);let s=null;if(t==null||t==="float32")s=new Float32Array(r);else if(t==="int32")s=new Int32Array(r);else if(t==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${t}`);for(let i=0;i<r;i++)s[i]=e();return Ee.makeTensor(s,n,t)}const r3e=ve({rand_:n3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fD{constructor(e,t,r,s,i){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=Zy.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,i,o;do s=2*this.random()-1,i=2*this.random()-1,o=s*s+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*s*a,t=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class s3e{constructor(e,t,r,s){this.alpha=e,this.beta=1/t,this.dtype=r;const i=s||Math.random();this.randu=Zy.alea(i.toString()),this.randn=new fD(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,s,i,o;for(;;){do s=this.randn.nextValue(),o=1+this.c*s;while(o<=0);if(o*=o*o,e=s*s,t=1-.331*e*e,r=.5*e+this.d*(1-o+Math.log(o)),i=this.randu(),i<t||Math.log(i)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class i3e{constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Zy.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o3e(n,e,t=1,r="float32",s){if(Ja(n),t==null&&(t=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const i=new s3e(e,t,r,s),o=fh(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const a3e=ve({randomGamma_:o3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l3e(n,e=0,t=1,r,s){if(Ja(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const i=new fD(e,t,r,!1,s),o=fh(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const w6=ve({randomNormal_:l3e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u3e(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return w6(n,0,1,e,t)}const c3e=ve({randomStandardNormal_:u3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h3e(n,e=0,t=1,r="float32",s){Ja(n);const i=fh(n,r),o=new i3e(e,t,null,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const pD=ve({randomUniform_:h3e});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d3e(n,e,t,r){return pD(n,e,t,"int32",r)}const f3e=ve({randomUniformInt_:d3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lx(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return Ee.runKernel(sAe,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p3e(n){const t={input:te(n,"input","real")};return Ee.runKernel(iAe,t)}const Ox=ve({real_:p3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m3e(n){const t={x:te(n,"x","reciprocal")};return Ee.runKernel(oAe,t)}const g3e=ve({reciprocal_:m3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y3e(n){const t={x:te(n,"x","relu")};return Ee.runKernel(aAe,t)}const JE=ve({relu_:y3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v3e(n){const t={x:te(n,"x","relu6")};return Ee.runKernel(hAe,t)}const b6=ve({relu6_:v3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x3e(n,e){const r={x:te(n,"x","reverse")},s={dims:e};return Ee.runKernel(dAe,r,s)}const rm=ve({reverse_:x3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w3e(n){const e=te(n,"x","reverse");return de(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),rm(e,0)}const b3e=ve({reverse1d_:w3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S3e(n,e){const t=te(n,"x","reverse");return de(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),rm(t,e)}const _3e=ve({reverse2d_:S3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T3e(n,e){const t=te(n,"x","reverse");return de(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),rm(t,e)}const E3e=ve({reverse3d_:T3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C3e(n,e){const t=te(n,"x","reverse");return de(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),rm(t,e)}const I3e=ve({reverse4d_:C3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N3e(n){const t={x:te(n,"x","round")};return Ee.runKernel(fAe,t)}const S6=ve({round_:N3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A3e(n){const t={x:te(n,"x","rsqrt","float32")};return Ee.runKernel(pAe,t)}const M3e=ve({rsqrt_:A3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k3e(n){const t={x:te(n,"x","selu")};return Ee.runKernel(xAe,t)}const R3e=ve({selu_:k3e});function D3e(n,e,t,r,s,i=[1,1],o="NHWC"){const a=te(n,"x","separableConv2d"),l=te(e,"depthwiseFilter","separableConv2d"),u=te(t,"pointwiseFilter","separableConv2d");let c=a,h=!1;if(a.rank===3&&(h=!0,c=lt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");de(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),de(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),de(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),de(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),de(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const d=l.shape[2],p=l.shape[3];de(u.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`);const g=cD(c,l,r,s,o,i),y=XE(g,u,1,"valid",o);return h?lt(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const $3e=ve({separableConv2d_:D3e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function P3e(n,e){const t=te(n,"x","setdiff1d"),r=te(e,"y","setdiff1d");de(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),de(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),de(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await t.data(),i=await r.data(),o=new Set(i);let a=0;for(let c=0;c<s.length;c++)o.has(s[c])||a++;const l=new HN([a],t.dtype),u=new HN([a],"int32");for(let c=0,h=0;c<s.length;c++)o.has(s[c])||(l.values[h]=s[c],u.values[h]=c,h++);return[l.toTensor(),u.toTensor()]}const L3e=P3e;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O3e(n){const t={x:te(n,"x","sign")};return Ee.runKernel(_Ae,t)}const F3e=ve({sign_:O3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z3e(n){const t={x:te(n,"x","sin","float32")};return Ee.runKernel(bAe,t)}const B3e=ve({sin_:z3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U3e(n){const t={x:te(n,"x","sinh")};return Ee.runKernel(SAe,t)}const V3e=ve({sinh_:U3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W3e(n,e,t){const r=te(n,"x","slice1d");return de(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),yr(r,[e],[t])}const G3e=ve({slice1d_:W3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H3e(n,e,t){const r=te(n,"x","slice2d");return de(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),yr(r,e,t)}const j3e=ve({slice2d_:H3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X3e(n,e,t){const r=te(n,"x","slice3d");return de(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),yr(r,e,t)}const q3e=ve({slice3d_:X3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K3e(n,e,t){const r=te(n,"x","slice4d");return de(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),yr(r,e,t)}const Y3e=ve({slice4d_:K3e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3e(n,e=-1){const t=te(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return Ee.runKernel(MAe,r,s)}const J3e=ve({softmax_:Z3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q3e(n){de(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Ee.runKernel(oNe,e)}const mD=ve({fft_:Q3e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ePe(n){de(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return Ee.runKernel(gNe,e)}const L_=ve({ifft_:ePe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tPe(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=lt(n,[t,e]);r=L_(s)}else{const s=[t,2*(e-1)],i=lt(Ox(n),[t,e]),o=lt(ZE(n),[t,e]),a=rm(yr(i,[0,1],[t,e-2]),1),l=Dt(rm(yr(o,[0,1],[t,e-2]),1),ar(-1)),u=To([i,a],1),c=To([o,l],1),h=lt(Fd(u,c),[s[0],s[1]]);r=L_(h)}if(r=Ox(r),n.rank===3&&n.shape[0]!==0){const s=r,i=n.shape[0];r=lt(r,[i,r.shape[0]/i,r.shape[1]]),s.dispose()}return r}const _6=ve({irfft_:tPe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nPe(n,e,t=0){const s={x:te(n,"x","split")},i={numOrSizeSplits:e,axis:t};return Ee.runKernel(AAe,s,i)}const Fx=ve({split_:nPe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rPe(n,e){de(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const g=n.shape.map(y=>0),w=n.shape.map(y=>y);w[n.shape.length-1]=e,s=yr(n,g,w),t=e}else if(e!=null&&e>t){const g=n.shape.map(w=>w);g[n.shape.length-1]=e-t,s=To([n,Py(g)],n.shape.length-1),t=e}else s=n;const i=Xa(s),o=lt(Fd(s,i),[r,t]),a=mD(o),l=Math.floor(t/2)+1,u=Ox(a),c=ZE(a),h=Fx(u,[l,t-l],u.shape.length-1),d=Fx(c,[l,t-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,lt(Fd(h[0],d[0]),p)}const gD=ve({rfft_:rPe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sPe(n,e){let t=te(n,"a","squaredDifference"),r=te(e,"b","squaredDifference");[t,r]=ws(t,r),bi(t.shape,r.shape);const s={a:t,b:r},i={};return Ee.runKernel(LAe,s,i)}const T6=ve({squaredDifference_:sPe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iPe(n,e){const t=te(n,"x","squeeze","string_or_numeric");return lt(t,Z2e(t.shape,e).newShape)}const zx=ve({squeeze_:iPe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oPe(n,e=0){const t=M_(n,"tensors","stack","string_or_numeric");de(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&de(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return Ee.runKernel(YNe,r,s)}const gh=ve({stack_:oPe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aPe(n,e=0){const r={x:te(n,"x","step")},s={alpha:e};return Ee.runKernel(ZAe,r,s)}const E6=ve({step_:aPe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lPe(n,e,t,r,s=0,i=0,o=0,a=0,l=0){const c={x:te(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:r,beginMask:s,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return Ee.runKernel(FAe,c,h)}const uPe=ve({stridedSlice_:lPe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cPe(n){const t={x:te(n,"x","tan","float32")};return Ee.runKernel(WAe,t)}const hPe=ve({tan_:cPe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sa(n,e){c0(n);const t=of(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return af(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function py(n,e,t){if(c0(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=of(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return af(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C6(n,e,t){if(c0(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=of(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return af(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dPe(n,e,t){if(c0(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=of(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return af(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fPe(n,e,t){if(c0(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=of(n,t);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return af(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pPe(n,e,t){if(c0(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=of(n,t);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,af(n,e,r,t)}function mPe(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(i+` update.rank < ${s}. `);if(n.length<r+(t.rank-s))throw new Error(i+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+n.length-r)throw new Error(i+` update.rank != ${s+n.length-r}`);for(let o=0;o<s;++o)if(t.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-s;++o)if(t.shape[o+s]!==n[o+r])throw new Error(i+` updates.shape[${o+s}] (${t.shape[o+s]}) != shape[${o+s}] (${n[o+s]})`)}function I6(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}mPe(t,e,n)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gPe(n,e,t){const r=te(n,"tensor","tensorScatterupdate"),s=te(e,"indices","tensorScatterupdate","int32"),i=te(t,"updates","tensorScatterupdate");if(I6(i,s,r.shape),r.dtype!==i.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${i.dtype}.`);const o={tensor:r,indices:s,updates:i},a={};return Ee.runKernel(gAe,o,a)}const yPe=ve({tensorScatterUpdate_:gPe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vPe(n,e=1,t=!0){const r=te(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const i={x:r},o={k:e,sorted:t},[a,l]=Ee.runKernel(HAe,i,o);return{values:a,indices:l}}const xPe=ve({topk_:vPe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wPe(n,e=0,t=1,r,s){if(Ja(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new fD(e,t,r,!0,s),o=fh(n,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const bPe=ve({truncatedNormal_:wPe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SPe(n,e=0){const t=te(n,"x","unique","string_or_numeric");de(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[i,o]=Ee.runKernel(XAe,r,s);return{values:i,indices:o}}const _Pe=ve({unique_:SPe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TPe(n,e,t){const r=te(n,"x","unsortedSegmentSum"),s=te(e,"segmentIds","unsortedSegmentSum","int32");de(kx(t),()=>"numSegments must be of dtype int");const i={x:r,segmentIds:s},o={numSegments:t};return Ee.runKernel(KAe,i,o)}const EPe=ve({unsortedSegmentSum_:TPe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CPe(n,e=0){const t=te(n,"x","unstack","string_or_numeric");de(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return Ee.runKernel(qAe,r,s)}const vm=ve({unstack_:CPe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IPe(n,e){return dD(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NPe(n,e=!0,t,r){return Ee.makeVariable(n,e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function APe(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const r=fh(n,"int32"),s=fh([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const o=r.indexToLoc(t[i]),a=i*n.length;s.values.set(o,a)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function MPe(n){const e=te(n,"condition","whereAsync","bool"),t=await e.data(),r=APe(e.shape,t);return n!==e&&e.dispose(),r}const N6=MPe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function kPe(n,e,t){const r=te(n,"tensor","boolMask"),s=te(e,"mask","boolMask","bool"),i=t??0,o=s.rank,a=r.shape;de(o>0,()=>"mask cannot be scalar"),Nl(a.slice(i,i+o),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let w=i;w<i+o;w++)l*=a[w];const u=a.slice(0,i).concat([l],a.slice(i+o)),c=lt(r,u),h=lt(s,[-1]),d=await N6(h),p=zx(d,[1]),g=a6(c,p,i);return n!==r&&r.dispose(),e!==s&&s.dispose(),p.dispose(),c.dispose(),h.dispose(),d.dispose(),g}const RPe=kPe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DPe(n,e,t){const r=te(n,"x","transpose");if(e==null&&(e=r.shape.map((o,a)=>a).reverse()),de(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{de(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},i={perm:e};return r.dtype==="complex64"?Qn(()=>{let o=Ox(r),a=ZE(r);return o=Ee.runKernel(nI,{x:o},i),a=Ee.runKernel(nI,{x:a},i),t&&(a=Qu(a)),Fd(o,a)}):Ee.runKernel(nI,s,i)}const sA=ve({transpose_:DPe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Pe(n,e,t,r,s=!0){const i=te(n,"v","movingAverage"),o=te(e,"x","movingAverage"),a=te(t,"decay","movingAverage");mMe(i,o),de(dh(i.shape,o.shape),()=>"Shape mismatch in v and x");const l=ar(1),u=Wn(l,a);let c=Dt(Wn(o,i),u);if(s){de(r!=null,()=>"When using zeroDebias: true, step is required.");const h=te(r,"step","movingAverage");c=Er(c,Wn(l,$x(a,h)))}return gn(i,c)}const PPe=ve({movingAverage_:$Pe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LPe(n,e,t){Ja(t);const r=te(n,"indices","scatterND","int32"),s=te(e,"updates","scatterND");I6(s,r,t);const i={indices:r,updates:s},o={shape:t};return Ee.runKernel(mAe,i,o)}const OPe=ve({scatterND_:LPe});function FPe(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(t.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${i}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zPe(n,e,t,r=0){Ja(t);const s=te(n,"sparseIndices","sparseToDense","int32"),i=te(e,"sparseValues","sparseToDense","string_or_numeric"),o=te(r,"defaultValue","sparseToDense",i.dtype);FPe(s,i,t,o);const a={sparseIndices:s,sparseValues:i,defaultValue:o},l={outputShape:t};return Ee.runKernel(PAe,a,l)}const BPe=ve({sparseToDense_:zPe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UPe(n,e){const t=te(e,"indices","gatherND","int32"),s={params:te(n,"x","gatherND","string_or_numeric"),indices:t};return Ee.runKernel(fNe,s)}const VPe=ve({gatherND_:UPe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WPe(n,e){if(e==null)return n.shape.slice();if(dh(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GPe(n,e,t,r){const s=te(n,"x","dropout");if(de(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),de(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Mi?s.clone():s;const i=WPe(s,t),o=1-e,a=Er(o6(gn(pD(i,0,1,"float32",r),o)),o);return Dt(s,a)}const HPe=ve({dropout_:GPe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A6(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function yD(n,e,t){const r=1-n%2,s=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+r-1);s[i]=e-t*Math.cos(o)}return Sa(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function jPe(n,e,t=1){const r=te(n,"predictions","inTopK"),s=te(e,"targets","inTopK");de(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),de(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Nl(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const i=r.shape[r.shape.length-1];de(t>0&&t<=i,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${i}), but got ${t}`);const o=await r.data(),a=await s.data(),[l,u]=[o.length/i,i],c=J2e("bool",l);for(let h=0;h<l;h++){const d=h*u,p=o.subarray(d,d+u),g=[];for(let w=0;w<p.length;w++)g.push({value:p[w],index:w});g.sort((w,y)=>y.value-w.value),c[h]=0;for(let w=0;w<t;w++)if(g[w].index===a[h]){c[h]=1;break}}return n!==r&&r.dispose(),e!==s&&s.dispose(),Ju(c,s.shape,"bool")}const XPe=jPe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qPe(n,e,t,r,s,i="NHWC",o){let a=n;n.rank===3&&(a=lt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=lt(e,[1,e.shape[0],e.shape[1],e.shape[2]])),de(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),de(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),de(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const u=i==="NHWC"?a.shape[3]:a.shape[1],c=i==="NHWC"?l.shape[3]:l.shape[1];de(u===t[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${t[2]}.`),de(c===t[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${t[3]}).`),_u("conv2dDerFilter",s,o);const h={x:a,dy:l},d={strides:r,pad:s,dataFormat:i,dimRoundingMode:o,filterShape:t};return Ee.runKernel(LIe,h,d)}const KPe=ve({conv2DBackpropFilter_:qPe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vD(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return Dt(n,E6(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function xD(n,e){let t=e;const r=YRe(n.shape,e.shape);return r.length>0&&(t=Jr(t,r)),lt(t,n.shape)}function wD(n,e,t,r){if(e==="linear")return n;if(e==="relu")return JE(n);if(e==="elu")return r6(n);if(e==="relu6")return b6(n);if(e==="prelu")return x6(n,t);if(e==="leakyrelu")return u6(n,r);if(e==="sigmoid")return $p(n);throw new Error(`Unknown fused activation ${e}.`)}const bD=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YPe({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",bD(Ee.state.gradientDepth,l)===!1){de(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let M=XE(n,e,t,r,s,i,o);return a!=null&&(M=gn(M,a)),wD(M,l,u,c)}const h=te(n,"x","conv2d","float32"),d=te(e,"filter","conv2d","float32");let p=h,g=!1;h.rank===3&&(g=!0,p=lt(h,[1,h.shape[0],h.shape[1],h.shape[2]])),de(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),de(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),_u("fused conv2d",r,o);const w=s==="NHWC"?p.shape[3]:p.shape[1];de(d.shape[2]===w,()=>`Error in conv2d: depth of input (${w}) must match input depth for filter ${d.shape[2]}.`),de(lf(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const y=uD(p.shape,d.shape,t,i,r,o);let x;a!=null&&(x=te(a,"bias","fused conv2d"),[x]=ws(x,h),s==="NHWC"?bi(y.outShape,x.shape):(de(x.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`),de(x.shape.length===0||x.shape[0]===y.outChannels||x.shape[0]===1,()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${y.outChannels})`)));let _;if(u!=null){const M=u.shape;if(de(M.length<=1||M.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${M.length}.`),M.length===1)de(M[0]===1||M[0]===y.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${M}) is not compatible with the number of output channels (${y.outChannels}).`);else if(M.length===3)try{bi(M,y.outShape)}catch{const L=`Error in fused conv2d: PReLU activation weights (${M}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(L)}_=te(u,"prelu weights","fused conv2d")}const T=(M,$)=>{de(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[L,k,R,P]=$,B=vD(M,R,l);de(R_(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const Z=t6(k.shape,B,L,t,r),V=KPe(k,B,L.shape,t,r),X=[Z,V];if(P!=null){const q=xD(P,B);X.push(q)}return X},E={x:p,filter:d,bias:x,preluActivationWeights:_},N={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return a==null?mh(($,L,k)=>{let R=Ee.runKernel(hO,E,N);return k([L,$,R]),g&&(R=lt(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:T}})(p,d):mh(($,L,k,R)=>{let P=Ee.runKernel(hO,E,N);return R([L,$,P,k]),g&&(P=lt(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:T}})(p,d,x)}const ZPe=ve({fusedConv2d_:YPe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JPe(n,e,t,r,s,i=[1,1],o){let a=n;n.rank===3&&(a=lt(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=lt(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={x:a,dy:l},c={strides:r,pad:s,dimRoundingMode:o,dilations:i,filterShape:t};return Ee.runKernel(qIe,u,c)}const QPe=ve({depthwiseConv2dNativeBackpropFilter_:JPe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eLe(n,e,t,r,s,i=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=lt(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const u={dy:a,filter:t},c={strides:r,pad:s,dimRoundingMode:o,dilations:i,inputShape:n},h=Ee.runKernel(KIe,u,c);return l?lt(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const tLe=ve({depthwiseConv2dNativeBackpropInput_:eLe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nLe({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(bD(Ee.state.gradientDepth,l)===!1){let N=cD(n,e,t,r,s,i,o);return a!=null&&(N=gn(N,a)),wD(N,l,u,c)}const h=te(n,"x","depthwiseConv2d","float32"),d=te(e,"filter","depthwiseConv2d","float32");let p=h,g=!1;h.rank===3&&(g=!0,p=lt(h,[1,h.shape[0],h.shape[1],h.shape[2]])),de(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),de(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),de(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),i==null&&(i=[1,1]),de(lf(t,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),_u("fused depthwiseConv2d",r,o);const w=uD(p.shape,d.shape,t,i,r,o,!0);let y;a!=null&&(y=te(a,"bias","fused conv2d"),[y]=ws(y,h),bi(w.outShape,y.shape));let x;u!=null&&(x=te(u,"prelu weights","fused depthwiseConv2d"));const _=(N,M)=>{de(R_(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[$,L,k,R]=M,P=vD(N,k,l),B=tLe(L.shape,P,$,t,r,i,o),Z=QPe(L,P,$.shape,t,r,i,o);if(R!=null){const V=xD(y,P);return[B,Z,V]}return[B,Z]},T={x:p,filter:d,bias:y,preluActivationWeights:x},E={strides:t,pad:r,dataFormat:s,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return a==null?mh((M,$,L)=>{let k=Ee.runKernel(dO,T,E);return L([$,M,k]),g&&(k=lt(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:_}})(p,d):mh((M,$,L,k)=>{let R=Ee.runKernel(dO,T,E);return k([$,M,R,L]),g&&(R=lt(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:_}})(p,d,y)}const rLe=ve({fusedDepthwiseConv2d_:nLe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sLe({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(bD(Ee.state.gradientDepth,i)===!1){let P=Pr(n,e,t,r);return s!=null&&(P=gn(P,s)),wD(P,i,o,a)}let l=te(n,"a","fused matMul"),u=te(e,"b","fused matMul");[l,u]=ws(l,u);const c=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=t?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],g=l.shape.slice(0,-2),w=u.shape.slice(0,-2),y=Bs(g),x=Bs(w);de(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${t} and transposeB=${r} must match.`);const T=bi(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,p]),E=t?lt(l,[y,c,d]):lt(l,[y,d,c]),N=r?lt(u,[x,p,h]):lt(u,[x,h,p]);let M;s!=null&&(M=te(s,"bias","fused matMul"),[M]=ws(M,l),bi(T,M.shape));let $;o!=null&&($=te(o,"prelu weights","fused matMul"));const L=(P,B)=>{const[Z,V,X,q]=B,se=vD(lt(P,X.shape),X,i);let W,J;if(!t&&!r?(W=Pr(se,V,!1,!0),J=Pr(Z,se,!0,!1)):!t&&r?(W=Pr(se,V,!1,!1),J=Pr(se,Z,!0,!1)):t&&!r?(W=Pr(V,se,!1,!0),J=Pr(Z,se,!1,!1)):(W=Pr(V,se,!0,!0),J=Pr(se,Z,!0,!0)),s!=null){const K=xD(q,se);return[W,J,K]}else return[W,J]},k={a:E,b:N,bias:M,preluActivationWeights:$},R={transposeA:t,transposeB:r,activation:i,leakyreluAlpha:a};return s==null?mh((B,Z,V)=>{const X=Ee.runKernel(cO,k,R);return V([B,Z,X]),{value:lt(X,T),gradFunc:L}})(E,N):mh((B,Z,V,X)=>{const q=Ee.runKernel(cO,k,R);return X([B,Z,q,V]),{value:lt(q,T),gradFunc:L}})(E,N,M)}const iLe=ve({fusedMatMul_:sLe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oLe=Object.freeze(Object.defineProperty({__proto__:null,conv2d:ZPe,depthwiseConv2d:rLe,matMul:iLe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aLe(n){return yD(n,.54,.46)}const lLe=ve({hammingWindow_:aLe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uLe(n){return yD(n,.5,.5)}const M6=ve({hannWindow_:uLe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cLe(n,e,t,r=!1,s=0){let i=0;const o=[];for(;i+e<=n.size;)o.push(yr(n,i,e)),i+=t;if(r)for(;i<n.size;){const a=i+e-n.size,l=To([yr(n,i,e-a),xw([a],s)]);o.push(l),i+=t}return o.length===0?py([],[0,e]):lt(To(o),[o.length,e])}const k6=ve({frame_:cLe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hLe(n,e,t,r,s=M6){r==null&&(r=A6(e));const i=k6(n,e,t),o=Dt(i,s(e));return gD(o,r)}const dLe=ve({stft_:hLe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fLe(n,e,t,r,s="bilinear",i=0){const o=te(n,"image","cropAndResize"),a=te(e,"boxes","cropAndResize","float32"),l=te(t,"boxInd","cropAndResize","int32"),u=a.shape[0];de(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),de(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${a.shape}.`),de(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${a.shape}.`),de(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),de(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),de(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:o,boxes:a,boxInd:l},h={method:s,extrapolationValue:i,cropSize:r};return Ee.runKernel(GIe,c,h)}const pLe=ve({cropAndResize_:fLe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mLe(n){const e=te(n,"image","flipLeftRight","float32");de(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return Ee.runKernel(lNe,t,{})}const gLe=ve({flipLeftRight_:mLe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yLe(n){const e=te(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];de(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),de(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,Kv(e,s)}const vLe=ve({grayscaleToRGB_:yLe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xLe(n){const e=te(n,"image","RGBToGrayscale"),t=e.rank-1,r=e.shape[t];de(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),de(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,i=Ns(e,"float32"),o=Sa([.2989,.587,.114]);let a;switch(e.rank){case 2:a=Qg("ij,j->i",i,o);break;case 3:a=Qg("ijk,k->ij",i,o);break;case 4:a=Qg("ijkl,l->ijk",i,o);break;case 5:a=Qg("ijklm,m->ijkl",i,o);break;case 6:a=Qg("ijklmn,n->ijklm",i,o);break;default:throw new Error("Not a valid tensor rank.")}return a=Kc(a,-1),Ns(a,s)}const wLe=ve({rgbToGrayscale_:xLe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bLe(n,e,t=0,r=.5){const s=te(n,"image","rotateWithOffset","float32");de(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const i={image:s},o={radians:e,fillValue:t,center:r};return Ee.runKernel(JAe,i,o)}const SLe=ve({rotateWithOffset_:bLe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h0(n,e,t,r,s,i){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return t=Math.min(t,o),de(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),de(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),de(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),de(e.rank===1,()=>"scores must be a 1D tensor"),de(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),de(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Le(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const i=te(n,"boxes","nonMaxSuppression","float32"),o=te(e,"scores","nonMaxSuppression","float32"),a=h0(i,o,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:r,scoreThreshold:s};return Ee.runKernel(HNe,{boxes:i,scores:o},l)}const TLe=ve({nonMaxSuppression_:_Le});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ELe(n,e,t){const r=CLe(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function CLe(n,e,t){return NLe(n,e,t||ILe)}function ILe(n,e){return n>e?1:n<e?-1:0}function NLe(n,e,t){let r=0,s=n.length,i=0,o=!1;for(;r<s;){i=r+(s-r>>>1);const a=t(e,n[i]);a>0?r=i+1:(s=i,o=!a)}return o?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ALe(n,e,t,r,s){return SD(n,e,t,r,s,0)}function MLe(n,e,t,r,s,i){return SD(n,e,t,r,s,0,!1,i,!0)}function kLe(n,e,t,r,s,i){return SD(n,e,t,r,s,i,!0)}function SD(n,e,t,r,s,i,o=!1,a=!1,l=!1){const u=[];for(let y=0;y<e.length;y++)e[y]>s&&u.push({score:e[y],boxIndex:y,suppressBeginIndex:0});u.sort(_O);const c=i>0?-.5/i:0,h=[],d=[];for(;h.length<t&&u.length>0;){const y=u.pop(),{score:x,boxIndex:_,suppressBeginIndex:T}=y;if(x<s)break;let E=!1;for(let N=h.length-1;N>=T;--N){const M=RLe(n,_,h[N]);if(M>=r){E=!0;break}if(y.score=y.score*DLe(r,c,M),y.score<=s)break}y.suppressBeginIndex=h.length,E||(y.score===x?(h.push(_),d.push(y.score)):y.score>s&&ELe(u,y,_O))}const p=h.length,g=t-p;a&&g>0&&(h.push(...new Array(g).fill(0)),d.push(...new Array(g).fill(0)));const w={selectedIndices:h};return o&&(w.selectedScores=d),l&&(w.validOutputs=p),w}function RLe(n,e,t){const r=n.subarray(e*4,e*4+4),s=n.subarray(t*4,t*4+4),i=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(a-i)*(l-o),g=(h-u)*(d-c);if(p<=0||g<=0)return 0;const w=Math.max(i,u),y=Math.max(o,c),x=Math.min(a,h),_=Math.min(l,d),T=Math.max(x-w,0)*Math.max(_-y,0);return T/(p+g-T)}function DLe(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function _O(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function $Le(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const i=te(n,"boxes","nonMaxSuppressionAsync"),o=te(e,"scores","nonMaxSuppressionAsync"),a=h0(i,o,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),u=l[0],c=l[1],{selectedIndices:h}=ALe(u,c,t,r,s);return i!==n&&i.dispose(),o!==e&&o.dispose(),Sa(h,"int32")}const PLe=$Le;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LLe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=te(n,"boxes","nonMaxSuppression"),a=te(e,"scores","nonMaxSuppression"),l=h0(o,a,t,r,s,i);t=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const u={boxes:o,scores:a},c={maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:i},h=Ee.runKernel(XNe,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}const OLe=ve({nonMaxSuppressionWithScore_:LLe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function FLe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=0){const o=te(n,"boxes","nonMaxSuppressionAsync"),a=te(e,"scores","nonMaxSuppressionAsync"),l=h0(o,a,t,r,s,i);t=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,i=l.softNmsSigma;const u=await Promise.all([o.data(),a.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=kLe(c,h,t,r,s,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Sa(d,"int32"),selectedScores:Sa(p)}}const zLe=FLe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BLe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=te(n,"boxes","nonMaxSuppression"),a=te(e,"scores","nonMaxSuppression"),l=h0(o,a,t,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,d={boxes:o,scores:a},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:i},g=Ee.runKernel(jNe,d,p);return{selectedIndices:g[0],validOutputs:g[1]}}const ULe=ve({nonMaxSuppressionPadded_:BLe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function VLe(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,i=!1){const o=te(n,"boxes","nonMaxSuppressionAsync"),a=te(e,"scores","nonMaxSuppressionAsync"),l=h0(o,a,t,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:g,validOutputs:w}=MLe(d,p,u,c,h,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:Sa(g,"int32"),validOutputs:ar(w,"int32")}}const WLe=VLe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GLe(n,e,t=!1,r=!1){const s=te(n,"images","resizeBilinear");de(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),de(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),de(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;s.rank===3&&(o=!0,i=lt(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:r,size:e},u=Ee.runKernel(cAe,a,l);return o?lt(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const HLe=ve({resizeBilinear_:GLe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jLe(n,e,t=!1,r=!1){const s=te(n,"images","resizeNearestNeighbor");de(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),de(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),de(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),de(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,o=!1;s.rank===3&&(o=!0,i=lt(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:r,size:e},u=Ee.runKernel(uAe,a,l);return o?lt(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const XLe=ve({resizeNearestNeighbor_:jLe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qLe(n,e="binary",t=!1,r=.5){const s=te(n,"image","threshold"),i=.2989,o=.587,a=.114,l=s.shape[0]*s.shape[1];let u=Dt(Sa([r]),255),c,h,d,p;if(de(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),de(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),de(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),de(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[c,h,d]=Fx(s,[1,1,1],-1);const y=Dt(c,i),x=Dt(h,o),_=Dt(d,a);p=gn(gn(y,x),_)}else p=n;if(e==="otsu"){const y=Q5(Ns(S6(p),"int32"),Ju([]),256);u=KLe(y,l)}const g=t?hD(p,u):YE(p,u);return Ns(Dt(g,255),"int32")}function KLe(n,e){let t=Sa([-1]),r=Sa([0]),s=Sa([0]),i,o,a,l,u,c;for(let h=0;h<n.size-1;h++){i=yr(n,0,h+1),o=yr(n,h+1),u=Er(Jr(i),e),c=Er(Jr(o),e);const d=Jr(Dt(i,Lx(0,i.size)));a=Er(d,Jr(i));const p=xw(o.shape,i.size),g=gn(Lx(0,o.size),p),w=Dt(o,g);l=Er(Jr(w),Jr(o));const y=Wn(a,l),x=Wn(a,l),_=Dt(u,c);s=Dt(Dt(_,y),x);const T=YE(s,r);r=Id(T,s,r),t=Id(T,Sa([h]),t)}return t}const YLe=ve({threshold_:qLe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZLe(n,e,t="nearest",r="constant",s=0,i){const o=te(n,"image","transform","float32"),a=te(e,"transforms","transform","float32");de(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),de(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),de(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},u={interpolation:t,fillMode:r,fillValue:s,outputShape:i};return Ee.runKernel(jAe,l,u)}const JLe=ve({transform_:ZLe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QLe(n,e,t){const r=te(n,"a","bandPart");de(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[i,o]=r.shape.slice(-2);let a,l;typeof e=="number"?(de(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),de(e<=i,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`),a=te(e<0?i:e,"numLower","bandPart")):(de(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=Id(rA(e,0),i,P_(e,i))),typeof t=="number"?(de(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),de(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),l=te(t<0?o:t,"numUpper","bandPart")):(de(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Id(rA(t,0),o,P_(t,o)));const u=lt(Lx(0,i,1,"int32"),[-1,1]),c=Lx(0,o,1,"int32"),h=Wn(u,c),d=D_(hD(h,a),l6(h,Qu(l))),p=Py([i,o],r.dtype);return lt(gh(vm(lt(r,[-1,i,o])).map(g=>Id(d,g,p))),s)}const eOe=ve({bandPart_:QLe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tOe(n){let e;if(Array.isArray(n)){e=!1,de(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let i=1;i<n.length;++i)de(n[i].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${s})`)}else e=!0,n=Fx(n,n.shape[0],0).map(s=>zx(s,[0]));de(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(Ee.tidy(()=>{let i=r[s];if(s>0)for(let o=0;o<s;++o){const a=Dt(Jr(Dt(t[o],i)),t[o]);i=Wn(i,a)}return Er(i,KE(i,"euclidean"))}));return e?gh(t,0):t}const nOe=ve({gramSchmidt_:tOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rOe(n,e=!1){if(de(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return TO(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),r=vm(lt(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],i=[];r.forEach(l=>{const[u,c]=TO(l,e);s.push(u),i.push(c)});const o=lt(gh(s,0),n.shape),a=lt(gh(i,0),n.shape);return[o,a]}}function TO(n,e=!1){return Ee.tidy(()=>{de(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=i6(t),i=Cd(n);const o=py([[1]],[1,1]);let a=Cd(o);const l=t>=r?r:t;for(let u=0;u<l;++u){const c=i,h=a,d=s;[a,i,s]=Ee.tidy(()=>{const p=yr(i,[u,u],[t-u,1]),g=KE(p),w=yr(i,[u,u],[1,1]),y=Id(YE(w,0),py([[-1]]),py([[1]])),x=Wn(w,Dt(y,g)),_=Er(p,x);_.shape[0]===1?a=Cd(o):a=To([o,yr(_,[1,0],[_.shape[0]-1,_.shape[1]])],0);const T=Qu(Er(Pr(y,x),g)),E=yr(i,[u,0],[t-u,r]),N=Dt(T,a),M=sA(a);if(u===0)i=Wn(E,Pr(N,Pr(M,E)));else{const k=Wn(E,Pr(N,Pr(M,E)));i=To([yr(i,[0,0],[u,r]),k],0)}const $=sA(N),L=yr(s,[0,u],[t,s.shape[1]-u]);if(u===0)s=Wn(L,Pr(Pr(L,a),$));else{const k=Wn(L,Pr(Pr(L,a),$));s=To([yr(s,[0,0],[t,u]),k],1)}return[a,i,s]}),qo([c,h,d])}return!e&&t>r&&(s=yr(s,[0,0],[t,r]),i=yr(i,[0,0],[r,r])),[s,i]})}const sOe=ve({qr_:rOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ho;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ho||(Ho={}));function iOe(n,e,t=Ho.SUM_BY_NONZERO_WEIGHTS){const r=te(n,"losses","computeWeightedLoss");let s=null;e!=null&&(s=te(e,"weights","computeWeightedLoss"));const i=s==null?r:Dt(r,s);if(t===Ho.NONE)return i;if(t===Ho.SUM)return Jr(i);if(t===Ho.MEAN){if(s==null)return $_(i);{const o=r.size/s.size,a=Er(Jr(i),Jr(s));return o>1?Er(a,ar(o)):a}}if(t===Ho.SUM_BY_NONZERO_WEIGHTS){if(s==null)return Er(Jr(i),ar(r.size));{const o=Dt(s,Ep(r.shape)),a=Ns(Jr(y6(o,ar(0))),"float32");return Er(Jr(i),a)}}throw Error(`Unknown reduction: ${t}`)}const bh=ve({computeWeightedLoss_:iOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oOe(n,e,t,r=Ho.SUM_BY_NONZERO_WEIGHTS){const s=te(n,"labels","absoluteDifference"),i=te(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=te(t,"weights","absoluteDifference")),Nl(s.shape,i.shape,"Error in absoluteDifference: ");const a=Va(Wn(s,i));return bh(a,o,r)}const aOe=ve({absoluteDifference_:oOe});function lOe(n,e,t,r,s=Ho.SUM_BY_NONZERO_WEIGHTS){const i=te(n,"labels","cosineDistance"),o=te(e,"predictions","cosineDistance");let a=null;r!=null&&(a=te(r,"weights","cosineDistance")),Nl(i.shape,o.shape,"Error in cosineDistance: ");const l=ar(1),u=Wn(l,Jr(Dt(i,o),t,!0));return bh(u,a,s)}const uOe=ve({cosineDistance_:lOe});function cOe(n,e,t,r=Ho.SUM_BY_NONZERO_WEIGHTS){let s=te(n,"labels","hingeLoss");const i=te(e,"predictions","hingeLoss");let o=null;t!=null&&(o=te(t,"weights","hingeLoss")),Nl(s.shape,i.shape,"Error in hingeLoss: ");const a=ar(1);s=Wn(Dt(ar(2),s),a);const l=JE(Wn(a,Dt(s,i)));return bh(l,o,r)}const hOe=ve({hingeLoss_:cOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dOe(n,e,t,r=1,s=Ho.SUM_BY_NONZERO_WEIGHTS){const i=te(n,"labels","huberLoss"),o=te(e,"predictions","huberLoss");let a=null;t!=null&&(a=te(t,"weights","huberLoss")),Nl(i.shape,o.shape,"Error in huberLoss: ");const l=ar(r),u=Va(Wn(o,i)),c=P_(u,l),h=Wn(u,c),d=gn(Dt(ar(.5),mu(c)),Dt(l,h));return bh(d,a,s)}const fOe=ve({huberLoss_:dOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pOe(n,e,t,r=1e-7,s=Ho.SUM_BY_NONZERO_WEIGHTS){const i=te(n,"labels","logLoss"),o=te(e,"predictions","logLoss");let a=null;t!=null&&(a=te(t,"weights","logLoss")),Nl(i.shape,o.shape,"Error in logLoss: ");const l=ar(1),u=ar(r),c=Qu(Dt(i,Px(gn(o,u)))),h=Dt(Wn(l,i),Px(gn(Wn(l,o),u))),d=Wn(c,h);return bh(d,a,s)}const mOe=ve({logLoss_:pOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gOe(n,e,t,r=Ho.SUM_BY_NONZERO_WEIGHTS){const s=te(n,"labels","meanSquaredError"),i=te(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=te(t,"weights","meanSquaredError")),Nl(s.shape,i.shape,"Error in meanSquaredError: ");const a=T6(s,i);return bh(a,o,r)}const yOe=ve({meanSquaredError_:gOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vOe(n,e){const t=te(n,"labels","sigmoidCrossEntropyWithLogits"),r=te(e,"logits","sigmoidCrossEntropyWithLogits");Nl(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=JE(r),i=Dt(r,t),o=c6(nm(Qu(Va(r))));return gn(Wn(s,i),o)}function xOe(n,e,t,r=0,s=Ho.SUM_BY_NONZERO_WEIGHTS){let i=te(n,"multiClassLabels","sigmoidCrossEntropy");const o=te(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=te(t,"weights","sigmoidCrossEntropy")),Nl(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const u=ar(r),c=ar(1),h=ar(.5);i=gn(Dt(i,Wn(c,u)),Dt(h,u))}const l=vOe(i,o);return bh(l,a,s)}const wOe=ve({sigmoidCrossEntropy_:xOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bOe(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return mh((s,i,o)=>{const l=d6(i,[t],!0),u=Wn(Ns(i,"float32"),l);o([s,u]);const c=Qu(Dt(u,s));return{value:Jr(c,[t]),gradFunc:(p,g)=>{const[w,y]=g,x=qE(p.shape,[t]);return[Dt(lt(p,x),Wn(Ns(w,"float32"),nm(y))),Dt(lt(p,x),Wn(nm(y),Ns(w,"float32")))]}}})(n,e)}function SOe(n,e,t,r=0,s=Ho.SUM_BY_NONZERO_WEIGHTS){let i=te(n,"onehotLabels","softmaxCrossEntropy");const o=te(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=te(t,"weights","softmaxCrossEntropy")),Nl(i.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const u=ar(r),c=ar(1),h=ar(i.shape[1]);i=gn(Dt(i,Wn(c,u)),Er(u,h))}const l=bOe(i,o);return bh(l,a,s)}const _Oe=ve({softmaxCrossEntropy_:SOe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TOe(n,e,t,r){const s=te(n,"indices","sparseFillEmptyRows","int32"),i=te(e,"values","sparseFillEmptyRows"),o=te(t,"denseShape","sparseFillEmptyRows","int32"),a=te(r,"defaultValue","sparseFillEmptyRows",i.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:s,values:i,denseShape:o,defaultValue:a},u=Ee.runKernel(kAe,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}const EOe=ve({sparseFillEmptyRows_:TOe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function COe(n,e,t){const r=te(n,"inputIndices","sparseReshape","int32"),s=te(e,"inputShape","sparseReshape","int32"),i=te(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const o={inputIndices:r,inputShape:s,newShape:i},a=Ee.runKernel(RAe,o);return{outputIndices:a[0],outputShape:a[1]}}const IOe=ve({sparseReshape_:COe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NOe(n,e,t){const r=te(n,"data","sparseSegmentMean"),s=te(e,"indices","sparseSegmentMean","int32"),i=te(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const o={data:r,indices:s,segmentIds:i};return Ee.runKernel(DAe,o)}const AOe=ve({sparseSegmentMean_:NOe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MOe(n,e,t){const r=te(n,"data","sparseSegmentSum"),s=te(e,"indices","sparseSegmentSum","int32"),i=te(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const o={data:r,indices:s,segmentIds:i};return Ee.runKernel($Ae,o)}const kOe=ve({sparseSegmentSum_:MOe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ROe(n,e,t,r,s,i,o,a){const l=te(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=te(e,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:t,nGramWidths:r,leftPad:s,rightPad:i,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:u},d=Ee.runKernel(zAe,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}const DOe=ve({stringNGrams_:ROe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Oe(n,e,t=!0){const r=te(n,"input","stringSplit","string"),s=te(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const i={skipEmpty:t},o={input:r,delimiter:s},a=Ee.runKernel(BAe,o,i);return{indices:a[0],values:a[1],shape:a[2]}}const POe=ve({stringSplit_:$Oe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LOe(n,e){const t=te(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return Ee.runKernel(UAe,s,r)}const OOe=ve({stringToHashBucketFast_:LOe});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FOe(n,e,t,r=!0){const s=te(n,"input","staticRegexReplace","string"),i={pattern:e,rewrite:t,replaceGlobal:r};return Ee.runKernel(OAe,{x:s},i)}const zOe=ve({staticRegexReplace_:FOe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BOe={fft:mD,ifft:L_,rfft:gD,irfft:_6},UOe={hammingWindow:lLe,hannWindow:M6,frame:k6,stft:dLe},Bx={flipLeftRight:gLe,grayscaleToRGB:vLe,resizeNearestNeighbor:XLe,resizeBilinear:HLe,rgbToGrayscale:wLe,rotateWithOffset:SLe,cropAndResize:pLe,nonMaxSuppression:TLe,nonMaxSuppressionAsync:PLe,nonMaxSuppressionWithScore:OLe,nonMaxSuppressionWithScoreAsync:zLe,nonMaxSuppressionPadded:ULe,nonMaxSuppressionPaddedAsync:WLe,threshold:YLe,transform:JLe},VOe={bandPart:eOe,gramSchmidt:nOe,qr:sOe},WOe={absoluteDifference:aOe,computeWeightedLoss:bh,cosineDistance:uOe,hingeLoss:hOe,huberLoss:fOe,logLoss:mOe,meanSquaredError:yOe,sigmoidCrossEntropy:wOe,softmaxCrossEntropy:_Oe},GOe={sparseFillEmptyRows:EOe,sparseReshape:IOe,sparseSegmentMean:AOe,sparseSegmentSum:kOe},HOe={stringNGrams:DOe,stringSplit:POe,stringToHashBucketFast:OOe,staticRegexReplace:zOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jOe=new Map,XOe=new Map;class qOe{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class pp{constructor(){this.classNameMap={}}static getMap(){return pp.instance==null&&(pp.instance=new pp),pp.instance}static register(e){pp.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function KOe(n,e,t){de(n.className!=null,()=>"Class being registered does not have the static className property defined."),de(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),de(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const r=t,s=e+">"+r;return pp.register(n),jOe.set(s,n),XOe.set(n,s),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xm extends qOe{minimize(e,t=!1,r){const{value:s,grads:i}=this.computeGradients(e,r);if(r!=null){const o=r.map(a=>({name:a.name,tensor:i[a.name]}));this.applyGradients(o)}else this.applyGradients(i);return qo(i),t?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return HDe(e,t)}dispose(){this.iterations_!=null&&qo(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ar(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(xm,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YOe extends xm{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=Ee.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Ee.registeredVariables[r],o=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:Qn(()=>Xa(i).variable(o))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:Qn(()=>Xa(i).variable(o))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedGrads[s].variable,u=this.accumulatedUpdates[s].variable;Qn(()=>{const c=gn(Dt(l,this.rho),Dt(mu(a),1-this.rho)),h=Dt(Er(ph(gn(u,this.epsilon)),ph(gn(l,this.epsilon))),a),d=gn(Dt(u,this.rho),Dt(mu(h),1-this.rho));l.assign(c),u.assign(d);const p=gn(Dt(h,-this.learningRate),i);i.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(qo(this.accumulatedGrads.map(e=>e.variable)),qo(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZOe extends xm{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Ee.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:Qn(()=>xw(i.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const a=this.accumulatedGrads[s].variable;Qn(()=>{const l=gn(a,mu(o));a.assign(l);const u=gn(Dt(Er(o,ph(gn(l,Ee.backend.epsilon()))),-this.learningRate),i);i.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&qo(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JOe extends xm{static get className(){return"Adam"}constructor(e,t,r,s=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Qn(()=>{this.accBeta1=ar(t).variable(),this.accBeta2=ar(r).variable()}),s==null&&(this.epsilon=Ee.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Qn(()=>{const r=Wn(1,this.accBeta1),s=Wn(1,this.accBeta2);t.forEach((i,o)=>{const a=Ee.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:Qn(()=>Xa(a).variable(l))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${i}/v`,variable:Qn(()=>Xa(a).variable(l))});const u=Array.isArray(e)?e[o].tensor:e[i];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedSecondMoment[o].variable,d=gn(Dt(c,this.beta1),Dt(u,1-this.beta1)),p=gn(Dt(h,this.beta2),Dt(mu(u),1-this.beta2)),g=Er(d,r),w=Er(p,s);c.assign(d),h.assign(p);const y=gn(Dt(Er(g,gn(ph(w),this.epsilon)),-this.learningRate),a);a.assign(y)}),this.accBeta1.assign(Dt(this.accBeta1,this.beta1)),this.accBeta2.assign(Dt(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&qo(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&qo(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),Qn(()=>{this.accBeta1.assign($x(this.beta1,this.iterations_+1)),this.accBeta2.assign($x(this.beta2,this.iterations_+1))});const t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QOe extends xm{static get className(){return"Adamax"}constructor(e,t,r,s=null,i=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.decay=i,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Qn(()=>{this.iteration=ar(0).variable(),this.accBeta1=ar(t).variable()}),s==null&&(this.epsilon=Ee.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);Qn(()=>{const r=Wn(1,this.accBeta1),s=Er(-this.learningRate,gn(Dt(this.iteration,this.decay),1));t.forEach((i,o)=>{const a=Ee.registeredVariables[i],l=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${i}/m`,variable:Xa(a).variable(l)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${i}/v`,variable:Xa(a).variable(l)});const u=Array.isArray(e)?e[o].tensor:e[i];if(u==null)return;const c=this.accumulatedFirstMoment[o].variable,h=this.accumulatedWeightedInfNorm[o].variable,d=gn(Dt(c,this.beta1),Dt(u,1-this.beta1)),p=Dt(h,this.beta2),g=Va(u),w=g6(p,g);c.assign(d),h.assign(w);const y=gn(Dt(Er(s,r),Er(d,gn(w,this.epsilon))),a);a.assign(y)}),this.iteration.assign(gn(this.iteration,1)),this.accBeta1.assign(Dt(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&qo(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&qo(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R6 extends xm{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const o=Ee.registeredVariables[r];Qn(()=>{const a=gn(Dt(this.c,i),o);o.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Gu(ar(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eFe extends R6{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=ar(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Ee.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:Qn(()=>Xa(i).variable(!1))});const o=this.accumulations[s].variable,a=Array.isArray(e)?e[s].tensor:e[r];a!=null&&Qn(()=>{let l;const u=gn(Dt(this.m,o),a);this.useNesterov?l=gn(Dt(this.c,gn(a,Dt(u,this.m))),i):l=gn(Dt(this.c,u),i),o.assign(u),i.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&qo(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tFe extends xm{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,s=null,i=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=i,s==null&&(this.epsilon=Ee.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const i=Ee.registeredVariables[r],o=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:Qn(()=>Xa(i).variable(o))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:Qn(()=>Xa(i).variable(o))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:Qn(()=>Xa(i).variable(o))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const l=this.accumulatedMeanSquares[s].variable,u=this.accumulatedMoments[s].variable;Qn(()=>{const c=gn(Dt(l,this.decay),Dt(mu(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[s].variable,d=gn(Dt(h,this.decay),Dt(a,1-this.decay)),p=Er(Dt(a,this.learningRate),ph(Wn(c,gn(mu(d),this.epsilon)))),g=gn(Dt(u,this.momentum),p);l.assign(c),h.assign(d),u.assign(g);const w=Wn(i,g);i.assign(w)}else{const h=gn(Dt(l,this.decay),Dt(mu(a),1-this.decay)),d=gn(Dt(u,this.momentum),Er(Dt(a,this.learningRate),ph(gn(h,this.epsilon))));l.assign(h),u.assign(d);const p=Wn(i,d);i.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&qo(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&qo(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&qo(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nFe=[YOe,ZOe,JOe,QOe,eFe,tFe,R6];function rFe(){for(const n of nFe)KOe(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sFe="model",iFe=".json",oFe=".weights.bin";function EO(n){return new Promise(e=>setTimeout(e)).then(n)}class sm{constructor(e){if(!kn().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(sm.URL_SCHEME)&&(e=e.slice(sm.URL_SCHEME.length)),(e==null||e.length===0)&&(e=sFe),this.modelJsonFileName=e+iFe,this.weightDataFileName=e+oFe}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Su.join(e.weightData),r=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=B5(e,s),o=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=o,await EO(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await EO(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:vw(e)}}}}sm.URL_SCHEME="downloads://";class aFe{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const r=new FileReader;r.onload=s=>{const i=JSON.parse(s.target.result),o=i.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(i.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const l=lD(i,u=>this.loadWeights(u));e(l)},r.onerror=s=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const t=[],r=[];for(const o of e)t.push(...o.weights),r.push(...o.paths);const s=this.checkManifestAndWeightFiles(e),i=r.map(o=>this.loadWeightsFile(o,s[o]));return Promise.all(i).then(o=>[t,o])}loadWeightsFile(e,t){return new Promise((r,s)=>{const i=new FileReader;i.onload=o=>{const a=o.target.result;r(a)},i.onerror=o=>s(`Failed to weights data from file of path '${e}'.`),i.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],r=this.weightsFiles.map(i=>SO(i.name)),s={};for(const i of e)i.paths.forEach(o=>{const a=SO(o);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);s[o]=this.weightsFiles[r.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const lFe=n=>kn().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(sm.URL_SCHEME)?uFe(n.slice(sm.URL_SCHEME.length)):null;hs.registerSaveRouter(lFe);function uFe(n="model"){return new sm(n)}function cFe(n){return new aFe(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CO(n,e,t,r){o(n),t=t??0,r=r??1,a(t,r);let s=0;const i=l=>(l.then(u=>{const c=t+ ++s/n.length*(r-t);return e(c),u}),l);function o(l){de(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,u){de(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),de(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),de(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(n.map(i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function D6(n,e){e==null&&(e={});const t=e.fetchFunc==null?kn().platform.fetch:e.fetchFunc,r=n.map(h=>t(h,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(r):await CO(r,e.onProgress,0,.5)).map(h=>h.arrayBuffer());return e.onProgress==null?await Promise.all(a):await CO(a,e.onProgress,.5,1)}function hFe(n,e){var t;const r=e.fetchFunc==null?kn().platform.fetch:e.fetchFunc;let s=0,i;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async o=>{for(var a;s<n.length;){i||(i=(await r(n[s],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:u}=await i.read();if(l){s++,i=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,s/n.length);continue}o.enqueue(u);return}o.close()}})}async function dFe(n,e="",t,r){return $6(o=>D6(o,{requestInit:r}))(n,e,t)}function $6(n){return async(e,t="",r)=>{const s=e.map(()=>!1),i={},o=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((p,g)=>{let w=0;p.weights.forEach(y=>{const x="quantization"in y?y.quantization.dtype:y.dtype,_=Qp[x]*Bs(y.shape),T=()=>{s[g]=!0,i[g]==null&&(i[g]=[]),i[g].push({manifestEntry:y,groupOffset:w,sizeBytes:_})};r!=null?r.forEach((E,N)=>{E===y.name&&(T(),o[N]=!0)}):T(),a.push(y.name),w+=_})}),!o.every(p=>p)){const p=r.filter((g,w)=>!o[w]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=s.reduce((p,g,w)=>(g&&p.push(w),p),[]),u=[];l.forEach(p=>{e[p].paths.forEach(g=>{const w=t+(t.endsWith("/")?"":"/")+g;u.push(w)})});const c=await n(u),h={};let d=0;return l.forEach(p=>{const g=e[p].paths.length,w=new Su(c.slice(d,d+g));i[p].forEach(x=>{const _=w.slice(x.groupOffset,x.groupOffset+x.sizeBytes),T=O5(_,[x.manifestEntry]);for(const E in T)h[E]=T[E]}),d+=g}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fFe="application/octet-stream",pFe="application/json";class _D{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(de(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=kn().platform.fetch,de(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&de(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=B5(e,r);if(t.body.append("model.json",new Blob([JSON.stringify(s)],{type:pFe}),"model.json"),e.weightData!=null){const o=Su.join(e.weightData);t.body.append("model.weights.bin",new Blob([o],{type:fFe}),"model.weights.bin")}const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:vw(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=t.modelTopology,s=t.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return lD(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),r=YN(e.weightsManifest),s=()=>hFe(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:r,getWeightStream:s})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=mFe(t),i=this.weightPathPrefix||r,o=[],a=[];for(const l of e)for(const u of l.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(u)):o.push(i+u+s);return this.weightUrlConverter&&o.push(...await Promise.all(a)),o}async loadWeights(e){const t=await this.getWeightUrls(e),r=YN(e),s=await D6(t,this.loadOptions);return[r,s]}}_D.URL_SCHEME_REGEX=/^https?:\/\//;function mFe(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),s=t>e?n.substring(t):"";return[r+"/",s]}function iA(n){return n.match(_D.URL_SCHEME_REGEX)!=null}const P6=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>iA(r)):t=iA(n),t)return TD(n,e)}return null};hs.registerSaveRouter(P6);hs.registerLoadRouter(P6);function TD(n,e){return new _D(n,e)}function gFe(n,e){return TD(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oI{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class L6{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class yFe{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function vFe(n,e,t,r){const s=arguments;return new yFe(O6(...s))}function O6(n,e,t,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new oI(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new oI({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new oI({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:r}))}function xFe(n){return new L6(n)}function wFe(n){return new L6(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F6=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Su,browserFiles:cFe,browserHTTPRequest:gFe,concatenateArrayBuffers:AMe,copyModel:ZMe,decodeWeights:O5,decodeWeightsStream:z5,encodeWeights:_Me,fromMemory:vFe,fromMemorySync:O6,getLoadHandlers:OMe,getModelArtifactsForJSON:lD,getModelArtifactsForJSONSync:U5,getModelArtifactsInfoForJSON:vw,getSaveHandlers:LMe,getWeightSpecs:YN,http:TD,isHTTPScheme:iA,listModels:KMe,loadWeights:dFe,moveModel:JMe,registerLoadRouter:PMe,registerSaveRouter:$Me,removeModel:YMe,weightsLoaderFactory:$6,withSaveHandler:xFe,withSaveHandlerSync:wFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let op;function bFe(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,i=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)i=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(GN(uO,Ee.backendName)!=null){const g={pixels:n},w={numChannels:e};return Ee.runKernel(uO,g,w)}const[u,c]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(o)h=n.getContext("2d").getImageData(0,0,u,c).data;else if(r||t)h=n.data;else if(i||s||a){if(op==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")op=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else op=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});op.canvas.width=u,op.canvas.height=c,op.drawImage(n,0,0,u,c),h=op.getImageData(0,0,u,c).data}let d;if(e===4)d=new Int32Array(h);else{const g=u*c;d=new Int32Array(g*e);for(let w=0;w<g;w++)for(let y=0;y<e;++y)d[w*e+y]=h[w*4+y]}return C6(d,[c,u,e],"int32")}const SFe=ve({fromPixels_:bFe});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */rFe();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Fe=kn();_Fe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ga;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(ga||(ga={}));var IO;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(IO||(IO={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TFe={};function z6(n){return TFe[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z(n,e,t,r,s){const i=e.inputParams[n];if(i&&i.inputIndexStart!==void 0){const a=i.inputIndexStart,l=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?a+1:i.inputIndexEnd,u=a<0?e.inputNames.length+a:a;if(i.type==="tensor")return Ri(e.inputNames[u],t,r,s);if(i.type==="tensors"){const d=e.inputs.slice(a,l);return e.inputNames.slice(a,l).filter((g,w)=>{var y;return((y=d[w])===null||y===void 0?void 0:y.op)!=="NoOp"}).map(g=>Ri(g,t,r,s))}const c=Ri(e.inputNames[u],t,r,s),h=c.dataSync();return i.type==="number"?h[0]:WN(c.shape,h)}const o=e.attrParams[n];return o&&o.value}function Ri(n,e,t,r){const[s,i]=ya(n,t);if(r!=null){const a=r.getHashTableHandleByName(s);if(a!=null)return a}const o=t.currentContextIds.find(a=>!!e[O_(s,a)]);return o!==void 0?e[O_(s,o)][i]:void 0}function NO(n,e,t){return e[O_(n,t.currentContextId)]}function Yc(n,e){const[t,r,s]=ya(n,e);return[O_(t,e&&e.currentContextId),r,s]}function O_(n,e){return e?`${n}-${e}`:n}function ya(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const i=e.parseNodeNameCache.get(n);if(i!=null)return i}const r=n.split(":");let s;if(r.length===1)s=[n,0,void 0];else{const i=r[0],o=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);s=[i,a,o]}return t&&e.parseNodeNameCache.set(n,s),s}function jS(n,e,t){let r=z("pad",n,e,t);if(r==="explicit"){r=z("explicitPaddings",n,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)s[i][0]=r[i*2],s[i][1]=r[i*2+1];return s}return r}function Zc(n){return n.kept?n:Cd(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EFe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],CFe=Object.freeze(Object.defineProperty({__proto__:null,json:EFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IFe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],NFe=Object.freeze(Object.defineProperty({__proto__:null,json:IFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AFe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],MFe=Object.freeze(Object.defineProperty({__proto__:null,json:AFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kFe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],RFe=Object.freeze(Object.defineProperty({__proto__:null,json:kFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DFe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],$Fe=Object.freeze(Object.defineProperty({__proto__:null,json:DFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PFe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],LFe=Object.freeze(Object.defineProperty({__proto__:null,json:PFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OFe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],FFe=Object.freeze(Object.defineProperty({__proto__:null,json:OFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zFe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],BFe=Object.freeze(Object.defineProperty({__proto__:null,json:zFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UFe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],VFe=Object.freeze(Object.defineProperty({__proto__:null,json:UFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WFe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],GFe=Object.freeze(Object.defineProperty({__proto__:null,json:WFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HFe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],jFe=Object.freeze(Object.defineProperty({__proto__:null,json:HFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XFe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],qFe=Object.freeze(Object.defineProperty({__proto__:null,json:XFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KFe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],YFe=Object.freeze(Object.defineProperty({__proto__:null,json:KFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZFe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],JFe=Object.freeze(Object.defineProperty({__proto__:null,json:ZFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QFe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],eze=Object.freeze(Object.defineProperty({__proto__:null,json:QFe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tze=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],nze=Object.freeze(Object.defineProperty({__proto__:null,json:tze},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rze=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],sze=Object.freeze(Object.defineProperty({__proto__:null,json:rze},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ize=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],oze=Object.freeze(Object.defineProperty({__proto__:null,json:ize},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aze=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],lze=Object.freeze(Object.defineProperty({__proto__:null,json:aze},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AO{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[CFe,NFe,MFe,RFe,$Fe,LFe,FFe,BFe,VFe,GFe,jFe,qFe,YFe,JFe,eze,nze,sze,oze,lze],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,t={}){const r=e.node,s=[],i=[],o=[],a=r.reduce((w,y)=>(w[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?s.push(w[y.name]):y.op==="Const"?i.push(w[y.name]):(y.input==null||y.input.length===0)&&o.push(w[y.name]),w),{});let l=[];const u=[];let c={},h={};t!=null&&(c=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const d=Object.keys(a);d.forEach(w=>{const y=a[w];y.inputNames.forEach((x,_)=>{const[T,,E]=Yc(x),N=a[T];if(N.outputs!=null){const M=N.outputs.indexOf(E);if(M!==-1){const $=`${T}:${M}`;y.inputNames[_]=$}}y.inputs.push(N),N.children.push(y)})}),Object.keys(h).length===0?d.forEach(w=>{const y=a[w];y.children.length===0&&u.push(y)}):Object.keys(h).forEach(w=>{const[y]=Yc(w),x=a[y];x!=null&&(x.signatureKey=h[w],u.push(x))}),Object.keys(c).length>0?Object.keys(c).forEach(w=>{const[y]=Yc(w),x=a[y];x&&(x.signatureKey=c[w],l.push(x))}):l=s;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((w,y)=>(w[y.signature.name]=this.mapFunction(y),w),{}));const g={nodes:a,inputs:l,outputs:u,weights:i,placeholders:s,signature:t,functions:p};return o.length>0&&(g.initNodes=o),g}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=z6(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((s,i)=>(s[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},s),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((s,i)=>{const o=i.type;let a;switch(i.type){case"string":a=oA(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=oA(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=fA(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=fA(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=lA(e.attr,i.tfName,i.defaultValue||0),a===void 0&&i.tfDeprecatedName&&(a=lA(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=dA(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=dA(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=aA(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=aA(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=mA(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=mA(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=hA(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=hA(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=pA(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=pA(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=uA(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=uA(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=cA(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=cA(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=MO(e.attr,i.tfName,i.defaultValue),a===void 0&&i.tfDeprecatedName&&(a=MO(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return s[i.name]={value:a,type:o},s},{})),r}mapFunction(e){const t=e.nodeDef,r=[],s=[];let i={};t!=null&&(i=t.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&s.push(h[d.name]),h),{}));const o=[],a=[];e.signature.inputArg.forEach(h=>{const[d]=Yc(h.name),p={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:ED(h.type),type:"dtype"}},children:[]};p.signatureKey=h.name,o.push(p),i[d]=p}),Object.keys(i).forEach(h=>{const d=i[h];d.inputNames.forEach((p,g)=>{const[w,,y]=Yc(p),x=i[w];if(x.outputs!=null){const _=x.outputs.indexOf(y);if(_!==-1){const T=`${w}:${_}`;d.inputNames[g]=T}}d.inputs.push(x),x.children.push(d)})});const u=e.ret;e.signature.outputArg.forEach(h=>{const[d,p]=Yc(u[h.name]),g=i[d];g!=null&&(g.defaultOutput=p,a.push(g))});const c=this.mapArgsToSignature(e);return{nodes:i,inputs:o,outputs:a,weights:s,placeholders:r,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function uze(n){const e=kn().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function B6(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):uze(n);return e?t:t.toLowerCase()}function oA(n,e,t,r=!1){const s=n[e];return s!=null?B6(s.s,r):t}function aA(n,e,t){const r=n[e];return r?r.b:t}function lA(n,e,t){const r=n[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:t;return typeof s=="number"?s:parseInt(s,10)}function ED(n){switch(typeof n=="string"&&(n=ga[n]),n){case ga.DT_FLOAT:case ga.DT_HALF:return"float32";case ga.DT_INT32:case ga.DT_INT64:case ga.DT_INT8:case ga.DT_UINT8:return"int32";case ga.DT_BOOL:return"bool";case ga.DT_DOUBLE:return"float32";case ga.DT_STRING:return"string";case ga.DT_COMPLEX64:case ga.DT_COMPLEX128:return"complex64";default:return null}}function MO(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function uA(n,e,t){const r=n[e];return r&&r.type?ED(r.type):t}function cA(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(s=>ED(s)):t}function U6(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function hA(n,e,t){const r=n[e];return r&&r.shape?U6(r.shape):t}function dA(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function fA(n,e,t,r=!1){const s=n[e];return s&&s.list&&s.list.s?s.list.s.map(i=>B6(i,r)):t}function pA(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>U6(s)):t}function mA(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cze{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,i)=>(s[i]=this.getAttr(i),s),{}))}getInput(e){return Ri(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return Ri(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return lA(this.node.rawAttrs,e,t);if(r.s!=null)return oA(this.node.rawAttrs,e,t);if(r.b!=null)return aA(this.node.rawAttrs,e,t);if(r.shape!=null)return hA(this.node.rawAttrs,e,t);if(r.type!=null)return uA(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return dA(this.node.rawAttrs,e,t);if(r.list.s!=null)return fA(this.node.rawAttrs,e,t);if(r.list.shape!=null)return pA(this.node.rawAttrs,e,t);if(r.list.b!=null)return mA(this.node.rawAttrs,e,t);if(r.list.type!=null)return cA(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fi=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:L5,abs:Va,acos:hke,acosh:fke,add:gn,addN:mke,all:yke,any:xke,argMax:bke,argMin:_ke,asin:Eke,asinh:Ike,atan:Ake,atan2:kke,atanh:Dke,avgPool:Z5,avgPool3d:Uke,basicLSTMCell:qke,batchNorm:jE,batchNorm2d:Qke,batchNorm3d:tRe,batchNorm4d:rRe,batchToSpaceND:J5,bincount:Q5,bitwiseAnd:oRe,booleanMaskAsync:RPe,broadcastArgs:lRe,broadcastTo:HS,buffer:fh,cast:Ns,ceil:hRe,clipByValue:fRe,clone:Cd,complex:Fd,concat:To,concat1d:mRe,concat2d:e6,concat3d:vRe,concat4d:wRe,conv1d:_Re,conv2d:XE,conv2dTranspose:CRe,conv3d:NRe,conv3dTranspose:RRe,cos:$Re,cosh:LRe,cosineWindow:yD,cumprod:FRe,cumsum:BRe,denseBincount:VRe,depthToSpace:GRe,depthwiseConv2d:cD,diag:XRe,dilation2d:KRe,div:Er,divNoNan:tDe,dot:rDe,dropout:HPe,einsum:Qg,elu:r6,enclosingPowerOfTwo:A6,ensureShape:aDe,equal:n6,erf:uDe,euclideanNorm:xDe,exp:nm,expandDims:Kc,expm1:_De,eye:i6,fft:mD,fill:xw,floor:o6,floorDiv:Y5,fused:oLe,gather:a6,gatherND:VPe,greater:YE,greaterEqual:l6,ifft:L_,imag:ZE,image:Bx,inTopKAsync:XPe,irfft:_6,isFinite:RDe,isInf:$De,isNaN:LDe,leakyRelu:u6,less:rA,lessEqual:hD,linalg:VOe,linspace:BDe,localResponseNormalization:VDe,log:Px,log1p:c6,logSigmoid:KDe,logSoftmax:JDe,logSumExp:d6,logicalAnd:D_,logicalNot:f6,logicalOr:p6,logicalXor:s$e,losses:WOe,lowerBound:o$e,matMul:Pr,max:fy,maxPool:m6,maxPool3d:u$e,maxPoolWithArgmax:h$e,maximum:g6,mean:$_,meshgrid:p$e,min:nA,minimum:P_,mirrorPad:y$e,mod:x$e,moments:b$e,movingAverage:PPe,mul:Dt,multiRNNCell:_$e,multinomial:E$e,neg:Qu,norm:KE,notEqual:y6,oneHot:N$e,ones:Ep,onesLike:M$e,op:ve,outerProduct:R$e,pad:ww,pad1d:P$e,pad2d:O$e,pad3d:z$e,pad4d:U$e,pool:j$e,pow:$x,prelu:x6,print:K5,prod:K$e,raggedGather:Z$e,raggedRange:Q$e,raggedTensorToTensor:t3e,rand:r3e,randomGamma:a3e,randomNormal:w6,randomStandardNormal:c3e,randomUniform:pD,randomUniformInt:f3e,range:Lx,real:Ox,reciprocal:g3e,relu:JE,relu6:b6,reshape:lt,reverse:rm,reverse1d:b3e,reverse2d:_3e,reverse3d:E3e,reverse4d:I3e,rfft:gD,round:S6,rsqrt:M3e,scalar:ar,scatterND:OPe,searchSorted:dD,selu:R3e,separableConv2d:$3e,setdiff1dAsync:L3e,sigmoid:$p,sign:F3e,signal:UOe,sin:B3e,sinh:V3e,slice:yr,slice1d:G3e,slice2d:j3e,slice3d:q3e,slice4d:Y3e,softmax:J3e,softplus:h6,spaceToBatchND:v6,sparse:GOe,sparseToDense:BPe,spectral:BOe,split:Fx,sqrt:ph,square:mu,squaredDifference:T6,squeeze:zx,stack:gh,step:E6,stridedSlice:uPe,string:HOe,sub:Wn,sum:Jr,tan:hPe,tanh:tA,tensor:Ju,tensor1d:Sa,tensor2d:py,tensor3d:C6,tensor4d:dPe,tensor5d:fPe,tensor6d:pPe,tensorScatterUpdate:yPe,tile:Kv,topk:xPe,transpose:sA,truncatedNormal:bPe,unique:_Pe,unsortedSegmentSum:EPe,unstack:vm,upperBound:IPe,variable:NPe,where:Id,whereAsync:N6,zeros:Py,zerosLike:Xa},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hze=(n,e,t,r=Fi)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(z("a",n,e,t),z("b",n,e,t))];case"AddN":return[r.addN(z("tensors",n,e,t))];case"FloorMod":case"Mod":return[r.mod(z("a",n,e,t),z("b",n,e,t))];case"Mul":return[r.mul(z("a",n,e,t),z("b",n,e,t))];case"RealDiv":case"Div":return[r.div(z("a",n,e,t),z("b",n,e,t))];case"DivNoNan":return[r.divNoNan(z("a",n,e,t),z("b",n,e,t))];case"FloorDiv":return[r.floorDiv(z("a",n,e,t),z("b",n,e,t))];case"Sub":return[r.sub(z("a",n,e,t),z("b",n,e,t))];case"Minimum":return[r.minimum(z("a",n,e,t),z("b",n,e,t))];case"Maximum":return[r.maximum(z("a",n,e,t),z("b",n,e,t))];case"Pow":return[r.pow(z("a",n,e,t),z("b",n,e,t))];case"SquaredDifference":return[r.squaredDifference(z("a",n,e,t),z("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dze=(n,e,t,r=Fi)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(z("x",n,e,t))];case"Acos":return[r.acos(z("x",n,e,t))];case"Acosh":return[r.acosh(z("x",n,e,t))];case"Asin":return[r.asin(z("x",n,e,t))];case"Asinh":return[r.asinh(z("x",n,e,t))];case"Atan":return[r.atan(z("x",n,e,t))];case"Atan2":return[r.atan2(z("x",n,e,t),z("y",n,e,t))];case"Atanh":return[r.atanh(z("x",n,e,t))];case"Ceil":return[r.ceil(z("x",n,e,t))];case"Complex":return[r.complex(z("real",n,e,t),z("imag",n,e,t))];case"Cos":return[r.cos(z("x",n,e,t))];case"Cosh":return[r.cosh(z("x",n,e,t))];case"Elu":return[r.elu(z("x",n,e,t))];case"Erf":return[r.erf(z("x",n,e,t))];case"Exp":return[r.exp(z("x",n,e,t))];case"Expm1":return[r.expm1(z("x",n,e,t))];case"Floor":return[r.floor(z("x",n,e,t))];case"Log":return[r.log(z("x",n,e,t))];case"Log1p":return[r.log1p(z("x",n,e,t))];case"Imag":return[r.imag(z("x",n,e,t))];case"Neg":return[r.neg(z("x",n,e,t))];case"Reciprocal":return[r.reciprocal(z("x",n,e,t))];case"Real":return[r.real(z("x",n,e,t))];case"Relu":return[r.relu(z("x",n,e,t))];case"Round":return[r.round(z("x",n,e,t))];case"Selu":return[r.selu(z("x",n,e,t))];case"Sigmoid":return[r.sigmoid(z("x",n,e,t))];case"Sin":return[r.sin(z("x",n,e,t))];case"Sign":return[r.sign(z("x",n,e,t))];case"Sinh":return[r.sinh(z("x",n,e,t))];case"Softplus":return[r.softplus(z("x",n,e,t))];case"Sqrt":return[r.sqrt(z("x",n,e,t))];case"Square":return[r.square(z("x",n,e,t))];case"Tanh":return[r.tanh(z("x",n,e,t))];case"Tan":return[r.tan(z("x",n,e,t))];case"ClipByValue":return[r.clipByValue(z("x",n,e,t),z("clipValueMin",n,e,t),z("clipValueMax",n,e,t))];case"Relu6":return[r.relu6(z("x",n,e,t))];case"Rsqrt":return[r.rsqrt(Ri(n.inputNames[0],e,t))];case"LeakyRelu":return[r.leakyRelu(z("x",n,e,t),z("alpha",n,e,t))];case"Prelu":return[r.prelu(z("x",n,e,t),z("alpha",n,e,t))];case"IsNan":return[r.isNaN(Ri(n.inputNames[0],e,t))];case"IsInf":return[r.isInf(Ri(n.inputNames[0],e,t))];case"IsFinite":return[r.isFinite(Ri(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ml(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){de(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const s=n[r],i=e[r];de(s<0||i<0||s===i,()=>t+` Shapes ${n} and ${e} must match`)}}}function kO(n){return!(typeof n=="number"||n.some(e=>e<0))}function Mv(n,e,t){let r=gA(n,t);const s=!kO(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(i=>{r=gA(i.shape,r)}),!kO(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function gA(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const s=n[r],i=e[r];if(s>=0&&i>=0&&s!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=s>=0?s:i}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fze{constructor(e,t,r,s,i,o,a){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=ar(0),Gu(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),ml(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,Gu(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,s)=>this.write(r,t[s]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return Ju([],[0].concat(this.elementShape));const r=this.readMany(e);return ml(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),gh(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Ju([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return ml(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),To(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,vm(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=e.map(l=>(r+=l,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=r===0?0:t.size/r,o=[];Qn(()=>{t=lt(t,[1,r,i]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:s[l-1],0],h=[1,e[l],i];o[l]=lt(yr(t,c,h),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class im{get id(){return this.idTensor.id}constructor(e,t,r,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e!=null&&e.forEach(i=>{if(r!==i.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${i.dtype}`);ml(t,i.shape,"TensorList shape mismatch: "),Gu(i)}),this.idTensor=ar(0),this.maxNumElements=s,Gu(this.idTensor)}copy(){return new im([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);ml(e,this.elementShape,"TensorList shape mismatch: ");const s=Mv(this.elementShape,this.tensors,e);return Qn(()=>{const i=this.tensors.map(o=>lt(o,s));return gh(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Mv(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,ml(s.shape,e,"TensorList shape mismatch: "),lt(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ml(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Gu(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new im([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);ml(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=Mv(this.elementShape,this.tensors,t);return lt(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ml(this.elementShape,t.shape,"TensorList shape mismatch: "),Gu(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);ml(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Mv(this.elementShape,this.tensors,r);return e.length===0?Ju([],[0].concat(s)):Qn(()=>{const i=e.map(o=>lt(this.tensors[o],s));return gh(i,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ml(this.elementShape,t,"TensorList shape mismatch: ");const r=Mv(this.elementShape,this.tensors,t);return this.size()===0?Ju([],[0].concat(r)):Qn(()=>{const s=this.tensors.map(i=>lt(i,r));return To(s,0)})}}function pze(n,e,t){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const s=n.shape.slice(1);ml(s,e,"TensorList shape mismatch: ");const i=vm(n);return new im(i,e,r)}function mze(n,e,t,r){return new im([],n,e,r)}function gze(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const i=new im([],t,n.dtype,r),o=vm(n,0);return e.forEach((a,l)=>{i.setItem(a,o[l])}),i}function yze(n,e,t){let r=0;const s=e.map(c=>(r+=c,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);const i=n.shape.slice(1),o=gA(i,t),a=r===0?0:n.size/r,l=Qn(()=>{const c=[];n=lt(n,[1,r,a]);for(let h=0;h<e.length;++h){const p=[0,h===0?0:s[h-1],0],g=[1,e[h],a];c[h]=lt(yr(n,p,g),o)}return n.dispose(),c}),u=new im([],t,n.dtype,e.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vze=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const r=z("thenBranch",n,e,t),s=z("elseBranch",n,e,t),i=z("cond",n,e,t),o=z("args",n,e,t);return(await i.data())[0]?t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const r=z("body",n,e,t),s=z("cond",n,e,t),i=z("args",n,e,t),o=await t.functionMap[s].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),a=i.map(c=>c.id);let l=await o[0].data();o.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let u=i;for(;l[0];){const c=u;u=await t.functionMap[r].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);const h=u.map(p=>p.id);c.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});const d=await t.functionMap[s].executeFunctionAsync(u,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return u}case"LoopCond":{const r=z("pred",n,e,t);return[Zc(r)]}case"Switch":{const r=z("pred",n,e,t);let s=z("data",n,e,t);return s.kept||(s=Zc(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=n.inputNames.find(s=>Ri(s,e,t)!==void 0);if(r){const s=Ri(r,e,t);return[Zc(s)]}return}case"Enter":{const r=z("frameName",n,e,t),s=z("tensor",n,e,t);return t.enterFrame(r),[Zc(s)]}case"Exit":{const r=z("tensor",n,e,t);return t.exitFrame(),[Zc(r)]}case"NextIteration":{const r=z("tensor",n,e,t);return t.nextIteration(),[Zc(r)]}case"TensorArrayV3":{const r=z("size",n,e,t),s=z("dtype",n,e,t),i=z("elementShape",n,e,t),o=z("dynamicSize",n,e,t),a=z("clearAfterRead",n,e,t),l=z("identicalElementShapes",n,e,t),u=z("name",n,e,t),c=new fze(u,s,r,i,l,o,a);return t.addTensorArray(c),[c.idTensor,ar(1)]}case"TensorArrayWriteV3":{const r=z("tensorArrayId",n,e,t),s=z("index",n,e,t),i=z("tensor",n,e,t),o=t.getTensorArray(r.id);return o.write(s,i),[o.idTensor]}case"TensorArrayReadV3":{const r=z("tensorArrayId",n,e,t),s=z("index",n,e,t);return[t.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=z("tensorArrayId",n,e,t),s=z("indices",n,e,t),i=z("dtype",n,e,t);return[t.getTensorArray(r.id).gather(s,i)]}case"TensorArrayScatterV3":{const r=z("tensorArrayId",n,e,t),s=z("indices",n,e,t),i=z("tensor",n,e,t),o=t.getTensorArray(r.id);return o.scatter(s,i),[o.idTensor]}case"TensorArrayConcatV3":{const r=z("tensorArrayId",n,e,t),s=t.getTensorArray(r.id),i=z("dtype",n,e,t);return[s.concat(i)]}case"TensorArraySplitV3":{const r=z("tensorArrayId",n,e,t),s=z("tensor",n,e,t),i=z("lengths",n,e,t),o=t.getTensorArray(r.id);return o.split(i,s),[o.idTensor]}case"TensorArraySizeV3":{const r=z("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return[ar(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=z("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=z("tensorListId",n,e,t),s=z("index",n,e,t),i=z("tensor",n,e,t),o=t.getTensorList(r.id);return o.setItem(s,i),[o.idTensor]}case"TensorListGetItem":{const r=z("tensorListId",n,e,t),s=z("index",n,e,t),i=z("elementShape",n,e,t),o=z("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(s,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=z("indices",n,e,t),s=z("tensor",n,e,t),i=z("elementShape",n,e,t),o=z("numElements",n,e,t),a=gze(s,r,i,o);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=z("elementShape",n,e,t),s=z("elementDType",n,e,t);let i;n.op==="TensorListReserve"?i="numElements":i="maxNumElements";const o=z(i,n,e,t),a=n.op==="TensorListReserve"?-1:o,l=mze(r,s,o,a);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const r=z("tensorListId",n,e,t),s=z("indices",n,e,t),i=z("elementShape",n,e,t),o=z("elementDType",n,e,t);return[t.getTensorList(r.id).gather(s,o,i)]}case"TensorListStack":{const r=z("tensorListId",n,e,t),s=z("elementShape",n,e,t),i=z("elementDType",n,e,t),o=z("numElements",n,e,t);return[t.getTensorList(r.id).stack(s,i,o)]}case"TensorListFromTensor":{const r=z("tensor",n,e,t),s=z("elementShape",n,e,t),i=z("elementDType",n,e,t),o=pze(r,s,i);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=z("tensorListId",n,e,t),s=t.getTensorList(r.id),i=z("dtype",n,e,t),o=z("elementShape",n,e,t);return[s.concat(i,o)]}case"TensorListPushBack":{const r=z("tensorListId",n,e,t),s=z("tensor",n,e,t),i=t.getTensorList(r.id);return i.pushBack(s),[i.idTensor]}case"TensorListPopBack":{const r=z("tensorListId",n,e,t),s=z("elementShape",n,e,t),i=z("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(s,i)]}case"TensorListSplit":{const r=z("tensor",n,e,t),s=z("elementShape",n,e,t),i=z("lengths",n,e,t),o=yze(r,i,s);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=z("tensorListId",n,e,t),s=t.getTensorList(r.id);return[ar(s.size(),"int32")]}case"TensorListResize":{const r=z("tensorListId",n,e,t),s=z("size",n,e,t),o=t.getTensorList(r.id).resize(s);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RO(n,e,t){const[r,s]=z("fusedOps",n,e,t),i=r==="biasadd",o=!i,a=s==="prelu",l=r==="fusedbatchnorm",u=z("numArgs",n,e,t);if(i){if(a&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=z("strides",n,e,t),h=jS(n,e,t),d=z("dataFormat",n,e,t).toUpperCase(),p=z("dilations",n,e,t);let[g,w]=z("args",n,e,t);o&&(w=g,g=void 0);const y=z("leakyreluAlpha",n,e,t);return{stride:c,pad:h,dataFormat:d,dilations:p,biasArg:g,preluArg:w,activationFunc:s,leakyreluAlpha:y}}const xze=(n,e,t,r=Fi)=>{switch(n.op){case"Conv1D":{const s=z("stride",n,e,t),i=z("pad",n,e,t),o=z("dataFormat",n,e,t).toUpperCase(),a=z("dilation",n,e,t);return[r.conv1d(z("x",n,e,t),z("filter",n,e,t),s,i,o,a)]}case"Conv2D":{const s=z("strides",n,e,t),i=jS(n,e,t),o=z("dataFormat",n,e,t).toUpperCase(),a=z("dilations",n,e,t);return[r.conv2d(z("x",n,e,t),z("filter",n,e,t),[s[1],s[2]],i,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=RO(n,e,t);return[r.fused.conv2d({x:z("x",n,e,t),filter:z("filter",n,e,t),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:i,dataFormat:o,dilations:a,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:h}=RO(n,e,t);return[r.fused.depthwiseConv2d({x:z("x",n,e,t),filter:z("filter",n,e,t),strides:[s[1],s[2]],pad:i,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=z("outputShape",n,e,t),i=z("strides",n,e,t),o=jS(n,e,t);return[r.conv2dTranspose(z("x",n,e,t),z("filter",n,e,t),s,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=z("strides",n,e,t),i=jS(n,e,t),o=z("dilations",n,e,t),a=z("dataFormat",n,e,t).toUpperCase();return[r.depthwiseConv2d(z("input",n,e,t),z("filter",n,e,t),[s[1],s[2]],i,a,[o[1],o[2]])]}case"Conv3D":{const s=z("strides",n,e,t),i=z("pad",n,e,t),o=z("dataFormat",n,e,t).toUpperCase(),a=z("dilations",n,e,t);return[r.conv3d(z("x",n,e,t),z("filter",n,e,t),[s[1],s[2],s[3]],i,o,[a[1],a[2],a[3]])]}case"AvgPool":{const s=z("strides",n,e,t),i=z("pad",n,e,t),o=z("kernelSize",n,e,t);return[r.avgPool(z("x",n,e,t),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPool":{const s=z("strides",n,e,t),i=z("pad",n,e,t),o=z("kernelSize",n,e,t);return[r.maxPool(z("x",n,e,t),[o[1],o[2]],[s[1],s[2]],i)]}case"MaxPoolWithArgmax":{const s=z("strides",n,e,t),i=z("pad",n,e,t),o=z("kernelSize",n,e,t),a=z("includeBatchInIndex",n,e,t),{result:l,indexes:u}=r.maxPoolWithArgmax(z("x",n,e,t),[o[1],o[2]],[s[1],s[2]],i,a);return[l,u]}case"AvgPool3D":{const s=z("strides",n,e,t),i=z("pad",n,e,t),o=z("kernelSize",n,e,t);return[r.avgPool3d(z("x",n,e,t),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"MaxPool3D":{const s=z("strides",n,e,t),i=z("pad",n,e,t),o=z("kernelSize",n,e,t);return[r.maxPool3d(z("x",n,e,t),[o[1],o[2],o[3]],[s[1],s[2],s[3]],i)]}case"Dilation2D":{const s=z("strides",n,e,t),i=z("pad",n,e,t),o=z("dilations",n,e,t),a=s[1],l=s[2],u=o[1],c=o[2];return[r.dilation2d(z("x",n,e,t),z("filter",n,e,t),[a,l],i,[u,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wze=(n,e,t,r=Fi)=>{switch(n.op){case"Fill":{const s=z("shape",n,e,t),i=z("dtype",n,e,t),o=z("value",n,e,t);return[r.fill(s,o,i)]}case"LinSpace":{const s=z("start",n,e,t),i=z("stop",n,e,t),o=z("num",n,e,t);return[r.linspace(s,i,o)]}case"Multinomial":{const s=z("logits",n,e,t),i=z("numSamples",n,e,t),o=z("seed",n,e,t);return[r.multinomial(s,i,o)]}case"OneHot":{const s=z("indices",n,e,t),i=z("depth",n,e,t),o=z("onValue",n,e,t),a=z("offValue",n,e,t),l=z("dtype",n,e,t);return[r.oneHot(s,i,o,a,l)]}case"Ones":return[r.ones(z("shape",n,e,t),z("dtype",n,e,t))];case"OnesLike":return[r.onesLike(z("x",n,e,t))];case"RandomStandardNormal":return[r.randomStandardNormal(z("shape",n,e,t),z("dtype",n,e,t),z("seed",n,e,t))];case"RandomUniform":return[r.randomUniform(z("shape",n,e,t),z("minval",n,e,t),z("maxval",n,e,t),z("dtype",n,e,t))];case"RandomUniformInt":return[r.randomUniformInt(z("shape",n,e,t),z("minval",n,e,t),z("maxval",n,e,t),z("seed",n,e,t))];case"Range":{const s=z("start",n,e,t),i=z("stop",n,e,t),o=z("step",n,e,t);return[r.range(s,i,o,z("dtype",n,e,t))]}case"TruncatedNormal":{const s=z("shape",n,e,t),i=z("mean",n,e,t),o=z("stdDev",n,e,t),a=z("seed",n,e,t);return[r.truncatedNormal(s,i,o,z("dtype",n,e,t),a)]}case"Zeros":return[r.zeros(z("shape",n,e,t),z("dtype",n,e,t))];case"ZerosLike":return[r.zerosLike(z("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aI(n,e,t){const r=z("boxes",n,e,t),s=z("scores",n,e,t),i=z("maxOutputSize",n,e,t),o=z("iouThreshold",n,e,t),a=z("scoreThreshold",n,e,t),l=z("softNmsSigma",n,e,t);return{boxes:r,scores:s,maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const bze=async(n,e,t,r,s=Fi)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=aI(n,e,t),h=await s.image.nonMaxSuppressionWithScoreAsync(i,o,a,l,u,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=aI(n,e,t),c=z("padToMaxOutputSize",n,e,t),h=await s.image.nonMaxSuppressionPaddedAsync(i,o,a,l,u,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=aI(n,e,t);return[await s.image.nonMaxSuppressionAsync(i,o,a,l,u)]}case"Where":{const i=s.cast(z("condition",n,e,t),"bool"),o=[await s.whereAsync(i)];return i.dispose(),o}case"ListDiff":return s.setdiff1dAsync(z("x",n,e,t),z("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sze=(n,e,t,r=Fi)=>{switch(n.op){case"LowerBound":{const s=z("sortedSequence",n,e,t),i=z("values",n,e,t);return[r.lowerBound(s,i)]}case"TopKV2":{const s=z("x",n,e,t),i=z("k",n,e,t),o=z("sorted",n,e,t),a=r.topk(s,i,o);return[a.values,a.indices]}case"UpperBound":{const s=z("sortedSequence",n,e,t),i=z("values",n,e,t);return[r.upperBound(s,i)]}case"Unique":{const s=z("x",n,e,t),i=r.unique(s);return[i.values,i.indices]}case"UniqueV2":{const s=z("x",n,e,t),i=z("axis",n,e,t),o=r.unique(s,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ze=(n,e,t,r=Fi)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const s=z("default",n,e,t);return[Ri(n.name,e,t)||s];case"Placeholder":return[Ri(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=z("x",n,e,t);return[Zc(c)]}case"IdentityN":return z("x",n,e,t).map(c=>Zc(c));case"Snapshot":const i=z("x",n,e,t);return[Zc(i)];case"Shape":return[r.tensor1d(z("x",n,e,t).shape,"int32")];case"ShapeN":return z("x",n,e,t).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(z("x",n,e,t).size,"int32")];case"Rank":return[r.scalar(z("x",n,e,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=z("x",n,e,t),a=z("data",n,e,t),l=z("message",n,e,t),u=z("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,u));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tze{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=ar(0),this.tensorMap=new Map,Gu(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ar(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),Qn(()=>{const s=vm(t),i=r.length,o=s.length;de(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let a=0;a<i;a++){const l=r[a],u=s[a];Gu(u),this.tensorMap.set(l,u)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return Qn(()=>{const s=[];for(let i=0;i<r.length;i++){const o=r[i],a=this.findWithDefault(o,t);s.push(a)}return gh(s)})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eze=async(n,e,t,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(n.name);if(s!=null)return[s];{const i=z("keyDType",n,e,t),o=z("valueDType",n,e,t),a=new Tze(i,o);return r.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=z("tableHandle",n,e,t,r),i=z("keys",n,e,t),o=z("values",n,e,t);return[await r.getHashTableById(s.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const s=z("tableHandle",n,e,t,r),i=z("keys",n,e,t),o=z("defaultValue",n,e,t);return[await r.getHashTableById(s.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=z("tableHandle",n,e,t,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cze=(n,e,t,r=Fi)=>{switch(n.op){case"ResizeBilinear":{const s=z("images",n,e,t),i=z("size",n,e,t),o=z("alignCorners",n,e,t),a=z("halfPixelCenters",n,e,t);return[r.image.resizeBilinear(s,[i[0],i[1]],o,a)]}case"ResizeNearestNeighbor":{const s=z("images",n,e,t),i=z("size",n,e,t),o=z("alignCorners",n,e,t),a=z("halfPixelCenters",n,e,t);return[r.image.resizeNearestNeighbor(s,[i[0],i[1]],o,a)]}case"CropAndResize":{const s=z("image",n,e,t),i=z("boxes",n,e,t),o=z("boxInd",n,e,t),a=z("cropSize",n,e,t),l=z("method",n,e,t),u=z("extrapolationValue",n,e,t);return[r.image.cropAndResize(s,i,o,a,l,u)]}case"ImageProjectiveTransformV3":{const s=z("images",n,e,t),i=z("transforms",n,e,t),o=z("outputShape",n,e,t),a=z("fillValue",n,e,t),l=z("interpolation",n,e,t),u=z("fillMode",n,e,t);return[r.image.transform(s,i,l.toLowerCase(),u.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ize=(n,e,t,r=Fi)=>{switch(n.op){case"Equal":return[r.equal(z("a",n,e,t),z("b",n,e,t))];case"NotEqual":return[r.notEqual(z("a",n,e,t),z("b",n,e,t))];case"Greater":return[r.greater(z("a",n,e,t),z("b",n,e,t))];case"GreaterEqual":return[r.greaterEqual(z("a",n,e,t),z("b",n,e,t))];case"Less":return[r.less(z("a",n,e,t),z("b",n,e,t))];case"LessEqual":return[r.lessEqual(z("a",n,e,t),z("b",n,e,t))];case"LogicalAnd":return[r.logicalAnd(z("a",n,e,t),z("b",n,e,t))];case"LogicalNot":return[r.logicalNot(z("a",n,e,t))];case"LogicalOr":return[r.logicalOr(z("a",n,e,t),z("b",n,e,t))];case"Select":case"SelectV2":return[r.where(z("condition",n,e,t),z("a",n,e,t),z("b",n,e,t))];case"BitwiseAnd":return[r.bitwiseAnd(z("a",n,e,t),z("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nze=(n,e,t,r=Fi)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(z("a",n,e,t),z("b",n,e,t),z("transposeA",n,e,t),z("transposeB",n,e,t))];case"Einsum":return[r.einsum(z("equation",n,e,t),...z("tensors",n,e,t))];case"Transpose":return[r.transpose(z("x",n,e,t),z("perm",n,e,t))];case"_FusedMatMul":const[s,i]=z("fusedOps",n,e,t),o=s==="biasadd",a=i==="prelu",l=z("numArgs",n,e,t),u=z("leakyreluAlpha",n,e,t);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=z("args",n,e,t);return[r.fused.matMul({a:z("a",n,e,t),b:z("b",n,e,t),transposeA:z("transposeA",n,e,t),transposeB:z("transposeB",n,e,t),bias:c,activation:i,preluActivationWeights:h,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(z("a",n,e,t),z("numLower",n,e,t),z("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aze=(n,e,t,r=Fi)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(z("x",n,e,t),z("axis",n,e,t),z("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(z("x",n,e,t),z("mean",n,e,t),z("variance",n,e,t),z("offset",n,e,t),z("scale",n,e,t),z("epsilon",n,e,t))];case"FusedBatchNormV3":return[r.batchNorm(z("x",n,e,t),z("mean",n,e,t),z("variance",n,e,t),z("offset",n,e,t),z("scale",n,e,t),z("epsilon",n,e,t))];case"LRN":return[r.localResponseNormalization(z("x",n,e,t),z("radius",n,e,t),z("bias",n,e,t),z("alpha",n,e,t),z("beta",n,e,t))];case"Softmax":return[r.softmax(z("x",n,e,t))];case"LogSoftmax":return[r.logSoftmax(z("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mze=(n,e,t,r=Fi)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:i}=r.raggedGather(z("paramsNestedSplits",n,e,t),z("paramsDenseValues",n,e,t),z("indices",n,e,t),z("outputRaggedRank",n,e,t));return s.concat(i)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:i}=r.raggedRange(z("starts",n,e,t),z("limits",n,e,t),z("splits",n,e,t));return[s,i]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(z("shape",n,e,t),z("values",n,e,t),z("defaultValue",n,e,t),z("rowPartitionTensors",n,e,t),z("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kze=(n,e,t,r=Fi)=>{switch(n.op){case"Max":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[r.max(z("x",n,e,t),a,l)]}case"Mean":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[r.mean(z("x",n,e,t),a,l)]}case"Min":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[r.min(z("x",n,e,t),a,l)]}case"Sum":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[r.sum(z("x",n,e,t),a,l)]}case"All":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[r.all(z("x",n,e,t),a,l)]}case"Any":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[r.any(z("x",n,e,t),a,l)]}case"ArgMax":{const a=z("axis",n,e,t);return[r.argMax(z("x",n,e,t),a)]}case"ArgMin":{const a=z("axis",n,e,t);return[r.argMin(z("x",n,e,t),a)]}case"Prod":{const a=z("axis",n,e,t),l=z("keepDims",n,e,t);return[r.prod(z("x",n,e,t),a,l)]}case"Cumprod":{const a=z("axis",n,e,t),l=z("exclusive",n,e,t),u=z("reverse",n,e,t);return[r.cumprod(z("x",n,e,t),a,l,u)]}case"Cumsum":{const a=z("axis",n,e,t),l=z("exclusive",n,e,t),u=z("reverse",n,e,t);return[r.cumsum(z("x",n,e,t),a,l,u)]}case"Bincount":const s=z("x",n,e,t),i=z("weights",n,e,t),o=z("size",n,e,t);return[r.bincount(s,i,o)];case"DenseBincount":{const a=z("x",n,e,t),l=z("weights",n,e,t),u=z("size",n,e,t),c=z("binaryOutput",n,e,t);return[r.denseBincount(a,l,u,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rze=(n,e,t,r=Fi)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=z("n",n,e,t),i=z("axis",n,e,t);let o=z("tensors",n,e,t);return o=o.slice(0,s),[r.concat(o,i)]}case"Gather":{const s=z("x",n,e,t),i=z("indices",n,e,t);return[r.gather(s,r.cast(i,"int32"),0)]}case"GatherV2":{const s=z("axis",n,e,t),i=z("batchDims",n,e,t),o=z("x",n,e,t),a=z("indices",n,e,t);return[r.gather(o,r.cast(a,"int32"),s,i)]}case"Reverse":{const s=z("dims",n,e,t),i=[];for(let a=0;a<s.length;a++)s[a]&&i.push(a);const o=z("x",n,e,t);return[r.reverse(o,i)]}case"ReverseV2":{const s=z("axis",n,e,t),i=z("x",n,e,t);return[r.reverse(i,s)]}case"Slice":{const s=z("begin",n,e,t),i=z("size",n,e,t);return[r.slice(z("x",n,e,t),s,i)]}case"StridedSlice":{const s=z("begin",n,e,t),i=z("end",n,e,t),o=z("strides",n,e,t),a=z("beginMask",n,e,t),l=z("endMask",n,e,t),u=z("ellipsisMask",n,e,t),c=z("newAxisMask",n,e,t),h=z("shrinkAxisMask",n,e,t),d=z("x",n,e,t);return[r.stridedSlice(d,s,i,o,a,l,u,c,h)]}case"Pack":return Qn(()=>{const s=z("axis",n,e,t),i=z("tensors",n,e,t),o=i[0].shape,a=r.squeeze(i[0]).shape,l=i.map(u=>{const c=dh(u.shape,o);if(!c&&!dh(r.squeeze(u).shape,a))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,o)});return[r.stack(l,s)]});case"Unpack":{const s=z("axis",n,e,t),i=z("tensor",n,e,t);return r.unstack(i,s)}case"Tile":{const s=z("reps",n,e,t);return[r.tile(z("x",n,e,t),s)]}case"Split":case"SplitV":{const s=z("axis",n,e,t),i=z("numOrSizeSplits",n,e,t),o=z("x",n,e,t);return r.split(o,i,s)}case"ScatterNd":{const s=z("indices",n,e,t),i=z("values",n,e,t),o=z("shape",n,e,t);return[r.scatterND(s,i,o)]}case"GatherNd":{const s=z("x",n,e,t),i=z("indices",n,e,t);return[r.gatherND(s,i)]}case"SparseToDense":{const s=z("sparseIndices",n,e,t),i=z("outputShape",n,e,t),o=z("sparseValues",n,e,t),a=z("defaultValue",n,e,t);return[r.sparseToDense(s,o,i,o.dtype===a.dtype?a:r.cast(a,o.dtype))]}case"TensorScatterUpdate":{const s=z("indices",n,e,t),i=z("values",n,e,t),o=z("tensor",n,e,t);return[r.tensorScatterUpdate(o,s,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dze=(n,e,t,r=Fi)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:i,emptyRowIndicator:o,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(z("indices",n,e,t),z("values",n,e,t),z("denseShape",n,e,t),z("defaultValue",n,e,t));return[s,i,o,a]}case"SparseReshape":{const{outputIndices:s,outputShape:i}=r.sparse.sparseReshape(z("inputIndices",n,e,t),z("inputShape",n,e,t),z("newShape",n,e,t));return[s,i]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(z("data",n,e,t),z("indices",n,e,t),z("segmentIds",n,e,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(z("data",n,e,t),z("indices",n,e,t),z("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ze=(n,e,t,r=Fi)=>{switch(n.op){case"FFT":return[r.fft(z("x",n,e,t))];case"IFFT":return[r.ifft(z("x",n,e,t))];case"RFFT":return[r.rfft(z("x",n,e,t))];case"IRFFT":return[r.irfft(z("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pze=(n,e,t,r=Fi)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(z("input",n,e,t),z("pattern",n,e,t),z("rewrite",n,e,t),z("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:s,nGramsSplits:i}=r.string.stringNGrams(z("data",n,e,t),z("dataSplits",n,e,t),z("separator",n,e,t),z("nGramWidths",n,e,t),z("leftPad",n,e,t),z("rightPad",n,e,t),z("padWidth",n,e,t),z("preserveShortSequences",n,e,t));return[s,i]}case"StringSplit":{const{indices:s,values:i,shape:o}=r.string.stringSplit(z("input",n,e,t),z("delimiter",n,e,t),z("skipEmpty",n,e,t));return[s,i,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(z("input",n,e,t),z("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lze=(n,e,t,r=Fi)=>{switch(n.op){case"Cast":return[r.cast(z("x",n,e,t),z("dtype",n,e,t))];case"ExpandDims":{const s=z("axis",n,e,t);return[r.expandDims(z("x",n,e,t),s)]}case"Squeeze":{const s=z("axis",n,e,t);return[r.squeeze(z("x",n,e,t),s)]}case"Reshape":return[r.reshape(z("x",n,e,t),z("shape",n,e,t))];case"EnsureShape":return[r.ensureShape(z("x",n,e,t),z("shape",n,e,t))];case"MirrorPad":return[r.mirrorPad(z("x",n,e,t),z("padding",n,e,t),z("mode",n,e,t))];case"PadV2":case"Pad":return[r.pad(z("x",n,e,t),z("padding",n,e,t),z("constantValue",n,e,t))];case"SpaceToBatchND":{const s=z("blockShape",n,e,t),i=z("paddings",n,e,t);return[r.spaceToBatchND(z("x",n,e,t),s,i)]}case"BatchToSpaceND":{const s=z("blockShape",n,e,t),i=z("crops",n,e,t);return[r.batchToSpaceND(z("x",n,e,t),s,i)]}case"DepthToSpace":{const s=z("blockSize",n,e,t),i=z("dataFormat",n,e,t).toUpperCase();return[r.depthToSpace(z("x",n,e,t),s,i)]}case"BroadcastTo":return[r.broadcastTo(z("x",n,e,t),z("shape",n,e,t))];case"BroadcastArgs":return[r.broadcastArgs(z("s0",n,e,t),z("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DO(n,e,t,r,s=Qn){const i=((o,a,l)=>{switch(o.category){case"arithmetic":return s(()=>hze(o,a,l));case"basic_math":return s(()=>dze(o,a,l));case"control":return vze(o,a,l);case"convolution":return s(()=>xze(o,a,l));case"creation":return s(()=>wze(o,a,l));case"dynamic":return bze(o,a,l);case"evaluation":return s(()=>Sze(o,a,l));case"image":return s(()=>Cze(o,a,l));case"graph":return s(()=>_ze(o,a,l));case"logical":return s(()=>Ize(o,a,l));case"matrices":return s(()=>Nze(o,a,l));case"normalization":return s(()=>Aze(o,a,l));case"ragged":return s(()=>Mze(o,a,l));case"reduction":return s(()=>kze(o,a,l));case"slice_join":return s(()=>Rze(o,a,l));case"sparse":return s(()=>Dze(o,a,l));case"spectral":return s(()=>$ze(o,a,l));case"string":return s(()=>Pze(o,a,l));case"transformation":return s(()=>Lze(o,a,l));case"hash_table":return Eze(o,a,l,r);case"custom":const u=z6(o.op);if(u&&u.customExecutor)return u.customExecutor(new cze(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Jp(i)?i.then(o=>[].concat(o)):[].concat(i)}class $O{constructor(e={},t={},r={},s={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PO(n,e,t,r){const s=new Set,i=[];let o=null,a=null;const l=new Set,u=new Set(Object.keys(n).map(d=>ya(d)[0]));r=r||[];const c=new Set(r.map(d=>ya(d.name)[0])),h=[...e];for(;h.length>0;){const d=h.pop();if((mp(d)||Gze(d)||Hze(d))&&o==null&&(o=d,a=o.children.map(p=>p.name).filter(p=>s.has(p))),s.add(d.name),t[d.name]==null&&!u.has(d.name)&&!c.has(d.name)){if(d.inputs.length===0){i.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:n,outputs:e,usedNodes:s,missingInputs:i,dynamicNode:o,syncInputs:a}}function Oze(n,e){const{usedNodes:t,inputs:r}=e,s=Object.keys(r).map(y=>ya(y)[0]).map(y=>n.nodes[y]),i=n.initNodes||[],o=y=>t.has(typeof y=="string"?y:y.name);function a(y){return[...new Map(y.map(x=>[x.name,x])).values()]}const l=a([...s,...n.weights,...i]).filter(o),u=a([...l,...Object.values(n.nodes)]).filter(o),c=new Map(u.map(y=>[y.name,y])),h={};for(const y of u){h[y.name]=h[y.name]||0;for(const x of y.children)o(x)||(h[x.name]=Number.POSITIVE_INFINITY),h[x.name]=(h[x.name]||0)+1}const d=Object.entries(h).filter(([,y])=>y===0).map(([y])=>y),p=[...d];for(;d.length>0;){const y=d.pop(),x=c.get(y);for(const _ of x.children.filter(o))--h[_.name]===0&&(p.push(_.name),d.push(_.name))}const g=p.map(y=>c.get(y)),w=Fze(g,l);return zze(w,l),w}function Fze(n,e){const t=new Map(n.map(o=>[o.name,o])),r=e.map(o=>o.name),s=new Set(r);for(;r.length>0;){const o=r.pop(),a=t.get(o);for(const l of a.children)!t.has(l.name)||s.has(l.name)||(s.add(l.name),r.push(l.name))}return n.filter(o=>s.has(o.name))}class _S extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function zze(n,e){const t=new Map(n.map((a,l)=>[a.name,l])),r=new Set(e.map(a=>a.name)),s=a=>r.has(typeof a=="string"?a:a.name),i=new Set(n.map(a=>a.name)),o=a=>i.has(typeof a=="string"?a:a.name);for(const a of n){for(const l of a.children.filter(o)){if(!t.has(l.name))throw new _S(`Child ${l.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(l.name))throw new _S(`Node ${a.name} is scheduled to run after its child ${l.name}.`)}if(!s(a))for(const l of a.inputs){if(!t.has(l.name))throw new _S(`Input ${l.name} of node ${a.name} is unreachable.`);if(t.get(l.name)>t.get(a.name))throw new _S(`Node ${a.name} is scheduled to run before its input ${l.name}.`)}}}function Bze(n){const e=new Map(n.map((a,l)=>[a.name,l])),t=Number.MAX_SAFE_INTEGER,r=n.map((a,l)=>mp(a)?t:l),s=a=>{const l=r[e.get(a.name)];return l??-1},i=n.map((a,l)=>a.children.map(s).reduce((u,c)=>Math.max(u,c),r[l])),o=new Map;for(let a=0;a<n.length;++a){const l=i[a];if(l===t)continue;const u=n[a],c=n[l];o.has(c.name)||o.set(c.name,[]),o.get(c.name).push(u)}return o}const Uze=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Vze=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Wze=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function mp(n){return Uze.has(n.op)}function Gze(n){return Vze.has(n.op)}function Hze(n){return Wze.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F_{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new F_(e.functions[r],this)})}getCompilationKey(e,t){const r=e.map(i=>i.name).sort(),s=t.map(i=>i.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(e,t){const r=PO(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:i,syncInputs:o}=r;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(s.length>0){const u=t.map(h=>h.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${s}]`)}const a=Oze(this.graph,r),l=Bze(a);return{orderedNodes:a,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return Gu(t),t}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,r])=>[t,this.cloneTensorList(r)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(d=>this.graph.nodes[ya(d)[0]]),i=t.map(d=>ya(d)[0]),o=new Set(i);let a=i.map(d=>this.graph.nodes[d]);a.length===0&&(a=this._outputs);const l=this.getCompilationKey(s,a);let u=this.compiledMap.get(l);u==null&&(u=this.compile(e,a),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=kn().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const c={},h={};return Qn(()=>{const d=new $O(this.weightMap,c,h,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(x=>{const[_,T]=ya(x,d),E=[];E[T]=e[x],p[_]=E,this.keepIntermediateTensors&&(this.clonedTensorsMap[_]=this.cloneTensorList(E))});const g=this.getFrozenTensorIds(p),{orderedNodes:w,nodeLiveUntilMap:y}=u;for(const x of w){if(p[x.name])continue;const _=DO(x,p,d,this._resourceManager);if(Jp(_))throw new Error(`The execution of the op '${x.op}' returned a promise. Please use model.executeAsync() instead.`);p[x.name]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[x.name]=this.cloneTensorList(_)),this.checkTensorForDisposalWithNodeLiveUntilInfo(x,p,d,g,o,y.get(x.name))}return this.parent==null&&d.dispose(g),t.map(x=>Ri(x,p,d))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,r,s,i,o,a){if(!(mp(t)||o.has(e))){for(const l of r[e])l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length);for(const l of t.inputs){if(mp(l))continue;const u=NO(l.name,r,s);if(u!=null)for(const c of u){if(!c||c.kept||i.has(c.id))continue;const h=a[c.id];h===1?(c.dispose(),delete a[c.id]):h!=null&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,r,s,i,o){function a(l){return mp(l)||i.has(l.name)}if(!(mp(e)||o==null))for(const l of o){if(a(l))continue;const u=NO(l.name,t,r);for(const c of u)!c||c.kept||s.has(c.id)||c.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,r=!1,s={},i={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=kn().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const o=new $O(this.weightMap,s,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,o,t,r),l=t.map(d=>Ri(d,a,o)),u=l.map(d=>d.id),c=Object.keys(e).map(d=>e[d].id),h=new Set([...u,...c,...this.weightIds]);return Object.values(a).forEach(d=>{d.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),this.parent==null&&o.dispose(h),l}async executeFunctionAsync(e,t,r){const s=e.reduce((i,o,a)=>(i[this.inputs[a].name]=o,i),{});return this._executeAsync(s,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,s){const i=Object.keys(e),o=i.map(E=>this.graph.nodes[ya(E)[0]]),a=r.map(E=>ya(E)[0]),l=new Set(a);let u=a.map(E=>this.graph.nodes[E]);u.length===0&&(u=this._outputs);const{usedNodes:c,missingInputs:h,dynamicNode:d,syncInputs:p}=PO(e,u,this.weightMap,this._initNodes),g=[...o,...this.graph.weights,...this._initNodes||[]].map(E=>({node:E,contexts:t.currentContext})),w=Object.assign({},this.weightMap);Object.keys(e).forEach(E=>{const[N,M]=ya(E),$=[];$[M]=e[E],w[N]=$});const y={},x=this.getFrozenTensorIds(w),_={};for(;g.length>0;){const E=this.processStack(o,g,t,w,_,x,l,y,c);await Promise.all(E)}d==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const T=u.filter(E=>!mp(E)&&!Ri(E.name,w,t)).map(E=>E.name);if(T.length>0){let E="";throw d!=null&&(E=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${T}] from the provided inputs [${i}]. Consider providing the following inputs: [${h}]. ${E}`)}return w}processStack(e,t,r,s,i,o,a,l,u){const c=[];for(;t.length>0;){const h=t.pop();r.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&z("isConstant",h.node,s,r)&&([d]=Yc(h.node.name,r)),s[h.node.name]==null){const p=DO(h.node,s,r,this._resourceManager);d||([d]=Yc(h.node.name,r));const g=r.currentContext;Jp(p)?c.push(p.then(w=>(s[d]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(w)),r.currentContext=g,this.checkTensorForDisposal(d,h.node,s,r,o,a,l),this.processChildNodes(h.node,t,r,s,i,u),w))):(s[d]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(p)),this.checkTensorForDisposal(d,h.node,s,r,o,a,l),this.processChildNodes(h.node,t,r,s,i,u))}else this.processChildNodes(h.node,t,r,s,i,u)}return c}processChildNodes(e,t,r,s,i,o){e.children.forEach(a=>{const[l]=Yc(a.name,r);i[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(u=>!!Ri(u,s,r))&&(i[l]=!0,t.push({contexts:r.currentContext,node:a})):a.inputNames.every(u=>!!Ri(u,s,r))&&(i[l]=!0,t.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[s]=ya(t),i=this.graph.nodes[s];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value,a=o.length===r.shape.length&&r.shape.every((l,u)=>o[u]===-1||o[u]===l);de(a,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&de(r.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var t,r;const s={};for(const i in e){const o=(r=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||r===void 0?void 0:r[i];o!=null?s[o.name]=e[i]:s[i]=e[i]}return s}checkInputs(e){const t=Object.keys(e).filter(r=>{const[s]=ya(r);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var r,s;const i=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[t];return i!=null?i.name:t},{})}checkOutputs(e){e.forEach(t=>{const[r]=ya(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class jze{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xze="?tfjs-format=file",qze="model.json";class Kze{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},r=F6){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,t==null&&(this.loadOptions={}),this.resourceManager=new jze}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Jp(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await z5(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const r=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(s=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=s,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new F_(AO.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=AO.Instance.transformGraph(e.modelInitializer);this.initializer=new F_(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof Mi?[e]:e,r={};return t.forEach((s,i)=>r[this.structuredOutputKeys[i]]=s),r}return e}predict(e,t){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,t){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var t;if(!(e instanceof Mi)&&!Array.isArray(e)){const i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(const o in i){const a=i[o];a.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((i,o)=>{var a,l,u;const c=(u=(l=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||l===void 0?void 0:l[o])===null||u===void 0?void 0:u.resourceId;return c!=null?i[o]=this.resourceIdToCapturedInput[c]:i[o]=e[s++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,r=Object.keys(t);for(let s=0;s<r.length;s++){const i=r[s],o=t[i];this.resourceIdToCapturedInput[o.resourceId]=e[s]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&qo(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function V6(n,e={},t=F6){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=Yze(n));const r=new Kze(n,e,t);return await r.load(),r}function Yze(n){return n.endsWith("/")||(n=n+"/"),`${n}${qze}${Xze}`}/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */function Bd(n,e,t,r){return new(t||(t=Promise))((function(s,i){function o(u){try{l(r.next(u))}catch(c){i(c)}}function a(u){try{l(r.throw(u))}catch(c){i(c)}}function l(u){var c;u.done?s(u.value):(c=u.value,c instanceof t?c:new t((function(h){h(c)}))).then(o,a)}l((r=r.apply(n,[])).next())}))}function Ud(n,e){var t,r,s,i,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(u){return(function(c){if(t)throw new TypeError("Generator is already executing.");for(;i&&(i=0,c[0]&&(o=0)),o;)try{if(t=1,r&&(s=2&c[0]?r.return:c[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,c[1])).done)return s;switch(r=0,s&&(c=[2&c[0],s.value]),c[0]){case 0:case 1:s=c;break;case 4:return o.label++,{value:c[1],done:!1};case 5:o.label++,r=c[1],c=[0];continue;case 7:c=o.ops.pop(),o.trys.pop();continue;default:if(s=o.trys,!((s=s.length>0&&s[s.length-1])||c[0]!==6&&c[0]!==2)){o=0;continue}if(c[0]===3&&(!s||c[1]>s[0]&&c[1]<s[3])){o.label=c[1];break}if(c[0]===6&&o.label<s[1]){o.label=s[1],s=c;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(c);break}s[2]&&o.ops.pop(),o.trys.pop();continue}c=e.call(n,o)}catch(h){c=[6,h],r=0}finally{t=s=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}})([l,u])}}}function Gg(n,e,t){if(t||arguments.length===2)for(var r,s=0,i=e.length;s<i;s++)!r&&s in e||(r||(r=Array.prototype.slice.call(e,0,s)),r[s]=e[s]);return n.concat(r||Array.prototype.slice.call(e))}function CD(n){return[Math.abs(n.endPoint[0]-n.startPoint[0]),Math.abs(n.endPoint[1]-n.startPoint[1])]}function z_(n){return[n.startPoint[0]+(n.endPoint[0]-n.startPoint[0])/2,n.startPoint[1]+(n.endPoint[1]-n.startPoint[1])/2]}function LO(n,e){e===void 0&&(e=1.5);var t=z_(n),r=CD(n),s=[e*r[0]/2,e*r[1]/2];return{startPoint:[t[0]-s[0],t[1]-s[1]],endPoint:[t[0]+s[0],t[1]+s[1]],palmLandmarks:n.palmLandmarks}}function OO(n){var e=z_(n),t=CD(n),r=Math.max.apply(Math,t)/2;return{startPoint:[e[0]-r,e[1]-r],endPoint:[e[0]+r,e[1]+r],palmLandmarks:n.palmLandmarks}}function FO(n,e){var t=[n.endPoint[0]-n.startPoint[0],n.endPoint[1]-n.startPoint[1]],r=[t[0]*e[0],t[1]*e[1]];return{startPoint:[n.startPoint[0]+r[0],n.startPoint[1]+r[1]],endPoint:[n.endPoint[0]+r[0],n.endPoint[1]+r[1]],palmLandmarks:n.palmLandmarks}}var Zze=(function(){function n(e,t,r,s,i,o){this.model=e,this.width=t,this.height=r,this.iouThreshold=i,this.scoreThreshold=o,this.anchors=s.map((function(a){return[a.x_center,a.y_center]})),this.anchorsTensor=py(this.anchors),this.inputSizeTensor=Sa([t,r]),this.doubleInputSizeTensor=Sa([2*t,2*r])}return n.prototype.normalizeBoxes=function(e){var t=this;return Qn((function(){var r=yr(e,[0,0],[-1,2]),s=yr(e,[0,2],[-1,2]),i=gn(Er(r,t.inputSizeTensor),t.anchorsTensor),o=Er(s,t.doubleInputSizeTensor),a=Dt(Wn(i,o),t.inputSizeTensor),l=Dt(gn(i,o),t.inputSizeTensor);return e6([a,l],1)}))},n.prototype.normalizeLandmarks=function(e,t){var r=this;return Qn((function(){var s=gn(Er(lt(e,[-1,7,2]),r.inputSizeTensor),r.anchors[t]);return Dt(s,r.inputSizeTensor)}))},n.prototype.getBoundingBoxes=function(e){return Bd(this,void 0,void 0,(function(){var t,r,s,i,o,a,l,u,c,h,d,p,g,w,y,x=this;return Ud(this,(function(_){switch(_.label){case 0:return t=Qn((function(){return Dt(Wn(e,.5),2)})),oD()==="webgl"?(s=kn().get("WEBGL_PACK_DEPTHWISECONV"),kn().set("WEBGL_PACK_DEPTHWISECONV",!0),r=this.model.predict(t),kn().set("WEBGL_PACK_DEPTHWISECONV",s)):r=this.model.predict(t),i=zx(r),o=Qn((function(){return zx($p(yr(i,[0,0],[-1,1])))})),a=yr(i,[0,1],[-1,4]),l=this.normalizeBoxes(a),u=console.warn,console.warn=function(){},c=Bx.nonMaxSuppression(l,o,1,this.iouThreshold,this.scoreThreshold),console.warn=u,[4,c.array()];case 1:return h=_.sent(),d=[t,r,c,i,l,a,o],h.length===0?(d.forEach((function(T){return T.dispose()})),[2,null]):(p=h[0],g=yr(l,[p,0],[1,-1]),w=yr(i,[p,5],[1,14]),y=Qn((function(){return lt(x.normalizeLandmarks(w,p),[-1,2])})),d.push(w),d.forEach((function(T){return T.dispose()})),[2,{boxes:g,palmLandmarks:y}])}}))}))},n.prototype.estimateHandBounds=function(e){return Bd(this,void 0,void 0,(function(){var t,r,s,i,o,a,l,u,c=this;return Ud(this,(function(h){switch(h.label){case 0:return t=e.shape[1],r=e.shape[2],s=Qn((function(){return Er(Bx.resizeBilinear(e,[c.width,c.height]),255)})),[4,this.getBoundingBoxes(s)];case 1:return(i=h.sent())===null?(s.dispose(),[2,null]):(o=i.boxes.arraySync(),a=o[0].slice(0,2),l=o[0].slice(2,4),u=i.palmLandmarks.arraySync(),s.dispose(),i.boxes.dispose(),i.palmLandmarks.dispose(),[2,(d={startPoint:a,endPoint:l,palmLandmarks:u},p=[r/this.width,t/this.height],{startPoint:[d.startPoint[0]*p[0],d.startPoint[1]*p[1]],endPoint:[d.endPoint[0]*p[0],d.endPoint[1]*p[1]],palmLandmarks:d.palmLandmarks.map((function(g){return[g[0]*p[0],g[1]*p[1]]}))})])}var d,p}))}))},n})(),lI={thumb:[1,2,3,4],indexFinger:[5,6,7,8],middleFinger:[9,10,11,12],ringFinger:[13,14,15,16],pinky:[17,18,19,20],palmBase:[0]};function Jze(n,e){var t,r=Math.PI/2-Math.atan2(-(e[1]-n[1]),e[0]-n[0]);return(t=r)-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}var zO=function(n,e){return[[1,0,n],[0,1,e],[0,0,1]]};function Cp(n,e){for(var t=0,r=0;r<n.length;r++)t+=n[r]*e[r];return t}function Qze(n,e){for(var t=[],r=0;r<n.length;r++)t.push(n[r][e]);return t}function BO(n,e){for(var t=[],r=n.length,s=0;s<r;s++){t.push([]);for(var i=0;i<r;i++)t[s].push(Cp(n[s],Qze(e,i)))}return t}function UO(n,e){var t=Math.cos(n),r=Math.sin(n),s=[[t,-r,0],[r,t,0],[0,0,1]],i=BO(zO(e[0],e[1]),s);return BO(i,zO(-e[0],-e[1]))}function VO(n,e){return[Cp(n,e[0]),Cp(n,e[1])]}var eBe=[0,-.4],tBe=[0,-.1],WO=[0,5,9,13,17,1,2],nBe=(function(){function n(e,t,r,s,i,o){this.boundingBoxDetector=e,this.meshDetector=t,this.meshWidth=r,this.meshHeight=s,this.maxContinuousChecks=i,this.detectionConfidence=o,this.regionsOfInterest=[],this.runsWithoutHandDetector=0,this.maxHandsNumber=1}return n.prototype.getBoxForPalmLandmarks=function(e,t){var r=e.map((function(s){return VO(Gg(Gg([],s,!0),[1],!1),t)}));return LO(OO(FO(this.calculateLandmarksBoundingBox(r),eBe)),3)},n.prototype.getBoxForHandLandmarks=function(e){for(var t=LO(OO(FO(this.calculateLandmarksBoundingBox(e),tBe)),1.65),r=[],s=0;s<WO.length;s++)r.push(e[WO[s]].slice(0,2));return t.palmLandmarks=r,t},n.prototype.transformRawCoords=function(e,t,r,s){var i,o,a,l,u=this,c=CD(t),h=[c[0]/this.meshWidth,c[1]/this.meshHeight],d=e.map((function(_){return[h[0]*(_[0]-u.meshWidth/2),h[1]*(_[1]-u.meshHeight/2),_[2]]})),p=UO(r,[0,0]),g=d.map((function(_){return Gg(Gg([],VO(_,p),!0),[_[2]],!1)})),w=(o=[[(i=s)[0][0],i[1][0]],[i[0][1],i[1][1]]],a=[i[0][2],i[1][2]],l=[-Cp(o[0],a),-Cp(o[1],a)],[o[0].concat(l[0]),o[1].concat(l[1]),[0,0,1]]),y=Gg(Gg([],z_(t),!0),[1],!1),x=[Cp(y,w[0]),Cp(y,w[1])];return g.map((function(_){return[_[0]+x[0],_[1]+x[1],_[2]]}))},n.prototype.estimateHand=function(e){return Bd(this,void 0,void 0,(function(){var t,r,s,i,o,a,l,u,c,h,d,p,g,w,y,x,_,T,E,N;return Ud(this,(function(M){switch(M.label){case 0:return(t=this.shouldUpdateRegionsOfInterest())!==!0?[3,2]:[4,this.boundingBoxDetector.estimateHandBounds(e)];case 1:return(r=M.sent())===null?(e.dispose(),this.regionsOfInterest=[],[2,null]):(this.updateRegionsOfInterest(r,!0),this.runsWithoutHandDetector=0,[3,3]);case 2:this.runsWithoutHandDetector++,M.label=3;case 3:return s=this.regionsOfInterest[0],i=Jze(s.palmLandmarks[0],s.palmLandmarks[2]),o=z_(s),a=[o[0]/e.shape[2],o[1]/e.shape[1]],l=Bx.rotateWithOffset(e,i,0,a),u=UO(-i,o),c=t===!0?this.getBoxForPalmLandmarks(s.palmLandmarks,u):s,h=(function($,L,k){var R=L.shape[1],P=L.shape[2],B=[[$.startPoint[1]/R,$.startPoint[0]/P,$.endPoint[1]/R,$.endPoint[0]/P]];return Bx.cropAndResize(L,B,[0],k)})(c,l,[this.meshWidth,this.meshHeight]),d=Er(h,255),h.dispose(),l.dispose(),oD()==="webgl"?(g=kn().get("WEBGL_PACK_DEPTHWISECONV"),kn().set("WEBGL_PACK_DEPTHWISECONV",!0),p=this.meshDetector.predict(d),kn().set("WEBGL_PACK_DEPTHWISECONV",g)):p=this.meshDetector.predict(d),w=p[0],y=p[1],d.dispose(),x=w.dataSync()[0],w.dispose(),x<this.detectionConfidence?(y.dispose(),this.regionsOfInterest=[],[2,null]):(_=lt(y,[-1,3]),T=_.arraySync(),y.dispose(),_.dispose(),E=this.transformRawCoords(T,c,i,u),N=this.getBoxForHandLandmarks(E),this.updateRegionsOfInterest(N,!1),[2,{landmarks:E,handInViewConfidence:x,boundingBox:{topLeft:N.startPoint,bottomRight:N.endPoint}}])}}))}))},n.prototype.calculateLandmarksBoundingBox=function(e){var t=e.map((function(s){return s[0]})),r=e.map((function(s){return s[1]}));return{startPoint:[Math.min.apply(Math,t),Math.min.apply(Math,r)],endPoint:[Math.max.apply(Math,t),Math.max.apply(Math,r)]}},n.prototype.updateRegionsOfInterest=function(e,t){if(t)this.regionsOfInterest=[e];else{var r=this.regionsOfInterest[0],s=0;if(r!=null&&r.startPoint!=null){var i=e.startPoint,o=i[0],a=i[1],l=e.endPoint,u=l[0],c=l[1],h=r.startPoint,d=h[0],p=h[1],g=r.endPoint,w=g[0],y=g[1],x=Math.max(o,d),_=Math.max(a,p),T=(Math.min(u,w)-x)*(Math.min(c,y)-_);s=T/((u-o)*(c-a)+(w-d)*(y-a)-T)}this.regionsOfInterest[0]=s>.8?r:e}},n.prototype.shouldUpdateRegionsOfInterest=function(){return this.regionsOfInterest.length!==this.maxHandsNumber||this.runsWithoutHandDetector>=this.maxContinuousChecks},n})();function rBe(){return Bd(this,void 0,void 0,(function(){return Ud(this,(function(n){return[2,V6("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1",{fromTFHub:!0})]}))}))}function sBe(){return Bd(this,void 0,void 0,(function(){return Ud(this,(function(n){return[2,V6("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1",{fromTFHub:!0})]}))}))}function iBe(){return Bd(this,void 0,void 0,(function(){return Ud(this,(function(n){return[2,nMe("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then((function(e){return e.json()}))]}))}))}function oBe(n){var e=n===void 0?{}:n,t=e.maxContinuousChecks,r=t===void 0?1/0:t,s=e.detectionConfidence,i=s===void 0?.8:s,o=e.iouThreshold,a=o===void 0?.3:o,l=e.scoreThreshold,u=l===void 0?.5:l;return Bd(this,void 0,void 0,(function(){var c,h,d,p,g,w;return Ud(this,(function(y){switch(y.label){case 0:return[4,Promise.all([iBe(),rBe(),sBe()])];case 1:return c=y.sent(),h=c[0],d=c[1],p=c[2],g=new Zze(d,256,256,h,a,u),w=new nBe(g,p,256,256,r,i),[2,new aBe(w)]}}))}))}var aBe=(function(){function n(e){this.pipeline=e}return n.getAnnotations=function(){return lI},n.prototype.estimateHands=function(e,t){return t===void 0&&(t=!1),Bd(this,void 0,void 0,(function(){var r,s,i,o,a,l,u,c,h;return Ud(this,(function(d){switch(d.label){case 0:return r=(function(p){return p instanceof Mi?[p.shape[0],p.shape[1]]:[p.height,p.width]})(e),s=r[1],i=Qn((function(){return e instanceof Mi||(e=SFe(e)),Kc(Ns(e,"float32"))})),[4,this.pipeline.estimateHand(i)];case 1:if(o=d.sent(),i.dispose(),o===null)return[2,[]];for(a=o,t===!0&&(a=(function(p,g){var w=p.handInViewConfidence,y=p.landmarks,x=p.boundingBox;return{handInViewConfidence:w,landmarks:y.map((function(_){return[g-1-_[0],_[1],_[2]]})),boundingBox:{topLeft:[g-1-x.topLeft[0],x.topLeft[1]],bottomRight:[g-1-x.bottomRight[0],x.bottomRight[1]]}}})(o,s)),l={},u=0,c=Object.keys(lI);u<c.length;u++)h=c[u],l[h]=lI[h].map((function(p){return a.landmarks[p]}));return[2,[{handInViewConfidence:a.handInViewConfidence,boundingBox:a.boundingBox,landmarks:a.landmarks,annotations:l}]]}}))}))},n})();const lBe=({onGesture:n,isGuiVisible:e})=>{const t=we.useRef(null),[r,s]=we.useState(null),[i,o]=we.useState(!0),[a,l]=we.useState(!1),[u,c]=we.useState("-"),[h,d]=we.useState("Initializing AI Engine..."),p=we.useRef(n);we.useEffect(()=>{p.current=n},[n]);const g=we.useRef(0),w=we.useRef([]),y=we.useRef([]),x=we.useRef(0);we.useEffect(()=>{let E=!0;const N=async()=>{try{d("Connecting to GPU..."),await Pte(),E&&d("Loading Local AI Model...");const L=await oBe({modelUrl:"public/models/handpose/model.json",detectionConfidence:.8,iouThreshold:.3,scoreThreshold:.75});E&&(s(L),o(!1))}catch($){console.error("Failed to load handpose model:",$),E&&d("Network Error: Check Connection")}},M=setTimeout(()=>{i&&E&&d("Downloading (First Run Takes Time)...")},5e3);return N(),()=>{E=!1,clearTimeout(M)}},[]);const _=we.useCallback(async()=>{if(r&&t.current&&t.current.video&&t.current.video.readyState===4){const E=Date.now();if(E-g.current<60){requestAnimationFrame(_);return}g.current=E;const N=t.current.video;if(N.videoWidth===0||N.videoHeight===0){requestAnimationFrame(_);return}try{const M=await r.estimateHands(N);if(M.length>0){x.current=0;const L=M[0].landmarks,k=L[0];if(!k){requestAnimationFrame(_);return}const R=-1*(k[0]/N.videoWidth*2-1),P=-1*(k[1]/N.videoHeight*2-1);w.current.push({x:R,y:P}),w.current.length>4&&w.current.shift();const B=w.current.reduce((Oe,Ke)=>({x:Oe.x+Ke.x,y:Oe.y+Ke.y}),{x:0,y:0}),Z=w.current.length,V=B.x/Z,X=B.y/Z,q=(Oe,Ke)=>Math.sqrt(Math.pow(Oe[0]-Ke[0],2)+Math.pow(Oe[1]-Ke[1],2)),se=q(L[0],L[9])||1,W=(Oe,Ke)=>q(L[0],L[Oe])>se*1.5,J=W(8,5),K=W(12,9),G=W(16,13),Q=W(20,17),ce=q(L[4],L[8])<se*.35;let ye="NONE";if(ce)ye="PINCH";else if(!J&&!K&&!G&&!Q)ye="CLOSED";else if(J&&!K&&!G&&!Q)ye="POINT";else if(J&&K&&G&&Q)ye="OPEN";else{const Oe=[J,K,G,Q].filter(Boolean).length;Oe>=3?ye="OPEN":Oe<=1?ye="CLOSED":ye="NONE"}y.current.push(ye),y.current.length>4&&y.current.shift();const Se=y.current.reduce((Oe,Ke)=>(Oe[Ke]=(Oe[Ke]||0)+1,Oe),{}),Re=Object.keys(Se).reduce((Oe,Ke)=>Se[Oe]>Se[Ke]?Oe:Ke);c(Re),p.current&&p.current({gesture:Re,position:{x:V,y:X},isDetected:!0,handSize:se/N.videoWidth})}else x.current++,x.current>5&&(y.current=[],w.current=[],c("NO HAND"),p.current&&p.current({gesture:"NONE",position:{x:0,y:0},isDetected:!1,handSize:0}))}catch{}}requestAnimationFrame(_)},[r]);return we.useEffect(()=>{if(r&&!i){const E=requestAnimationFrame(_);return()=>cancelAnimationFrame(E)}},[r,i,_]),Ie.jsxs("div",{className:`fixed bottom-4 right-4 z-50 transition-all duration-500 ease-in-out ${e?"opacity-100 translate-y-0":"opacity-0 translate-y-10 pointer-events-none"}`,children:[Ie.jsxs("div",{className:"relative w-28 h-36 md:w-48 md:h-36 rounded-lg border-[#d4af37]/50 bg-black/90 border overflow-hidden shadow-[0_0_20px_rgba(212,175,55,0.2)]",children:[a?Ie.jsxs("div",{className:"flex flex-col items-center justify-center h-full text-[#d4af37] p-2 text-center gap-2",children:[Ie.jsx("span",{className:"text-xl",children:""}),Ie.jsx("span",{className:"text-[10px] font-luxury uppercase tracking-widest",children:"Camera Unavailable"})]}):Ie.jsxs(Ie.Fragment,{children:[Ie.jsx(Vee,{ref:t,mirrored:!0,videoConstraints:{facingMode:"user"},className:`w-full h-full object-cover transition-opacity duration-500 ${i?"opacity-20":"opacity-80"}`,onUserMediaError:()=>l(!0)}),!i&&Ie.jsx("div",{className:"absolute inset-0 bg-gradient-to-b from-transparent via-[#d4af37]/10 to-transparent animate-scan pointer-events-none"})]}),i&&!a&&Ie.jsxs("div",{className:"absolute inset-0 flex flex-col items-center justify-center text-[#d4af37] gap-2 p-4 bg-black/80 backdrop-blur-sm",children:[Ie.jsx("div",{className:"w-5 h-5 border-2 border-[#d4af37] border-t-transparent rounded-full animate-spin"}),Ie.jsx("span",{className:"text-[9px] font-luxury uppercase tracking-widest text-center animate-pulse",children:h})]}),Ie.jsxs("div",{className:"absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black via-black/90 to-transparent pt-6 pb-2 px-3 flex flex-col md:flex-row justify-end md:justify-between items-start md:items-end gap-0 md:gap-0",children:[Ie.jsx("span",{className:"text-[9px] md:text-[8px] text-[#d4af37]/80 font-luxury tracking-widest uppercase mb-0.5 md:mb-0",children:"Gesture"}),Ie.jsx("span",{className:`text-[11px] md:text-[9px] font-mono font-bold ${u==="PINCH"?"text-[#00ffff]":u==="POINT"?"text-[#00ff00]":u==="OPEN"?"text-white":"text-[#d4af37]"}`,children:u})]})]}),Ie.jsx("style",{children:`
        @keyframes scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }
        .animate-scan {
            animation: scan 3s linear infinite;
        }
      `})]})},uBe=()=>{const[n,e]=we.useState(1),[t]=we.useState({bottom:"#022b1c",top:"#217a46"}),r=we.useRef({x:0,y:0,isDetected:!1,handSize:0,gesture:"NONE"}),[s,i]=we.useState([]),[o,a]=we.useState(!1),l=we.useRef(null),[u,c]=we.useState(!1),[h,d]=we.useState(""),[p,g]=we.useState(null),[w,y]=we.useState(!0),x=we.useCallback(L=>{L.isDetected?(L.gesture==="OPEN"&&e(0),L.gesture==="CLOSED"&&e(1),r.current={x:L.position.x,y:L.position.y,isDetected:!0,handSize:L.handSize,gesture:L.gesture}):(r.current.isDetected=!1,r.current.gesture="NONE")},[]),_=()=>{e(L=>L===1?0:1)},T=()=>{var L;(L=l.current)==null||L.click()},E=()=>{if(s.length>0){const L=s[Math.floor(Math.random()*s.length)];g(L)}else g(null);c(!0)},N=L=>{L.target.files&&L.target.files.length>0&&(a(!0),e(0),setTimeout(()=>{const R=Array.from(L.target.files).slice(0,30).map(P=>URL.createObjectURL(P));i(P=>(P.forEach(B=>URL.revokeObjectURL(B)),R)),l.current&&(l.current.value=""),setTimeout(()=>{a(!1),setTimeout(()=>{e(1)},800)},1200)},50))},M=`
    group relative 
    w-10 h-10 md:w-12 md:h-12
    rounded-full 
    bg-black/30 backdrop-blur-md 
    border border-white/20 
    text-slate-300 
    transition-all duration-500 ease-out 
    hover:border-white/60 hover:text-white hover:bg-white/10 
    hover:shadow-[0_0_25px_rgba(255,255,255,0.2)] 
    active:scale-90 active:bg-white/20
    flex justify-center items-center cursor-pointer
  `;return Ie.jsxs("div",{className:"relative w-full h-screen bg-black overflow-hidden",children:[Ie.jsx("input",{type:"file",ref:l,onChange:N,accept:"image/*",multiple:!0,className:"hidden"}),o&&Ie.jsxs("div",{className:"absolute inset-0 z-[100] flex flex-col items-center justify-center bg-black/90 backdrop-blur-md transition-all duration-500 animate-in fade-in",children:[Ie.jsxs("div",{className:"relative w-16 h-16 mb-6",children:[Ie.jsx("div",{className:"absolute inset-0 border-2 border-t-[#d4af37] border-r-transparent border-b-[#d4af37] border-l-transparent rounded-full animate-spin"}),Ie.jsx("div",{className:"absolute inset-2 border-2 border-t-transparent border-r-white/30 border-b-transparent border-l-white/30 rounded-full animate-spin-reverse"}),Ie.jsx("div",{className:"absolute inset-0 flex items-center justify-center text-[#d4af37] text-xl animate-pulse",children:""})]}),Ie.jsx("div",{className:"text-[#d4af37] font-luxury tracking-[0.25em] text-xs uppercase animate-pulse",children:"..."}),Ie.jsx("style",{children:`
                @keyframes spin-reverse {
                    from { transform: rotate(360deg); }
                    to { transform: rotate(0deg); }
                }
                .animate-spin-reverse {
                    animation: spin-reverse 2s linear infinite;
                }
              `})]}),Ie.jsx("div",{className:`absolute top-6 left-6 z-20 pointer-events-none transition-opacity duration-700 ${u||o?"opacity-0":"opacity-100"}`,children:Ie.jsxs("div",{className:"bg-black/30 backdrop-blur-md border border-[#d4af37]/30 rounded-lg p-3 space-y-2 shadow-[0_0_20px_rgba(212,175,55,0.05)]",children:[Ie.jsx("div",{className:"text-[10px] text-[#d4af37] font-luxury uppercase tracking-widest mb-1 border-b border-white/10 pb-1",children:""}),Ie.jsxs("div",{className:"flex items-center gap-3",children:[Ie.jsx("div",{className:"w-6 h-6 rounded bg-white/5 border border-white/10 flex items-center justify-center text-white text-xs",children:""}),Ie.jsx("span",{className:"text-[10px] text-slate-300 font-luxury uppercase tracking-wider",children:"  "})]}),Ie.jsxs("div",{className:"flex items-center gap-3",children:[Ie.jsx("div",{className:"w-6 h-6 rounded bg-white/5 border border-white/10 flex items-center justify-center text-white text-xs",children:""}),Ie.jsx("span",{className:"text-[10px] text-slate-300 font-luxury uppercase tracking-wider",children:"  "})]}),Ie.jsxs("div",{className:"flex items-center gap-3",children:[Ie.jsx("div",{className:"w-6 h-6 rounded bg-white/5 border border-white/10 flex items-center justify-center text-white text-xs",children:""}),Ie.jsx("span",{className:"text-[10px] text-slate-300 font-luxury uppercase tracking-wider",children:"  "})]})]})}),Ie.jsx("div",{className:`absolute inset-0 z-10 transition-all duration-700 ${u?"blur-sm scale-95 opacity-50":"blur-0 scale-100 opacity-100"}`,children:Ie.jsx(Fee,{mixFactor:n,colors:t,inputRef:r,userImages:s,signatureText:h})}),u&&Ie.jsxs("div",{className:"absolute inset-0 z-40 flex items-center justify-center p-4 bg-black/60 backdrop-blur-md transition-opacity duration-500 animate-in fade-in",children:[Ie.jsxs("div",{className:"relative bg-[#f8f8f8] p-4 pb-12 shadow-[0_0_50px_rgba(255,255,255,0.2)] transform transition-transform duration-700 scale-100 rotate-[-2deg]",style:{width:"min(80vw, 320px)",aspectRatio:"3.5/4.2"},children:[Ie.jsx("button",{onClick:()=>c(!1),className:"absolute -top-4 -right-4 w-8 h-8 rounded-full bg-black border border-white/20 text-white flex items-center justify-center hover:bg-white hover:text-black transition-colors z-50",children:""}),Ie.jsxs("div",{className:"w-full h-[75%] bg-[#1a1a1a] overflow-hidden relative shadow-inner",children:[p?Ie.jsx("img",{src:p,alt:"Memory",className:"w-full h-full object-cover"}):Ie.jsx("div",{className:"w-full h-full flex items-center justify-center text-white/40 font-body text-lg italic tracking-widest text-center px-4",children:"~~"}),Ie.jsx("div",{className:"absolute inset-0 bg-gradient-to-tr from-white/0 via-white/5 to-white/20 pointer-events-none"})]}),Ie.jsx("div",{className:"absolute bottom-0 left-0 w-full h-[25%] flex items-center justify-center px-4",children:Ie.jsx("input",{autoFocus:!0,type:"text",placeholder:"Sign here...",value:h,onChange:L=>d(L.target.value),className:"w-full text-center bg-transparent border-none outline-none font-script text-3xl md:text-4xl text-[#1a1a1a] placeholder:text-gray-300/50",style:{transform:"translateY(-5px) rotate(-1deg)"},maxLength:20})})]}),Ie.jsx("div",{className:"absolute bottom-10 left-0 w-full flex justify-center",children:Ie.jsx("button",{onClick:()=>c(!1),className:`
    group relative 
    w-auto px-8 h-10
    overflow-hidden rounded-sm 
    bg-black/80 backdrop-blur-md 
    border border-white/40 
    text-slate-300 font-luxury text-[11px] uppercase tracking-[0.25em] 
    transition-all duration-500 ease-out 
    hover:border-white/80 hover:text-black hover:bg-white 
    hover:shadow-[0_0_25px_rgba(255,255,255,0.2)] 
    active:scale-95
    flex justify-center items-center cursor-pointer
  `,children:""})})]}),Ie.jsxs("div",{className:`absolute top-6 right-6 md:top-10 md:right-10 z-30 pointer-events-auto flex flex-row md:flex-col items-center md:items-end gap-3 md:gap-4 transition-opacity duration-500 ${u||o?"opacity-0 pointer-events-none":"opacity-100"}`,children:[Ie.jsx("button",{onClick:()=>y(L=>!L),className:`${M} ${w?"text-white border-white/60 bg-white/10":"text-slate-300"}`,title:w?"":"",children:w?Ie.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.2,stroke:"currentColor",className:"w-5 h-5 md:w-6 md:h-6",children:Ie.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25h-9A2.25 2.25 0 002.25 7.5v9a2.25 2.25 0 002.25 2.25z"})}):Ie.jsxs("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.2,stroke:"currentColor",className:"w-5 h-5 md:w-6 md:h-6",children:[Ie.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M15.75 10.5l4.72-4.72a.75.75 0 011.28.53v11.38a.75.75 0 01-1.28.53l-4.72-4.72M12 18.75H4.5a2.25 2.25 0 01-2.25-2.25V9m12.841 9.091L16.5 19.5m-1.409-1.409c.407-.407.659-.97.659-1.591v-9a2.25 2.25 0 00-2.25-2.25h-9c-.621 0-1.184.252-1.591.659m3.75-3.75l3.75-3.75"}),Ie.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M3 3l18 18"})]})}),Ie.jsx("button",{onClick:T,className:M,title:"",children:Ie.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.2,stroke:"currentColor",className:"w-5 h-5 md:w-6 md:h-6",children:Ie.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z"})})}),Ie.jsx("button",{onClick:E,className:M,title:"",children:Ie.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.2,stroke:"currentColor",className:"w-5 h-5 md:w-6 md:h-6",children:Ie.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10"})})}),Ie.jsx("button",{onClick:_,className:M,title:n===1?"":"",children:n===1?Ie.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.2,stroke:"currentColor",className:"w-5 h-5 md:w-6 md:h-6",children:Ie.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15"})}):Ie.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:1.2,stroke:"currentColor",className:"w-5 h-5 md:w-6 md:h-6",children:Ie.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25"})})})]}),Ie.jsx(lBe,{onGesture:x,isGuiVisible:w})]})},W6=document.getElementById("root");if(!W6)throw new Error("Could not find root element to mount to");const cBe=E8.createRoot(W6);cBe.render(Ie.jsx(Yv.StrictMode,{children:Ie.jsx(uBe,{})}));
